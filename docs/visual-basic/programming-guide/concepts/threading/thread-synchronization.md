---
title: "Поток синхронизации (Visual Basic) | Документы Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 240937905254120f777ce140049084279c35005c
ms.contentlocale: ru-ru
ms.lasthandoff: 04/12/2017

---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="1d51b-102">Синхронизация потоков (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="1d51b-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="1d51b-103">В следующих разделах описаны функции и классы, которые могут использоваться для синхронизации доступа к ресурсам в многопоточных приложениях.</span><span class="sxs-lookup"><span data-stu-id="1d51b-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="1d51b-104">Одним из преимуществ использования нескольких потоков в приложении является асинхронное выполнение каждого потока.</span><span class="sxs-lookup"><span data-stu-id="1d51b-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="1d51b-105">Для приложений Windows, это позволяет длительные задачи выполняться в фоновом режиме, при этом окно приложения и элементы управления остаются активными.</span><span class="sxs-lookup"><span data-stu-id="1d51b-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="1d51b-106">Для сервера приложений многопоточность обеспечивает возможность обработки каждого входящего запроса в отдельном потоке.</span><span class="sxs-lookup"><span data-stu-id="1d51b-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="1d51b-107">В противном случае — каждый новый запрос не будет получить обслуживаться, пока предыдущий запрос был полностью удовлетворен.</span><span class="sxs-lookup"><span data-stu-id="1d51b-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="1d51b-108">Тем не менее должно координироваться асинхронность потоками означает, что доступ к ресурсам, таких как дескрипторы файлов, сетевые подключения и память.</span><span class="sxs-lookup"><span data-stu-id="1d51b-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="1d51b-109">В противном случае — два или более потоков удалось получить доступ к тому же ресурсу одновременно, поток не будет учитывать действия другого.</span><span class="sxs-lookup"><span data-stu-id="1d51b-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="1d51b-110">Повреждение данных непредсказуемым образом.</span><span class="sxs-lookup"><span data-stu-id="1d51b-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="1d51b-111">Для простых операций над числовыми типами данных синхронизация потоков может быть выполнено с членами <xref:System.Threading.Interlocked>класса.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="1d51b-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="1d51b-112">Для всех других данных типов и ресурсов не являющихся потокобезопасными, многопоточность может безопасно выполняться только с помощью конструкций в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="1d51b-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="1d51b-113">Сведения о многопоточном программировании см. в разделе:</span><span class="sxs-lookup"><span data-stu-id="1d51b-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="1d51b-114">Основы управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="1d51b-114">Managed Threading Basics</span></span>](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [<span data-ttu-id="1d51b-115">Использование потоков и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="1d51b-115">Using Threads and Threading</span></span>](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [<span data-ttu-id="1d51b-116">Управляемые потоки советы и рекомендации</span><span class="sxs-lookup"><span data-stu-id="1d51b-116">Managed Threading Best Practices</span></span>](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="1d51b-117">Lock и SyncLock ключевые слова</span><span class="sxs-lookup"><span data-stu-id="1d51b-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="1d51b-118">Visual Basic `SyncLock` инструкция может использоваться для выполнения блока кода к завершению без прерывания работы других потоков.</span><span class="sxs-lookup"><span data-stu-id="1d51b-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="1d51b-119">Это достигается путем получения блокировки взаимного исключения для заданного объекта в течение всего блока кода.</span><span class="sxs-lookup"><span data-stu-id="1d51b-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="1d51b-120">A `SyncLock` инструкция получает объект в качестве аргумента, за которыми блок кода, который должен выполняться одновременно только одним потоком.</span><span class="sxs-lookup"><span data-stu-id="1d51b-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="1d51b-121">Например:</span><span class="sxs-lookup"><span data-stu-id="1d51b-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="1d51b-122">Аргумент, предоставляемый для `SyncLock` ключевое слово должно быть объекта на основании ссылочного типа и используется для определения области блокировки.</span><span class="sxs-lookup"><span data-stu-id="1d51b-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="1d51b-123">В приведенном выше примере область блокировки ограничена данной функции, так как нет ссылки на объект `lockThis` существует вне функции.</span><span class="sxs-lookup"><span data-stu-id="1d51b-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="1d51b-124">Если такая ссылка существовала, область блокировки включала бы для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="1d51b-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="1d51b-125">Строго говоря предоставленного объекта используется исключительно для уникальной идентификации ресурса общим для нескольких потоков, поэтому он может быть произвольный экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="1d51b-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="1d51b-126">На практике этот объект обычно представляет ресурс для потока, в который требуется синхронизация.</span><span class="sxs-lookup"><span data-stu-id="1d51b-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="1d51b-127">Например если объект контейнера будет использоваться несколькими потоками, контейнер может быть передан блокировки и блок синхронизированного кода после блокировки для доступа к контейнеру.</span><span class="sxs-lookup"><span data-stu-id="1d51b-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="1d51b-128">При условии, что другие потоки блокируются для того же контейнера перед доступом к нему, а затем обеспечивается Безопасная синхронизация доступа к объекту.</span><span class="sxs-lookup"><span data-stu-id="1d51b-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="1d51b-129">Как правило, лучше всего избежать блокировки на `public` типа, или экземпляров объектов, которыми не управляет код вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="1d51b-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="1d51b-130">Например `lockThis` может быть проблематичным, если экземпляр доступны публично, поскольку код может блокировать объект также.</span><span class="sxs-lookup"><span data-stu-id="1d51b-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="1d51b-131">Это может вызвать ситуаций взаимной блокировки, когда два или более потоков ждать выпуска того же объекта.</span><span class="sxs-lookup"><span data-stu-id="1d51b-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="1d51b-132">Блокировка открытого типа данных, в отличие от объекта, может вызвать проблемы по той же причине.</span><span class="sxs-lookup"><span data-stu-id="1d51b-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="1d51b-133">Блокировка строковых литералов наиболее опасна, поскольку строковые литералы являются *интернировано* общеязыковой среды выполнения (CLR).</span><span class="sxs-lookup"><span data-stu-id="1d51b-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="1d51b-134">Это означает, что существует один экземпляр любого строкового литерала для всей программы, точно такой же объект будет представлять литерал во всех запущенных доменах приложения и во всех потоках.</span><span class="sxs-lookup"><span data-stu-id="1d51b-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="1d51b-135">В результате блокировка, устанавливаемая на строку с тем же содержимым в любом месте в приложении, блокирует все экземпляры этой строки в приложении.</span><span class="sxs-lookup"><span data-stu-id="1d51b-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="1d51b-136">Поэтому лучше блокировки не интернировано член закрытым или защищенным.</span><span class="sxs-lookup"><span data-stu-id="1d51b-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="1d51b-137">Некоторые классы предоставляют члены, специально предназначенные для блокировки.</span><span class="sxs-lookup"><span data-stu-id="1d51b-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="1d51b-138"><xref:System.Array>Тип, к примеру, предоставляет <xref:System.Array.SyncRoot%2A>.</xref:System.Array.SyncRoot%2A> </xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="1d51b-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="1d51b-139">Во многих типах коллекций `SyncRoot` также члена.</span><span class="sxs-lookup"><span data-stu-id="1d51b-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="1d51b-140">Дополнительные сведения о `SyncLock` инструкции содержатся в следующих разделах:</span><span class="sxs-lookup"><span data-stu-id="1d51b-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="1d51b-141">Оператор SyncLock</span><span class="sxs-lookup"><span data-stu-id="1d51b-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a><span data-ttu-id="1d51b-142">Мониторы</span><span class="sxs-lookup"><span data-stu-id="1d51b-142">Monitors</span></span>  
 <span data-ttu-id="1d51b-143">Как `SyncLock` ключевое слово, мониторы предотвратить блоки кода от одновременного выполнения нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="1d51b-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="1d51b-144"><xref:System.Threading.Monitor.Enter%2A>Метод допускает только один поток для продолжения в следующие инструкции, другие потоки блокируются до выполняемый поток вызывает <xref:System.Threading.Monitor.Exit%2A>.</xref:System.Threading.Monitor.Exit%2A> </xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="1d51b-145">Это аналогично использованию `SyncLock` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="1d51b-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="1d51b-146">Пример:</span><span class="sxs-lookup"><span data-stu-id="1d51b-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="1d51b-147">Это эквивалентно:</span><span class="sxs-lookup"><span data-stu-id="1d51b-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="1d51b-148">С помощью `SyncLock` ключевое слово является желательным по сравнению с использованием <xref:System.Threading.Monitor>класса напрямую, и поскольку `SyncLock` компактнее и поскольку `SyncLock` гарантирует освобождение базового монитора, даже если защищенный код вызывает исключение.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="1d51b-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="1d51b-149">Это осуществляется с помощью `Finally` ключевое слово, которое выполняет свой блок кода, независимо от того, является ли исключение.</span><span class="sxs-lookup"><span data-stu-id="1d51b-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="1d51b-150">События синхронизации и дескрипторы ожидания</span><span class="sxs-lookup"><span data-stu-id="1d51b-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="1d51b-151">Использование блокировки или монитора полезно для предотвращения одновременного выполнения чувствительных поток блоков кода, но эти структуры не позволяют одному потоку передавать события в другой.</span><span class="sxs-lookup"><span data-stu-id="1d51b-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="1d51b-152">Это требует *события синхронизации*, которые являются объекты, обладающие одним из двух состояний сигнальное и без получения сигнала, который может использоваться для активации и приостановки потоков.</span><span class="sxs-lookup"><span data-stu-id="1d51b-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="1d51b-153">Потоки можно приостанавливать их ожидать события синхронизации, заставляя и можно активировать, меняя сигнальное состояние события.</span><span class="sxs-lookup"><span data-stu-id="1d51b-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="1d51b-154">Если поток попытается ожидать события, который уже получил сигнал, поток продолжает выполняться без задержек.</span><span class="sxs-lookup"><span data-stu-id="1d51b-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="1d51b-155">Существует два типа событий синхронизации: <xref:System.Threading.AutoResetEvent>и <xref:System.Threading.ManualResetEvent>.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="1d51b-156">Они отличаются только в том, что <xref:System.Threading.AutoResetEvent>изменения из сигнал до состояния автоматически каждый раз, он активирует потока.</xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="1d51b-157">И наоборот <xref:System.Threading.ManualResetEvent>позволяет любому числу потоков, чтобы активировать его сигнальное состояние и только вернется к несигнальное состояние при его <xref:System.Threading.EventWaitHandle.Reset%2A>вызывается метод.</xref:System.Threading.EventWaitHandle.Reset%2A> </xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="1d51b-158">Можно сделать потоков для ожидания события путем вызова одного из методов ожидания, например <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, или <xref:System.Threading.WaitHandle.WaitAll%2A>.</xref:System.Threading.WaitHandle.WaitAll%2A> </xref:System.Threading.WaitHandle.WaitAny%2A> </xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="1d51b-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>вызывающий поток ожидает сигнала одно событие <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName>блокирует поток до сигнальное одно или несколько указанных событий, и <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName>блокирует поток, пока все указанные события сигнальное.</xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName></xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="1d51b-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="1d51b-160">Событие оповещенным, когда его <xref:System.Threading.EventWaitHandle.Set%2A>вызывается метод.</xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="1d51b-161">В следующем примере создается и запускается по потоку `Main` функции.</span><span class="sxs-lookup"><span data-stu-id="1d51b-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="1d51b-162">Новый поток ожидает события с помощью <xref:System.Threading.WaitHandle.WaitOne%2A>метод.</xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1d51b-163">Выполнение потока приостанавливается до получения сигнала главным потоком, выполняющего `Main` функции.</span><span class="sxs-lookup"><span data-stu-id="1d51b-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="1d51b-164">После получения сигнала возвращается дополнительный поток.</span><span class="sxs-lookup"><span data-stu-id="1d51b-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="1d51b-165">В этом случае поскольку событие используется только для активации одного потока, либо <xref:System.Threading.AutoResetEvent>или <xref:System.Threading.ManualResetEvent>классы могут использоваться.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="1d51b-166">Объект взаимного исключения</span><span class="sxs-lookup"><span data-stu-id="1d51b-166">Mutex Object</span></span>  
 <span data-ttu-id="1d51b-167">Объект *мьютекс* похож на монитор; предотвращает одновременное выполнение блока кода, несколько потоков одновременно.</span><span class="sxs-lookup"><span data-stu-id="1d51b-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="1d51b-168">На самом деле название «мьютекс» – сокращенная форма термина «взаимно исключают друг друга.»</span><span class="sxs-lookup"><span data-stu-id="1d51b-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="1d51b-169">В отличие от мониторов тем не менее, мьютекс может использоваться для синхронизации потоков по процессам.</span><span class="sxs-lookup"><span data-stu-id="1d51b-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="1d51b-170">Мьютекс представленного <xref:System.Threading.Mutex>класса.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="1d51b-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="1d51b-171">При использовании для синхронизации внутри процесса мьютекс называется *именованный мьютекс* так, как он будет использоваться в другом приложении, и поэтому его нельзя сделать общим посредством глобальной или статической переменной.</span><span class="sxs-lookup"><span data-stu-id="1d51b-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="1d51b-172">Ему необходимо назначить имя, чтобы оба приложения могут обращаться к тому же объекту мьютекса.</span><span class="sxs-lookup"><span data-stu-id="1d51b-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="1d51b-173">Несмотря на то, что семафор может использоваться для синхронизации потоков внутри процесса, с помощью <xref:System.Threading.Monitor>обычно является более предпочтительной, поскольку мониторы были созданы специально для .NET Framework и более эффективно используют ресурсы.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="1d51b-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="1d51b-174">Напротив <xref:System.Threading.Mutex>класс является оболочкой для конструкции Win32.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="1d51b-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="1d51b-175">Хотя мощнее монитора, мьютекса требуются переходы взаимодействия, которые больше вычислительных ресурсов, чем <xref:System.Threading.Monitor>класс.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="1d51b-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="1d51b-176">Пример использования мьютекса см. в разделе [мьютексы](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span><span class="sxs-lookup"><span data-stu-id="1d51b-176">For an example of using a mutex, see [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="1d51b-177">Interlocked-класс</span><span class="sxs-lookup"><span data-stu-id="1d51b-177">Interlocked Class</span></span>  
 <span data-ttu-id="1d51b-178">Можно использовать методы <xref:System.Threading.Interlocked>класса для предотвращения проблем, возникающих при попытке нескольких потоков одновременно обновить или сравнить значения.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="1d51b-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="1d51b-179">Методы этого класса позволяют безопасно увеличивать, уменьшение, обмен и сравнения значений из любого потока.</span><span class="sxs-lookup"><span data-stu-id="1d51b-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="1d51b-180">Замок</span><span class="sxs-lookup"><span data-stu-id="1d51b-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="1d51b-181">В некоторых случаях может потребоваться заблокировать ресурс только в том случае, когда данные записываются и разрешить нескольким клиентам одновременно считывать данные, когда данные не обновляются.</span><span class="sxs-lookup"><span data-stu-id="1d51b-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="1d51b-182"><xref:System.Threading.ReaderWriterLock>Класс обеспечивает монопольный доступ к ресурсу во время которого поток изменяет ресурс, но разрешает монопольного доступа чтения.</xref:System.Threading.ReaderWriterLock></span><span class="sxs-lookup"><span data-stu-id="1d51b-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="1d51b-183">Замок являются альтернативой монопольные блокировки, которые заставляют другие потоки ожидать, даже если их не нужно обновлять данные.</span><span class="sxs-lookup"><span data-stu-id="1d51b-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="1d51b-184">Взаимоблокировок</span><span class="sxs-lookup"><span data-stu-id="1d51b-184">Deadlocks</span></span>  
 <span data-ttu-id="1d51b-185">Синхронизация потоков является необходимостью в многопоточных приложениях, но всегда существует опасность создания `deadlock`, где несколько потоков ожидают друг друга, и приложение к остановке.</span><span class="sxs-lookup"><span data-stu-id="1d51b-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="1d51b-186">Взаимоблокировка аналогично ситуации, в которой автомобили останавливаются на stop четырехстороннюю и каждый пользователь ожидает другая для перехода.</span><span class="sxs-lookup"><span data-stu-id="1d51b-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="1d51b-187">Как избежать взаимоблокировок важна. ключом является тщательное планирование.</span><span class="sxs-lookup"><span data-stu-id="1d51b-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="1d51b-188">Взаимоблокировки часто можно предвидеть, диаграмму многопотокового приложения, прежде чем приступить к кодированию.</span><span class="sxs-lookup"><span data-stu-id="1d51b-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1d51b-189">См. также</span><span class="sxs-lookup"><span data-stu-id="1d51b-189">See Also</span></span>  
 <span data-ttu-id="1d51b-190"><xref:System.Threading.Thread></xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="1d51b-190"><xref:System.Threading.Thread></span></span>   
 <span data-ttu-id="1d51b-191"><xref:System.Threading.WaitHandle.WaitOne%2A></xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-191"><xref:System.Threading.WaitHandle.WaitOne%2A></span></span>   
 <span data-ttu-id="1d51b-192"><xref:System.Threading.WaitHandle.WaitAny%2A></xref:System.Threading.WaitHandle.WaitAny%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-192"><xref:System.Threading.WaitHandle.WaitAny%2A></span></span>   
 <span data-ttu-id="1d51b-193"><xref:System.Threading.WaitHandle.WaitAll%2A></xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-193"><xref:System.Threading.WaitHandle.WaitAll%2A></span></span>   
 <span data-ttu-id="1d51b-194"><xref:System.Threading.Thread.Join%2A></xref:System.Threading.Thread.Join%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-194"><xref:System.Threading.Thread.Join%2A></span></span>   
 <span data-ttu-id="1d51b-195"><xref:System.Threading.Thread.Start%2A></xref:System.Threading.Thread.Start%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-195"><xref:System.Threading.Thread.Start%2A></span></span>   
 <span data-ttu-id="1d51b-196"><xref:System.Threading.Thread.Sleep%2A></xref:System.Threading.Thread.Sleep%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-196"><xref:System.Threading.Thread.Sleep%2A></span></span>   
 <span data-ttu-id="1d51b-197"><xref:System.Threading.Monitor></xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="1d51b-197"><xref:System.Threading.Monitor></span></span>   
 <span data-ttu-id="1d51b-198"><xref:System.Threading.Mutex></xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="1d51b-198"><xref:System.Threading.Mutex></span></span>   
 <span data-ttu-id="1d51b-199"><xref:System.Threading.AutoResetEvent></xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-199"><xref:System.Threading.AutoResetEvent></span></span>   
 <span data-ttu-id="1d51b-200"><xref:System.Threading.ManualResetEvent></xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="1d51b-200"><xref:System.Threading.ManualResetEvent></span></span>   
 <span data-ttu-id="1d51b-201"><xref:System.Threading.Interlocked></xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="1d51b-201"><xref:System.Threading.Interlocked></span></span>   
 <span data-ttu-id="1d51b-202"><xref:System.Threading.WaitHandle></xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="1d51b-202"><xref:System.Threading.WaitHandle></span></span>   
 <span data-ttu-id="1d51b-203"><xref:System.Threading.EventWaitHandle></xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="1d51b-203"><xref:System.Threading.EventWaitHandle></span></span>   
 <span data-ttu-id="1d51b-204"><xref:System.Threading></xref:System.Threading></span><span class="sxs-lookup"><span data-stu-id="1d51b-204"><xref:System.Threading></span></span>   
 <span data-ttu-id="1d51b-205"><xref:System.Threading.EventWaitHandle.Set%2A></xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="1d51b-205"><xref:System.Threading.EventWaitHandle.Set%2A></span></span>   
<span data-ttu-id="1d51b-206"> [Многопоточные приложения (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span><span class="sxs-lookup"><span data-stu-id="1d51b-206"> [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span></span>  
<span data-ttu-id="1d51b-207"> [Оператор SyncLock](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span><span class="sxs-lookup"><span data-stu-id="1d51b-207"> [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span></span>  
<span data-ttu-id="1d51b-208"> [Мьютексы](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span><span class="sxs-lookup"><span data-stu-id="1d51b-208"> [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span></span>  
 @System.Threading.Monitor   
<span data-ttu-id="1d51b-209"> [Блокируемые операции](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span><span class="sxs-lookup"><span data-stu-id="1d51b-209"> [Interlocked Operations](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span></span>  
<span data-ttu-id="1d51b-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span><span class="sxs-lookup"><span data-stu-id="1d51b-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span></span>  
<span data-ttu-id="1d51b-211"> [Синхронизация данных для многопоточности](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span><span class="sxs-lookup"><span data-stu-id="1d51b-211"> [Synchronizing Data for Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span></span>
