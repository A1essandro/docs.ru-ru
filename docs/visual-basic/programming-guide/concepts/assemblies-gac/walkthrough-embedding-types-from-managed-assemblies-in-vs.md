---
title: "Пошаговое руководство: Внедрение типов из управляемых сборок в Visual Studio (Visual Basic) | Документы Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 56ed12ba-adff-4e9c-a668-7fcba80c4795
caps.latest.revision: 3
author: stevehoag
ms.author: shoag
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Machine Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: adc58e081cd9b874a841d84b11d92cbffb6ba6b8
ms.lasthandoff: 03/13/2017

---
# <a name="walkthrough-embedding-types-from-managed-assemblies-in-visual-studio-visual-basic"></a>Пошаговое руководство: Внедрение типов из управляемых сборок в Visual Studio (Visual Basic)
При внедрении информации о типе из управляемой сборки со строгими именами могут слабую типами в приложении для достижения независимости версий. То есть программы могут записываться в использовать типы из нескольких версий управляемой библиотеки без повторной компиляции для каждой версии.  
  
 Внедрение типа часто используется с COM-взаимодействием, например приложение, которое использует объекты автоматизации Microsoft Office. Внедрение данных о типе позволяет одному построению программы работать с различными версиями Microsoft Office на разных компьютерах. Тем не менее можно также использовать тип внедрение с полностью управляемое решение.  
  
 Сведения о типе может быть внедрен из сборки, которая имеет следующие характеристики:  
  
-   Сборка предоставляет по крайней мере один открытый интерфейс.  
  
-   Внедренные интерфейсы отмечены `ComImport` атрибут и `Guid` атрибута (и уникальный идентификатор GUID).  
  
-   Сборка отмечена `ImportedFromTypeLib` атрибут или `PrimaryInteropAssembly` атрибут и уровня сборки `Guid` атрибута. (По умолчанию шаблоны проектов Visual Basic включают уровня сборки `Guid` атрибута.)  
  
 После указания открытых интерфейсов, которые могут быть внедрены, можно создать классы среды выполнения, которые реализуют эти интерфейсы. Клиентская программа встраивает сведения о типе для этих интерфейсов во время разработки, ссылаясь на сборку, содержащую открытые интерфейсы и параметр `Embed Interop Types` ссылку на свойство `True`. Это эквивалентно с помощью компилятора командной строки и ссылки на сборки с помощью `/link` параметр компилятора. Клиентская программа может затем загрузить экземпляры объектов среды выполнения, типизированного как эти интерфейсы. При создании новой версии сборки со строгими именами среды выполнения, клиентская программа не нужно повторно компилировать с обновленной сборкой среды выполнения. Вместо этого клиентская программа будет использовать любой сборки среды выполнения доступна версия, используя внедренные данные о типе для открытых интерфейсов.  
  
 Поскольку основная функция внедрения типа — поддержка внедрения информации о типе из сборок взаимодействия COM, при внедрении информации о типе в полностью управляемое решение, применяются следующие ограничения:  
  
-   Внедряются только атрибуты, специфичные для COM-взаимодействия; другие атрибуты игнорируются.  
  
-   Если тип использует универсальные параметры и тип универсального параметра является внедренным типом, этот тип не может использоваться через границы сборок. Примеры использования через границы сборок включают вызов метода из другой сборки или тип является производным от типа, определенного в другой сборке.  
  
-   Константы не внедряются.  
  
-   <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName>Класс не поддерживает внедренный тип в качестве ключа.</xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> Можно реализовать собственный тип словаря для поддержки внедренного типа в качестве ключа.  
  
 В этом пошаговом руководстве необходимо следующее:  
  
-   Создайте сборку строгим именем, которая имеет открытый интерфейс, содержащий сведения о типе, который может быть внедрен.  
  
-   Создание сборки со строгим именем, которая реализует открытый интерфейс.  
  
-   Создание клиентской программы, которая включает сведения о типе из открытого интерфейса и создает экземпляр класса из сборки среды выполнения.  
  
-   Изменение и повторное построение сборки среды выполнения.  
  
-   Запустите программу клиента, чтобы увидеть, что новая версия сборки среды выполнения используется без повторной компиляции клиентской программы.  
  
[!INCLUDE[note_settings_general](../../../../csharp/language-reference/compiler-messages/includes/note_settings_general_md.md)]  
  
## <a name="creating-an-interface"></a>Создание интерфейса  
  
#### <a name="to-create-the-type-equivalence-interface-project"></a>Создание проекта интерфейса эквивалентности типа  
  
1.  В Visual Studio на **файл** наведите указатель мыши на **New** и нажмите кнопку **проекта**.  
  
2.  В **новый проект** в диалоговом **типы проектов** область, убедитесь, что **Windows** выбран. Выберите **библиотеки классов** в **шаблоны** области. В **имя** введите `TypeEquivalenceInterface`, а затем нажмите кнопку **ОК**. Создан новый проект.  
  
3.  В **обозревателе решений**, щелкните правой кнопкой мыши файл Class1.vb и выберите **переименование**. Переименуйте файл `ISampleInterface.vb` и нажмите клавишу ВВОД. Переименование файла также Переименуйте класс в `ISampleInterface`. Этот класс будет представлять открытый интерфейс для класса.  
  
4.  Щелкните правой кнопкой мыши проект TypeEquivalenceInterface и нажмите кнопку **свойства**. Откройте вкладку **Компиляция**. Задать выходной путь к местоположению на компьютере разработчика, такие как `C:\TypeEquivalenceSample`. Это расположение также будет использоваться позже в этом пошаговом руководстве.  
  
5.  Не выходя свойства проекта, откройте **подписи** вкладки. Выберите **подписать сборку** параметр. В **выберите файл ключей строгого имени** выберите ** <New...> **.</New...> В **имя файла ключа** введите `key.snk`. Очистить **защитить мой файл ключей паролем** флажок. Нажмите кнопку **ОК**.  
  
6.  Откройте файл ISampleInterface.vb. Добавьте следующий код в файле класса ISampleInterface для создания интерфейса ISampleInterface.  
  
<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  
7.  На **средства** меню, щелкните **создать Guid**. В **создать GUID** диалоговом нажмите кнопку **формат реестра** и нажмите кнопку **копирования**. Нажмите кнопку **Выход**.  
  
8.  В `Guid` атрибут, удалите образец GUID и вставьте идентификатор GUID, скопированный из **создать GUID** диалоговое окно. Удалите фигурные скобки ({}) из скопированного GUID.  
  
9. На **проекта** меню, щелкните **Показать все файлы**.  
  
10. В **обозревателе решений**, разверните **Мой проект** папки. Дважды щелкните файл AssemblyInfo.vb. Добавьте следующий атрибут к файлу.  
  
<CodeContentPlaceHolder>1</CodeContentPlaceHolder>  
     Сохраните файл.  
  
11. Сохраните проект.  
  
12. Щелкните правой кнопкой мыши проект TypeEquivalenceInterface и нажмите кнопку **сборки**. DLL-файла библиотеки классов компилируется и сохранен на выходной путь построения (например, C:\TypeEquivalenceSample).  
  
## <a name="creating-a-runtime-class"></a>Создание класса среды выполнения  
  
#### <a name="to-create-the-type-equivalence-runtime-project"></a>Создание проекта среды выполнения эквивалентности типа  
  
1.  В Visual Studio на **файл** наведите указатель мыши на **New** и нажмите кнопку **проекта**.  
  
2.  В **новый проект** в диалоговом **типы проектов** область, убедитесь, что **Windows** выбран. Выберите **библиотеки классов** в **шаблоны** области. В **имя** введите `TypeEquivalenceRuntime`, а затем нажмите кнопку **ОК**. Создан новый проект.  
  
3.  В **обозревателе решений**, щелкните правой кнопкой мыши файл Class1.vb и выберите **переименование**. Переименуйте файл `SampleClass.vb` и нажмите клавишу ВВОД. Переименование файла также класс будет переименован в `SampleClass`. Этот класс будет реализовывать `ISampleInterface` интерфейса.  
  
4.  Щелкните правой кнопкой мыши проект TypeEquivalenceRuntime и нажмите кнопку **свойства**. Откройте вкладку **Компиляция**. В то же расположение, которое используется в проекте TypeEquivalenceInterface, например, задайте для выходной путь `C:\TypeEquivalenceSample`.  
  
5.  Не выходя свойства проекта, откройте **подписи** вкладки. Выберите **подписать сборку** параметр. В **выберите файл ключей строгого имени** выберите ** <New...> **.</New...> В **имя файла ключа** введите `key.snk`. Очистить **защитить мой файл ключей паролем** флажок. Нажмите кнопку **ОК**.  
  
6.  Щелкните правой кнопкой мыши проект TypeEquivalenceRuntime и нажмите кнопку **добавить ссылку**. Щелкните **Обзор** вкладку и перейдите в папку выходных данных. Выберите файл TypeEquivalenceInterface.dll и нажмите кнопку **ОК**.  
  
7.  На **проекта** меню, щелкните **Показать все файлы**.  
  
8.  В **обозревателе решений**, разверните **ссылки** папки. Выберите ссылку TypeEquivalenceInterface. В окне свойств для ссылки на TypeEquivalenceInterface **версии** свойства **False**.  
  
9. Добавьте следующий код в файл класса SampleClass создание класса SampleClass.  
  
<CodeContentPlaceHolder>2</CodeContentPlaceHolder>  
10. Сохраните проект.  
  
11. Щелкните правой кнопкой мыши проект TypeEquivalenceRuntime и нажмите кнопку **сборки**. DLL-файла библиотеки классов компилируется и сохранен на выходной путь построения (например, C:\TypeEquivalenceSample).  
  
## <a name="creating-a-client-project"></a>Создание клиентского проекта  
  
#### <a name="to-create-the-type-equivalence-client-project"></a>Создание проекта клиента эквивалентности типа  
  
1.  В Visual Studio на **файл** наведите указатель мыши на **New** и нажмите кнопку **проекта**.  
  
2.  В **новый проект** в диалоговом **типы проектов** область, убедитесь, что **Windows** выбран. Выберите **консольное приложение** в **шаблоны** области. В **имя** введите `TypeEquivalenceClient`, а затем нажмите кнопку **ОК**. Создан новый проект.  
  
3.  Щелкните правой кнопкой мыши проект TypeEquivalenceClient и нажмите кнопку **свойства**. Откройте вкладку **Компиляция**. В то же расположение, которое используется в проекте TypeEquivalenceInterface, например, задайте для выходной путь `C:\TypeEquivalenceSample`.  
  
4.  Щелкните правой кнопкой мыши проект TypeEquivalenceClient и нажмите кнопку **добавить ссылку**. Щелкните **Обзор** вкладку и перейдите в папку выходных данных. Выберите файл TypeEquivalenceInterface.dll (не TypeEquivalenceRuntime.dll) и нажмите кнопку **ОК**.  
  
5.  На **проекта** меню, щелкните **Показать все файлы**.  
  
6.  В **обозревателе решений**, разверните **ссылки** папки. Выберите ссылку TypeEquivalenceInterface. В окне свойств для ссылки на TypeEquivalenceInterface **Embed Interop Types** свойства **True**.  
  
7.  Добавьте следующий код в файл Module1.vb для создания клиентской программы.  
  
<CodeContentPlaceHolder>3</CodeContentPlaceHolder>  
8.  Нажмите CTRL + F5, чтобы построить и запустить программу.  
  
## <a name="modifying-the-interface"></a>Изменение интерфейса  
  
#### <a name="to-modify-the-interface"></a>Изменение интерфейса  
  
1.  В Visual Studio на **файл** наведите указатель мыши на **откройте**, а затем нажмите кнопку **решение или проект**.  
  
2.  В **открыть проект** диалоговое окно, щелкните правой кнопкой мыши проект TypeEquivalenceInterface и нажмите кнопку **свойства**. Перейдите на вкладку **Приложение** . Щелкните **сведения о сборке** кнопки. Изменение **версию сборки** и **версия файла** значения `2.0.0.0`.  
  
3.  Откройте файл ISampleInterface.vb. Добавьте следующую строку кода в интерфейс ISampleInterface.  
  
<CodeContentPlaceHolder>4</CodeContentPlaceHolder>  
     Сохраните файл.  
  
4.  Сохраните проект.  
  
5.  Щелкните правой кнопкой мыши проект TypeEquivalenceInterface и нажмите кнопку **сборки**. Новая версия DLL-файла библиотеки классов компилируется и сохраняется в папке выходных данных построения (например, C:\TypeEquivalenceSample).  
  
## <a name="modifying-the-runtime-class"></a>Изменение класса среды выполнения  
  
#### <a name="to-modify-the-runtime-class"></a>Изменение класса среды выполнения  
  
1.  В Visual Studio на **файл** наведите указатель мыши на **откройте**, а затем нажмите кнопку **решение или проект**.  
  
2.  В **открыть проект** диалоговое окно, щелкните правой кнопкой мыши проект TypeEquivalenceRuntime и нажмите кнопку **свойства**. Перейдите на вкладку **Приложение** . Щелкните **сведения о сборке** кнопки. Изменение **версию сборки** и **версия файла** значения `2.0.0.0`.  
  
3.  Откройте SampleClass.vbfile. Добавьте следующий код в класс SampleClass.  
  
```vb  
Public Function GetDate() As DateTime Implements ISampleInterface.GetDate  
    Return Now  
End Function  
```  
  
     Save the file.  
  
4.  Сохраните проект.  
  
5.  Щелкните правой кнопкой мыши проект TypeEquivalenceRuntime и нажмите кнопку **сборки**. Обновленная версия DLL-файла библиотеки классов компилируется и сохраняется в папке выходных данных ранее указанной сборки (например, C:\TypeEquivalenceSample).  
  
6.  В проводнике откройте папку выходной файл (например, C:\TypeEquivalenceSample). Дважды щелкните TypeEquivalenceClient.exe для запуска программы. В программе отображается новая версия сборки TypeEquivalenceRuntime не выполнена.  
  
## <a name="see-also"></a>См. также  
 [/ LINK (Visual Basic)](../../../../visual-basic/reference/command-line-compiler/link.md)   
 [Основные понятия программирования](../../../../visual-basic/programming-guide/concepts/index.md)   
 [Программирование с использованием сборок](http://msdn.microsoft.com/library/25918b15-701d-42c7-95fc-c290d08648d6)   
 [Сборки и глобальный кэш сборок (Visual Basic)](../../../../visual-basic/programming-guide/concepts/assemblies-gac/index.md)

