---
title: "Интерфейсы (Visual Basic)"
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- Visual Basic code, interfaces
- interfaces, Visual Basic
- interfaces
- interfaces [Visual Basic]
ms.assetid: 61b06674-12c9-430b-be68-cc67ecee1f5b
caps.latest.revision: 11
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 775e4512a5ff31c7059961f6332c6bdc0dc5247a
ms.openlocfilehash: 0b3f13cd69564a61da1a961e35c5319e4c2d79aa
ms.contentlocale: ru-ru
ms.lasthandoff: 08/11/2017

---
# <a name="interfaces-visual-basic"></a><span data-ttu-id="6f83b-102">Интерфейсы (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="6f83b-102">Interfaces (Visual Basic)</span></span>
<span data-ttu-id="6f83b-103">*Интерфейсы* определяют свойства, методы и события, которые можно реализовать в классах.</span><span class="sxs-lookup"><span data-stu-id="6f83b-103">*Interfaces* define the properties, methods, and events that classes can implement.</span></span> <span data-ttu-id="6f83b-104">Интерфейсы позволяют определить возможности в виде небольших групп тесно связанных свойств, методов и событий. Это снижает число проблем совместимости, так как можно создавать усовершенствованные реализации интерфейсов без изменения существующего кода.</span><span class="sxs-lookup"><span data-stu-id="6f83b-104">Interfaces allow you to define features as small groups of closely related properties, methods, and events; this reduces compatibility problems because you can develop enhanced implementations for your interfaces without jeopardizing existing code.</span></span> <span data-ttu-id="6f83b-105">Вы можете добавлять новые функции в любое время с помощью дополнительных интерфейсов и реализаций.</span><span class="sxs-lookup"><span data-stu-id="6f83b-105">You can add new features at any time by developing additional interfaces and implementations.</span></span>  
  
 <span data-ttu-id="6f83b-106">Далее представлены другие причины, из-за которых вам может потребоваться использовать интерфейсы вместо наследования классов.</span><span class="sxs-lookup"><span data-stu-id="6f83b-106">There are several other reasons why you might want to use interfaces instead of class inheritance:</span></span>  
  
-   <span data-ttu-id="6f83b-107">Интерфейсы более удобны в ситуациях, в которых приложениям требуется множество возможно несвязанных типов объектов для предоставления определенных возможностей.</span><span class="sxs-lookup"><span data-stu-id="6f83b-107">Interfaces are better suited to situations in which your applications require many possibly unrelated object types to provide certain functionality.</span></span>  
  
-   <span data-ttu-id="6f83b-108">Интерфейсы более гибкие, чем базовые классы, так как вы можете определить одну реализацию, в которой можно реализовать несколько интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="6f83b-108">Interfaces are more flexible than base classes because you can define a single implementation that can implement multiple interfaces.</span></span>  
  
-   <span data-ttu-id="6f83b-109">Интерфейсы предпочтительнее в случаях, в которых нет необходимости наследовать реализацию базового класса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-109">Interfaces are better in situations in which you do not have to inherit implementation from a base class.</span></span>  
  
-   <span data-ttu-id="6f83b-110">Интерфейсы полезны, когда невозможно использовать наследование класса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-110">Interfaces are useful when you cannot use class inheritance.</span></span> <span data-ttu-id="6f83b-111">Например, структуры не могут наследовать от классов, но они могут реализовывать интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="6f83b-111">For example, structures cannot inherit from classes, but they can implement interfaces.</span></span>  
  
## <a name="declaring-interfaces"></a><span data-ttu-id="6f83b-112">Объявление интерфейсов</span><span class="sxs-lookup"><span data-stu-id="6f83b-112">Declaring Interfaces</span></span>  
 <span data-ttu-id="6f83b-113">Определения интерфейса заключаются в операторы `Interface` и `End Interface`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-113">Interface definitions are enclosed within the `Interface` and `End Interface` statements.</span></span> <span data-ttu-id="6f83b-114">После оператора `Interface` можно добавить необязательный оператор `Inherits`, в котором указывается один или несколько наследуемых интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="6f83b-114">Following the `Interface` statement, you can add an optional `Inherits` statement that lists one or more inherited interfaces.</span></span> <span data-ttu-id="6f83b-115">Операторы `Inherits` должны предшествовать всем другим операторам в объявлении, за исключением комментариев.</span><span class="sxs-lookup"><span data-stu-id="6f83b-115">The `Inherits` statements must precede all other statements in the declaration except comments.</span></span> <span data-ttu-id="6f83b-116">Остальными операторами в определении интерфейса должны быть `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure` и `Enum`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-116">The remaining statements in the interface definition should be `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure`, and `Enum` statements.</span></span> <span data-ttu-id="6f83b-117">Интерфейсы не могут содержать код реализаций или операторы, связанные с кодом реализации, такие как `End Sub` и `End Property`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-117">Interfaces cannot contain any implementation code or statements associated with implementation code, such as `End Sub` or `End Property`.</span></span>  
  
 <span data-ttu-id="6f83b-118">В пространстве имен операторы интерфейса по умолчанию относятся к типу `Friend`, но также их можно явно объявить как `Public` или `Friend`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-118">In a namespace, interface statements are `Friend` by default, but they can also be explicitly declared as `Public` or `Friend`.</span></span> <span data-ttu-id="6f83b-119">Интерфейсы, определенные в классах, модулях, интерфейсах и структурах по умолчанию объявлены как `Public`, но их также можно явно объявить как `Public`, `Friend`, `Protected` и `Private`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-119">Interfaces defined within classes, modules, interfaces, and structures are `Public` by default, but they can also be explicitly declared as `Public`, `Friend`, `Protected`, or `Private`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6f83b-120">Ключевое слово `Shadows` может применяться ко всем элементам интерфейса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-120">The `Shadows` keyword can be applied to all interface members.</span></span> <span data-ttu-id="6f83b-121">Ключевое слово `Overloads` слово может применяться к операторам `Sub`, `Function`, и `Property`, объявленным в определении интерфейса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-121">The `Overloads` keyword can be applied to `Sub`, `Function`, and `Property` statements declared in an interface definition.</span></span> <span data-ttu-id="6f83b-122">Кроме того, операторы `Property` могут содержать модификаторы `Default`, `ReadOnly` и `WriteOnly`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-122">In addition, `Property` statements can have the `Default`, `ReadOnly`, or `WriteOnly` modifiers.</span></span> <span data-ttu-id="6f83b-123">Другие модификаторы (`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride` и `Overridable`) не разрешены.</span><span class="sxs-lookup"><span data-stu-id="6f83b-123">None of the other modifiers—`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride`, or `Overridable`—are allowed.</span></span> <span data-ttu-id="6f83b-124">Дополнительные сведения см. в разделе [Контексты объявления и уровни доступа по умолчанию](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).</span><span class="sxs-lookup"><span data-stu-id="6f83b-124">For more information, see [Declaration Contexts and Default Access Levels](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).</span></span>  
  
 <span data-ttu-id="6f83b-125">Например, в следующем примере кода определяется интерфейс с одной функцией, одним свойством и одним событием.</span><span class="sxs-lookup"><span data-stu-id="6f83b-125">For example, the following code defines an interface with one function, one property, and one event.</span></span>  
  
 <span data-ttu-id="6f83b-126">[!code-vb[VbVbalrOOP#17](../../../../visual-basic/misc/codesnippet/VisualBasic/index_1.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-126">[!code-vb[VbVbalrOOP#17](../../../../visual-basic/misc/codesnippet/VisualBasic/index_1.vb)]</span></span>  
  
## <a name="implementing-interfaces"></a><span data-ttu-id="6f83b-127">Реализация интерфейсов</span><span class="sxs-lookup"><span data-stu-id="6f83b-127">Implementing Interfaces</span></span>  
 <span data-ttu-id="6f83b-128">Зарезервированное слово [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] `Implements` используется двумя способами.</span><span class="sxs-lookup"><span data-stu-id="6f83b-128">The [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] reserved word `Implements` is used in two ways.</span></span> <span data-ttu-id="6f83b-129">Оператор `Implements` означает, что класс или структура реализуют интерфейс.</span><span class="sxs-lookup"><span data-stu-id="6f83b-129">The `Implements` statement signifies that a class or structure implements an interface.</span></span> <span data-ttu-id="6f83b-130">Ключевое слово `Implements` указывает, что элемент класса или структуры реализует определенный элемент интерфейса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-130">The `Implements` keyword signifies that a class member or structure member implements a specific interface member.</span></span>  
  
### <a name="implements-statement"></a><span data-ttu-id="6f83b-131">Оператор Implements</span><span class="sxs-lookup"><span data-stu-id="6f83b-131">Implements Statement</span></span>  
 <span data-ttu-id="6f83b-132">Если класс или структура реализует один или несколько интерфейсов, они должны содержать оператор `Implements` сразу после оператора `Class` или `Structure`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-132">If a class or structure implements one or more interfaces, it must include the `Implements` statement immediately after the `Class` or `Structure` statement.</span></span> <span data-ttu-id="6f83b-133">Оператору `Implements` требуется разделенный запятыми список интерфейсов, которые должны быть реализованы с помощью класса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-133">The `Implements` statement requires a comma-separated list of interfaces to be implemented by a class.</span></span> <span data-ttu-id="6f83b-134">Структура или класс должны реализовать все элементы интерфейса с помощью ключевого слова `Implements`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-134">The class or structure must implement all interface members using the `Implements` keyword.</span></span>  
  
### <a name="implements-keyword"></a><span data-ttu-id="6f83b-135">Ключевое слово Implements</span><span class="sxs-lookup"><span data-stu-id="6f83b-135">Implements Keyword</span></span>  
 <span data-ttu-id="6f83b-136">Ключевому слову `Implements` требуется разделенный запятыми список элементов интерфейса, которые необходимо реализовать.</span><span class="sxs-lookup"><span data-stu-id="6f83b-136">The `Implements` keyword requires a comma-separated list of interface members to be implemented.</span></span> <span data-ttu-id="6f83b-137">Как правило, указывается только один элемент интерфейса, но можно указать несколько элементов.</span><span class="sxs-lookup"><span data-stu-id="6f83b-137">Generally, only a single interface member is specified, but you can specify multiple members.</span></span> <span data-ttu-id="6f83b-138">Спецификация элемента интерфейса состоит из имени интерфейса, которое должно быть указано в операторе implements внутри класса, точки и имени реализуемой функции-члена, свойства или события.</span><span class="sxs-lookup"><span data-stu-id="6f83b-138">The specification of an interface member consists of the interface name, which must be specified in an implements statement within the class; a period; and the name of the member function, property, or event to be implemented.</span></span> <span data-ttu-id="6f83b-139">В имени элемента, который реализует элемент интерфейса, может использоваться любой допустимый идентификатор — к нему не применяется соглашение `InterfaceName_MethodName`, используемое в более ранних версиях [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span><span class="sxs-lookup"><span data-stu-id="6f83b-139">The name of a member that implements an interface member can use any legal identifier, and it is not limited to the `InterfaceName_MethodName` convention used in earlier versions of [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].</span></span>  
  
 <span data-ttu-id="6f83b-140">Например, в следующем примере кода показано, как объявить подпрограмму с именем `Sub1`, в которой реализуется метод интерфейса:</span><span class="sxs-lookup"><span data-stu-id="6f83b-140">For example, the following code shows how to declare a subroutine named `Sub1` that implements a method of an interface:</span></span>  
  
 <span data-ttu-id="6f83b-141">[!code-vb[VbVbalrOOP#69](../../../../visual-basic/misc/codesnippet/VisualBasic/index_2.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-141">[!code-vb[VbVbalrOOP#69](../../../../visual-basic/misc/codesnippet/VisualBasic/index_2.vb)]</span></span>  
  
 <span data-ttu-id="6f83b-142">Типы параметров и типы возвращаемого значения элемента реализации должны соответствовать объявлению свойства или элемента в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="6f83b-142">The parameter types and return types of the implementing member must match the interface property or member declaration in the interface.</span></span> <span data-ttu-id="6f83b-143">Наиболее распространенный способ реализации элемента интерфейса — использование элемента с таким же, как у интерфейса, именем, как показано в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="6f83b-143">The most common way to implement an element of an interface is with a member that has the same name as the interface, as shown in the previous example.</span></span>  
  
 <span data-ttu-id="6f83b-144">Для объявления реализации метода интерфейса можно использовать любые атрибуты, которые допустимы в объявлении метода экземпляра, включая `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default` и `Static`.</span><span class="sxs-lookup"><span data-stu-id="6f83b-144">To declare the implementation of an interface method, you can use any attributes that are legal on instance method declarations, including `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default`, and `Static`.</span></span> <span data-ttu-id="6f83b-145">Атрибут `Shared` недопустим, поскольку он определяет класс, а не метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="6f83b-145">The `Shared` attribute is not legal since it defines a class rather than an instance method.</span></span>  
  
 <span data-ttu-id="6f83b-146">С помощью `Implements` можно также написать один метод, который реализует несколько методов, определенных в интерфейсе, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="6f83b-146">Using `Implements`, you can also write a single method that implements multiple methods defined in an interface, as in the following example:</span></span>  
  
 <span data-ttu-id="6f83b-147">[!code-vb[VbVbalrOOP#70](../../../../visual-basic/misc/codesnippet/VisualBasic/index_3.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-147">[!code-vb[VbVbalrOOP#70](../../../../visual-basic/misc/codesnippet/VisualBasic/index_3.vb)]</span></span>  
  
 <span data-ttu-id="6f83b-148">Закрытый элемент можно использовать для реализации члена интерфейса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-148">You can use a private member to implement an interface member.</span></span> <span data-ttu-id="6f83b-149">Если закрытый член реализует член интерфейса, этот элемент становится доступен через интерфейс, хотя он недоступен напрямую через переменные класса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-149">When a private member implements a member of an interface, that member becomes available by way of the interface even though it is not available directly on object variables for the class.</span></span>  
  
### <a name="interface-implementation-examples"></a><span data-ttu-id="6f83b-150">Примеры реализации интерфейсов</span><span class="sxs-lookup"><span data-stu-id="6f83b-150">Interface Implementation Examples</span></span>  
 <span data-ttu-id="6f83b-151">Классы, реализующие интерфейс, должны реализовать все свойства, методы и события.</span><span class="sxs-lookup"><span data-stu-id="6f83b-151">Classes that implement an interface must implement all its properties, methods, and events.</span></span>  
  
 <span data-ttu-id="6f83b-152">В примере ниже определены два интерфейса.</span><span class="sxs-lookup"><span data-stu-id="6f83b-152">The following example defines two interfaces.</span></span> <span data-ttu-id="6f83b-153">Второй интерфейс, `Interface2`, наследует `Interface1` и определяет дополнительное свойство и метод.</span><span class="sxs-lookup"><span data-stu-id="6f83b-153">The second interface, `Interface2`, inherits `Interface1` and defines an additional property and method.</span></span>  
  
 <span data-ttu-id="6f83b-154">[!code-vb[VbVbalrOOP#39](../../../../visual-basic/misc/codesnippet/VisualBasic/index_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-154">[!code-vb[VbVbalrOOP#39](../../../../visual-basic/misc/codesnippet/VisualBasic/index_4.vb)]</span></span>  
  
 <span data-ttu-id="6f83b-155">В следующем примере реализуется `Interface1`, интерфейс, определенный в предыдущем примере:</span><span class="sxs-lookup"><span data-stu-id="6f83b-155">The next example implements `Interface1`, the interface defined in the previous example:</span></span>  
  
 <span data-ttu-id="6f83b-156">[!code-vb[VbVbalrOOP#40](../../../../visual-basic/misc/codesnippet/VisualBasic/index_5.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-156">[!code-vb[VbVbalrOOP#40](../../../../visual-basic/misc/codesnippet/VisualBasic/index_5.vb)]</span></span>  
  
 <span data-ttu-id="6f83b-157">В последнем примере реализуется `Interface2`, включающий метод, унаследованный от `Interface1`:</span><span class="sxs-lookup"><span data-stu-id="6f83b-157">The final example implements `Interface2`, including a method inherited from `Interface1`:</span></span>  
  
 <span data-ttu-id="6f83b-158">[!code-vb[VbVbalrOOP#41](../../../../visual-basic/misc/codesnippet/VisualBasic/index_6.vb)]</span><span class="sxs-lookup"><span data-stu-id="6f83b-158">[!code-vb[VbVbalrOOP#41](../../../../visual-basic/misc/codesnippet/VisualBasic/index_6.vb)]</span></span>  
  
 <span data-ttu-id="6f83b-159">Можно реализовать свойство только для чтения со свойством, доступным для чтения и записи (т. е. не нужно объявлять его свойством только для чтения в классе реализации).</span><span class="sxs-lookup"><span data-stu-id="6f83b-159">You can implement a readonly property with a readwrite property (that is, you do not have to declare it readonly in the implementing class).</span></span>  <span data-ttu-id="6f83b-160">В реализации интерфейса должны быть по крайней мере реализованы элементы, которые объявляются интерфейсом, но можно обеспечить дополнительные возможности, например разрешить запись свойства.</span><span class="sxs-lookup"><span data-stu-id="6f83b-160">Implementing an interface promises to implement at least the members that the interface declares, but you can offer more functionality, such as allowing your property to be writable.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="6f83b-161">См. также</span><span class="sxs-lookup"><span data-stu-id="6f83b-161">Related Topics</span></span>  
  
|<span data-ttu-id="6f83b-162">Заголовок</span><span class="sxs-lookup"><span data-stu-id="6f83b-162">Title</span></span>|<span data-ttu-id="6f83b-163">Описание</span><span class="sxs-lookup"><span data-stu-id="6f83b-163">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="6f83b-164">Пошаговое руководство. Создание и реализация интерфейсов</span><span class="sxs-lookup"><span data-stu-id="6f83b-164">Walkthrough: Creating and Implementing Interfaces</span></span>](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)|<span data-ttu-id="6f83b-165">Содержит подробные процедуры, которые помогут вам определить и реализовать собственный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="6f83b-165">Provides a detailed procedure that takes you through the process of defining and implementing your own interface.</span></span>|  
|[<span data-ttu-id="6f83b-166">Расхождение в универсальных интерфейсах</span><span class="sxs-lookup"><span data-stu-id="6f83b-166">Variance in Generic Interfaces</span></span>](../../concepts/covariance-contravariance/variance-in-generic-interfaces.md)|<span data-ttu-id="6f83b-167">В этом разделе описываются ковариация и контрвариация в универсальных интерфейсах, а также представлен список вариативных универсальных интерфейсов платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="6f83b-167">Discusses covariance and contravariance in generic interfaces and provides a list of variant generic interfaces in the .NET Framework.</span></span>|

