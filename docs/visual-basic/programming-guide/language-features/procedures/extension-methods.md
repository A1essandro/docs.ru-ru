---
title: "Методы расширения (Visual Basic) | Документы Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- vb.ExtensionMethods
dev_langs:
- VB
helpviewer_keywords:
- extending data types
- extension methods [Visual Basic]
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
caps.latest.revision: 41
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Machine Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 381fa0db2d92590d23ebd71a7823a8465e94a6e6
ms.lasthandoff: 03/13/2017

---
# <a name="extension-methods-visual-basic"></a>Методы расширения (Visual Basic)
Методы расширения позволяют разработчикам добавлять пользовательские функциональные возможности типам данных, которые уже определены, не создавая новый производный тип. Методы расширения делают возможным написание метода, который может вызываться, как если бы это был метод экземпляра существующего типа.  
  
## <a name="remarks"></a>Примечания  
 Метод расширения может быть только `Sub` процедуры или `Function` процедуры. Нельзя определить свойство расширения, поле или событие. Все методы расширения должен быть помечен атрибутом расширения `<Extension()>` из <xref:System.Runtime.CompilerServices?displayProperty=fullName>имен.</xref:System.Runtime.CompilerServices?displayProperty=fullName>  
  
 Первый параметр в определении метода расширения указывает тип данных, который расширяет метод. При выполнении метода первый параметр привязан к экземпляру типа данных, который вызывает метод.  
  
## <a name="example"></a>Пример  
  
### <a name="description"></a>Описание  
 В следующем примере определяется `Print` расширение <xref:System.String>тип данных.</xref:System.String> Использует метод `Console.WriteLine` для отображения строки. Параметр `Print` метода `aString`, устанавливает, что метод расширяет <xref:System.String>класс.</xref:System.String>  
  
 [!code-vb[VbVbalrExtensionMethods&#1;](./codesnippet/VisualBasic/extension-methods_1.vb)]  
  
 Обратите внимание, что определение метода расширения помечено атрибутом расширения `<Extension()>`. Помечать модуль, в котором определен метод является необязательным, но каждый метод расширения должен быть помечен. <xref:System.Runtime.CompilerServices>Чтобы получить доступ к атрибуту расширения должен быть импортирован.</xref:System.Runtime.CompilerServices>  
  
 Методы расширения могут быть объявлены только внутри модулей. Как правило модуль, в котором определен метод расширения не же модулем, в котором он вызван. Вместо этого модуля, содержащего метод расширения импортируется, если необходимо, чтобы включить их в область. После модуля, содержащего `Print` находится в области видимости, метод может быть вызван, как если бы он был обычным экземпляром метода, не принимающего аргументов, таких как `ToUpper`:  
  
 [!code-vb[VbVbalrExtensionMethods&#2;](./codesnippet/VisualBasic/extension-methods_2.vb)]  
  
 Следующий пример `PrintAndPunctuate`, также является расширением <xref:System.String>, определенным с помощью двух параметров.</xref:System.String> Первый параметр `aString`, устанавливает, что метод расширения расширяет <xref:System.String>.</xref:System.String> Второй параметр `punc`, должно быть строкой знаков препинания, который передается в качестве аргумента при вызове метода. Метод отображает строку, следуют знаки пунктуации.  
  
 [!code-vb[VbVbalrExtensionMethods&#3;](./codesnippet/VisualBasic/extension-methods_3.vb)]  
  
 Метод вызывается отправкой аргумента строки для `punc`:`example.PrintAndPunctuate(".")`  
  
 В следующем примере показан `Print` и `PrintAndPunctuate` определен и вызывается. <xref:System.Runtime.CompilerServices>импортируется в модуле определения для обеспечения доступа к атрибуту расширения.</xref:System.Runtime.CompilerServices>  
  
### <a name="code"></a>Код  
  
```vb  
Imports System.Runtime.CompilerServices  
  
Module StringExtensions  
  
    <Extension()>   
    Public Sub Print(ByVal aString As String)  
        Console.WriteLine(aString)  
    End Sub  
  
    <Extension()>   
    Public Sub PrintAndPunctuate(ByVal aString As String,   
                                 ByVal punc As String)  
        Console.WriteLine(aString & punc)  
    End Sub  
  
End Module  
```  
  
 Затем методы расширения введены в область действия и именем.  
  
```vb  
Imports ConsoleApplication2.StringExtensions  
Module Module1  
  
    Sub Main()  
  
        Dim example As String = "Example string"  
        example.Print()  
  
        example = "Hello"  
        example.PrintAndPunctuate(".")  
        example.PrintAndPunctuate("!!!!")  
  
    End Sub  
End Module  
```  
  
### <a name="comments"></a>Комментарии  
 Все, что необходимо для выполнения этих или подобных методов расширения том, что они в области видимости. Если в области модуля, содержащего метод расширения, он отображается в технологии IntelliSense и может вызываться, как если бы он был обычным экземпляром метода.  
  
 Обратите внимание, что при вызове методов никакой аргумент не передается качестве первого параметра. Параметр `aString` в предыдущем методе определения привязан к `example`, экземпляр `String` , вызывает их. Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.  
  
 Если метод расширения вызывается для объекта, который имеет значение `Nothing`, выполняет метод расширения. Это не относится к обычный методами экземпляра. Можно явным образом проверить наличие `Nothing` в методе расширения.  
  
## <a name="types-that-can-be-extended"></a>Типы, которые могут быть расширены  
 Можно определить метод расширения большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:  
  
-   Классы (ссылочные типы)  
  
-   Структуры (типы значений)  
  
-   Интерфейсы  
  
-   Делегаты  
  
-   Аргументы ByRef и ByVal  
  
-   Параметры универсального метода.  
  
-   Массивы  
  
 Так как первый параметр указывает тип данных, который расширяет метод расширения, он является обязательным и не может быть необязательным. По этой причине `Optional` параметры и `ParamArray` параметры не могут быть первый параметр в списке параметров.  
  
 Методы расширения не учитываются в позднего связывания. В следующем примере инструкция `anObject.PrintMe()` вызывает <xref:System.MissingMemberException>исключение, то же исключение, можно будет увидеть, если второй `PrintMe` определение метода расширения были удалены.</xref:System.MissingMemberException>  
  
 [!code-vb[VbVbalrExtensionMethods №&9;](./codesnippet/VisualBasic/extension-methods_4.vb)]  
  
## <a name="best-practices"></a>Рекомендации  
 Методы расширения предоставляют удобный и мощный способ расширить существующий тип. Тем не менее для успешного использования, которые необходимо учитывать некоторые моменты. Эти советы главным образом касаются авторов библиотек классов, но они могут повлиять на любое приложение, использующее методы расширения.  
  
 Как правило методы расширения, добавленные к типам, которые не принадлежат более уязвимыми, чем методы расширения, добавленные к типам, которые вы управляете. Число объектов может возникнуть в классах, которые вам не принадлежат, могут конфликтовать с методами расширения.  
  
-   Если существует любой доступный элемент экземпляра, который имеет подпись, совместимую с аргументами в вызывающей инструкции, и при этом сужающие преобразования не требуется для параметра от аргумента, метод экземпляра будет использоваться в предпочтение любому методу расширения. Таким образом Если соответствующий метод экземпляра добавляется в класс в некоторой точке, существующий элемент расширения, основанные на могут стать недоступными.  
  
-   Автор метода расширения не может помешать другим программистам записать конфликтующие методы расширения, которые могут иметь приоритет над исходным расширением.  
  
-   Надежность можно повысить, помещая методы расширения в свое собственное пространство имен. Потребители библиотеки могут включить пространство имен или исключить его или выбрать пространства имен отдельно от остальной части библиотеки.  
  
-   Он может оказаться более безопасным расширить интерфейсы, чем для расширения классов, особенно в том случае, если вы не являетесь владельцем интерфейса или класса. Изменения в интерфейсе влияет на каждый класс, который его реализует. Таким образом автору, можно снизить вероятность для добавления или изменения методов в интерфейсе. Однако если класс реализует два интерфейса, имеющих методы расширения с такой же сигнатурой, ни один из методов расширения не виден.  
  
-   Расширить наиболее конкретный тип, можно. В иерархии типов Если выбран тип, от которого наследуются другие типы, существуют уровни возможностей для введения методов экземпляра или других методов расширения, которые могут конфликтовать с вашими.  
  
## <a name="extension-methods-instance-methods-and-properties"></a>Методы расширения, методы экземпляра и свойства  
 Когда метод в области экземпляра имеет подпись, совместимую с аргументом вызывающего оператора, метод экземпляра выбирается в предпочтение любому методу расширения. Метод экземпляра имеет приоритет, даже если метод расширения является более подходящим. В следующем примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod` , имеющий один параметр типа `Integer`. Метод расширения `ExampleMethod` расширяет `ExampleClass`, и имеет один параметр типа `Long`.  
  
 [!code-vb[VbVbalrExtensionMethods&#4;](./codesnippet/VisualBasic/extension-methods_5.vb)]  
  
 При первом вызове `ExampleMethod` в следующем коде вызывает метод расширения, так как `arg1` — `Long` и совместим только с `Long` параметр в методе расширения. Второй вызов `ExampleMethod` имеет `Integer` аргумент, `arg2`, и он вызывает метод экземпляра.  
  
 [!code-vb[VbVbalrExtensionMethods&#5;](./codesnippet/VisualBasic/extension-methods_6.vb)]  
  
 Теперь можно изменить типы данных параметров в двух методах:  
  
 [!code-vb[VbVbalrExtensionMethods №&6;](./codesnippet/VisualBasic/extension-methods_7.vb)]  
  
 Код в `Main` вызывает метод экземпляра оба раза. Это, поскольку оба `arg1` и `arg2` имеют расширяющее преобразование `Long`, а метод экземпляра имеет преимущество перед методом расширения в обоих случаях.  
  
 [!code-vb[VbVbalrExtensionMethods&#7;](./codesnippet/VisualBasic/extension-methods_8.vb)]  
  
 Таким образом метод расширения не может заменить существующий метод экземпляра. Тем не менее если метод расширения имеет то же имя, что и метод экземпляра, но не конфликтуют подписи, может осуществляться обоих методов. Например если класс `ExampleClass` содержит метод с именем `ExampleMethod` , не имеющий аргументов, методы расширения с одинаковыми именами, но различными сигнатурами, допускаются, как показано в следующем коде.  
  
 [!code-vb[VbVbalrExtensionMethods №&8;](./codesnippet/VisualBasic/extension-methods_9.vb)]  
  
 Результат выполнения этого кода выглядит следующим образом:  
  
 `Extension method`  
  
 `Instance method`  
  
 Ситуация выглядит проще со свойствами: Если метод расширения имеет то же имя, как свойство класса, он расширяет, метод расширения невидим и недоступен.  
  
## <a name="extension-method-precedence"></a>Приоритет метода расширения  
 Когда два метода расширения, которые имеют идентичные подписи, присутствуют в области действия и доступны, будет вызван метод с более высоким приоритетом. Приоритет метода расширения основан на механизм, используемый для переноса метода в область. Ниже перечислены иерархия приоритетов от самого высокого до самого низкого.  
  
1.  Методы расширения, определенные внутри текущего модуля.  
  
2.  Методы расширения определенные внутри типов данных в текущем пространстве имен или один из его родителей, с дочерними пространствами имен, имеющими более высокий приоритет, чем родительские пространства имен.  
  
3.  Методы расширения, определенные внутри любых импортов типа в текущем файле.  
  
4.  Методы расширения, определенные внутри любых импортов пространств имен в текущем файле.  
  
5.  Методы расширения, определенные внутри любых импортов типов на уровне проекта.  
  
6.  Методы расширения, определенные внутри любых импортов пространств имен уровня проекта.  
  
 Если приоритет не позволяет устранить неоднозначность, можно использовать полное доменное имя для указания метода, который вы вызываете. Если `Print` метод в предыдущем примере определен в модуле с именем `StringExtensions`, полное доменное имя является `StringExtensions.Print(example)` вместо `example.Print()`.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Runtime.CompilerServices></xref:System.Runtime.CompilerServices>   
 <xref:System.Runtime.CompilerServices.ExtensionAttribute></xref:System.Runtime.CompilerServices.ExtensionAttribute>   
 [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)   
 [Оператор Module](../../../../visual-basic/language-reference/statements/module-statement.md)   
 [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)   
 [Необязательные параметры](./optional-parameters.md)   
 [Массивы параметров](./parameter-arrays.md)   
 [Общие сведения об атрибутах](../../../../visual-basic/programming-guide/concepts/attributes/index.md)   
 [Область видимости в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)
