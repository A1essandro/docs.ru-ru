---
title: Методы расширения (Visual Basic)
ms.custom: ''
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- vb.ExtensionMethods
helpviewer_keywords:
- extending data types [Visual Basic]
- extension methods [Visual Basic]
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
caps.latest.revision: 41
author: dotnet-bot
ms.author: dotnetcontent
ms.openlocfilehash: d3db3bc2b213b78ef2dceebcf56c9d5fbfa3016e
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="extension-methods-visual-basic"></a>Методы расширения (Visual Basic)
Методы расширения позволяют разработчикам добавлять пользовательские функциональные возможности для типов данных, которые уже определены без создания нового производного типа. Методы расширения позволяют написать метод, который может вызываться, как если бы это был метод экземпляра существующего типа.  
  
## <a name="remarks"></a>Примечания  
 Метод расширения может быть только `Sub` процедуры или `Function` процедуры. Нельзя определить свойство расширения, поле или событие. Все методы расширения должны быть помечены атрибутом расширения `<Extension()>` из <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> пространства имен.  
  
 Первый параметр в определении метода расширения указывает тип данных, который расширяет метод. При выполнении метода первый параметр привязан к экземпляру типа данных, который вызывает метод.  
  
## <a name="example"></a>Пример  
  
### <a name="description"></a>Описание  
 В следующем примере определяется `Print` расширение <xref:System.String> тип данных. Этот метод использует `Console.WriteLine` для отображения строки. Параметр `Print` метода `aString`, устанавливает, что метод расширяет <xref:System.String> класса.  
  
 [!code-vb[VbVbalrExtensionMethods#1](./codesnippet/VisualBasic/extension-methods_1.vb)]  
  
 Обратите внимание, что определение метода расширения помечено атрибутом расширения `<Extension()>`. Помечать модуль, в которой определен метод является необязательным, но каждый метод расширения должен быть помечен. <xref:System.Runtime.CompilerServices>Чтобы получить доступ к атрибуту расширения должен быть импортирован.  
  
 Методы расширения могут быть объявлены только внутри модулей. Как правило модуль, в которой определен метод расширения не же модулем, в котором он вызван. Вместо этого модуля, содержащего метод расширения импортируется, если необходимо, чтобы привести его в область. После модуля, содержащего `Print` находится в области видимости, метод может быть вызван, как если бы он был обычным экземпляром метода, не принимающую аргументы, такие как `ToUpper`:  
  
 [!code-vb[VbVbalrExtensionMethods#2](./codesnippet/VisualBasic/extension-methods_2.vb)]  
  
 Следующий пример `PrintAndPunctuate`, также является расширением <xref:System.String>, определенным с помощью двух параметров. Первый параметр `aString`, устанавливает, что метод расширения расширяет <xref:System.String>. Второй параметр `punc`, должно быть строкой знаки пунктуации, передается в качестве аргумента при вызове метода. Метод отображает строку, следуют знаки пунктуации.  
  
 [!code-vb[VbVbalrExtensionMethods#3](./codesnippet/VisualBasic/extension-methods_3.vb)]  
  
 Метод вызывается отправкой аргумента строки для `punc`:`example.PrintAndPunctuate(".")`  
  
 В следующем примере показан `Print` и `PrintAndPunctuate` определен и вызывается. <xref:System.Runtime.CompilerServices>импортируется в модуле определения для обеспечения доступа к атрибуту расширения.  
  
### <a name="code"></a>Код  
  
```vb  
Imports System.Runtime.CompilerServices  
  
Module StringExtensions  
  
    <Extension()>   
    Public Sub Print(ByVal aString As String)  
        Console.WriteLine(aString)  
    End Sub  
  
    <Extension()>   
    Public Sub PrintAndPunctuate(ByVal aString As String,   
                                 ByVal punc As String)  
        Console.WriteLine(aString & punc)  
    End Sub  
  
End Module  
```  
  
 Затем методы расширения добавлены в область действия и вызывается.  
  
```vb  
Imports ConsoleApplication2.StringExtensions  
Module Module1  
  
    Sub Main()  
  
        Dim example As String = "Example string"  
        example.Print()  
  
        example = "Hello"  
        example.PrintAndPunctuate(".")  
        example.PrintAndPunctuate("!!!!")  
  
    End Sub  
End Module  
```  
  
### <a name="comments"></a>Комментарии  
 Все, что требуется для выполнения этих или подобных методов расширения является то, что они в области. Если в области действия модуля, содержащего метод расширения, он отображается в IntelliSense и может вызываться, как если бы он был обычным экземпляром метода.  
  
 Обратите внимание, что при вызове методов, никакой аргумент не передается качестве первого параметра. Параметр `aString` в предыдущий метод определения привязан к `example`, экземпляр `String` , вызывает их. Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.  
  
 Если метод расширения вызывается для объекта, который имеет значение `Nothing`, выполняет метод расширения. Это не относится к обычный методами экземпляра. Вы можете явно не проверять `Nothing` в методе расширения.  
  
## <a name="types-that-can-be-extended"></a>Типы, которые могут быть расширены  
 Можно определить метод расширения большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:  
  
-   Классы (ссылочные типы)  
  
-   Структуры (типы значений)  
  
-   Интерфейсы  
  
-   Делегаты  
  
-   Аргументы ByRef и ByVal  
  
-   Параметры универсального метода.  
  
-   Массивы  
  
 Так как первый параметр указывает тип данных, который расширяет метод расширения, он является обязательным и не может быть необязательным. По этой причине `Optional` параметры и `ParamArray` параметры не могут быть первый параметр в списке параметров.  
  
 Методы расширения не учитываются в позднего связывания. В следующем примере инструкция `anObject.PrintMe()` вызывает <xref:System.MissingMemberException> исключения, которые появляются, если и то же исключение второй `PrintMe` определение метода расширения были удалены.  
  
 [!code-vb[VbVbalrExtensionMethods#9](./codesnippet/VisualBasic/extension-methods_4.vb)]  
  
## <a name="best-practices"></a>Рекомендации  
 Методы расширения предоставляют удобный и мощный способ расширить существующий тип. Тем не менее для успешного использования, которые необходимо учитывать некоторые моменты. Эти рекомендации применяются главным образом для авторов библиотек классов, но они могут повлиять на любое приложение, использующее методы расширения.  
  
 Как правило методы расширения, добавленные к типам, которые вам не принадлежат более уязвимы чем методы расширения, добавленные к типам, которыми вы управляете. Количество операций, может возникнуть в классах, которые вам не принадлежат, могут конфликтовать с методами расширения.  
  
-   Если существует любой доступный элемент экземпляра, который имеет сигнатуру, совместимую с аргументами в вызывающей инструкции, при этом сужающие преобразования не требуется для параметра от аргумента, метод экземпляра будет использоваться в предпочтение любому методу расширения. Таким образом Если соответствующий метод экземпляра добавляется в класс в некоторой точке, существующий элемент расширения, основанные на могут стать недоступными.  
  
-   Автор метода расширения не может помешать другим программистам записать конфликтующие методы расширения, которые могут иметь приоритет над исходным расширением.  
  
-   Надежность можно повысить, помещая методы расширения в свое собственное пространство имен. Потребители библиотеки можно включить пространство имен или исключить его или выбрать пространства имен отдельно от остальной части библиотеки.  
  
-   Он может оказаться более безопасным расширить интерфейсы, чем расширения классов, особенно в том случае, если вы не являетесь владельцем интерфейса или класса. Изменения в интерфейсе влияет на каждый класс, который его реализует. Таким образом автор, можно снизить вероятность для добавления или изменения методов в интерфейсе. Однако если класс реализует два интерфейса, имеющих методы расширения с такой же сигнатурой, ни один из методов расширения не виден.  
  
-   Расширить наиболее конкретный тип, который вы можете. В иерархии типов Если выбран тип, от которого наследуются другие типы, существуют уровни возможностей для введения методов экземпляра или других методов расширения, которые могут конфликтовать с вашими.  
  
## <a name="extension-methods-instance-methods-and-properties"></a>Методы расширения, методы экземпляра и свойства  
 Когда метод экземпляра в области имеет сигнатуру, совместимую с аргументом вызывающего оператора, метод экземпляра выбирается в предпочтение любому методу расширения. Метод экземпляра имеет более высокий приоритет, даже если метод расширения является более подходящим. В следующем примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod` , имеющий один параметр типа `Integer`. Метод расширения `ExampleMethod` расширяет `ExampleClass`, и имеет один параметр типа `Long`.  
  
 [!code-vb[VbVbalrExtensionMethods#4](./codesnippet/VisualBasic/extension-methods_5.vb)]  
  
 Первый вызов `ExampleMethod` в следующий код вызывает метод расширения, поскольку `arg1` — `Long` и совместим только с `Long` параметр метода расширения. Второй вызов `ExampleMethod` имеет `Integer` аргумент, `arg2`, и он вызывает метод экземпляра.  
  
 [!code-vb[VbVbalrExtensionMethods#5](./codesnippet/VisualBasic/extension-methods_6.vb)]  
  
 Теперь обратный типы данных параметров двумя способами:  
  
 [!code-vb[VbVbalrExtensionMethods#6](./codesnippet/VisualBasic/extension-methods_7.vb)]  
  
 Код в `Main` вызывает метод экземпляра оба раза. Это, поскольку оба `arg1` и `arg2` иметь расширяющее преобразование `Long`, а метод экземпляра имеет преимущество перед методом расширения в обоих случаях.  
  
 [!code-vb[VbVbalrExtensionMethods#7](./codesnippet/VisualBasic/extension-methods_8.vb)]  
  
 Таким образом метод расширения не может заменить существующий метод экземпляра. Тем не менее если метод расширения имеет то же имя, что и метод экземпляра, но подписи не конфликтуют, оба метода может быть доступен. Например если класс `ExampleClass` содержит метод с именем `ExampleMethod` , не имеющий аргументов, методы расширения с тем же именем, но различными сигнатурами, допускаются, как показано в следующем коде.  
  
 [!code-vb[VbVbalrExtensionMethods#8](./codesnippet/VisualBasic/extension-methods_9.vb)]  
  
 Результат выполнения этого кода выглядит следующим образом:  
  
 `Extension method`  
  
 `Instance method`  
  
 Ситуация выглядит проще со свойствами: Если метод расширения имеет имя, совпадающее с именем свойства класса, который он расширяет, метод расширения не отображается и не доступен.  
  
## <a name="extension-method-precedence"></a>Приоритет метода расширения  
 Когда два метода расширения, имеющие одинаковые сигнатуры в области и доступны, будет вызван метод с более высоким приоритетом. Приоритет метода расширения основан на механизм, используемый для переноса метода в область. Ниже перечислены иерархии приоритета, от наибольшего к наименьшему.  
  
1.  Методы расширения, определенные внутри текущего модуля.  
  
2.  Методы расширения определенные внутри типов данных в текущем пространстве имен или один из его родительских объектов с дочерними пространствами имен, имеющими более высокий приоритет, чем родительские пространства имен.  
  
3.  Методы расширения, определенные внутри любых импортов типа в текущем файле.  
  
4.  Методы расширения, определенные внутри любых импортов пространства имен в текущем файле.  
  
5.  Методы расширения, определенные внутри любых импортов типов на уровне проекта.  
  
6.  Методы расширения, определенные внутри любых импортов пространства имен на уровне проекта.  
  
 Если приоритет не позволяет устранить неоднозначность, можно использовать полное доменное имя для указания метода, который вы вызываете. Если `Print` метод в предыдущем примере определен в модуле с именем `StringExtensions`, полное доменное имя является `StringExtensions.Print(example)` вместо `example.Print()`.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Runtime.CompilerServices>  
 <xref:System.Runtime.CompilerServices.ExtensionAttribute>  
 [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)  
 [Оператор Module](../../../../visual-basic/language-reference/statements/module-statement.md)  
 [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)  
 [Необязательные параметры](./optional-parameters.md)  
 [Массивы параметров](./parameter-arrays.md)  
 [Обзор атрибутов](../../../../visual-basic/programming-guide/concepts/attributes/index.md)  
 [Область в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)
