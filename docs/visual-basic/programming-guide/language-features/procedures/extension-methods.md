---
title: "Методы расширения (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
f1_keywords: 
  - "vb.ExtensionMethods"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "расширение типов данных"
  - "методы расширения [Visual Basic]"
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
caps.latest.revision: 41
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 41
---
# Методы расширения (Visual Basic)
[!INCLUDE[vs2017banner](../../../../visual-basic/includes/vs2017banner.md)]

Методы расширения позволяют разработчикам добавлять пользовательские функциональные возможности типам данных, которые уже определены, не создавая новый производный тип.  Методы расширения делают возможным написание метода, который может вызываться, как если бы это был метод экземпляра существующего типа.  
  
## Заметки  
 Методом расширения может быть только процедура `Sub` или `Function`.  Нельзя определить свойство расширения, поле или событие.  Все методы расширения должен быть помечены атрибутом расширения `<Extension()>` из пространства имен <xref:System.Runtime.CompilerServices?displayProperty=fullName>.  
  
 Первый параметр в определении метода расширения указывает тип данных, который расширяет метод.  При выполнении метода первый параметр привязан к экземпляру типа данных, который вызывает метод.  
  
## Пример  
  
### Описание  
 В следующем примере определяется расширение `Print` до типа данных <xref:System.String>.  Метод использует `Console.WriteLine` для отображения строки.  Параметр метода `Print`, `aString`, устанавливает, что метод расширяет класс <xref:System.String>.  
  
 [!code-vb[VbVbalrExtensionMethods#1](./codesnippet/VisualBasic/extension-methods_1.vb)]  
  
 Обратите внимание, что определение метода расширения помечено атрибутом расширения `<Extension()>`.  Помечать модуль, в котором определен метод, не обязательно, но каждый метод расширения должен быть помечен.  Для получения доступа к атрибуту расширения следует импортировать пространство имен <xref:System.Runtime.CompilerServices>.  
  
 Методы расширения могут быть объявлены только внутри модулей.  Как правило, модуль, в котором определен метод расширения, является не тем же модулем, в котором он вызывается.  Вместо этого, модуль, содержащий метод расширения, импортируется, если необходимо, для включения его в область.  После введения в область действия модуля, содержащего `Print`, метод может быть вызван, как если бы он был обычным экземпляром метода, не имеющего аргументов, например, `ToUpper`:  
  
 [!code-vb[VbVbalrExtensionMethods#2](./codesnippet/VisualBasic/extension-methods_2.vb)]  
  
 В следующем примере `PrintAndPunctuate` является также расширением <xref:System.String>, но определенным с помощью двух параметров.  Первый параметр, `aString`, устанавливает, что метод расширения расширяет <xref:System.String>.  Второй параметр, `punc`, должен быть строкой знаков пунктуации, передаваемой в качестве аргумента при вызове метода.  Метод отображает строку со следующими за ней знаками пунктуации.  
  
 [!code-vb[VbVbalrExtensionMethods#3](./codesnippet/VisualBasic/extension-methods_3.vb)]  
  
 Метод вызывается отправкой аргумента строки для `punc`: `example.PrintAndPunctuate(".")`  
  
 В следующем примере определяются и вызываются методы `Print` и `PrintAndPunctuate`.  Пространство имен <xref:System.Runtime.CompilerServices> импортируется в модуле определения, чтобы сделать возможным доступ к атрибуту расширения.  
  
### Код  
  
```vb#  
Imports System.Runtime.CompilerServices  
  
Module StringExtensions  
  
    <Extension()>   
    Public Sub Print(ByVal aString As String)  
        Console.WriteLine(aString)  
    End Sub  
  
    <Extension()>   
    Public Sub PrintAndPunctuate(ByVal aString As String,   
                                 ByVal punc As String)  
        Console.WriteLine(aString & punc)  
    End Sub  
  
End Module  
```  
  
 Затем методы расширения вносятся в область действия и вызываются.  
  
```vb#  
Imports ConsoleApplication2.StringExtensions  
Module Module1  
  
    Sub Main()  
  
        Dim example As String = "Example string"  
        example.Print()  
  
        example = "Hello"  
        example.PrintAndPunctuate(".")  
        example.PrintAndPunctuate("!!!!")  
  
    End Sub  
End Module  
```  
  
### Комментарии  
 Все, что необходимо для выполнения этих или подобных методов расширения, — это включение их в область действия.  Если модуль, содержащий метод расширения, входит в область действия, он отображается в технологии IntelliSense и может вызываться, как если бы он был обычным методом экземпляра.  
  
 Обратите внимание, что при вызове методов аргумент не отправляется для первого параметра.  Параметр `aString` в предыдущих определениях метода привязан к `example` — экземпляру `String`, который вызывает их.  Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.  
  
 Если метод расширения вызывается для объекта, для которого установлено значение `Nothing`, метод расширения выполняется.  Эта операция не применяется к обычным методам экземпляров.  Можно явно проверять `Nothing` в методе расширения.  
  
## Типы, которые могут быть расширены  
 Можно определить метод расширения большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:  
  
-   Классы \(ссылочные типы\)  
  
-   Структуры \(типы значений\)  
  
-   Интерфейсы  
  
-   Делегаты  
  
-   Аргументы ByVal и ByRef  
  
-   Параметры базового метода  
  
-   Массивы  
  
 Поскольку первый параметр задает тип данных, который расширяет метод расширения, он необходим и не может быть необязательным.  По этой причины параметры `Optional` и `ParamArray` не могут быть первым параметром в списке параметров.  
  
 При позднем связывании методы расширения не учитываются.  В следующем примере инструкция `anObject.PrintMe()` вызывает исключение <xref:System.MissingMemberException>; такое же исключение возникает, если удалить определение второго метода расширения `PrintMe`.  
  
 [!code-vb[VbVbalrExtensionMethods#9](./codesnippet/VisualBasic/extension-methods_4.vb)]  
  
## Рекомендации  
 Методы расширения предоставляют удобный и мощный способ расширить существующий тип.  Однако чтобы использовать их успешно, существуют некоторые рекомендации.  Эти советы главным образом касаются авторов библиотек классов, но могут и повлиять на любое приложение, использующее методы расширения.  
  
 Как правило, методы расширения, которые Вы добавляете к типам, которые Вам не принадлежат, являются более уязвимыми, чем методы расширения, добавленные к типам, которыми Вы управляете.  Число объектов может возникнуть в классах, которые Вам не принадлежат, и это может конфликтовать с методами расширения.  
  
-   Если существует какой\-либо доступный элемент экземпляра, который имеет сигнатуру, совместимую с аргументами в вызывающей инструкции, и при этом сужающие преобразования не требуется для параметра от аргумента, метод экземпляра будет использоваться в предпочтение к любому методу расширения.  Таким образом, если соответствующий метод экземпляра добавляется в класс в некоторой точке, существующий элемент расширения, на который вы полагаетесь, может стать недоступным.  
  
-   Автор метода расширения не может помешать другим программистам записать конфликтующие методы расширения, которые могут иметь приоритет над исходным расширением.  
  
-   Надежность можно повысить, помещая методы расширения в свое собственное пространство имен.  Потребители библиотеки могут включить пространство имен, исключить или выбрать пространства имен отдельно от остальной части библиотеки.  
  
-   Может оказаться более безопасным расширить интерфейсы, а не расширить классы, особенно если вы не являетесь владельцем интерфейса или класса.  Изменения в интерфейсе влияют на каждый класс, реализующий его.  Таким образом можно снизить вероятность добавления или изменения автором методов в интерфейсе.  Однако, если класс реализует два интерфейса, имеющих методы расширения с одной и той же сигнатурой, ни один из методов расширения не виден.  
  
-   Можно расширить наиболее конкретный тип.  В иерархии типов, если выбран тип, от которого многие другие типы являются производными, существуют уровни возможностей для введения методов экземпляра или других методов расширения, способных конфликтовать с вашими.  
  
## Методы расширения, Методы экземпляра и Свойства  
 Когда входящий в сферу действия метод экземпляра имеет совместимую с аргументом вызывающего оператора сигнатуру, метод экземпляра выбирается в предпочтение любому методу расширения.  Метод экземпляра имеет приоритет, даже когда метод расширения является более подходящим.  В приведенном примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod`, имеющий один параметр типа `Integer`.  Метод расширения `ExampleMethod` расширяет `ExampleClass` и обладает одним параметром типа `Long`.  
  
 [!code-vb[VbVbalrExtensionMethods#4](./codesnippet/VisualBasic/extension-methods_5.vb)]  
  
 Первое обращение к `ExampleMethod` в следующем коде вызывает метод расширения, поскольку `arg1` является `Long` и совместим только с параметром `Long` в методе расширения.  Во втором обращении к `ExampleMethod` присутствует аргумент `Integer`, `arg2`, и он вызывает метод экземпляра.  
  
 [!code-vb[VbVbalrExtensionMethods#5](./codesnippet/VisualBasic/extension-methods_6.vb)]  
  
 Теперь изменим типы данных параметров на обратные двумя способами:  
  
 [!code-vb[VbVbalrExtensionMethods#6](./codesnippet/VisualBasic/extension-methods_7.vb)]  
  
 Здесь код в `Main` вызывает метод экземпляра оба раза.  Это происходит, поскольку как `arg1`, так и `arg2` обладают расширяющим преобразованием относительно `Long`, а метод экземпляра имеет преимущество перед методом расширения в обоих случаях.  
  
 [!code-vb[VbVbalrExtensionMethods#7](./codesnippet/VisualBasic/extension-methods_8.vb)]  
  
 Таким образом, метод расширения не может заменить существующий метод экземпляра.  Однако, если метод расширения имеет то же имя, что и метод экземпляра, но с сигнатурами не возникает конфликта, оба метода остаются доступными.  Например, если класс `ExampleClass` содержит метод с именем `ExampleMethod`, не имеющий аргументов, методы расширения с одинаковыми именами, но различными сигнатурами, допускаются, как показано в следующем коде.  
  
 [!code-vb[VbVbalrExtensionMethods#8](./codesnippet/VisualBasic/extension-methods_9.vb)]  
  
 Результат выполнения этого кода выглядит следующим образом:  
  
 `Extension method`  
  
 `Instance method`  
  
 Ситуация выглядит проще со свойствами: если метод расширения имеет то же имя, что и свойство класса, который он расширяет, метод расширения невидим и недоступен.  
  
## Приоритет метода расширения  
 Когда два метода расширения, имеющие одинаковые сигнатуры, присутствуют в области действия и доступны, будет вызван метод с более высоким приоритетом.  Приоритет метода расширения основан на механизме, используемом для переноса метода в область.  В следующем списке показана иерархия приоритетов от самого высокого до самого низкого.  
  
1.  Методы расширения, определенные внутри текущего модуля.  
  
2.  Методы расширения, определенные внутри типов данных в текущем пространстве имен или одном из его родителей, с дочерними пространствами имен, имеющими более высокий приоритет, чем родительские пространства имен.  
  
3.  Методы расширения, определенные внутри любых импортов типа в текущем файле.  
  
4.  Методы расширения, определенные внутри любых импортов пространств имен в текущем файле.  
  
5.  Методы расширения, определенные внутри любых импортов типов на уровне проекта.  
  
6.  Методы расширения, определенные внутри любого импорта пространства имен на уровне проекта.  
  
 Если приоритет не помогает устранить неоднозначность, можно использовать полное проверенное имя для указания метода, который вы вызываете.  Если метод `Print` в более раннем примере определен в модуле с именем `StringExtensions`, полным именем является `StringExtensions.Print(example)` вместо `example.Print()`.  
  
## См. также  
 <xref:System.Runtime.CompilerServices>   
 <xref:System.Runtime.CompilerServices.ExtensionAttribute>   
 [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)   
 [Оператор Module](../../../../visual-basic/language-reference/statements/module-statement.md)   
 [Параметры и аргументы процедуры](../../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)   
 [Необязательные параметры](../../../../visual-basic/programming-guide/language-features/procedures/optional-parameters.md)   
 [Массивы параметров](../../../../visual-basic/programming-guide/language-features/procedures/parameter-arrays.md)   
 [Атрибуты](../Topic/Attributes%20\(C%23%20and%20Visual%20Basic\).md)   
 [Область видимости в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/scope.md)