---
title: Устранение неполадок в процедурах (Visual Basic)
ms.custom: ''
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology:
- devlang-visual-basic
ms.topic: article
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures [Visual Basic], troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures [Visual Basic], about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
caps.latest.revision: 17
author: dotnet-bot
ms.author: dotnetcontent
ms.openlocfilehash: 7e54c965dc15131734be2c5bcfe04ad70292bf23
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="troubleshooting-procedures-visual-basic"></a>Устранение неполадок в процедурах (Visual Basic)
Этой странице перечислены некоторые общие проблемы, которые могут возникнуть при работе с процедурами.  
  
## <a name="returning-an-array-type-from-a-function-procedure"></a>Возврат типа массива из процедуры Function  
 Если `Function` процедура возвращает тип данных массива, нельзя использовать `Function` имя для хранения значений в элементах массива. Если вы попытаетесь это сделать, компилятор интерпретирует его как вызов `Function`. Следующий пример приводит к возникновению ошибки компилятора.  
  
 `Function allOnes(ByVal n As Integer) As Integer()`  
  
 `For i As Integer = 1 To n - 1`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `allOnes(i) = 1`  
  
 `Next i`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `Return allOnes()`  
  
 `End Function`  
  
 Инструкция `allOnes(i) = 1` создает ошибку компилятора, поскольку для вызова `allOnes` с аргументом неверного типа данных (одноэлементный `Integer` вместо `Integer` массива). Инструкция `Return allOnes()` создает ошибку компилятора, поскольку для вызова `allOnes` без аргумента.  
  
 **Правильный подход:** возможность изменения элементов массива, должно быть возвращено, определение внутреннего массива как локальная переменная. В следующем примере компилируется без ошибок.  
  
 [!code-vb[VbVbcnProcedures#66](./codesnippet/VisualBasic/troubleshooting-procedures_1.vb)]  
  
## <a name="argument-not-being-modified-by-procedure-call"></a>Аргумент не изменен вызовом процедуры  
 Если вы собираетесь разрешить процедуре изменять программный элемент базового аргумента в вызывающем коде, необходимо передать его по ссылке. Но процедура может доступа к элементам аргумента ссылочного типа, даже если он передается по значению.  
  
-   **Базовый переменной**. Чтобы разрешить процедуре заменить значение элемента базовой переменной, процедура должна объявить параметр [ByRef](../../../../visual-basic/language-reference/modifiers/byref.md). Также, вызывающий код не должен заключать аргумент в круглые скобки, поскольку это переопределяет `ByRef` механизм передачи.  
  
-   **Ссылаться на элементы типа**. Если параметр объявлен [ByVal](../../../../visual-basic/language-reference/modifiers/byval.md), процедура не может изменить элемент базовой переменной. Однако если аргумент имеет ссылочный тип, процедура может изменить члены объекта, на который он указывает, несмотря на то, что она не может заменить значение переменной. Например если аргумент является массивом, процедура нельзя присвоить новый массив, но его можно изменить один или несколько его элементов. Изменение элементов, отражаются в базовую переменную массива в вызывающем коде.  
  
 В следующем примере определяется две процедуры, которые принимают переменную массива по значению и работать над его элементами. Процедура `increase` просто добавляет единицу к каждому элементу. Процедура `replace` присваивает новый массив параметру `a()` и добавляет единицу к каждому элементу. Однако, переопределение не влияет на базовую переменную массива в вызывающем коде, так как `a()` объявлен `ByVal`.  
  
 [!code-vb[VbVbcnProcedures#35](./codesnippet/VisualBasic/troubleshooting-procedures_2.vb)]  
  
 [!code-vb[VbVbcnProcedures#38](./codesnippet/VisualBasic/troubleshooting-procedures_3.vb)]  
  
 Следующий пример выполняет вызовы `increase` и `replace`.  
  
 [!code-vb[VbVbcnProcedures#37](./codesnippet/VisualBasic/troubleshooting-procedures_4.vb)]  
  
 Первый `MsgBox` вызове отображается «после увеличения (n): 11, 21, 31, 41». Поскольку `n` является ссылочным типом, `increase` может изменить его элементы, даже если он передается `ByVal`.  
  
 Второй `MsgBox` вызове отображается «после замены(n): 11, 21, 31, 41». Поскольку `n` передается `ByVal`, `replace` не может изменить переменную `n` путем присвоения нового массива. Когда `replace` создает новый экземпляр массива `k` и присваивает его локальной переменной `a`, он теряет ссылку на `n` передается в вызывающий код. Когда он увеличивает члены `a`, только локальный массив `k` зависит.  
  
 **Правильный подход:** чтобы иметь возможность изменить элемент базовой переменной, передайте его по ссылке. В следующем примере показано изменение в объявлении `replace` , позволяющее заменить один массив на другой в вызывающем коде.  
  
 [!code-vb[VbVbcnProcedures#64](./codesnippet/VisualBasic/troubleshooting-procedures_5.vb)]  
  
## <a name="unable-to-define-an-overload"></a>Не удалось определить перегрузку  
 Если вы хотите определить перегруженные версии процедуры, необходимо использовать одинаковое имя, но другой сигнатурой. Если компилятор не может отличить объявление от перегруженного варианта с такой же сигнатурой, он создает ошибку.  
  
 *Подписи* процедуры определяется имя процедуры и список параметров. Каждая перегрузка должен иметь имя, совпадающее с именем все другие перегрузки, но должна отличаться от всех, по крайней мере одним из компонентов подписи. Дополнительные сведения см. в разделе [перегрузка процедур](./procedure-overloading.md).  
  
 Следующие элементы, даже если они относятся к списку параметров, не являются компонентами подписи процедуры:  
  
-   Ключевые слова модификаторов процедур, таких как `Public`, `Shared`, и `Static`  
  
-   Имена параметров  
  
-   Ключевые слова модификаторов параметров, таких как `ByRef` и `Optional`  
  
-   Тип данных возвращаемого значения (за исключением оператора преобразования)  
  
 Нельзя перегрузить процедуру путем изменения только один или несколько из вышеперечисленных элементов.  
  
 **Правильный подход:** возможность определить перегрузка процедуры, необходимо изменить подпись. Так как необходимо использовать то же имя, необходимо изменить номер, порядок или типы данных параметров. Универсальная процедура можно задавать разное число параметров типа. В оператор преобразования ([функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md)), можно изменить тип возвращаемого значения.  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузки разрешение с необязательными и ParamArray-аргументы  
 Если происходит перегрузка процедуры с одним или несколькими [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) параметры или [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) параметр, необходимо избегать дублирования *неявные перегрузки*. Сведения см. в разделе [вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md).  
  
## <a name="calling-a-wrong-version-of-an-overloaded-procedure"></a>Вызов неверной версии перегруженной процедуры  
 Если процедура имеет несколько перегруженных версий, необходимо уметь работать с их списки параметров и понять, как Visual Basic разрешает вызовы между перегрузками. В противном случае можно вызвать перегрузку, отличную от предполагаемой.  
  
 После определения перегрузки, которую требуется вызвать стараться придерживайтесь следующих правил:  
  
-   Укажите правильное количество аргументов и в правильном порядке.  
  
-   В идеальном случае аргументы должны иметь те же типы данных, что и соответствующие параметры. В любом случае тип данных каждого аргумента должен расширяться, соответствующего параметра. Это верно даже при использовании [оператор Option Strict](../../../../visual-basic/language-reference/statements/option-strict-statement.md) значение `Off`. Если перегрузка требует сужающего преобразования списка аргументов, перегрузки не может быть вызвана.  
  
-   При указании аргументов, которые требуют расширения, задайте их типы данных как можно ближе к типам данных параметров. Если два или несколько перегрузок принимают типы данных аргументов, компилятор разрешает вызов перегрузку, которая вызывает наименьший объем расширения.  
  
 Можно уменьшить вероятность несоответствия типов данных с помощью [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) ключевое слово преобразования при подготовке аргументов.  
  
### <a name="overload-resolution-failure"></a>Сбой разрешения перегрузки  
 При вызове перегруженной процедуры, компилятор пытается выбрать единственную перегрузку. Если он выполняется успешно, он разрешает вызов этой перегрузки. Если исключаются все перегрузки или его нельзя уменьшить быть выбран единственный вариант, он выдает ошибку.  
  
 В следующем примере показано перегруженного процесса разрешения.  
  
 [!code-vb[VbVbcnProcedures#62](./codesnippet/VisualBasic/troubleshooting-procedures_6.vb)]  
  
 [!code-vb[VbVbcnProcedures#63](./codesnippet/VisualBasic/troubleshooting-procedures_7.vb)]  
  
 В первом вызове компилятор устраняет первую перегрузку, так как тип первого аргумента (`Short`) сужается к типу соответствующего параметра (`Byte`). Затем исключаются третья перегрузка, так как каждый тип аргумента во второй перегрузке (`Short` и `Single`) может быть расширен до соответствующего типа в третьей перегрузке (`Integer` и `Single`). Вторая перегрузка требует меньшего расширения, поэтому компилятор использует его для вызова.  
  
 Во втором вызове компилятор не может устранить зависимости от сужения перегрузок. Она также аннулирует третьей перегрузке по той же причине, что и первый вызов, так как он может вызвать вторую перегрузку с меньшим расширением типов аргументов. Однако компилятор не может разрешить между первой и второй перегрузок. Каждая имеет один определенный тип параметра, может быть расширен до соответствующего типа в другой (`Byte` для `Short`, но `Single` для `Double`). Поэтому компилятор создает ошибку разрешения перегрузки.  
  
 **Правильный подход:** могли осуществлять вызов перегруженной процедуры без неоднозначности, используйте [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) для сопоставления типов данных аргументов в типы параметров. В следующем примере показано вызов `z` , требующий разрешения второй перегрузки.  
  
 [!code-vb[VbVbcnProcedures#65](./codesnippet/VisualBasic/troubleshooting-procedures_8.vb)]  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузки разрешение с необязательными и ParamArray-аргументы  
 Если две перегрузки процедуры имеют одинаковые сигнатуры, за исключением того, что последний параметр объявляется [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) в одном и [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) в другой, компилятор разрешает вызов процедуры в соответствии с наиболее точное соответствие. Дополнительные сведения см. в разделе [разрешение перегрузки](./overload-resolution.md).  
  
## <a name="see-also"></a>См. также  
 [Процедуры](./index.md)  
 [Подпрограммы](./sub-procedures.md)  
 [Процедуры функций](./function-procedures.md)  
 [Процедуры свойств](./property-procedures.md)  
 [Процедуры операторов](./operator-procedures.md)  
 [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)  
 [Перегрузка процедур](./procedure-overloading.md)  
 [Вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md)  
 [Разрешение перегрузки](./overload-resolution.md)
