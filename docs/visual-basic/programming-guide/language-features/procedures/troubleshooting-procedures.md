---
title: "Устранение неполадок в процедурах (Visual Basic) | Документы Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures, troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures, about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
caps.latest.revision: 17
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: a5445d6da982e4eea5b1047505e4bee3380ed472
ms.lasthandoff: 03/13/2017

---
# <a name="troubleshooting-procedures-visual-basic"></a>Устранение неполадок в процедурах (Visual Basic)
На этой странице перечислены некоторые общие проблемы, которые могут возникнуть при работе с процедурами.  
  
## <a name="returning-an-array-type-from-a-function-procedure"></a>Возврат типа массива из процедуры Function  
 Если `Function` процедура возвращает массив, нельзя использовать `Function` имя для хранения значений элементов массива. Попытка сделать это, компилятор интерпретирует как вызов `Function`. В следующем примере возникает ошибки компилятора.  
  
 `Function allOnes(ByVal n As Integer) As Integer()`  
  
 `For i As Integer = 1 To n - 1`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `allOnes(i) = 1`  
  
 `Next i`  
  
 `' The following statement generates a`   `COMPILER ERROR`  `.`  
  
 `Return allOnes()`  
  
 `End Function`  
  
 Инструкция `allOnes(i) = 1` создает ошибку компилятора, поскольку для вызова `allOnes` с аргументом неверного типа данных (одноэлементный `Integer` вместо `Integer` массива). Инструкция `Return allOnes()` создает ошибку компилятора, поскольку для вызова `allOnes` без аргументов.  
  
 **Правильный подход:** может изменять элементы массива, который должен быть возвращен, определить внутреннего массива как локальная переменная. В следующем примере компилируется без ошибок.  
  
 [!code-vb[VbVbcnProcedures&#66;](./codesnippet/VisualBasic/troubleshooting-procedures_1.vb)]  
  
## <a name="argument-not-being-modified-by-procedure-call"></a>Аргумент не изменен вызовом процедуры  
 Если предполагается позволить процедуре изменять программный элемент, лежащий в основе аргумента в вызывающем коде, необходимо передать его по ссылке. Но процедура может доступа к элементам аргумента ссылочного типа, даже если при передаче по значению.  
  
-   **Базовый переменной**. Чтобы разрешить процедуре заменить значение элемента базовой переменной, процедура должна объявить параметр [ByRef](../../../../visual-basic/language-reference/modifiers/byref.md). Также, вызывающий код не должен заключать аргумент в круглые скобки, поскольку это переопределяет `ByRef` механизм передачи.  
  
-   **Ссылаться на элементы типа**. Если параметр объявлен [ByVal](../../../../visual-basic/language-reference/modifiers/byval.md), процедура не может изменить элемент базовой переменной. Однако если аргумент имеет ссылочный тип, процедура может изменить члены объекта, на который он указывает, несмотря на то, что она не может заменить значение переменной. Например если аргумент является переменной массива, ему нельзя присвоить новый массив, к ней, но его можно изменить один или несколько его элементов. Изменение элементов, отражаются в базовой переменной массива в вызывающем коде.  
  
 В следующем примере определяется две процедуры, которые принимают переменную массива по значению и работать над его элементами. Процедура `increase` просто добавляет единицу к каждому элементу. Процедура `replace` присваивает новый массив параметру `a()` и затем добавляет единицу к каждому элементу. Однако переназначение не влияет на базовую переменную массива в вызывающем коде, так как `a()` объявляется `ByVal`.  
  
 [!code-vb[VbVbcnProcedures&#35;](./codesnippet/VisualBasic/troubleshooting-procedures_2.vb)]  
  
 [!code-vb[VbVbcnProcedures&#38;](./codesnippet/VisualBasic/troubleshooting-procedures_3.vb)]  
  
 Следующий пример вызывает `increase` и `replace`.  
  
 [!code-vb[VbVbcnProcedures&#37;](./codesnippet/VisualBasic/troubleshooting-procedures_4.vb)]  
  
 Первый `MsgBox` вызове отображается «после увеличения (n): 11, 21, 31, 41». Поскольку `n` является ссылочным типом, `increase` может изменить его элементы, несмотря на то, что он передается `ByVal`.  
  
 Второй `MsgBox` вызове отображается «после замены(n): 11, 21, 31, 41». Поскольку `n` передается `ByVal`, `replace` не может изменить переменную `n` , назначив ему новый массив. Когда `replace` создает новый экземпляр массива `k` и назначает его локальной переменной `a`, он теряет ссылку на `n` передается в вызывающий код. Когда он увеличивает члены `a`, только локальный массив `k` изменяется.  
  
 **Правильный подход:** возможность изменить элемент базовой переменной, передать его по ссылке. В следующем примере показано изменение в объявлении `replace` , позволяющее заменить один массив на другой в вызывающем коде.  
  
 [!code-vb[VbVbcnProcedures&#64;](./codesnippet/VisualBasic/troubleshooting-procedures_5.vb)]  
  
## <a name="unable-to-define-an-overload"></a>Не удалось определить перегрузку  
 Если вы хотите определить перегруженную версию процедуры, необходимо использовать то же имя, но другую подпись. Если компилятор не может отличить объявление от перегруженного варианта с той же сигнатурой, он выдает ошибку.  
  
 *Подписи* процедуры определяется именем процедуры и списком параметров. Каждая перегрузка должен иметь имя, совпадающее с именем все другие перегрузки, но должна отличаться от всех, по крайней мере одним из компонентов подписи. Дополнительные сведения см. в разделе [перегрузка процедур](./procedure-overloading.md).  
  
 Следующие элементы, даже если они относятся к списку параметров, не являются компонентами сигнатуры процедуры:  
  
-   Ключевые слова модификаторов процедур, таких как `Public`, `Shared`, и`Static`  
  
-   Имена параметров  
  
-   Зарезервированные слова модификаторов параметров, таких как `ByRef` и`Optional`  
  
-   Тип данных возвращаемого значения (за исключением оператора преобразования)  
  
 Нельзя перегрузить процедуру, варьируя только один или несколько из вышеперечисленных элементов.  
  
 **Правильный подход:** для определения перегрузки процедуры должны различаться подпись. Так как необходимо использовать то же имя, должны меняться число, порядок и типы данных параметров. В универсальной процедуре можно варьировать число параметров типа. В операторе преобразовании ([функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md)), можно варьировать возвращаемый тип.  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузка разрешение с дополнительными и аргументы ParamArray  
 Если происходит перегрузка процедуры с одним или несколькими [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) параметры или [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) параметр, необходимо избегать дублирования *неявные перегрузки*. Сведения см. в разделе [вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md).  
  
## <a name="calling-a-wrong-version-of-an-overloaded-procedure"></a>Вызов неверной версии перегруженной процедуры  
 Если процедура имеет несколько перегруженных версий, следует ознакомиться со всеми их списками параметров и понять, как [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] разрешает вызовы между перегрузками. В противном случае можно вызвать перегрузку, отличную от предполагаемой.  
  
 После определения перегрузки, которую необходимо вызвать, следует соблюдать следующие правила:  
  
-   Укажите правильное количество аргументов и в правильном порядке.  
  
-   В идеальном случае аргументы должны иметь те же типы данных, что и соответствующие параметры. В любом случае тип данных каждого аргумента должен расширяться до соответствующего параметра. Это верно даже при [оператор Option Strict](../../../../visual-basic/language-reference/statements/option-strict-statement.md) значение `Off`. Если перегрузка требует сужающего преобразования списка аргументов, перегрузка не может быть вызвана.  
  
-   При указании аргументов, которые требуют расширения, задайте их типы данных как можно ближе к типам данных параметров. Если две или более перегрузки принимают типы данных аргументов, компилятор разрешает вызов перегрузки, которое вызывает наименьший объем расширения.  
  
 Можно уменьшить вероятность несоответствия типов данных с помощью [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) ключевого слова преобразования при подготовке аргументов.  
  
### <a name="overload-resolution-failure"></a>Сбой разрешения перегрузки  
 При вызове перегруженной процедуры компилятор пытается выбрать единственную перегрузку. В случае успеха он разрешает вызов этой перегрузки. Если исключаются все перегрузки или он не может снизить быть выбран единственный вариант, он выдает ошибку.  
  
 В следующем примере показано перегруженного процесса разрешения.  
  
 [!code-vb[VbVbcnProcedures&#62;](./codesnippet/VisualBasic/troubleshooting-procedures_6.vb)]  
  
 [!code-vb[VbVbcnProcedures&#63;](./codesnippet/VisualBasic/troubleshooting-procedures_7.vb)]  
  
 В первом вызове компилятор устраняет первую перегрузку, так как тип первого аргумента (`Short`) сужается к типу соответствующего параметра (`Byte`). Затем исключаются третья перегрузка, так как каждый тип аргумента во второй перегрузке (`Short` и `Single`) может быть расширен до соответствующего типа в третьей перегрузке (`Integer` и `Single`). Вторая перегрузка требует меньшего расширения, поэтому компилятор использует ее для вызова.  
  
 Во втором вызове компилятор не может устранить любую из перегрузок зависимости от сужения. Он исключаются третья перегрузка по тем же причинам, как в первом вызове, поскольку можно вызвать вторую перегрузку с меньшим расширением типов аргументов. Однако компилятор не может разрешить между первой и второй перегрузок. Каждая имеет один определенный тип параметра, может быть расширен до соответствующего типа в другой (`Byte` для `Short`, но `Single` для `Double`). Поэтому компилятор создает ошибку разрешения перегрузки.  
  
 **Правильный подход:** возможность вызов перегруженной процедуры без неоднозначности, используйте [функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md) соответствуют типы данных аргументов в типы параметров. В следующем примере показано вызов `z` , требующий разрешения второй перегрузки.  
  
 [!code-vb[VbVbcnProcedures&#65;](./codesnippet/VisualBasic/troubleshooting-procedures_8.vb)]  
  
### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Перегрузка разрешение с дополнительными и аргументы ParamArray  
 Если две перегрузки процедуры имеют идентичные подписи, за исключением того, что последний параметр объявляется [необязательно](../../../../visual-basic/language-reference/modifiers/optional.md) в одном и [ParamArray](../../../../visual-basic/language-reference/modifiers/paramarray.md) в другой, компилятор разрешает вызов процедуры, выбирая наиболее близкий вариант. Дополнительные сведения см. в разделе [разрешения перегруженных](./overload-resolution.md).  
  
## <a name="see-also"></a>См. также  
 [Процедуры](./index.md)   
 [Sub-процедуры](./sub-procedures.md)   
 [Процедуры функций](./function-procedures.md)   
 [Процедуры свойств](./property-procedures.md)   
 [Процедуры операторов](./operator-procedures.md)   
 [Параметры и аргументы процедуры](./procedure-parameters-and-arguments.md)   
 [Перегрузка процедур](./procedure-overloading.md)   
 [Вопросы, связанные с перегрузкой процедур](./considerations-in-overloading-procedures.md)   
 [Разрешение перегрузки](./overload-resolution.md)
