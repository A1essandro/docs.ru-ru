---
title: Анонимные типы (Visual Basic)
ms.custom: ''
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- vb.AnonymousType
helpviewer_keywords:
- anonymous types [Visual Basic], about anonymous types
- anonymous types [Visual Basic]
- types [Visual Basic], anonymous
ms.assetid: 7b87532c-4b3e-4398-8503-6ea9d67574a4
caps.latest.revision: 46
author: dotnet-bot
ms.author: dotnetcontent
ms.openlocfilehash: 530e21e1595f9bbc3436280418287413e2a48111
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="anonymous-types-visual-basic"></a>Анонимные типы (Visual Basic)
Visual Basic поддерживает анонимные типы, которые позволяют создавать объекты без написания определения класса для типа данных. Вместо этого компилятор создает класс для вас. Класс не имеет имени, наследует непосредственно от <xref:System.Object>и содержит свойства, которые указаны при объявлении объекта. Так как имя типа данных не указан, он называется *анонимного типа*.  
  
 В следующем примере объявляется и создается переменная `product` как экземпляр анонимного типа, который имеет два свойства `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#1](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_1.vb)]  
  
 Объект *выражение запроса* использует анонимные типы для объединения столбцов данных, выбранных по запросу. Невозможно определить тип результата заранее, так как невозможно предсказать, столбцы, которые может выбрать определенный запрос. Анонимные типы позволяют написать запрос, выбирающий любое количество столбцов, в любом порядке. Компилятор создает тип данных, который соответствует указанным свойствам и заданном порядке.  
  
 В следующих примерах `products` приведен список объектов продукта, каждый из которых имеет много свойств. Переменная `namePriceQuery` содержит определение запроса, который при выполнении возвращает коллекцию экземпляров анонимного типа с двумя свойствами `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#2](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_2.vb)]  
  
 Переменная `nameQuantityQuery` содержит определение запроса, который при выполнении возвращает коллекцию экземпляров анонимного типа с двумя свойствами `Name` и `OnHand`.  
  
 [!code-vb[VbVbalrAnonymousTypes#3](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_3.vb)]  
  
 Дополнительные сведения о коде, созданном компилятором для анонимного типа см. в разделе [определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
> [!CAUTION]
>  Имя анонимного типа будет создан компилятором и могут различаться для разных компиляций. Код должен использовать или не зависит от имени анонимного типа, так как имя может измениться при повторной компиляции проекта.  
  
## <a name="declaring-an-anonymous-type"></a>Объявление анонимного типа  
 При объявлении экземпляра анонимного типа используется список инициализаторов для указания свойств типа. Можно указать только свойства при объявлении анонимного типа, не другие элементы класса, например методы или события. В следующем примере `product1` представляет собой экземпляр анонимного типа, который имеет два свойства: `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#4](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_4.vb)]  
  
 Если назначить свойства как ключевые свойства, их можно использовать для сравнения на равенство двух экземпляров анонимного типа. Однако значения ключевых свойств не может изменяться. В разделе Основные свойства далее в этом разделе для получения дополнительной информации.  
  
 Обратите внимание, что объявление экземпляра анонимного типа как объявление экземпляра именованного типа с помощью инициализатора объекта:  
  
 [!code-vb[VbVbalrAnonymousTypes#5](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_5.vb)]  
  
 Дополнительные сведения о других способах задания свойств анонимного типа см. в разделе [как: определить имена свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md).  
  
## <a name="key-properties"></a>Ключевые свойства  
 Ключевые свойства отличаются от неключевые свойства фундаментальные способами:  
  
-   Чтобы определить, равны ли два экземпляра, сравниваются только значения ключевых свойств.  
  
-   Значения ключевых свойств доступны только для чтения и не может быть изменено.  
  
-   Только ключевые значения свойства включаются в алгоритме созданный компилятором хэш-код для анонимного типа.  
  
### <a name="equality"></a>Равенство  
 Экземпляры анонимных типов могут быть равны только в том случае, если они являются экземплярами одного анонимного типа. Компилятор обрабатывает два экземпляра как экземпляры того же типа, при соблюдении следующих условий:  
  
-   Они объявляются в той же сборке.  
  
-   Все свойства имеют те же имена, те же возвращаемые типы и объявляются в том же порядке. Имя сравнения регистр не учитывается.  
  
-   Те же свойства в каждом помечаются как ключевые свойства.  
  
-   По крайней мере одно свойство в каждое объявление является свойством ключа.  
  
 Экземпляр анонимного типа, который не имеет ключевого свойства равен только самому себе.  
  
 [!code-vb[VbVbalrAnonymousTypes#6](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_6.vb)]  
  
 Два экземпляра одного анонимного типа равны, если равны значения их ключевых свойств. Следующие примеры иллюстрируют способ проверки равенства.  
  
 [!code-vb[VbVbalrAnonymousTypes#7](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_7.vb)]  
  
### <a name="read-only-values"></a>Значения, доступные только для чтения  
 Невозможно изменить значения ключевых свойств. Например, в `prod8` в предыдущем примере `Name` и `Price` поля являются `read-only`, но `OnHand` может быть изменено.  
  
 [!code-vb[VbVbalrAnonymousTypes#8](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_8.vb)]  
  
## <a name="anonymous-types-from-query-expressions"></a>Анонимные типы из выражений запросов  
 Выражения запросов не всегда требуют создания анонимных типов. Если это возможно, они используют существующий тип для хранения данных столбца. Это происходит, когда запрос возвращает либо все записи из источника данных или только одно поле из каждой записи. В следующих примерах кода `customers` — это коллекция объектов `Customer` класса. Класс имеет много свойств, и может включать один или несколько из них в результатах запроса в любом порядке. В первых двух примерах анонимные типы не требуется, так как запросы выбирают элементы из именованных типов:  
  
-   `custs1`содержит коллекцию строк, поскольку `cust.Name` является строкой.  
  
     [!code-vb[VbVbalrAnonymousTypes#30](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_9.vb)]  
  
-   `custs2`содержит коллекцию `Customer` объектов, так как каждый элемент `customers` — `Customer` объекта, а весь элемент выбран в запросе.  
  
     [!code-vb[VbVbalrAnonymousTypes#31](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_10.vb)]  
  
 Однако соответствующие именованные типы доступны не всегда. Можно выбрать имена клиентов и адреса для одной цели, идентификаторы клиентов и расположения для другого и имена клиентов, адреса и журнал заказов клиентов для третьего. Анонимные типы позволяют выбрать любое сочетание свойств, в любом порядке, без предварительного объявления нового именованного типа для хранения результатов. Вместо этого компилятор создает анонимный тип для каждой группы свойств. Следующий запрос выбирает только имя и ИД клиента из каждого `Customer` объекта в `customers`. Таким образом компилятор создает анонимный тип, который содержит только эти два свойства.  
  
 [!code-vb[VbVbalrAnonymousTYpes#32](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_11.vb)]  
  
 Имена и типы данных свойств в анонимном типе, взяты из аргументов `Select`, `cust.Name` и `cust.ID`. Свойства в анонимный тип, созданный по запросу всегда являются ключевыми свойствами. Когда `custs3` выполняется в следующих `For Each` цикла, результат представляет собой коллекцию экземпляров анонимного типа с двумя ключевыми свойствами `Name` и `ID`.  
  
 [!code-vb[VbVbalrAnonymousTypes#33](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_12.vb)]  
  
 Элементы в коллекции, представленной `custs3` строго типизированы, можно использовать IntelliSense для просмотра доступных свойств и для проверки их типов.  
  
 Дополнительные сведения см. в разделе [Знакомство с LINQ в Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md).  
  
## <a name="deciding-whether-to-use-anonymous-types"></a>Принятие решения об использовании анонимные типы  
 Прежде чем создавать объект как экземпляр анонимного класса, убедитесь, что это наиболее подходящий вариант. Например если вы хотите создать временный объект, содержащий связанные данные, а не нужен для других полей и методов, которые могут содержать полный класс, анонимный тип — это хорошее решение. Анонимные типы также являются удобным различные наборы свойств для каждого объявления, или если вы хотите изменить порядок свойств. Тем не менее если проект содержит несколько объектов, которые имеют те же свойства в определенном порядке, можно объявить их проще с помощью именованного типа с помощью конструктора класса. Например, с соответствующим конструктором, проще объявить несколько экземпляров `Product` класса не требуется объявлять несколько экземпляров анонимного типа.  
  
 [!code-vb[VbVbalrAnonymousTypes#9](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_13.vb)]  
  
 Является еще одним преимуществом использования именованных типов, компилятор может перехватить случайную опечатку имени свойства. В предыдущих примерах `firstProd2`, `secondProd2`, и `thirdProd2` должны быть экземплярами одного анонимного типа. Однако, если случайно объявить `thirdProd2` в одном из следующих способов, его тип будет отличаться от `firstProd2` и `secondProd2`.  
  
 [!code-vb[VbVbalrAnonymousTypes#10](../../../../visual-basic/language-reference/modifiers/codesnippet/VisualBasic/anonymous-types_14.vb)]  
  
 Более того существуют ограничения на использование анонимных типов, которые не применяются к экземплярам именованных типов. `firstProd2`, `secondProd2`, и `thirdProd2` являются экземплярами одного анонимного типа. Однако имя для общего анонимного типа недоступен и не может находиться там, где ожидается имя типа в коде. Например анонимный тип не может использоваться для определения сигнатуры метода, для объявления других переменных или полей или в любом объявлении типа. В результате анонимные типы не подходит при наличии совместное использование информации в методы.  
  
## <a name="an-anonymous-type-definition"></a>Определение анонимного типа  
 В ответ на объявление экземпляра анонимного типа компилятор создает определение нового класса, который содержит указанные свойства.  
  
 Если анонимный тип содержит по крайней мере одно ключевое свойство, определение переопределяет три члена, унаследованные от <xref:System.Object>: <xref:System.Object.Equals%2A>, <xref:System.Object.GetHashCode%2A>, и <xref:System.Object.ToString%2A>. Код, созданный для проверки равенства и определения значения хэш-кода рассматривает только ключевые свойства. Если анонимный тип не содержит ключевых свойств, только <xref:System.Object.ToString%2A> переопределяется. Явно именованные свойства анонимного типа не могут конфликтовать с этими созданными методами. Другими словами, нельзя использовать `.Equals`, `.GetHashCode`, или `.ToString` для имени свойства.  
  
 Определения анонимного типа, которые имеют по крайней мере одно ключевое свойство, также реализуют <xref:System.IEquatable%601?displayProperty=nameWithType> интерфейса, где `T` тип анонимного типа.  
  
 Дополнительные сведения о коде, созданном компилятором, и функциональные возможности переопределенных методов см. в разделе [определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
## <a name="see-also"></a>См. также  
 [Инициализаторы объектов. Именованные и анонимные типы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)  
 [Вывод локального типа](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)  
 [Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md) (Знакомство с LINQ в Visual Basic)  
 [Практическое руководство. Выведение имен свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)  
 [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md)  
 [Key](../../../../visual-basic/language-reference/modifiers/key.md)
