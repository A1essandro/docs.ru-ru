---
title: "Универсальные типы в Visual Basic (Visual Basic) | Документы Microsoft"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- generic interfaces
- data type arguments, defining
- generic delegates
- arguments [Visual Basic], data types
- Of keyword, using
- delegates, generic
- constraints, Visual Basic generic types
- generic parameters
- data type parameters
- procedures, generic
- generic procedures
- data types [Visual Basic], generic
- data types [Visual Basic], as parameters
- generics [Visual Basic], generic types
- data types [Visual Basic], as arguments
- generic classes, Visual Basic
- parameters, type
- type arguments
- interfaces, generic
- generics [Visual Basic]
- types [Visual Basic], generic
- parameters, generic
- generic structures
- generic classes
- type parameters
- data type arguments
- structures, generic
- parameters, data type
- collections, generic
- classes [Visual Basic], generic
- data type parameters, defining
- type arguments, defining
- arguments [Visual Basic], type
ms.assetid: 89f771d9-ecbb-4737-88b8-116b63c6cf4d
caps.latest.revision: 45
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 40b175655b2b2341fd15e763058a3dae1291f2c4
ms.contentlocale: ru-ru
ms.lasthandoff: 04/12/2017

---
# <a name="generic-types-in-visual-basic-visual-basic"></a><span data-ttu-id="25a39-102">Универсальные типы в Visual Basic (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="25a39-102">Generic Types in Visual Basic (Visual Basic)</span></span>
<span data-ttu-id="25a39-103">*Универсальный тип* является одиночным элементом программирования, который используется для выполнения одинаковой функциональности для различных типов данных.</span><span class="sxs-lookup"><span data-stu-id="25a39-103">A *generic type* is a single programming element that adapts to perform the same functionality for a variety of data types.</span></span> <span data-ttu-id="25a39-104">При определении универсальных классов или процедур не нужно определять отдельную версию для каждого типа данных, для которых может потребоваться выполнение этой функциональности.</span><span class="sxs-lookup"><span data-stu-id="25a39-104">When you define a generic class or procedure, you do not have to define a separate version for each data type for which you might want to perform that functionality.</span></span>  
  
 <span data-ttu-id="25a39-105">В качестве аналогии можно привести отвертку со съемными головками.</span><span class="sxs-lookup"><span data-stu-id="25a39-105">An analogy is a screwdriver set with removable heads.</span></span> <span data-ttu-id="25a39-106">Вы смотрите на шуруп, который нужно завинтить, и выбираете подходящую головку (шлицевую, крестовую или звездообразную).</span><span class="sxs-lookup"><span data-stu-id="25a39-106">You inspect the screw you need to turn and select the correct head for that screw (slotted, crossed, starred).</span></span> <span data-ttu-id="25a39-107">Меняя головки, вы выполняете с помощью отвертки одну и ту же функцию: завинчиваете или вывинчиваете шуруп.</span><span class="sxs-lookup"><span data-stu-id="25a39-107">Once you insert the correct head in the screwdriver handle, you perform the exact same function with the screwdriver, namely turning the screw.</span></span>  
  
 <span data-ttu-id="25a39-108">![Схема отвертки, используемой в качестве универсального средства](../../../../visual-basic/programming-guide/language-features/data-types/media/genericscrewdriver.gif "GenericScrewDriver")</span><span class="sxs-lookup"><span data-stu-id="25a39-108">![Diagram of a screwdriver set as a generic tool](../../../../visual-basic/programming-guide/language-features/data-types/media/genericscrewdriver.gif "GenericScrewDriver")</span></span>  
<span data-ttu-id="25a39-109">Набор отверток в качестве универсального средства</span><span class="sxs-lookup"><span data-stu-id="25a39-109">Screwdriver set as a generic tool</span></span>  
  
 <span data-ttu-id="25a39-110">При определении универсального типа его можно параметризовать с помощью одного или нескольких типов данных.</span><span class="sxs-lookup"><span data-stu-id="25a39-110">When you define a generic type, you parameterize it with one or more data types.</span></span> <span data-ttu-id="25a39-111">Это позволяет использовать код, чтобы адаптировать типы данных к его требованиям.</span><span class="sxs-lookup"><span data-stu-id="25a39-111">This allows the using code to tailor the data types to its requirements.</span></span> <span data-ttu-id="25a39-112">В коде можно объявить несколько различных элементов программирования из универсального элемента, каждый из которых действует для разных наборов типов данных.</span><span class="sxs-lookup"><span data-stu-id="25a39-112">Your code can declare several different programming elements from the generic element, each one acting on a different set of data types.</span></span> <span data-ttu-id="25a39-113">Но все объявленные элементы подчиняются одинаковой логике, независимо от того, какие типы данных они используют.</span><span class="sxs-lookup"><span data-stu-id="25a39-113">But the declared elements all perform the identical logic, no matter what data types they are using.</span></span>  
  
 <span data-ttu-id="25a39-114">Допустим, вам нужно создать и использовать класс очереди, который работает с определенным типом данных, например `String`.</span><span class="sxs-lookup"><span data-stu-id="25a39-114">For example, you might want to create and use a queue class that operates on a specific data type such as `String`.</span></span> <span data-ttu-id="25a39-115">Можно объявить класс из <xref:System.Collections.Generic.Queue%601?displayProperty=fullName>, как показано в следующем примере.</xref:System.Collections.Generic.Queue%601?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="25a39-115">You can declare such a class from <xref:System.Collections.Generic.Queue%601?displayProperty=fullName>, as the following example shows.</span></span>  
  
 <span data-ttu-id="25a39-116">[!code-vb[VbVbalrDataTypes&#1;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_1.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-116">[!code-vb[VbVbalrDataTypes#1](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_1.vb)]</span></span>  
  
 <span data-ttu-id="25a39-117">Теперь можно использовать `stringQ` для работы исключительно со значениями `String` .</span><span class="sxs-lookup"><span data-stu-id="25a39-117">You can now use `stringQ` to work exclusively with `String` values.</span></span> <span data-ttu-id="25a39-118">Так как `stringQ` предназначен конкретно для `String` , а не является универсальным для значений `Object` , вам не потребуется позднее связывание или преобразование типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-118">Because `stringQ` is specific for `String` instead of being generalized for `Object` values, you do not have late binding or type conversion.</span></span> <span data-ttu-id="25a39-119">Это экономит время выполнения и сокращает число ошибок во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="25a39-119">This saves execution time and reduces run-time errors.</span></span>  
  
 <span data-ttu-id="25a39-120">Дополнительные сведения об использовании универсального типа см. в разделе [Практическое руководство: использование универсального класса](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md).</span><span class="sxs-lookup"><span data-stu-id="25a39-120">For more information on using a generic type, see [How to: Use a Generic Class](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md).</span></span>  
  
## <a name="example-of-a-generic-class"></a><span data-ttu-id="25a39-121">Пример универсального класса</span><span class="sxs-lookup"><span data-stu-id="25a39-121">Example of a Generic Class</span></span>  
 <span data-ttu-id="25a39-122">В следующем примере показано определение каркаса универсального класса.</span><span class="sxs-lookup"><span data-stu-id="25a39-122">The following example shows a skeleton definition of a generic class.</span></span>  
  
 <span data-ttu-id="25a39-123">[!code-vb[VbVbalrDataTypes&#2;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_2.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-123">[!code-vb[VbVbalrDataTypes#2](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_2.vb)]</span></span>  
  
 <span data-ttu-id="25a39-124">В предыдущем каркасе `t` — это *параметр типа*, то есть заполнитель для типа данных, указанного при объявлении класса.</span><span class="sxs-lookup"><span data-stu-id="25a39-124">In the preceding skeleton, `t` is a *type parameter*, that is, a placeholder for a data type that you supply when you declare the class.</span></span> <span data-ttu-id="25a39-125">В другом месте в коде можно объявлять различные версии `classHolder` , указав различные типы данных для `t`.</span><span class="sxs-lookup"><span data-stu-id="25a39-125">Elsewhere in your code, you can declare various versions of `classHolder` by supplying various data types for `t`.</span></span> <span data-ttu-id="25a39-126">Два таких объявления показаны в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="25a39-126">The following example shows two such declarations.</span></span>  
  
 <span data-ttu-id="25a39-127">[!code-vb[VbVbalrDataTypes&#3;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_3.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-127">[!code-vb[VbVbalrDataTypes#3](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_3.vb)]</span></span>  
  
 <span data-ttu-id="25a39-128">Предыдущие инструкции объявляют *сконструированные классы*, в которых указанный тип заменяет параметр типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-128">The preceding statements declare *constructed classes*, in which a specific type replaces the type parameter.</span></span> <span data-ttu-id="25a39-129">Эта замена распространяется по всему коду сконструированного класса.</span><span class="sxs-lookup"><span data-stu-id="25a39-129">This replacement is propagated throughout the code within the constructed class.</span></span> <span data-ttu-id="25a39-130">В следующем примере показано, как процедура `processNewItem` выглядит в `integerClass`.</span><span class="sxs-lookup"><span data-stu-id="25a39-130">The following example shows what the `processNewItem` procedure looks like in `integerClass`.</span></span>  
  
 <span data-ttu-id="25a39-131">[!code-vb[VbVbalrDataTypes&#4;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_4.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-131">[!code-vb[VbVbalrDataTypes#4](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_4.vb)]</span></span>  
  
 <span data-ttu-id="25a39-132">Более полный пример см. в разделе [как: определить класс, можно предоставить одинаковую функциональность с различными типами данных](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md).</span><span class="sxs-lookup"><span data-stu-id="25a39-132">For a more complete example, see [How to: Define a Class That Can Provide Identical Functionality on Different Data Types](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md).</span></span>  
  
## <a name="eligible-programming-elements"></a><span data-ttu-id="25a39-133">Допустимые элементы программирования</span><span class="sxs-lookup"><span data-stu-id="25a39-133">Eligible Programming Elements</span></span>  
 <span data-ttu-id="25a39-134">Можно определять и использовать универсальные классы, структуры, интерфейсы, процедуры и делегаты.</span><span class="sxs-lookup"><span data-stu-id="25a39-134">You can define and use generic classes, structures, interfaces, procedures, and delegates.</span></span> <span data-ttu-id="25a39-135">Обратите внимание, что [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] определяет несколько универсальных классов, структур и интерфейсов, которые представляют собой часто используемые универсальные элементы.</span><span class="sxs-lookup"><span data-stu-id="25a39-135">Note that the [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] defines several generic classes, structures, and interfaces that represent commonly used generic elements.</span></span> <span data-ttu-id="25a39-136"><xref:System.Collections.Generic?displayProperty=fullName>Пространство имен предоставляет словари, списки, очереди и стеки.</xref:System.Collections.Generic?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="25a39-136">The <xref:System.Collections.Generic?displayProperty=fullName> namespace provides dictionaries, lists, queues, and stacks.</span></span> <span data-ttu-id="25a39-137">Перед определением собственного универсального элемента, проверьте, если он уже находится в папке <xref:System.Collections.Generic?displayProperty=fullName>.</xref:System.Collections.Generic?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="25a39-137">Before defining your own generic element, see if it is already available in <xref:System.Collections.Generic?displayProperty=fullName>.</span></span>  
  
 <span data-ttu-id="25a39-138">Процедуры не являются типами, но можно определять и использовать универсальные процедуры.</span><span class="sxs-lookup"><span data-stu-id="25a39-138">Procedures are not types, but you can define and use generic procedures.</span></span> <span data-ttu-id="25a39-139">В разделе [универсальные процедуры в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md).</span><span class="sxs-lookup"><span data-stu-id="25a39-139">See [Generic Procedures in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-procedures.md).</span></span>  
  
## <a name="advantages-of-generic-types"></a><span data-ttu-id="25a39-140">Преимущества универсальных типов</span><span class="sxs-lookup"><span data-stu-id="25a39-140">Advantages of Generic Types</span></span>  
 <span data-ttu-id="25a39-141">Универсальный тип служит в качестве основы для объявления нескольких различных программных элементов, каждый из которых работает с определенным типом данных.</span><span class="sxs-lookup"><span data-stu-id="25a39-141">A generic type serves as a basis for declaring several different programming elements, each of which operates on a specific data type.</span></span> <span data-ttu-id="25a39-142">Альтернативы для универсального типа:</span><span class="sxs-lookup"><span data-stu-id="25a39-142">The alternatives to a generic type are:</span></span>  
  
1.  <span data-ttu-id="25a39-143">одиночный тип, работающий с типом данных `Object` .</span><span class="sxs-lookup"><span data-stu-id="25a39-143">A single type operating on the `Object` data type.</span></span>  
  
2.  <span data-ttu-id="25a39-144">Набор *типозависимых* версий типа; каждая версия кодируется индивидуально и работает с одним конкретным типом данных (например `String`, `Integer`) или с определяемым пользователем типом, например `customer`.</span><span class="sxs-lookup"><span data-stu-id="25a39-144">A set of *type-specific* versions of the type, each version individually coded and operating on one specific data type such as `String`, `Integer`, or a user-defined type such as `customer`.</span></span>  
  
 <span data-ttu-id="25a39-145">Универсальный тип имеет следующие преимущества по сравнению с этими альтернативами.</span><span class="sxs-lookup"><span data-stu-id="25a39-145">A generic type has the following advantages over these alternatives:</span></span>  
  
-   <span data-ttu-id="25a39-146">**Безопасность типа.**</span><span class="sxs-lookup"><span data-stu-id="25a39-146">**Type Safety.**</span></span> <span data-ttu-id="25a39-147">Универсальные типы обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="25a39-147">Generic types enforce compile-time type checking.</span></span> <span data-ttu-id="25a39-148">Типы на основе `Object` принимают любой тип данных, и необходимо написать код, чтобы проверить, является ли тип входных данных приемлемым.</span><span class="sxs-lookup"><span data-stu-id="25a39-148">Types based on `Object` accept any data type, and you must write code to check whether an input data type is acceptable.</span></span> <span data-ttu-id="25a39-149">При использовании универсальных типов компилятор может перехватить несоответствие типов до выполнения.</span><span class="sxs-lookup"><span data-stu-id="25a39-149">With generic types, the compiler can catch type mismatches before run time.</span></span>  
  
-   <span data-ttu-id="25a39-150">**Производительность.**</span><span class="sxs-lookup"><span data-stu-id="25a39-150">**Performance.**</span></span> <span data-ttu-id="25a39-151">Универсальные типы не должны *упаковывать* и *unупаковывать* данные, так как каждый из них является специальным для одного типа данных.</span><span class="sxs-lookup"><span data-stu-id="25a39-151">Generic types do not have to *box* and *unbox* data, because each one is specialized for one data type.</span></span> <span data-ttu-id="25a39-152">Операции, основанные на `Object` , должны упаковывать типы входных данных для их преобразования в `Object` и распаковать данные, предназначенные для вывода.</span><span class="sxs-lookup"><span data-stu-id="25a39-152">Operations based on `Object` must box input data types to convert them to `Object` and unbox data destined for output.</span></span> <span data-ttu-id="25a39-153">Упаковка и распаковка снижают производительность.</span><span class="sxs-lookup"><span data-stu-id="25a39-153">Boxing and unboxing reduce performance.</span></span>  
  
     <span data-ttu-id="25a39-154">Типы на основе `Object` имеют позднее связывание, а значит, для доступа к их элементам требуется дополнительный код во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="25a39-154">Types based on `Object` are also late-bound, which means that accessing their members requires extra code at run time.</span></span> <span data-ttu-id="25a39-155">Это также снижает производительность.</span><span class="sxs-lookup"><span data-stu-id="25a39-155">This also reduces performance.</span></span>  
  
-   <span data-ttu-id="25a39-156">**Объединение кода.**</span><span class="sxs-lookup"><span data-stu-id="25a39-156">**Code Consolidation.**</span></span> <span data-ttu-id="25a39-157">Код в универсальном типе должен быть определен только один раз.</span><span class="sxs-lookup"><span data-stu-id="25a39-157">The code in a generic type has to be defined only once.</span></span> <span data-ttu-id="25a39-158">Набор типозависимых версий типа должен реплицировать тот же код в каждой версии. Единственное отличие состоит в конкретном типе данных для этой версии.</span><span class="sxs-lookup"><span data-stu-id="25a39-158">A set of type-specific versions of a type must replicate the same code in each version, with the only difference being the specific data type for that version.</span></span> <span data-ttu-id="25a39-159">При использовании универсальных типов типозависимые версии формируются из исходного универсального типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-159">With generic types, the type-specific versions are all generated from the original generic type.</span></span>  
  
-   <span data-ttu-id="25a39-160">**Повторное использование кода.**</span><span class="sxs-lookup"><span data-stu-id="25a39-160">**Code Reuse.**</span></span> <span data-ttu-id="25a39-161">Код, который не зависит от определенного типа данных, можно повторно использовать с различными типами данных, если он является универсальным.</span><span class="sxs-lookup"><span data-stu-id="25a39-161">Code that does not depend on a particular data type can be reused with various data types if it is generic.</span></span> <span data-ttu-id="25a39-162">Часто его можно повторно использовать даже с типом данных, который изначально не предусматривался.</span><span class="sxs-lookup"><span data-stu-id="25a39-162">You can often reuse it even with a data type that you did not originally predict.</span></span>  
  
-   <span data-ttu-id="25a39-163">**Поддержка интегрированной среды разработки.**</span><span class="sxs-lookup"><span data-stu-id="25a39-163">**IDE Support.**</span></span> <span data-ttu-id="25a39-164">При использовании сконструированного типа, объявленного из универсального типа, интегрированная среда разработки (IDE) может предоставить дополнительную поддержку при разработке кода.</span><span class="sxs-lookup"><span data-stu-id="25a39-164">When you use a constructed type declared from a generic type, the integrated development environment (IDE) can give you more support while you are developing your code.</span></span> <span data-ttu-id="25a39-165">Например, IntelliSense может показать типозависимые параметры аргумента для конструктора или метода.</span><span class="sxs-lookup"><span data-stu-id="25a39-165">For example, IntelliSense can show you the type-specific options for an argument to a constructor or method.</span></span>  
  
-   <span data-ttu-id="25a39-166">**Универсальные алгоритмы.**</span><span class="sxs-lookup"><span data-stu-id="25a39-166">**Generic Algorithms.**</span></span> <span data-ttu-id="25a39-167">Абстрактные алгоритмы, которые не зависят от типов, хорошо подходят для универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="25a39-167">Abstract algorithms that are type-independent are good candidates for generic types.</span></span> <span data-ttu-id="25a39-168">Например универсальная процедура, которая сортирует пункты с помощью <xref:System.IComparable>интерфейса может использоваться с любым типом данных, который реализует <xref:System.IComparable>.</xref:System.IComparable> </xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="25a39-168">For example, a generic procedure that sorts items using the <xref:System.IComparable> interface can be used with any data type that implements <xref:System.IComparable>.</span></span>  
  
## <a name="constraints"></a><span data-ttu-id="25a39-169">Ограничения</span><span class="sxs-lookup"><span data-stu-id="25a39-169">Constraints</span></span>  
 <span data-ttu-id="25a39-170">Несмотря на то, что код в определении универсального типа должен быть максимально независимым от типов, может потребоваться определенная возможность любого типа данных, указанного для универсального типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-170">Although the code in a generic type definition should be as type-independent as possible, you might need to require a certain capability of any data type supplied to your generic type.</span></span> <span data-ttu-id="25a39-171">Например, если вы хотите сравнить два элемента с целью сортировки или упорядочивания, их тип данных должен реализовывать <xref:System.IComparable>интерфейса.</xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="25a39-171">For example, if you want to compare two items for the purpose of sorting or collating, their data type must implement the <xref:System.IComparable> interface.</span></span> <span data-ttu-id="25a39-172">Соблюдение этого требования можно обеспечить путем добавления *ограничения* к параметру типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-172">You can enforce this requirement by adding a *constraint* to the type parameter.</span></span>  
  
### <a name="example-of-a-constraint"></a><span data-ttu-id="25a39-173">Пример ограничения</span><span class="sxs-lookup"><span data-stu-id="25a39-173">Example of a Constraint</span></span>  
 <span data-ttu-id="25a39-174">В следующем примере показано определение класса с ограничением, которое требует аргумент типа для реализации <xref:System.IComparable>.</xref:System.IComparable> схемы</span><span class="sxs-lookup"><span data-stu-id="25a39-174">The following example shows a skeleton definition of a class with a constraint that requires the type argument to implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="25a39-175">[!code-vb[VbVbalrDataTypes&#5;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_5.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-175">[!code-vb[VbVbalrDataTypes#5](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_5.vb)]</span></span>  
  
 <span data-ttu-id="25a39-176">Если последующий код попытается создать класс из `itemManager` используя тип, который не реализует <xref:System.IComparable>, компилятор сообщает об ошибке.</xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="25a39-176">If subsequent code attempts to construct a class from `itemManager` supplying a type that does not implement <xref:System.IComparable>, the compiler signals an error.</span></span>  
  
### <a name="types-of-constraints"></a><span data-ttu-id="25a39-177">Типы ограничений</span><span class="sxs-lookup"><span data-stu-id="25a39-177">Types of Constraints</span></span>  
 <span data-ttu-id="25a39-178">Ограничение может содержать приведенные ниже требования в любой комбинации.</span><span class="sxs-lookup"><span data-stu-id="25a39-178">Your constraint can specify the following requirements in any combination:</span></span>  
  
-   <span data-ttu-id="25a39-179">Аргумент типа должен реализовывать один или несколько интерфейсов</span><span class="sxs-lookup"><span data-stu-id="25a39-179">The type argument must implement one or more interfaces</span></span>  
  
-   <span data-ttu-id="25a39-180">Аргумент типа должен наследовать только из одного класса или быть типом только одного класса.</span><span class="sxs-lookup"><span data-stu-id="25a39-180">The type argument must be of the type of, or inherit from, at most one class</span></span>  
  
-   <span data-ttu-id="25a39-181">Аргумент типа должен предоставлять конструктор без параметров, доступный коду, который создает объекты из него.</span><span class="sxs-lookup"><span data-stu-id="25a39-181">The type argument must expose a parameterless constructor accessible to the code that creates objects from it</span></span>  
  
-   <span data-ttu-id="25a39-182">Аргумент типа должен быть *типом ссылки*или *типом значения*.</span><span class="sxs-lookup"><span data-stu-id="25a39-182">The type argument must be a *reference type*, or it must be a *value type*</span></span>  
  
 <span data-ttu-id="25a39-183">Если нужно задать более одного требования, используйте разделенный запятыми *список ограничений* , заключенный в фигурные скобки (`{ }`).</span><span class="sxs-lookup"><span data-stu-id="25a39-183">If you need to impose more than one requirement, you use a comma-separated *constraint list* inside braces (`{ }`).</span></span> <span data-ttu-id="25a39-184">Если требуется доступ к конструктору, включают [оператор New](../../../../visual-basic/language-reference/operators/new-operator.md) ключевое слово в списке.</span><span class="sxs-lookup"><span data-stu-id="25a39-184">To require an accessible constructor, you include the [New Operator](../../../../visual-basic/language-reference/operators/new-operator.md) keyword in the list.</span></span> <span data-ttu-id="25a39-185">Чтобы требовать ссылочный тип, включите ключевое слово `Class` . Чтобы требовать тип значения, включите ключевое слово `Structure` .</span><span class="sxs-lookup"><span data-stu-id="25a39-185">To require a reference type, you include the `Class` keyword; to require a value type, you include the `Structure` keyword.</span></span>  
  
 <span data-ttu-id="25a39-186">Дополнительные сведения об ограничениях см. в разделе [список типов](../../../../visual-basic/language-reference/statements/type-list.md).</span><span class="sxs-lookup"><span data-stu-id="25a39-186">For more information on constraints, see [Type List](../../../../visual-basic/language-reference/statements/type-list.md).</span></span>  
  
### <a name="example-of-multiple-constraints"></a><span data-ttu-id="25a39-187">Пример множественных ограничений</span><span class="sxs-lookup"><span data-stu-id="25a39-187">Example of Multiple Constraints</span></span>  
 <span data-ttu-id="25a39-188">В следующем примере показано каркасное определение универсального класса со списком ограничений в параметре типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-188">The following example shows a skeleton definition of a generic class with a constraint list on the type parameter.</span></span> <span data-ttu-id="25a39-189">В коде, который создает экземпляр этого класса, аргумент типа должен реализовывать <xref:System.IComparable>и <xref:System.IDisposable>интерфейсы ссылочным типом и предоставлять доступ к конструктору без параметров.</xref:System.IDisposable> </xref:System.IComparable></span><span class="sxs-lookup"><span data-stu-id="25a39-189">In the code that creates an instance of this class, the type argument must implement both the <xref:System.IComparable> and <xref:System.IDisposable> interfaces, be a reference type, and expose an accessible parameterless constructor.</span></span>  
  
 <span data-ttu-id="25a39-190">[!code-vb[VbVbalrDataTypes №&6;](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_6.vb)]</span><span class="sxs-lookup"><span data-stu-id="25a39-190">[!code-vb[VbVbalrDataTypes#6](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-types_6.vb)]</span></span>  
  
## <a name="important-terms"></a><span data-ttu-id="25a39-191">Важные термины</span><span class="sxs-lookup"><span data-stu-id="25a39-191">Important Terms</span></span>  
 <span data-ttu-id="25a39-192">Универсальные типы вводят и используют следующие термины.</span><span class="sxs-lookup"><span data-stu-id="25a39-192">Generic types introduce and use the following terms:</span></span>  
  
-   <span data-ttu-id="25a39-193">*Универсальный тип*.</span><span class="sxs-lookup"><span data-stu-id="25a39-193">*Generic Type*.</span></span> <span data-ttu-id="25a39-194">Определение класса, структуры, интерфейса, процедуры или делегата, для которого необходимо указать по крайней мере один тип данных при объявлении.</span><span class="sxs-lookup"><span data-stu-id="25a39-194">A definition of a class, structure, interface, procedure, or delegate for which you supply at least one data type when you declare it.</span></span>  
  
-   <span data-ttu-id="25a39-195">*Параметр типа*.</span><span class="sxs-lookup"><span data-stu-id="25a39-195">*Type Parameter*.</span></span> <span data-ttu-id="25a39-196">В определении универсального типа это заполнитель для типа данных, указываемый при объявлении типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-196">In a generic type definition, a placeholder for a data type you supply when you declare the type.</span></span>  
  
-   <span data-ttu-id="25a39-197">*Аргумент типа*.</span><span class="sxs-lookup"><span data-stu-id="25a39-197">*Type Argument*.</span></span> <span data-ttu-id="25a39-198">Определенный тип данных, который заменяет параметр типа при объявлении сконструированного типа из универсального типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-198">A specific data type that replaces a type parameter when you declare a constructed type from a generic type.</span></span>  
  
-   <span data-ttu-id="25a39-199">*Ограничение*.</span><span class="sxs-lookup"><span data-stu-id="25a39-199">*Constraint*.</span></span> <span data-ttu-id="25a39-200">Условие для параметра типа, ограничивающее аргумент типа, который можно указать для него.</span><span class="sxs-lookup"><span data-stu-id="25a39-200">A condition on a type parameter that restricts the type argument you can supply for it.</span></span> <span data-ttu-id="25a39-201">Ограничение может требовать, чтобы аргумент типа реализовывал определенный интерфейс, был определенным классом или наследовал от него, имел доступный конструктор без параметров или был ссылочным типом или типом значения.</span><span class="sxs-lookup"><span data-stu-id="25a39-201">A constraint can require that the type argument must implement a particular interface, be or inherit from a particular class, have an accessible parameterless constructor, or be a reference type or a value type.</span></span> <span data-ttu-id="25a39-202">Можно объединять эти ограничения, но невозможно указывать более одного класса.</span><span class="sxs-lookup"><span data-stu-id="25a39-202">You can combine these constraints, but you can specify at most one class.</span></span>  
  
-   <span data-ttu-id="25a39-203">*Сконструированный тип*.</span><span class="sxs-lookup"><span data-stu-id="25a39-203">*Constructed Type*.</span></span> <span data-ttu-id="25a39-204">Класс, структура, интерфейс, процедура или делегат, объявленный из универсального типа с помощью указания аргументов типа для параметров типа.</span><span class="sxs-lookup"><span data-stu-id="25a39-204">A class, structure, interface, procedure, or delegate declared from a generic type by supplying type arguments for its type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="25a39-205">См. также</span><span class="sxs-lookup"><span data-stu-id="25a39-205">See Also</span></span>  
 <span data-ttu-id="25a39-206">[Типы данных](../../../../visual-basic/programming-guide/language-features/data-types/index.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-206">[Data Types](../../../../visual-basic/programming-guide/language-features/data-types/index.md) </span></span>  
<span data-ttu-id="25a39-207"> [Знаки типов](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-207"> [Type Characters](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md) </span></span>  
<span data-ttu-id="25a39-208"> [Типы значений и ссылочные типы](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-208"> [Value Types and Reference Types](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md) </span></span>  
<span data-ttu-id="25a39-209"> [Преобразования типов в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-209"> [Type Conversions in Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md) </span></span>  
<span data-ttu-id="25a39-210"> [Устранение неполадок типы данных](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-210"> [Troubleshooting Data Types](../../../../visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md) </span></span>  
<span data-ttu-id="25a39-211"> [Типы данных](../../../../visual-basic/language-reference/data-types/data-type-summary.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-211"> [Data Types](../../../../visual-basic/language-reference/data-types/data-type-summary.md) </span></span>  
<span data-ttu-id="25a39-212"> [Предложение Of (Visual Basic)](../../../../visual-basic/language-reference/statements/of-clause.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-212"> [Of](../../../../visual-basic/language-reference/statements/of-clause.md) </span></span>  
<span data-ttu-id="25a39-213"> [Как](../../../../visual-basic/language-reference/statements/as-clause.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-213"> [As](../../../../visual-basic/language-reference/statements/as-clause.md) </span></span>  
<span data-ttu-id="25a39-214"> [Тип данных Object](../../../../visual-basic/language-reference/data-types/object-data-type.md) </span><span class="sxs-lookup"><span data-stu-id="25a39-214"> [Object Data Type](../../../../visual-basic/language-reference/data-types/object-data-type.md) </span></span>  
<span data-ttu-id="25a39-215"> [Ковариация и контрвариация](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8) </span><span class="sxs-lookup"><span data-stu-id="25a39-215"> [Covariance and Contravariance](http://msdn.microsoft.com/library/a58cc086-276f-4f91-a366-85b7f95f38b8) </span></span>  
<span data-ttu-id="25a39-216"> [Итераторы](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</span><span class="sxs-lookup"><span data-stu-id="25a39-216"> [Iterators](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)</span></span>
