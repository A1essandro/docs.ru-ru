---
title: Кортежи в Visual Basic
ms.custom: ''
ms.date: 04/23/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology:
- devlang-visual-basic
ms.topic: article
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 68c82e75ce4a438381bc9c60ce8c992565eb31cb
ms.sourcegitcommit: 9a4fe1a1c37b26532654b4bbe22d702237950009
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2018
---
# <a name="tuples-visual-basic"></a>Кортежи (Visual Basic)

Начиная с Visual Basic 2017 г., в языке Visual Basic предлагает встроенную поддержку кортежей, который делает создание кортежей и доступ к элементам проще кортежей. Кортеж — это структура данных недоступно, с определенным номером и последовательность значений. При создании экземпляра кортежа, следует определить, количество и тип данных каждого значения (или элемент). Например кортеж (или пары) состоит из двух элементов. Возможно, первый `Boolean` значение, а второй — `String`. Поскольку кортежей упростить процесс сохранения нескольких значений в одном объекте, они часто используются как упрощенный способ возвращать несколько значений из метода.

> [!IMPORTANT]
> Поддержка кортежа требует <xref:System.ValueTuple> типа. Если 4.7 .NET Framework не установлена, необходимо добавить пакет NuGet `System.ValueTuple`, который можно найти в коллекции NuGet. Без этого пакета может получить ошибку компиляции аналогично «Предопределенный тип «ValueTuple(Of,,,)» не определен и не импортирован.»

## <a name="instantiating-and-using-a-tuple"></a>Создание и использование кортежа

Создать кортеж, заключив его круглые скобки обмена мгновенными сообщениями значений с разделителями запятыми. Затем каждый из этих значений становится полем кортежа. Например, следующий код определяет triple (или кортежа 3) с помощью `Date` как значение его первого, `String` его вторым и `Boolean` как третьего.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

По умолчанию имя каждого поля в кортеж включает строку `Item` вместе с положением на основе одного поля в кортеже. Для 3-кортежа `Date` поле является `Item1`, `String` поле является `Item2`и `Boolean` поле является `Item3`. Следующий пример отображает значения полей кортежа, созданный в предыдущей строке кода

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

Поля кортеж Visual Basic, чтения и записи; После создания экземпляра кортеж его значения можно изменить. Следующий пример изменяет две из трех полей кортежа, созданные в предыдущем примере и отображает результат.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a>Создание экземпляра и использование именованных кортежа

Вместо того чтобы использовать имена по умолчанию для полей кортежа, можно создать экземпляр *кортеж с именем* , назначив собственные имена элементов кортежа. Поля кортежа может осуществляться по именам и назначенный *или* , их имена по умолчанию. В следующем примере создается же кортеж 3 как ранее, за исключением того, что она явно указана первое поле `EventDate`, второй `Name`, а в третьем `IsHoliday`. Затем он отображает значения полей, изменяет их и отображает значения полей еще раз.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a>Имена элементов выводимых кортежа

Начиная с 15,3 Visual Basic, Visual Basic могут выводить имена элементов кортежа; необходимо назначить их явно. Выводимый кортежа имена полезны в тех случаях, когда инициализировать кортежа из набора переменных, и требуется имя элемента кортежа должен совпадать с именем переменной. 

В следующем примере создается `stateInfo` кортеж, содержащий три явно именованные элементы, `state`, `stateName`, и `capital`. Обратите внимание, что при именовании элементы, оператор инициализации кортежа просто назначает именованных элементов значения переменных таким же именем.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]
 
Поскольку элементы и переменные имеют то же имя, компилятор Visual Basic может определить имена полей, как показано в следующем примере.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

Чтобы включить имена элементов interred кортеж, необходимо определить версии компилятора Visual Basic для использования в проекте Visual Basic (\*.vbproj) файла: 

```xml 
<PropertyGroup> 
  <LangVersion>15.3</LangVersion> 
</PropertyGroup> 
```

Номер версии может быть любой версии компилятора Visual Basic, начиная с 15,3. Вместо того чтобы жестко запрограммированные конкретной версии компилятора, можно указать «Последней» в качестве значения `LangVersion` компилироваться в последней версии компилятора Visual Basic, установленного в системе.

В некоторых случаях компилятор Visual Basic не может определить имя элемента кортежа из допустимое имя и поля кортеж может ссылаться только с помощью его имя по умолчанию, например `Item1`, `Item2`и т. д. Сюда входит следующее.

- Допустимое имя совпадает имя элемента кортежа, таких как `Item3`, `Rest`, или `ToString`.

- Имя кандидата дублируется в кортеже.
 
Если не удается определить имя поля, Visual Basic не создает ошибку компилятора, а также является исключение, создаваемое во время выполнения. Вместо этого поля кортежа должна ссылаться на стандартные имена, такие как `Item1` и `Item2`. 
  
## <a name="tuples-versus-structures"></a>Кортежи и структур

Кортеж Visual Basic — это тип значения, который представляет собой экземпляр одного из **System.ValueTuple** универсальных типов. Например `holiday` кортежа, определенных в предыдущем примере является экземпляром класса <xref:System.ValueTuple%603> структуры. Она должна быть упрощенный контейнер для данных. Поскольку кортежа стремится упростить процесс создания объекта с несколькими элементами данных, он не имеет некоторые возможности, которые может иметь пользовательскую структуру. Сюда входит следующее.

- Пользовательские элементы. Не удается определить собственные свойства, методы или события для кортеж.

- Проверка. Не удалось проверить данные, присвоенные поля.

- Неизменность. Кортежи Visual Basic может изменяться. В отличие от этого пользовательская структура позволяет вам управлять ли экземпляр изменяемым или неизменяемым.

Если пользовательские элементы, свойства и проверка полей или неизменность важны, следует использовать в Visual Basic [структуры](../../../language-reference/statements/structure-statement.md) инструкцию, чтобы определить тип пользовательского значения.

Кортеж Visual Basic наследуют элементы его **ValueTuple** типа. В дополнение к его полям к ним относятся следующие методы:

| Член | Описание |
| ---|---|
| CompareTo | Сравнивает текущий кортеж другой кортежу с одинаковым числом элементов. |
| Равно | Определяет, равен ли текущий кортеж другой кортеж или объектом. |
| GetHashCode | Вычисляет хэш-код для текущего экземпляра. |
| ToString | Возвращает строковое представление в виде кортежа `(Item1, Item2...)`, где `Item1` и `Item2` представляют значения полей кортежа. |

Кроме того **ValueTuple** типы реализуют <xref:System.Collections.IStructuralComparable> и <xref:System.Collections.IStructuralEquatable> интерфейсы, которые позволяют определить функции сравнения клиента.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Visual Basic поддерживает назначение между типами кортежа, имеющих одинаковое число полей. Можно преобразовать типы полей, если выполняется одно из следующих условий:

- Поле источника и целевой, того же типа.

- Расширяющее (или неявными) преобразование исходного типа в конечный тип определяется. 

- `Option Strict` — `On`, и определена, сужающего диапазон значений (или явных) преобразования типа источника к целевому типу. Это преобразование может создать исключение, если исходное значение выходит за пределы типа целевого объекта.

Другие преобразования в контексте назначений не учитываются. Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

Первые две переменные `unnamed` и `anonymous`, не имеют имен семантики, указанное для поля. По умолчанию используются соответствующие имена полей `Item1` и `Item2`. Последние два переменные `named` и `differentName` имеют имена полей семантики. Обратите внимание на то, что поля в этих двух кортежах называются по-разному.

Все четыре эти кортежей, имеют одинаковый номер полей (так называемый «арность») и типы эти поля идентичны. Таким образом, все эти назначения работают:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

Обратите внимание на то, что имена кортежей не назначаются. Значения полей назначаются в соответствии с порядком полей в кортеже.

И, наконец, обратите внимание, что можно назначить `named` кортеж `conversion` кортежа, несмотря на то что в первое поле `named` — `Integer`и в первое поле `conversion` — `Long`. Это назначение завершается успешно, поскольку преобразование `Integer` для `Long` расширяющие преобразования.

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

Кортежи с различным количеством поля не может быть назначен:

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Метод может возвращать только одно значение. Часто хотя вам бы хотелось вызов метода для возврата нескольких значений. Чтобы обойти это ограничение несколькими способами:

- Можно создать пользовательский класс или структуру, свойства или поля представляют значения, возвращаемого методом. Таким образом — это решение высокой плотности; необходимо определить пользовательский тип которого предназначен только для извлечения значений из вызова метода.

- Возвращает одно значение из метода и возврата оставшиеся значения, передавая их по ссылке в метод. Это включает в себя дополнительную нагрузку, связанную с создания экземпляра переменной и риски при перезаписи значение переменной, которая передается по ссылке.

- Можно использовать кортеж, который предоставляет простое решение для извлечения с несколькими возвращаемыми значениями.

Например **TryParse** методы возврата .NET `Boolean` значение, указывающее, успешно ли выполнена операция синтаксического анализа. Результат операции анализа возвращается в переменную, передаваемый по ссылке в метод. Как правило, вызов метода анализа, такие как <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> выглядит следующим образом:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

Мы можем вернуться кортеж из операции анализа, если мы программу-оболочку вызова <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> в нашей методе. В следующем примере `NumericLibrary.ParseInteger` вызовы <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> метод и возвращает кортеж, именованный с двумя элементами. 

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

Затем можно вызвать метод с помощью следующего кода:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a>Visual Basic кортежи и кортежи в .NET Framework

Visual Basic кортеж представляет собой экземпляр одного из **System.ValueTuple** универсальных типов, которые впервые появились в .NET Framework 4.7. Платформа .NET Framework также включает набор универсального **System.Tuple** классы. Эти классы тем не менее, отличаются от кортежей Visual Basic и **System.ValueTuple** универсальных типов в следующих случаях:

- Элементы **кортежа** классы являются свойства с именем `Item1`, `Item2`, и т. д. В Visual Basic кортежей и **ValueTuple** поля, типы элементов кортежа.

- Элементы нельзя назначить значимые имена **кортежа** экземпляра или **ValueTuple** экземпляра. Visual Basic позволяет присваивать имена, которые смысловое значение поля.

- Свойства **кортежа** экземпляра доступны только для чтения; кортежи являются неизменяемыми. В Visual Basic кортежей и **ValueTuple** типы, поля кортежа, чтения и записи; кортежи может изменяться.

- Универсальный **кортежа** типы являются ссылочными типами. Используя эти **кортежа** типы означает выделение объектов. В критических путях это может заметно влиять на производительность приложения. Visual Basic кортежей и **ValueTuple** типы являются типами значений.

Методы расширения в <xref:System.TupleExtensions> класс облегчить преобразование между кортежи Visual Basic и .NET **кортежа** объектов. **ToTuple** метод преобразует кортеж Visual Basic .NET **кортежа** объекта и **ToValueTuple** метод преобразует .NET **кортежа** Объект кортежа Visual Basic.

Следующий пример создает кортеж, преобразует его в .NET **кортежа** объекта и преобразует его обратно кортеж Visual Basic. Затем в примере сравнивается этот кортеж исходной версией, чтобы убедиться, что они равны.

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a>См. также

[Справочник по языку Visual Basic](index.md)  
