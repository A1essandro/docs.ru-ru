---
title: Оператор SyncLock
ms.date: 07/20/2015
f1_keywords:
- vb.SyncLock
- SyncLock
helpviewer_keywords:
- threading [Visual Basic], locks
- SyncLock statement [Visual Basic]
- locks, threads
ms.assetid: 14501703-298f-4d43-b139-c4b6366af176
ms.openlocfilehash: cf2aad9ec2ba67200d175fbcddfcb49afeac6efc
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="synclock-statement"></a>Оператор SyncLock
Получает монопольную блокировку для блока операторов перед выполнением блока.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
SyncLock lockobject  
    [ block ]  
End SyncLock  
```  
  
## <a name="parts"></a>Части  
 `lockobject`  
 Обязательно. Выражение, возвращающее ссылку на объект.  
  
 `block`  
 Необязательный. Блок операторов, которые должны выполняться, когда блокировка получена.  
  
 `End SyncLock`  
 Завершает `SyncLock` блока.  
  
## <a name="remarks"></a>Примечания  
 `SyncLock` Оператор гарантирует, что блок операторов не будут выполняться одновременно несколькими потоками. `SyncLock` запрещает каждому потоку входе в блок, пока его не выполняет никакой другой поток.  
  
 Чаще всего используют `SyncLock` для защиты данных от обновления несколькими потоками одновременно. Операторы для работы с данными необходимо перейти к завершению без прерывания, поместите их внутри `SyncLock` блока.  
  
 Блок операторов, защищенный монопольной блокировкой, иногда называется *критический раздел*.  
  
## <a name="rules"></a>Правила  
  
-   Ветвление. Нельзя осуществлять ветвление в `SyncLock` запретить вне блока.  
  
-   Блокировка значения объекта. Значение `lockobject` не может быть `Nothing`. Необходимо создать объект блокировки, прежде чем использовать его в `SyncLock` инструкции.  
  
     Не удается изменить значение `lockobject` при выполнении `SyncLock` блока. Механизм требует, что объект блокировки остаются неизменными.  
  
-   Нельзя использовать [Await](../../../visual-basic/language-reference/operators/await-operator.md) оператор в `SyncLock` блока.  
  
## <a name="behavior"></a>Поведение  
  
-   Механизм. Когда поток достигает `SyncLock` инструкции, она оценивает `lockobject` выражение и приостанавливает выполнение, пока не получит монопольную блокировку объекта, возвращенного выражением. Если другой поток достигает `SyncLock` инструкции, он получает блокировку пока первый поток выполняет `End SyncLock` инструкции.  
  
-   Защищенные данные. Если `lockobject` — `Shared` переменных, монопольная блокировка предотвращает поток в любом экземпляре класса выполнение `SyncLock` блок во время его выполнения любого другого потока. Это обеспечивает защиту данных, общими для всех экземпляров.  
  
     Если `lockobject` является переменной экземпляра (не `Shared`), Блокировка предотвращает выполнение потока в текущем экземпляре выполнения `SyncLock` блока, в то же время, как другой поток, в том же экземпляре. Это обеспечивает защиту данных, содержащихся в отдельном экземпляре.  
  
-   Получение и освобождение. Объект `SyncLock` блок ведет себя как `Try...Finally` построения, в котором `Try` блок получает монопольную блокировку на `lockobject` и `Finally` блок освобождает его. По этой причине `SyncLock` блок гарантирует снятие блокировки, независимо от того, как выйти из блока. Это верно даже в случае возникновения необработанного исключения.  
  
-   Платформа вызывает функцию. `SyncLock` Блок получает и освобождает монопольную блокировку путем вызова `Enter` и `Exit` методы `Monitor` класса в <xref:System.Threading> пространства имен.  
  
## <a name="programming-practices"></a>Примеры программирования  
 `lockobject` Выражение должно всегда быть объектом, принадлежащим исключительно к классу. Следует объявить `Private` объектную переменную, чтобы защитить данные, относящиеся к текущему экземпляру или `Private Shared` объектную переменную, чтобы защитить данные, общие для всех экземпляров.  
  
 Не следует использовать `Me` ключевое слово для предоставления блокировки для экземпляра объекта данных. Если внешний класс код содержит ссылку на экземпляр класса, он может использовать эту ссылку как объект блокировки для `SyncLock` блок полностью отличаются от вас, защиты данных. Таким образом, классу и другой класс может заблокировать друг с другом выполнение их несвязанных `SyncLock` блоков. Аналогично, блокировка строки может быть проблематично, так как для любого другого кода в процессе, используя ту же строку будет совместно использовать ту же блокировку.  
  
 Также не следует использовать `Me.GetType` способ предоставления объекта блокировки для общих данных. Это вызвано `GetType` всегда возвращает тот же `Type` объекта для заданного имени класса. Внешний код может вызвать `GetType` для класса и получить тот же объект блокировки, которые вы используете. Это приведет к появлению двух классов, блокирует друг с другом и с их `SyncLock` блоков.  
  
## <a name="examples"></a>Примеры  
  
### <a name="description"></a>Описание  
 В следующем примере класс, который поддерживает простой список сообщений. Сообщения хранятся в массиве, а последний элемент этого массива в переменной. `addAnotherMessage` Процедура увеличивает значение последнего элемента и сохраняет новое сообщение. Эти две операции защищены `SyncLock` и `End SyncLock` инструкций, поскольку после увеличения последний элемент нового сообщения должны сохраняться до любого другого потока может увеличить последний элемент еще раз.  
  
 Если `simpleMessageList` один список сообщений для всех его экземпляров, переменные общих классов `messagesList` и `messagesLast` должна быть объявлена как `Shared`. В данном случае переменная `messagesLock` также должен быть `Shared`, после чего будет объект блокировки, используемые каждым экземпляром.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#1](../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/synclock-statement_1.vb)]  
  
### <a name="description"></a>Описание  
 В следующем примере используется потоков и `SyncLock`. При условии, что `SyncLock` присутствует оператор, блок операторов является критической секции и `balance` никогда не будет отрицательным числом. Вы можете закомментировать `SyncLock` и `End SyncLock` инструкции, чтобы выявить эффект от пропускают `SyncLock` ключевое слово.  
  
### <a name="code"></a>Код  
 [!code-vb[VbVbalrThreading#21](../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/synclock-statement_2.vb)]  
  
### <a name="comments"></a>Комментарии  
  
## <a name="see-also"></a>См. также  
 <xref:System.Threading>  
 <xref:System.Threading.Monitor>  
 [Синхронизация потоков](../../programming-guide/concepts/threading/thread-synchronization.md)  
 [Работа с потоками](../../programming-guide/concepts/threading/index.md)
