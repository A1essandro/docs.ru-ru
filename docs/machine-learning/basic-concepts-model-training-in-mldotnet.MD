---
title: Основные понятия для обучения модели в ML.NET
description: В этой статье разъясняются основные понятия в сценариях *обучения моделей* в ML.NET. Не все понятия относятся к самому простому сценарию *прогнозирования с помощью существующей модели*.
ms.date: 02/13/2019
ms.topic: overview
ms.custom: mvc
ms.openlocfilehash: c47d5832527dca1416abfc55756dca48f1daf493
ms.sourcegitcommit: bef803e2025642df39f2f1e046767d89031e0304
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/15/2019
ms.locfileid: "56303664"
---
# <a name="basic-concepts-for-model-training-in-mlnet"></a>Основные понятия для обучения модели в ML.NET

В этой статье разъясняются основные понятия в сценариях *обучения моделей* в ML.NET. Не все понятия относятся к самому простому сценарию *прогнозирования с помощью существующей модели*.

## <a name="model-training-concepts"></a>Понятия, связанные с обучением моделей

В этом документе рассматриваются следующие понятия, связанные с обучением модели в ML.NET:

- [*Данные*](#data) представлены в виде интерфейса `IDataView`.
  - В ML.NET данные аналогичны представлению SQL: Это отложенно-вычисляемый, неизменяемый, поддерживающий курсоры, неоднородный и схематизированный набор данных. 
  - Полезный документ об интерфейсе данных — [Принципы проектирования IDataView](https://github.com/dotnet/machinelearning/blob/master/docs/code/IDataViewDesignPrinciples.md).
- [*Преобразователь*](#transformer) представлен в виде интерфейса `ITransformer`.
  - Преобразователь — это компонент, который принимает данные, выполняет с ними определенные действия и возвращает новые преобразованные данные.
  - Например, модель машинного обучения можно считать преобразователем, который принимает функции и возвращает прогнозы.
  - Еще один пример: создатель маркеров текста принимает отдельные текстовые столбцы и выводит векторный столбец с отдельными словами, извлеченными из текста.
- [*Модуль чтения данных*](#data-reader) представлен в виде интерфейса `IDataReader<T>`.
  - Модуль чтения данных — это компонент ML.NET для создания данных. Он принимает экземпляр `T` и возвращает данные из него. 
  - Например, *TextLoader* — это `IDataReader<IMultiStreamSource>`. Он принимает источник и создает данные. 
- [*Средство оценки*](#estimator) представлено в виде интерфейса `IEstimator<T>`.
  - Это объект, который учится на основе данных. Результатом обучения является *преобразователь*.
  - Можно представить *алгоритм* машинного обучения как средство оценки, которое учится на основе данных и создает *модель* машинного обучения.
- [*Прогнозирующая функция*](#prediction-function) представлена в виде класса `PredictionEngine<TSrc, TDst>`.
  - Прогнозирующую функцию можно рассматривать как машину, которая применяет преобразователь к одной строке, например во время прогнозирования.

## <a name="data"></a>Данные

В ML.NET данные аналогичны представлению SQL: Это отложенно-вычисляемый, поддерживающий курсоры, неоднородный и схематизированный набор данных.

- Он имеет *схему* (экземпляр интерфейса `ISchema`), содержащую сведения о столбцах представления данных.
  - У каждого столбца есть *имя*, *тип* и произвольный набор *метаданных*, связанных с ним.
  - *Метаданные* столбца содержат такие сведения, как имена слота векторного столбца. Сами метаданные представлены в виде других однострочных *данных*, которые являются уникальными для каждого столбца.
  - Представление данных является источником *курсоров*. Курсоры SQL: Курсор — это объект, который выполняет итерацию по данным по одной строке за раз и представляет доступные данные.
  - Естественно, данные поддерживают любое количество активных курсоров при необходимости. Так как сами данные являются неизменяемыми, курсоры по-настоящему независимы.
  - Курсоры обычно обращаются только к подмножеству столбцов: Для повышения эффективности ML.NET вычисляет только значения столбцов, которые необходимы курсору.

## <a name="transformer"></a>Преобразователь

Преобразователь — это компонент, который принимает данные, выполняет с ними определенные действия и возвращает новые преобразованные данные.

Большинство преобразователей в ML.NET, как правило, работают с *входными столбцами* по одному и создают *выходной столбец*. Например, `new HashTransformer("bar", "foo")` принимает значения из столбца "foo", хэширует их и объединяет в столбец "bar". 

Имена входных и выходных столбцов часто совпадают. В этом случае старый столбец заменяется новым. Например, `new HashTransformer("foo")` принимает значения из столбца "foo", хэширует их и помещает обратно в столбец "foo". 

Любой преобразователь создает новое представление данных при вызове `Transform`. Помните, что представления данных являются неизменяемыми.

Еще один важный момент — поскольку данные вычисляются отложенно, *преобразователи также работают отложенно*. По сути, после вызова

```csharp
var newData = transformer.Transform(oldData)
```

никаких вычислений не происходит. Только после того, как вы получите курсор из `newData` и начнете использовать значение, `newData` вызывает логику преобразования `transformer` (и даже в этом случае, только если `transformer` необходим для создания запрошенных столбцов).

### <a name="transformer-chains"></a>Цепочки преобразователей

Полезное свойство преобразователя в том, что *вы можете создать последовательное применение преобразователей как еще один преобразователь*:

```csharp
var fullTransformer = transformer1.Append(transformer2).Append(transformer3);
```

Это свойство часто используется в ML.NET: как правило, обученная модель ML.NET представляет собой цепочку преобразователей, которая по сути является *преобразователем*.

## <a name="data-reader"></a>Модуль чтения данных

Модуль чтения данных является компонентом ML.NET для создания данных: он принимает экземпляр `T` и возвращает данные из него.

Интересно отметить, что вы можете создать модуль чтения данных, присоединив преобразователь к существующему модулю чтения данных. Таким образом вы можете использовать модуль чтения с поведением преобразования:

```csharp
var newReader = reader.Append(transformer1).Append(transformer2)
```

Еще одно сходство с преобразователями заключается в том, что из-за отложенного вычисления данных *модули чтения также являются отложенными*: фактическое чтение не происходит (или почти не происходит) при вызове `reader.Read()` — только при запросе курсора на полученные данные модуль чтения начинает работу.

## <a name="estimator"></a>Средство оценки

*Средство оценки* — это объект, который учится на основе данных. Результатом обучения является *преобразователь*.

В ML.NET это свойство используется для создания конвейеров обучения, которые связывают различные средства оценки:

```csharp
MLContext mlContext = new MLContext(seed: 0);

var pipeline = mlContext.Transforms.CopyColumns("Label","FareAmount")
    .Append(mlContext.Transforms.Categorical.OneHotEncoding("VendorId"))
    .Append(mlContext.Transforms.Categorical.OneHotEncoding("RateCode"))
    .Append(mlContext.Transforms.Categorical.OneHotEncoding("PaymentType"))
    .Append(mlContext.Transforms.Concatenate("Features","VendorId","RateCode","PassengerCount","TripTime","TripDistance","PaymentType"))
    .Append(mlContext.Regression.Trainers.FastTree("Label","Features"));

var model = pipeline.Fit(dataView);
```

Важное свойство средств оценки заключается в том, *что они работают активно, а не отложенно*: при каждом вызове `Fit` происходит обучение, а на это может требоваться время.

## <a name="prediction-function"></a>Прогнозирующая функция

Прогнозирующую функцию можно рассматривать как компонент, который применяет преобразователь к одной строке.

Когда у вас будет модель (*преобразователь*, обученный с помощью `Fit()` или загруженный из другого места), ее можно использовать для создания прогнозов с помощью обычных вызовов к `model.Transform(data)`. Но при использовании этой модели в реальных сценариях часто у вас не бывает много примеров для прогнозирования. У вас есть по примеру за раз, и вам сразу нужны своевременные прогнозы.

Конечно, можно свести это к пакетному прогнозированию:

- Создайте представление данных с одной строкой.
- Вызовите `model.Transform(data)` для получения спрогнозированного представления данных.
- Поставьте курсор на полученных данных.
- Переместите курсор на один шаг, чтобы перейти к первой (и единственной) строке.
- Извлеките из нее прогнозируемые значения.

Предыдущий алгоритм может осуществляться с помощью [понимания схемы](https://github.com/dotnet/machinelearning/blob/master/docs/code/SchemaComprehension.md) с двумя объектами, определяемыми пользователем, `InputExample` и `OutputPrediction`, как в следующем примере:

```csharp
var inputData = mlContext.Data.ReadFromEnumerable(new InputExample[] { example });
var outputData = model.Transform(inputData);
var output = mlContext.CreateEnumerable<OutputPrediction>(outputData,reuseRowObject:false).First();
```

Но это неудобно и влечет за собой снижение производительности. Вместо этого объект прогнозирующей функции выполняет ту же работу, но быстрее и удобнее, с помощью метода расширения `CreatePredictionEngine`:

```csharp
var predictionEngine = model.CreatePredictionEngine<InputExample,OutputPrediction>(mlContext);
var prediction = predictionEngine.Predict(example);
```

Прогнозирующая функция является *нереентерабельной и потокобезопасной*. Если вы хотите осуществлять прогнозирование с несколькими потоками, вам нужна прогнозирующая функция для каждого потока.
