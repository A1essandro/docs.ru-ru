---
title: "Перенос в .NET Core — библиотеки"
description: "Перенос в .NET Core — библиотеки"
keywords: .NET, .NET Core
author: cartermp
manager: wpickett
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: a0fd860d-d6b6-4659-b325-8a6e6f5fa4a1
translationtype: Human Translation
ms.sourcegitcommit: 46061efa8e33c6a73befa5181eb33b8deb2fa637
ms.openlocfilehash: 051c8d46abdafe722eec77a440e384efbae0e70a

---

# <a name="porting-to-net-core-libraries"></a>Перенос в .NET Core — библиотеки

С выпуском .NET Core 1.0 появилась возможность переносить существующий код библиотек, чтобы он мог выполняться на разных платформах.  В этой статье рассматриваются библиотека .NET Standard и недоступные технологии, объясняется меньшее число интерфейсов API, доступных в .NET Core 1.0, описывается использование средств, входящих в состав пакета SDK для предварительной версии 2 платформы .NET Core, а также рекомендуемые подходы к переносу кода.

Перенос может потребовать немало времени, особенно если у вас большая база кода.  Вам также следует быть готовыми адаптировать приведенные здесь рекомендации в соответствии с особенностями вашего кода.  Каждая база кода имеет свои отличия, поэтому в этой статье мы попытались дать наиболее общие рекомендации, но, возможно, вам потребуется отклониться от них и пойти своим путем.

## <a name="prerequisites"></a>Предварительные требования

В этой статье предполагается, что вы используете Visual Studio 2015 или более поздней версии в ОС Windows.  Двоичные файлы, необходимые для сборки кода .NET Core, недоступны в предыдущих версиях Visual Studio.

В статье также предполагается, что вы знакомы с [рекомендуемым процессом переноса](index.md) и устранили все проблемы с [зависимостями сторонних разработчиков](third-party-deps.md).

## <a name="targeting-the-net-standard-library"></a>Нацеливание на библиотеку .NET Standard

Лучший способ создания кроссплатформенной библиотеки для .NET Core — нацеливание на [библиотеку .NET Standard](../../standard/library.md).  Библиотека .NET Standard представляет собой формальную спецификацию интерфейсов API .NET, которые должны быть доступны во всех средах выполнения .NET.  Она поддерживается средой выполнения .NET Core.

Это означает, что вам необходимо найти компромисс между интерфейсами API, которые можно использовать, и поддерживаемыми платформами, выбрав ту версию платформы .NET Standard, которая позволяет достичь нужного компромисса.

На данный момент существует 7 разных версий .NET Standard: от версии 1.0 до версии 1.6.  Выбирая более позднюю версию, вы получаете доступ к большему количеству интерфейсов API, но круг целевых платформ сужается.  Если вы выберете более раннюю версию, ваш код сможет выполняться на большем количестве целевых платформ, но за счет сокращения количества доступных интерфейсов API.

Для удобства ниже приводится таблица, в которой сопоставлены все версии .NET Standard и поддерживаемые платформы.

| Имя платформы | Alias |  |  |  |  |  | | |
| :---------- | :--------- |:--------- |:--------- |:--------- |:--------- |:--------- |:--------- |:--------- |
|.NET Standard | netstandard | 1,0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 |
|.NET Core|netcoreapp|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|1,0|
|.NET Framework|net|&rarr;|4.5|4.5.1|4.6|4.6.1|4.6.2|4.6.3|
|Платформы Mono и Xamarin||&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|&rarr;|*|
|Универсальная платформа Windows |uap|&rarr;|&rarr;|&rarr;|&rarr;|10.0|||
|Windows|win|&rarr;|8.0|8.1|||||
|Windows Phone|wpa|&rarr;|&rarr;|8.1|||||
|Windows Phone Silverlight|wp|8.0|||||||

Очень важно понимать, что **проект, предназначенный для более ранней версии, не может ссылаться на проект, предназначенный для более поздней версии**.  Например, проект, предназначенный для платформы .NET Standard версии 1.2, не может ссылаться на проекты, предназначенные для платформы .NET Standard версии 1.3 или более поздней.  Однако проекты **могут** ссылаться на более ранние версии, то есть проект, предназначенный для платформы .NET Standard 1.3, может ссылаться на проект, предназначенный для платформы .NET Standard 1.2 или более ранней.

Рекомендуется выбирать самую раннюю возможную версию .NET Standard и использовать ее в рамках всего проекта.

Дополнительные сведения см. в разделе [Библиотека платформы .NET Standard](../../standard/library.md).

## <a name="key-technologies-not-yet-available-on-the-net-standard-or-net-core"></a>Ключевые технологии, пока не доступные в .NET Standard или .NET Core

Возможно, вы используете некоторые технологии .NET Framework, которые в настоящее время недоступны для .NET Core.  Каждый из следующих подразделов посвящен одной из таких технологий.  Приводятся альтернативные варианты, которые можно применить, если это представляется целесообразным.

### <a name="app-domains"></a>Домены приложений

Домены приложений могут использоваться в .NET Framework в различных целях. Для изоляции кода мы рекомендуем в качестве альтернативы отдельные процессы или контейнеры. Для динамической загрузки сборок рекомендуется использовать новый класс @System.Runtime.Loader.AssemblyLoadContext.

### <a name="remoting"></a>Удаленное взаимодействие

Для взаимодействия между процессами вместо удаленного взаимодействия можно применять механизмы межпроцессного взаимодействия (IPC), такие как [каналы](https://docs.microsoft.com/dotnet/core/api/system.io.pipes) и [отображенные в память файлы](https://docs.microsoft.com/dotnet/core/api/system.io.memorymappedfiles.memorymappedfile).

Для взаимодействия между компьютерами в качестве альтернативы можно использовать сетевое решение, желательно протокол на основе обычного текста с низкими издержками, например HTTP.  Как вариант можно рассмотреть [KestrelHttpServer](https://github.com/aspnet/KestrelHttpServer), веб-сервер, используемый платформой ASP.NET Core.  Еще один вариант — создание удаленного прокси-сервера посредством [Castle.Core](https://github.com/castleproject/Core).

### <a name="binary-serialization"></a>Двоичная сериализация

В качестве альтернативы двоичной сериализации имеется множество различных технологий сериализации.  Следует выбрать ту из них, которая соответствует вашим требованиям к форматированию и размеру данных.  Вот некоторые популярные варианты:

* [JSON.NET](http://www.newtonsoft.com/json) для JSON;
* @System.Runtime.Serialization.DataContractSerializer — для XML и JSON
* @System.Xml.Serialization.XmlSerializer — для XML
* [protobuf-net](https://github.com/mgravell/protobuf-net) для буферов протоколов.

Чтобы получить сведения о преимуществах каждого из этих вариантов и выбрать наиболее подходящий, перейдите по соответствующим ссылкам.  Существует также множество других форматов и технологий сериализации, многие из которых имеют открытый исходный код.

### <a name="sandboxes"></a>"Песочницы"

В качестве альтернативы "песочницам" можно применять ограничения безопасности, обеспечиваемые операционной системой, например учетные записи пользователей для выполнения процессов с минимальным набором прав.

## <a name="overview-of-projectjson"></a>Общие сведения о `project.json`

[Модель проекта project.json](../tools/project-json.md) — это модель проекта, входящая в состав предварительной версии 2 пакета SDK для .NET Core 1.0.  Она предлагает ряд преимуществ, которые могут вам потребоваться:

* простая настройка для различных версий: целевые сборки можно создавать на основе одной и той же сборки;
* возможность легко создать пакет NuGet со сборкой проекта;
* отсутствие необходимости в указании списка файлов в файле проекта;
* унификация зависимостей пакетов NuGet и межпроектных зависимостей.

> Хотя модель проекта `project.json` в конечном итоге устареет, в настоящее время ее можно использовать для сборки библиотек на основе .NET Standard.

### <a name="the-project-file-projectjson"></a>Файл проекта: `project.json`

Проекты .NET Core определяются каталогом, содержащим файл `project.json`.  Именно в этом файле объявляются различные аспекты проекта, в том числе зависимости пакетов, конфигурация компилятора, конфигурация среды выполнения и многое другое.

Команда `dotnet restore` считывает этот файл проекта, восстанавливает все зависимости для проекта и создает файл `project.lock.json`.  Этот файл содержит все сведения, которые требуются системе сборки для сборки проекта.

Дополнительные сведения о файле `project.json` см.в [справке по файлу project.json](../tools/project-json.md).

### <a name="the-solution-file-globaljson"></a>Файл решения: `global.json`

`global.json` — это необязательный файл, который можно включить в решение, содержащее несколько проектов.  Обычно он находится в корневом каталоге набора проектов.  С его помощью можно сообщать системе сборки о различных подкаталогах, содержащих проекты.  Этот файл предназначен для больших систем, состоящих из нескольких проектов.

Например, можно разделить код на папку `/src` верхнего уровня и папку `/test` следующим образом:

```json
{
    "projects":[ "src", "test" ]
}
```

Затем можно создавать файлы `project.json` в собственных вложенных папках в папках `/src` и `/test`.

### <a name="how-to-multitarget-with-projectjson"></a>Настройка для различных версий с помощью `project.json`

Многие библиотеки настраиваются для различных версий, чтобы иметь максимально возможный охват.  В .NET Core настройка для различных версий — одно из основных преимуществ, так как вы можете легко создавать сборки для конкретных платформ на основе одной единственной сборки.

Чтобы выполнить настройку для различных версий, нужно всего лишь добавить правильный моникер целевой платформы (TFM) в файл `project.json`, использовать правильные зависимости для каждой целевой платформы (`dependencies` для .NET Core и `frameworkAssemblies` для .NET Framework), а также при необходимости использовать директивы `#if` с целью условной компиляции исходного кода для использования API конкретных платформ.

Предположим, что вы создаете библиотеку, выполняющую некоторые сетевые операции, и вы хотите, чтобы она выполнялась во всех версиях .NET Framework, в профиле переносимой библиотеки классов (PCL) и в .NET Core.  Для целевых платформ .NET Core и .NET Framework 4.5 или более поздних версий можно использовать библиотеки `System.Net.Http` и `async`/`await`.  Однако для более ранних версий .NET Framework эти интерфейсы API недоступны.

Вот пример раздела `frameworks` файла `project.json`, предназначенного для версий .NET Framework 2.0, 3.5, 4.0, 4.5 и .NET Standard 1.6.

```javascript
{
    "frameworks":{
        "net20":{
            "frameworkAssemblies":{
                "System.Net":""
            }
        },
        "net35":{
            "frameworkAssemblies":{
                "System.Net":""
            }
        },
        "net40":{
            "frameworkAssemblies":{
                "System.Net":""
            }
        },
        "net45":{
            "frameworkAssemblies":{
                "System.Net.Http":"",
                "System.Threading.Tasks":""
            }
        },
        ".NETPortable,Version=v4.5,Profile=Profile259": {
            "buildOptions": {
                "define": [ "PORTABLE" ]
             },
             "frameworkAssemblies":{
                 "mscorlib":"",
                 "System":"",
                 "System.Core":"",
                 "System.Net.Http":""
             }
        },
        "netstandard16":{
            "dependencies":{
                "NETStandard.Library":"1.6.0",
                "System.Net.Http":"4.0.1",
                "System.Threading.Tasks":"4.0.11"
            }
        },
    }
}
```

Обратите внимание на то, что нацеливание на PCL осуществляется особым образом: необходимо указать определение сборки, распознаваемое компилятором, а также все используемые сборки, включая `mscorlib`.  

После этого в исходном коде можно использовать зависимости следующим образом:

```csharp
#if (NET20 || NET35 || NET40 || PORTABLE)
using System.Net;
#else
using System.Net.Http;
using System.Threading.Tasks;
#endif
```

Обратите внимание на то, что все целевые платформы .NET Framework и .NET Standard имеют имена, распознаваемые компилятором:

```
.NET Framework 2.0   --> NET20
.NET Framework 3.5   --> NET35
.NET Framework 4.0   --> NET40
.NET Framework 4.5   --> NET45
.NET Framework 4.5.1 --> NET451
.NET Framework 4.5.2 --> NET452
.NET Framework 4.6   --> NET46
.NET Framework 4.6.1 --> NET461
.NET Framework 4.6.2 --> NET462
.NET Standard 1.0    --> NETSTANDARD1_0
.NET Standard 1.1    --> NETSTANDARD1_1
.NET Standard 1.2    --> NETSTANDARD1_2
.NET Standard 1.3    --> NETSTANDARD1_3
.NET Standard 1.4    --> NETSTANDARD1_4
.NET Standard 1.5    --> NETSTANDARD1_5
.NET Standard 1.6    --> NETSTANDARD1_6
```

Как было сказано ранее, при нацеливании на PCL необходимо указать определение сборки, распознаваемое компилятором.  Определения по умолчанию, которое может использовать компилятор, нет.

### <a name="using-projectjson-in-visual-studio"></a>Использование файла `project.json` в Visual Studio

Использовать `project.json` в Visual Studio можно двумя способами:

1. новый тип проекта xproj;
2. перенацеленный проект PCL, поддерживающий .NET Standard.

У каждого способа есть свои преимущества и недостатки.

#### <a name="when-to-pick-an-xproj-project"></a>Когда следует выбирать проект Xproj

Новая система проектов Xproj в Visual Studio использует возможности модели проекта на основе `project.json` для обеспечения двух основных преимуществ в дополнение к возможностям существующих типов проектов: простая настройка для разных версий путем создания нескольких сборок и возможность создать пакет NuGet непосредственно при сборке.

Однако в то же время она лишена ряда возможностей, которые вы, возможно, используете, таких как:

- поддержка F# или Visual Basic;
- создание вспомогательных сборок с локализованными строками ресурсов;
- прямые ссылки на файл `.dll` в файловой системе;
- возможность ссылаться на проект на основе csproj в диспетчере ссылок (однако прямое использование файла `.dll` поддерживается).

Если потребности проекта сравнительно невелики и вы можете использовать новые возможности xproj, следует выбрать эту систему проектов.  Чтобы сделать это в Visual Studio, выполните указанные ниже действия:

1. Необходимо использовать Visual Studio 2015 или более поздней версии.
2. Выберите "Файл" > "Создать проект".
3. В узле Visual C# выберите элемент .NET Core.
4. Выберите шаблон "Библиотека классов (.NET Core)". 

#### <a name="when-to-pick-a-pcl-project"></a>Когда следует выбирать проект PCL

Для нацеливания на .NET Core можно использовать традиционную систему проектов в Visual Studio. Для этого создайте переносимую библиотеку классов (PCL) и выберите элемент .NET Core в диалоговом окне настройки проекта.  Затем вам потребуется перенацелить проект так, чтобы он основывался на платформе .NET Standard:

1. Щелкните правой кнопкой мыши файл проекта в Visual Studio и выберите пункт "Свойства".
2. В разделе "Сборка" выберите "Преобразовать в .NET Standard".

Если требования к системе проектов сложнее, выбор за вами.  Обратите внимание на то, что если вам необходимо выполнить настройку для разных версий путем создания сборок для конкретных платформ, как с помощью системы проектов `xproj`, то вам потребуется создать библиотеку PCL "с подменой", как описано в разделе [Обеспечение правильной работы переносимых библиотек классов](https://blogs.msdn.microsoft.com/dsplaisted/2012/08/27/how-to-make-portable-class-libraries-work-for-you/).

## <a name="retargeting-your-net-framework-code-to-net-framework-462"></a>Перенацеливание кода .NET Framework на версию .NET Framework 4.6.2

Если ваш код не предназначен для платформы .NET Framework 4.6.2, рекомендуется перенацелить его.  Это позволит использовать альтернативные интерфейсы API в случаях, когда .NET Standard не поддерживает существующие интерфейсы API.

Для каждого проекта в Visual Studio, который нужно перенести, выполните указанные ниже действия:

1. Щелкните проект правой кнопкой мыши и выберите пункт "Свойства".
2. В раскрывающемся списке "Целевая рабочая среда" выберите значение .NET Framework 4.6.2.
3. Перекомпилируйте проекты.

Вот и все!  Так как ваши проекты теперь предназначены для .NET Framework 4.6.2, вы можете использовать эту версию .NET Framework в качестве основы для переноса кода.

## <a name="determining-the-portability-of-your-code"></a>Определение переносимости кода

Следующий шаг — запуск анализатора переносимости API (ApiPort) для создания отчета о переносимости и его последующий анализ.

Вам необходимо уметь работать со [средством переносимости API (ApiPort)](https://github.com/Microsoft/dotnet-apiport/blob/master/docs/HowTo/) и создавать отчеты о переносимости для нацеливания на .NET Core.  Выполняемые действия могут различаться в зависимости от ваших потребностей и личных предпочтений.  Ниже описываются несколько разных подходов — вы можете использовать их в различных сочетаниях в зависимости от структуры кода.

### <a name="dealing-primarily-with-the-compiler"></a>Работа в первую очередь с компилятором

Такой подход может быть оптимальным для небольших проектов или проектов, в которых используется небольшое количество интерфейсов API .NET Framework.  Этот подход очень прост:

1. При необходимости запустите средство ApiPort для проекта.
2. Если средство ApiPort запускалось, вкратце просмотрите отчет.
3. Скопируйте весь код в новый проект .NET Core.
4. Исправьте ошибки компилятора, пока код не будет компилироваться. При необходимости обращайтесь к отчету о совместимости.
5. Повторите эту процедуру, если необходимо.

Хотя такой подход отличается низкой систематичностью, ориентация на код может помочь быстро устранить все проблемы и оказаться оптимальной для небольших проектов или библиотек.  Наиболее подходящим здесь может быть проект, содержащий только модели данных.

### <a name="staying-on-the-net-framework-until-portability-issues-are-resolved"></a>Использование .NET Framework до устранения проблем переносимости

Такой подход может быть оптимальным, если вам нужен код, который компилируется на протяжении всего процесса.  Он выглядит следующим образом.

1. Запустите средство ApiPort для проекта.
2. Устраните проблемы, используя другие интерфейсы API, являющиеся переносимыми.
3. Запомните области, для которых нет прямых альтернатив.
4. Повторяйте шаги 1–3 для всех переносимых проектов, пока вы не будете уверены в том, что каждый из них готов к копированию в проект .NET Core.
5. Скопируйте код в новые проекты .NET Core.
6. Разрешите проблемы, которые вы запомнили ранее.

Такой тщательный подход является более систематичным, чем простое устранение ошибок компилятора, но он по-прежнему в некоторой степени ориентирован на код и имеет то преимущество, что код является компилируемым на всех этапах.  Способы устранения некоторых проблем, которые не далось разрешить использованием другого интерфейса API, могут быть самыми разными.  Для некоторых проектов может оказаться необходимым разработать более детальный план. Эта задача рассматривается в следующем подходе.

### <a name="developing-a-comprehensive-plan-of-attack"></a>Разработка детального плана

Этот подход может быть оптимальным для более крупных и сложных проектов, в которых для поддержки .NET Core может потребоваться реструктурировать код или повторно написать некоторые части.  Он выглядит следующим образом.

1. Запустите средство ApiPort для проекта.
2. Определите, в каких местах кода используется каждый непереносимый тип и как он влияет на переносимость в целом.

   1.  Изучите особенности этих типов.  Их немного, но они часто используются?  Или их много, но используются они нечасто?  Ограничена ли область их использования или они распределены по всему коду?
   
   2. Можно ли легко изолировать непереносимый код, чтобы с ним было проще работать?
   
   В. Требуется ли рефакторинг кода?
   
   Г. Есть ли для непереносимых типов альтернативные интерфейсы API, выполняющие те же задачи?  Например, если используется класс `WebClient`, вместо него можно использовать класс `HttpClient`.
   
   Д. Есть ли другие переносимые интерфейсы API, которые можно использовать для выполнения задачи, даже если это не совсем равноценная замена?  Например, если вы используете `XmlSchema` для анализа XML, но вам не требуется обнаружение схемы XML, вы можете использовать интерфейсы API `System.Linq.Xml` и анализировать данные вручную.

3. Если у вас есть сборки, которые трудно перенести, возможно, пока стоит оставить их в .NET Framework?  Следует учесть ряд факторов:

   1. В библиотеке могут быть функции, которые несовместимы с .NET Core, так как они слишком тесно связаны с возможностями .NET Framework или Windows.  Возможно, пока стоит отказаться от этих функций и выпустить версию библиотеки для .NET Core с ограниченной функциональностью?
   
   2. Поможет ли в этом случае рефакторинг?
   
4. Целесообразно ли написание собственной реализации недоступного интерфейса API .NET Framework?

   Вместо этого можно рассмотреть возможность копирования, изменения и использования кода из [библиотеки эталонного исходного кода .NET Framework](https://github.com/Microsoft/referencesource).  Он предоставляется по [лицензии MIT](https://github.com/Microsoft/referencesource/blob/master/LICENSE.txt), поэтому делать это можно достаточно свободно.  Только не забывайте соответствующим образом упоминать корпорацию Майкрософт в своем коде.
   
5. При необходимости повторите этот процесс для различных проектов.
6. Разработав план, выполните его.
 
Этап анализа может занять некоторое время в зависимости от объема базы кода.  Потратив некоторое время на этот этап, чтобы тщательно проанализировать требуемый объем изменений и разработать план, вы сможете сэкономить много времени в долгосрочной перспективе, особенно если у вас сложная база кода.

План может предусматривать внесение существенных изменений в базу кода с сохранением нацеливания на .NET Framework 4.6.2, что делает этот подход более структурированным по сравнению с предыдущим.  Способ реализации плана зависит от базы кода.

### <a name="mixing-approaches"></a>Сочетание подходов

В каждом конкретном случае, скорее всего, потребуется использовать описанные выше подходы в разных сочетаниях.  Выбирайте наиболее подходящие варианты для себя и вашей базы коды.

## <a name="porting-your-tests"></a>Перенос тестов

Чтобы гарантировать правильную работу кода после его переноса в .NET Core, лучше всего тестировать его в процессе переноса.  Для этого потребуется использовать платформу тестирования, которая будет выполнять сборку и запуск тестов для .NET Core.  В настоящее время имеются три варианта:

* [xUnit](https://xunit.github.io/)
   - [Начало работы](http://xunit.github.io/docs/getting-started-dnx.html)
   - [Средство для преобразования проекта MSTest в xUnit](https://github.com/dotnet/codeformatter/tree/master/src/XUnitConverter)
* [NUnit](http://www.nunit.org/)
  - [Начало работы](https://github.com/nunit/docs/wiki/Installation)
  - [Запись блога о миграции из MSTest в NUnit](http://www.florian-rappl.de/News/Page/275/convert-mstest-to-nunit)
* [MSTest](https://msdn.microsoft.com/library/ms243147.aspx)

## <a name="recommended-approach-to-porting"></a>Рекомендуемый подход к переносу

Наконец, перенесите сам код.  Процедура переноса во многом зависит от того, как структурирован ваш код .NET Framework.  Тем не менее ниже описывается рекомендованный подход, который может хорошо подойти вашей базе кода.

Перенос кода лучше всего начинать с основных компонентов библиотеки.  Это могут быть модели данных или какие-либо иные базовые классы и методы, используемые всеми остальными компонентами прямо или косвенно.

1. Перенесите тестовый проект с целью тестирования того уровня библиотеки, который вы переносите на данном этапе.
2. Скопируйте основные компоненты библиотеки в новый проект .NET Core и выберите версию .NET Standard, которая должна поддерживаться.
3. Внесите изменения, необходимые для компиляции кода.  Зачастую для этого требуется добавить зависимости пакетов NuGet в файл `project.json`.
4. Проведите тесты и внесите необходимые исправления.
5. Выберите следующий уровень кода для переноса и повторите шаги 2 и 3.

Методично двигаясь от базовых компонентов библиотеки к более высоким уровням и тестируя каждый из них требуемым образом, вы обеспечиваете систематичность переноса и изоляцию проблем, относящихся к отдельным уровням кода.



<!--HONumber=Nov16_HO1-->


