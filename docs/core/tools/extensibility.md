---
title: "Модель расширяемости CLI в .NET Core | Microsoft Docs"
description: "Модель расширяемости CLI .NET Core"
keywords: "CLI, расширяемость, пользовательские команды, .NET Core"
author: blackdwarf
ms.author: mairaw
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net-core
ms.technology: dotnet-cli
ms.devlang: dotnet
ms.assetid: 1bebd25a-120f-48d3-8c25-c89965afcbcd
translationtype: Human Translation
ms.sourcegitcommit: 2ad428dcda9ef213a8487c35a48b33929259abba
ms.openlocfilehash: 48f06f0af3768f7129e0a2b3a89bbdc7795959dc

---

# <a name="net-core-cli-extensibility-model"></a>Модель расширяемости CLI .NET Core 

> [!WARNING]
> Эта статья применима к инструментам .NET Core (предварительная версия 2). Информацию об инструментах .NET Core (предварительная версия 4) для версии-кандидата Visual Studio 2017 см. в статье [Модель расширяемости CLI в .NET Core (предварительная версия 4 инструментов)](../preview3/tools/extensibility.md).

## <a name="overview"></a>Обзор
В этом документе рассматриваются основные способы расширения средств интерфейса командной строки (CLI) и приводятся сценарии, в которых используется каждое из этих средств. В ней вкратце описывается использование средств, а также приводятся замечания по созданию средств обоих типов. 

## <a name="how-to-extend-cli-tools"></a>Расширение средств CLI
Средства CLI можно расширять двумя основными способами:

1. посредством пакетов NuGet для каждого отдельного проекта;
2. посредством системного пути;

Два указанных выше механизма расширяемости не являются взаимоисключающими: вы можете использовать оба или только один из них. Выбор зависит в первую очередь от цели, которой вы стремитесь достичь своим расширением.

## <a name="per-project-based-extensibility"></a>Расширяемость на основе отдельных проектов
Средства для отдельных проектов — это [переносимые консольные приложения](../deploying/index.md), которые распространяются как пакеты NuGet. Средства доступны только в контексте проекта, который ссылается на них и для которого они восстанавливаются. Вызов вне контекста проекта (например, вне каталога, содержащего проект) завершится сбоем, так как команду не удастся найти.

Эти средства также идеально подходят для создания серверов, так как для них не требуется ничего, кроме `project.json`. Процесс сборки выполняет восстановление для соответствующего проекта, и средства становятся доступны. Проекты на таких языках, как F#, также относятся к этой категории. В конце концов, каждый проект может быть написан только на одном языке. 

Наконец, эта модель расширяемости обеспечивает поддержку создания средств, которым требуется доступ к выходным данным сборки проекта. Например, различные средства просмотра Razor в приложениях MVC [ASP.NET](https://www.asp.net/) попадают в эту категорию. 

### <a name="consuming-per-project-tools"></a>Использование средств для отдельных проектов
Для использования этих средств необходимо добавить узел `tools` в файл `project.json`. Внутри узла `tools` необходимо сослаться на пакет, в котором находится средство. После выполнения команды `dotnet restore` средство и его зависимости восстанавливаются. 

Для средств, выполнение которых требует загрузки выходных данных сборки проекта, обычно имеется еще одна зависимость, которая указывается в списке стандартных зависимостей в файле проекта. Это означает, что средства, загружающие код проекта, имеют два компонента: 

1. основное средство вызова;
2. любое количество других средств, которые содержат рабочую логику. 

Зачем же нужны два компонента? Средства, которым требуется загружать выходные данные сборки проекта, и проект, в котором они работают, должны иметь единую схему зависимостей. Добавляя бит зависимости, мы позволяем пакету NuGet разрешать эти зависимости в виде единой схемы. Средство вызова необходимо для определения расположения, а также платформ зависимого средства. Средство вызова может принимать любые заданные пользователем аргументы перенаправления (`-c`, `-o`, `-b`) для поиска зависимого средства. Оно также может применять любые политики в случае, если имеется несколько зависимых средств для разных платформ (то есть оно определяет, нужно ли запускать все эти средства, только одно из них и т. д.). В целом логика может совместно использоваться двумя этими средствами любым необходимым образом. 

Рассмотрим пример добавления простого средства на основе узла tools в простой проект. Предположим, что имеется команда `dotnet-api-search`, которая позволяет искать указанный интерфейс API в пакетах NuGet. Вот файл `project.json` консольного приложения, которое использует это средство:

```json
{
    "version": "1.0.0",
    "compilationOptions": {
        "emitEntryPoint": true
    },
    "dependencies": {
        "Microsoft.NETCore.App": {
            "type": "platform",
            "version": "1.0.0"
        }
    },
    "tools": {
        "dotnet-api-search": {
            "version": "1.0.0",
            "imports": ["dnxcore50"]
        }
    },
    "frameworks": {
        "netcoreapp1.0": {}
    }
}
```

Узел `tools` имеет структуру, подобную структуре узла `dependencies`. Ему требуются по крайней мере идентификатор пакета, содержащего средство, и его версия. В приведенном выше примере имеется еще один оператор — `imports`. Он влияет на процесс восстановления средства и указывает, что, помимо целевых платформ, средство также совместимо с целевой платформой `dnxcore50`. Дополнительные сведения можно найти в [справочнике по project.json](project-json.md).

### <a name="building-tools"></a>Создание средств
Как было сказано ранее, средства — это просто переносимые консольные приложения. Они создаются так же, как любые другие консольные приложения. После сборки используйте команду [`dotnet pack`](dotnet-pack.md), чтобы создать пакет NuGet (nupkg), содержащий код, сведения о зависимостях и т. д. Имя пакета может быть любым, но содержащееся в нем приложение, то есть двоичный файл средства, должно соответствовать соглашению `dotnet-<command>`, чтобы среда `dotnet` могла вызывать его. 

Так как средства — это переносимые приложения, то для его запуска у пользователя должна быть та версия библиотек .NET Core, для которой выполнялась сборка средства. Зависимости, которые использует средство и которые не содержатся в библиотеках .NET Core, восстанавливаются и помещаются в кэш NuGet. Таким образом, средство в целом выполняется с помощью сборок из библиотек .NET Core, а также сборок из кэша NuGet. 

Подобные средства имеют схему зависимостей, которая никак не связана со схемой зависимостей проекта, использующего эти средства. Процесс восстановления сначала восстанавливает зависимости проекта, а затем восстанавливает каждое из средств и их зависимости. 

Вы можете найти более подробные примеры и различные сочетания в [репозитории CLI .NET Core](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects). Вы также можете найти [реализацию используемых средств](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages) в том же репозитории. 

Сборка средств, которые загружают выходные данные сборки проекта для выполнения, производится несколько иначе. Как уже говорилось, подобные средства имеют два компонента:

1. средство диспетчера, которое вызывает пользователь;
2. зависимость для конкретной платформы, которая содержит логику поиска выходных данных сборки и совершаемых с ними действий.

Ярким примером могут служить команды [Entity Framework (EF)](https://github.com/aspnet/EntityFramework), а также команда [`dotnet test`](dotnet-test.md). В обоих случаях имеется средство, на которое указывает ссылка в узле `tools` файла `project.json`, — это основной диспетчер. Пользователь вызывает средство в командной строке. Второй компонент — это зависимость, которая указывается в основных зависимостях проекта (корневых или платформенно-зависимых). Этот пакет, собственно, содержит логику средства. Он является обычной зависимостью и будет восстановлен в рамках процесса восстановления проекта. 

В отличие от средств предыдущего типа такие средства являются частью схемы проекта, который использует их. Это связано с тем, что им требуется доступ к коду проекта и, возможно, всем его зависимостям. Например, средствам EF требуется такой доступ по той причине, что им необходимо искать в сборках нужный код, например миграции.  

Еще одной причиной существования такого двухаспектного решения является обеспечение более понятной модели вызова. Большинство команд CLI, которые сбрасывают определенные объекты на диске (например, `dotnet build`, `dotnet publish`), позволяют пользователям перенаправлять выходные данные по другому пути с помощью аргумента `--output`, `--build-base-path` или `--configuration`. В случае со средствами EF, например, для поиска выходных данных сборки проекта необходимо указать те же аргументы с теми же значениями *как* для драйвера `dotnet`, так и для команды `ef`. При использовании модели вызова пользователи передают аргументы в средство диспетчера, которое затем применяет их для нахождения необходимого двоичного файла, содержащего логику, в выходных каталогах. 

Хороший пример такого подхода можно найти в [репозитории CLI .NET Core](https://github.com/dotnet/cli):

* [Пример файла project.json](https://github.com/dotnet/cli/blob/rel/1.0.0-preview2/TestAssets/DesktopTestProjects/AppWithDirectDependencyDesktopAndPortable/project.json)
* [Реализация диспетчера](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-dependency-tool-invoker)
* [Реализация зависимости, связанной с платформой](https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages/dotnet-desktop-and-portable)


### <a name="path-based-extensibility"></a>Расширяемость на основе пути
Расширяемость на основе пути обычно используется на компьютерах разработки, на которых требуется средство, которое охватывает более одного проекта. Основным недостатком такого механизма расширения является его привязка к компьютеру, на котором размещается средство. Если средство требуется на другом компьютере, его необходимо развернуть.

Такая схема расширяемости набора средств CLI очень проста. Как указано в [обзоре CLI .NET Core](index.md), драйвер `dotnet` может выполнять любую команду, имя которой соответствует соглашению `dotnet-<command>`. Логика разрешения по умолчанию сначала проверяет несколько расположений и в конечном итоге переключается на системный путь. Если запрошенная команда существует по системному пути и является двоичным файлом, который можно вызвать, драйвер `dotnet` вызовет ее. 

Двоичный файл может быть практически любым файлом, который может выполнить операционная система. В системах Unix это означает любой файл с битом выполнения, заданным посредством `chmod +x`. В Windows это любые файлы, которые система может запускать. 

В качестве примера рассмотрим очень простую реализацию команды `dotnet clean`. Для ее реализации мы используем `bash`. Команда просто удаляет каталоги `bin/` и `obj/` в текущем каталоге. Если в нее передается аргумент `--lock`, она также удаляет файл `project.lock.json`. Полный код команды приводится ниже. 

```bash
#!/bin/bash

# Delete the bin and obj dirs
rm -rf bin/ obj/

LOCK_FILE=$1
if [[ "$LOCK_FILE" = "--lock" ]]; then
    rm project.lock.json
fi


echo "Cleaning complete..."
```

В Mac OS можно сохранить этот скрипт как `dotnet-clean` и задать его бит выполнения с помощью `chmod +x dotnet-clean`. Затем можно создать символьную ссылку на него в `/usr/local/bin` с помощью команды `ln -s dotnet-clean /usr/local/bin/`. Это позволит вызывать чистую команду с использованием синтаксиса `dotnet clean`. Чтобы протестировать эту возможность, создайте приложение, выполните для него команду `dotnet build`, а затем выполните `dotnet clean`. 

## <a name="conclusion"></a>Заключение
Средства CLI .NET Core обеспечивают две основные точки расширяемости. Средства для отдельных проектов включены в контекст проекта, но обеспечивают простую установку путем восстановления. Подход на основе пути подходит для общих межпроектных средств, которые могут использоваться на одном компьютере. 



<!--HONumber=Jan17_HO3-->


