---
title: "Размещение .NET Core"
description: "Размещение среды выполнения .NET Core из машинного кода"
keywords: ".NET, .NET Core, размещение, размещение .NET Core"
author: mjrousos
ms.author: mikerou
ms.date: 2/3/2017
ms.topic: article
ms.prod: .net-core
ms.devlang: dotnet
ms.assetid: 13edec8b-614d-47ed-9e95-ed6d3b94ec0c
ms.translationtype: HT
ms.sourcegitcommit: e0271ba3392ce8861dc916714af8c16d4581ce4f
ms.openlocfilehash: 1f0983b909244dda7270d3eff01dc302383639a5
ms.contentlocale: ru-ru
ms.lasthandoff: 08/14/2017

---

# <a name="hosting-net-core"></a>Размещение .NET Core

Как и весь управляемый код, приложения .NET Core выполняются основным приложением. Основное приложение отвечает за запуск среды выполнения (включая такие компоненты, как JIT и сборщик мусора), создание доменов приложений и вызов управляемых точек входа.

Размещение среды выполнения .NET Core является расширенным сценарием, и в большинстве случаев разработчикам .NET Core не нужно беспокоиться о размещении, так как процессы сборки .NET Core предоставляют основное приложение по умолчанию для запуска приложений .NET Core. Но в отдельных ситуациях бывает удобно разместить среду выполнения .NET Core явным образом — либо как средство вызова управляемого кода в собственном процессе, либо для получения большего контроля над работой среды выполнения.

В этой статье приводится обзор действий, необходимых для запуска среды выполнения .NET Core из машинного кода, создания исходного домена приложений (<xref:System.AppDomain>) и выполнения в нем управляемого кода.

## <a name="prerequisites"></a>Предварительные требования

Так как основные приложения являются собственными, в этом учебнике рассматривается создание приложения C++ для размещения .NET Core. Вам потребуется среда разработки C++ (например, предоставляемая в [Visual Studio](https://www.visualstudio.com/downloads/)).

Потребуется также и простое приложение .NET Core для проверки основного приложения, поэтому следует установить пакет [.NET Core SDK](https://www.microsoft.com/net/core) и [создать небольшое тестовое приложение .NET Core](../../core/tutorials/with-visual-studio.md) (например, приложение "Hello World"). Достаточно приложения "Hello World", созданного с помощью нового шаблона для консольного проекта .NET Core.

В этом учебнике и связанном с ним примере создается основное приложение Windows. Сведения о размещении приложений в Unix см. в разделе примечаний в конце этой статьи.

## <a name="creating-the-host"></a>Создание основного приложения

[Пример основного приложения](https://github.com/dotnet/docs/tree/master/samples/core/hosting), в котором демонстрируются описанные здесь действия, доступен в репозитории dotnet/docs на сайте GitHub. Комментарии в файле примера *host.cpp* четко соответствуют пронумерованным шагам в этом учебнике. Инструкции по загрузке см. в разделе [Просмотр и скачивание примеров](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).

Помните, что пример основного приложения предназначен для учебных целей, поэтому в нем реализована минимальная проверка ошибок, а удобочитаемость поставлена выше эффективности. Дополнительные реальные примеры основного приложения доступны в репозитории [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts). В частности, хорошим приложением общего назначения является [основное приложение CoreRun](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun), к которому стоит обратиться после изучения более простого примера.

### <a name="a-note-about-mscoreeh"></a>Примечание о mscoree.h
Основной интерфейс размещения .NET Core (`ICLRRuntimeHost2`) определяется в [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL). Версия заголовка этого файла (mscoree.h), на которую должно ссылаться ваше основное приложение, создается через MIDL при сборке [среды выполнения .NET Core](https://github.com/dotnet/coreclr/). Если вы не хотите создавать среду выполнения .NET Core, в репозитории dotnet/coreclr имеется [уже готовый заголовок](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) mscoree.h. [Инструкции по созданию среды выполнения .NET Core](https://github.com/dotnet/coreclr#building-the-repository) можно найти в соответствующем репозитории GitHub. 

### <a name="step-1---identify-the-managed-entry-point"></a>Шаг 1. Определение управляемой точки входа
Сразу после задания ссылки на необходимые заголовки (например, [mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) и stdio.h) основное приложение .NET Core, среди прочего, должно найти управляемую точку входа, которую будет использовать. В нашем примере основного приложения это осуществляется простым использованием первого аргумента командной строки в качестве пути к управляемому двоичному файлу, из которого будет выполнен метод `main`.

[!code-cpp[NetCoreHost#1](../../../samples/core/hosting/host.cpp#1)]

### <a name="step-2---find-and-load-coreclrdll"></a>Шаг 2. Поиск и загрузка CoreCLR.dll
API среды выполнения .NET Core находятся в *CoreCLR.dll* (для Windows). Чтобы получить интерфейс размещения (`ICLRRuntimeHost2`), нужно найти и загрузить *CoreCLR.dll*. Соглашение о поиске *CoreCLR.dll* определяется самим основным приложением. Некоторые основные приложения ожидают найти этот файл в известном в рамках всего компьютера расположении (например, %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0). Другие ожидают, что *CoreCLR.dll* будет загружен из расположения, где размещается основное или обычное приложение. Отдельные приложения для поиска библиотеки обращаются к переменной среды.

В Linux или Mac основной библиотекой времени выполнения является *libcoreclr.so* или *libcoreclr.dylib*, соответственно.

Наш пример основного приложения проверяет наличие *CoreCLR.dll* в нескольких общих расположениях. После нахождения ее требуется загрузить через `LoadLibrary` (либо `dlopen` в Linux или Mac).

[!code-cpp[NetCoreHost#2](../../../samples/core/hosting/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost2-instance"></a>Шаг 3. Получение экземпляра ICLRRuntimeHost2
Интерфейс размещения `ICLRRuntimeHost2` получается путем вызова `GetProcAddress` (либо `dlsym` в Linux или Mac) на `GetCLRRuntimeHost` с последующим вызовом этой функции. 

[!code-cpp[NetCoreHost#3](../../../samples/core/hosting/host.cpp#3)]

### <a name="step-4---setting-startup-flags-and-starting-the-runtime"></a>Шаг 4. Установка флагов запуска и запуск среды выполнения
Располагая `ICLRRuntimeHost2`, можно задать флаги запуска для всей среды выполнения и запустить ее. Флаги запуска определяют, какой сборщик мусора (GC) используется (параллельный или серверный), будем ли мы использовать один или несколько доменов приложений и какая используется политика оптимизации загрузчика (для нейтральной к доменам загрузки сборок).

[!code-cpp[NetCoreHost#4](../../../samples/core/hosting/host.cpp#4)]

Среда выполнения запускается с помощью вызова функции `Start`.

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a>Шаг 5. Параметры подготовки домена приложения
После запуска среды выполнения нужно настроить домен приложения. Существует ряд параметров, которые требуется указать при создании домена приложения .NET, но сначала их нужно подготовить.

Флаги домена приложения указывают его поведение, связанное с безопасностью и взаимодействием. Более старые основные приложения Silverlight использовали эти параметры для выполнения пользовательского кода в "песочнице", но большинство современных основных приложений .NET Core выполняет пользовательский код с полным доверием и допускает взаимодействие.

[!code-cpp[NetCoreHost#5](../../../samples/core/hosting/host.cpp#5)]

Определив используемые флаги домена приложения, следует задать его свойства. Они представляют собой пары строк "ключ-значение". Многие свойства определят, как домен приложения загружает сборки.

К распространенным свойствам домена приложения относятся следующие:

* `TRUSTED_PLATFORM_ASSEMBLIES` Это список путей сборки (с разделителями ";" в Windows и ":" в Unix), которому домен приложения должен предоставлять приоритет при загрузке и назначать полное доверие (даже в частично доверенных доменах). Этот список предназначен для хранения сборок "Framework" и других доверенных модулей аналогично глобальному кэшу сборок в сценариях .NET Framework. Некоторые основные приложения помещают все библиотеки рядом с *coreclr.dll* в этом списке, другие имеют жестко заданные манифесты, где перечислены нужные доверенные сборки.
* `APP_PATHS` Это список путей для поиска сборки, когда ее не удается найти в списке доверенных платформенных сборок (TPA). Эти пути описывают расположения, где можно найти пользовательские сборки. В изолированном домене приложения сборки, загруженные из этих путей, получают лишь частичное доверие. Стандартные пути APP_PATH включают в себя путь откуда было загружено целевое приложение, а также другие расположения, где могут находиться активы пользователей.
*  `APP_NI_PATHS` Этот список очень похож на APP_PATHS, за исключением того, что он обозначает пути для поиска образов в машинном коде.
*  `NATIVE_DLL_SEARCH_DIRECTORIES` Это свойство представляет собой список путей, по которым загрузчик ищет собственные библиотеки DLL, вызываемые через p/invoke.
*  `PLATFORM_RESOURCE_ROOTS` Этот список содержит пути для поиска вспомогательных сборок ресурсов (в подкаталогах для конкретных языков и региональных параметров).
*  `AppDomainCompatSwitch` Эта строка указывает, какие аспекты совместимости следует использовать для сборок без явного моникера целевой платформы (атрибут уровня сборки, показывающий, для какой платформы предназначена сборка). В общем случае здесь следует установить значение `"UseLatestBehaviorWhenTFMNotSpecified"`, но некоторым основным приложениям могут потребоваться более старые аспекты совместимости с Silverlight или Windows Phone.

В нашем [простом примере основного приложения](https://github.com/dotnet/docs/tree/master/samples/core/hosting) эти свойства настроены следующим образом:

[!code-cpp[NetCoreHost#6](../../../samples/core/hosting/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a>Шаг 6. Создание домена приложения
После подготовки всех свойств и флагов домена приложения можно воспользоваться `ICLRRuntimeHost2::CreateAppDomainWithManager` для настройки домена приложения. При необходимости эта функция принимает полное имя сборки и имя типа, используемые в качестве диспетчера домена приложения. Диспетчер домена приложения может позволить основному приложению управлять некоторыми аспектами поведения домена приложения и предоставлять точки входа для запуска управляемого кода, если основное приложение не предназначено для вызова пользовательского кода напрямую.   

[!code-cpp[NetCoreHost#7](../../../samples/core/hosting/host.cpp#7)]

### <a name="step-7---run-managed-code"></a>Шаг 7. Выполнение управляемого кода
Запустив домен приложения, основное приложение может приступить в выполнению управляемого кода. Для этого проще всего использовать `ICLRRuntimeHost2::ExecuteAssembly`, чтобы вызвать метод точки входа управляемой сборки. Обратите внимание, что эта функция работает только в сценариях с одним доменом.

[!code-cpp[NetCoreHost#8](../../../samples/core/hosting/host.cpp#8)]

Если `ExecuteAssembly` не соответствует потребностям вашего основного приложения, можно использовать `CreateDelegate`, чтобы создать указатель функции в статическом управляемом методе. При этом основному приложению нужно знать сигнатуру вызываемого метода (чтобы создать тип указателя функции), но основные приложения способны гибко вызывать код, отличный от точки входа сборки.

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
  domainId,
  L"HW, Version=1.0.0.0, Culture=neutral",  // Target managed assembly
  L"ConsoleApplication.Program",            // Target managed type
  L"Main",                                  // Target entry point (static method)
  (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a>Шаг 8. Очистка
Наконец, основное приложение должно выполнить очистку, выгрузив домены приложений, остановив среду выполнения и освободив ссылку `ICLRRuntimeHost2`.

[!code-cpp[NetCoreHost#9](../../../samples/core/hosting/host.cpp#9)]

## <a name="about-hosting-net-core-on-unix"></a>Размещение .NET Core в Unix
.NET Core — это кроссплатформенный продукт, работающий в операционных системах Windows, Linux и Mac. Но, как и собственные приложения, основные приложения для разных платформ будут несколько отличаться. Описанный выше процесс использования `ICLRRuntimeHost2` для запуска среды выполнения, создания домена приложения и выполнения управляемого кода должен работать в любой поддерживаемой операционной системе. Но в платформах Unix работа с интерфейсами, определенными в mscoree.h, может быть затруднена, так как mscoree сделало много предположений, ориентированных на Win32.

Чтобы упростить размещение на платформах Unix, в [coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) предоставлен набор дополнительных оболочек API размещения, которые менее зависимы от платформы.

Пример использования coreclrhost.h (вместо прямого указания mscoree.h) можно просмотреть в [основном приложении UnixCoreRun](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts). Процедура использования API из coreclrhost.h для размещения среды выполнения аналогична действиям для mscoree.h:

1. Определите выполняемый управляемый код (например, по параметрам командной строки). 
2. Загрузите библиотеку CoreCLR.
    1. `dlopen("./libcoreclr.so", RTLD_NOW | RTLD_LOCAL);` 
3. Получите указатели функций `coreclr_initialize`, `coreclr_create_delegate`, `coreclr_execute_assembly` и `coreclr_shutdown` в CoreCLR, используя `dlsym`.
    1. `coreclr_initialize_ptr coreclr_initialize = (coreclr_initialize_ptr)dlsym(coreclrLib, "coreclr_initialize");`
4. Настройте свойства домена приложения (например, список доверенных платформенных сборок). Этот процесс аналогичен шагу 5 из описанной выше процедуры для mscoree.
5. Используйте `coreclr_initialize` для запуска среды выполнения и создания домена приложения. При этом также создается указатель `hostHandle`, который будет использоваться в будущих вызовах размещения.
    1. Обратите внимание, что эта функция выполняет роль шагов 4 и 6 из предыдущей процедуры. 
6. Используйте `coreclr_execute_assembly` или `coreclr_create_delegate` для выполнения управляемого кода. Эти функции являются аналогами функций `ExecuteAssembly` и `CreateDelegate` в mscoree из шага 7 предыдущей процедуры.
7. Используйте `coreclr_shutdown`, чтобы выгрузить домен приложения и завершить работу среды выполнения. 

## <a name="conclusion"></a>Заключение
После создания основного приложения его можно проверить, запустив из командной строки и передав любые аргументы (например, запускаемое управляемое приложение), которые оно ожидает. При указании запускаемого приложения .NET Core для основного приложения обязательно используйте библиотеку DLL, созданную `dotnet build`. Исполняемые файлы, созданные `dotnet publish` для автономных приложений, фактически являются основным приложением .NET Core по умолчанию (таким образом, в ключевых сценариях приложение можно запустить непосредственно из командной строки); пользовательский код компилируется в DLL-файл с тем же именем. 

Если изначально что-то работает неправильно, еще раз проверьте, что *coreclr.dll* находится в расположении, ожидаемом основным приложением, все необходимые библиотеки Framework включены в список доверенных платформенных сборок, а разрядность CoreCLR (32- или 64-разрядная версия) соответствует сборке основного приложения.

Размещение среды выполнения .NET Core — это расширенный сценарий, который многие разработчики не используют. Но он может сильно пригодиться тем, кому нужно запускать управляемый код из собственного процесса либо требуется расширенный контроль над поведением среды выполнения .NET Core. Так как среда .NET Core может выполняться параллельно с самой собой, можно даже создать основные приложения, которые инициализируют и запускают несколько версий среды выполнения .NET Core и выполняют в них приложения в рамках одного процесса. 

