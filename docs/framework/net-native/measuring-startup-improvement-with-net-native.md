---
title: "Измерение улучшения запуска с машинным кодом .NET | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: c4d25b24-9c1a-4b3e-9705-97ba0d6c0289
caps.latest.revision: 7
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 7
---
# Измерение улучшения запуска с машинным кодом .NET
[!INCLUDE[net_native](../../../includes/net-native-md.md)]значительно сокращает время запуска приложений.  Это улучшение особенно заметно на портативных устройствах малой мощности, а также при сложных приложениях.  Этот раздел поможет вам приступить к работе с основным инструментарием, который необходим для измерения данного улучшения запуска.  
  
 Для облегчения анализа производительности, платформа.NET Framework и Windows используют платформу трассировки событий для Windows \(ETW\), которая позволяет приложениям уведомлять средства для работы при возникновении событий.  Затем можно использовать инструмент PerfView для просмотра и анализа событий ЕТW.  В этом разделе объясняется, как:  
  
-   Использовать класс <xref:System.Diagnostics.Tracing.EventSource> для порождения событий.  
  
-   Использовать PerfView для сбора событий.  
  
-   Использовать PerfView для отображения событий.  
  
## Использование EventSource для порождения событий  
 <xref:System.Diagnostics.Tracing.EventSource>предоставляет базовый класс для создания настраиваемого поставщика событий.  Как правило, создается подкласс <xref:System.Diagnostics.Tracing.EventSource> и методы `Write*` помещаются в оболочку с вашими собственными методами событий.  Обычно используется единый шаблон для каждого <xref:System.Diagnostics.Tracing.EventSource>.  
  
 Например, в следующем примере класс может использоваться для измерения двух характеристик производительности:  
  
-   времени до вызова конструктора класса `App`.  
  
-   времени до вызова конструктора класса `MainPage`.  
  
 [!code-csharp[ProjectN_ETW#1](../../../samples/snippets/csharp/VS_Snippets_CLR/projectn_etw/cs/etw1.cs#1)]  
  
 Здесь необходимо обратить внимание на несколько моментов.  Во\-первых, создается единственный элемент в `AppEventSource.Log`.  Этот экземпляр будет использоваться для ведения журналов.  Во\-вторых, каждый метод событий имеет <xref:System.Diagnostics.Tracing.EventAttribute>.  Это позволяет средствам для работы связать индекс метода <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> с методом, который был вызван на `AppEventSource`.  
  
 Обратите внимание, что эти события являются чисто иллюстративными.  Большая часть кода приложения будет выполняться после этих событий.  Следует понимать, какие события в коде соответствуют взаимодействию с пользователем, измерять их и улучшить их показатели.  Кроме того, сами события заносят в журнал только один экземпляр за все время.  Часто бывает полезно иметь пару начала и окончания событий для каждой операции.  При проверке запуска приложения, событием запуска, как правило, становится событие «Process\/Start» \(Начало процесса\), которое порождает операционная система.  
  
 Например, предположим, что создается программа чтения RSS\-каналов.  Несколько интересных мест для занесения событий в журнал:  
  
-   При первом отображении главной страницы.  
  
-   При десериализации старой истории RSS из локального хранилища.  
  
-   Когда приложение начинает синхронизацию новых историй.  
  
-   Когда приложение завершило синхронизацию новых историй.  
  
 Инструментировать приложения очень просто: достаточно вызвать соответствующий метод в производном классе.  С помощью `AppEventSource` из предыдущего примера можно инструментировать приложение следующим образом:  
  
 [!code-csharp[ProjectN_ETW#2](../../../samples/snippets/csharp/VS_Snippets_CLR/projectn_etw/cs/etw2.cs#2)]  
  
 После инструментирования приложения можно приступить к сбору событий.  
  
## Сбор событий с PerfView  
 PerfView использует события ЕТW для облегчения выполнения всех видов анализа производительности приложения.  Это средство также содержит графический интерфейс настройки, который позволяет включать и выключать ведение журнала для различных типов событий.  PerfView — это бесплатное средство, которое можно загрузить из [центра загрузки Майкрософт](http://www.microsoft.com/download/details.aspx?id=28567).  Для получения дополнительных сведений просмотрите [видео\-учебники PerfView](http://channel9.msdn.com/Series/PerfView-Tutorial).  
  
> [!NOTE]
>  PerfView не может использоваться для сбора событий в системах ARM.  Для сбора событий в системах ARM, используйте средство записи производительности Windows \(WPR\).  Дополнительные сведения см. в [записях блога Вэнс Моррисон \(Vance Morrison\)](http://blogs.msdn.com/b/vancem/archive/2012/12/19/collecting-etw-perfview-data-on-an-windows-rt-winrt-arm-surface-device.aspx).  
  
 PerfView также можно вызвать из командной строки.  Чтобы занести в журнал только события своего поставщика, откройте окно командной строки и введите команду:  
  
```  
perfview -KernelEvents:Process -OnlyProviders:*MyCompany-MyApp collect outputFile   
```  
  
 Здесь:  
  
 `-KernelEvents:Process`  
 Указывает, что вам необходимо знать, когда процесс запускается и останавливается.  Для приложения необходимо событие Process\/Start, чтобы оно могло быть вычтено из времени других событий.  
  
 `-OnlyProviders:*MyCompany-MyApp`  
 Отключает других поставщиков, которые PerfView включает по умолчанию и включает поставщика MyCompany MyApp.  \(Звездочка означает, что это <xref:System.Diagnostics.Tracing.EventSource>.\)  
  
 `collect outputFile`  
 Указывает, что необходимо начать сбор и сохранение данных outputFile.etl.zip.  
  
 Выполнение приложения после запуска PerfView.  Есть несколько моментов, которые необходимо помнить при запуске приложения.  
  
-   Используйте построение выпуска, а не отладочное построение.  Отладочные построения часто содержат проверку дополнительных ошибок и ошибок обработки кода, в результате чего приложение будет работать медленнее, чем ожидалось.  
  
-   Выполнение приложений с подключенным отладчиком влияет на  его производительность.  
  
-   Windows использует несколько стратегий кэширования, чтобы ускорить время запуска приложения.  Если ваше приложение кэшировано в памяти и его не нужно загружать с диска, оно запускается быстрее.  Для обеспечения согласованности, запустите и закройте приложение несколько раз перед его измерением.  
  
 После выполнения приложения таким образом, чтобы PerfView могло собрать порожденные события, нажмите кнопку **Stop Collection** \(Остановить сбор\).  Как правило, следует остановить сбор перед закрытием приложения, чтобы не получить посторонних событий.  Тем не менее, если измеряется быстродействия завершения работы или приостановки, будет необходимо продолжить сбор.  
  
## Отображение событий  
 Чтобы просмотреть уже собранные события, используйте PerfView для открытия созданных файлов .etl или. etl.zip и нажмите кнопку **Events** \(События\).  К этому моменту ETW уже соберет информацию о большом количестве событий, в том числе о событиях из других процессов.  Чтобы сузить ваш анализ на определенных измерениях, заполните следующие текстовые поля в представлении событий:  
  
-   В поле **Process Filter** \(Фильтр процесса\) укажите имя приложения \(без ".exe"\).  
  
-   В поле **Event Types Filter** \(Фильтр типов событий\) укажите `Process/Start | MyCompany-MyApp`.  Это задает фильтр событий из MyCompany MyApp и события Windows Kernel\/Process\/Start \(Ядро\/процесс\/запуск\).  
  
 Выберите все события, перечисленные в левой панели \(Ctrl \+ A\), и нажмите клавишу **Ввод**.  Теперь можно будет видеть метки времени каждого события.  Эти метки времени измеряются относительно начала трассировки, поэтому следует вычесть время каждого события из времени запуска процесса, чтобы определить время, прошедшее с момента запуска.  При использовании Ctrl \+ щелчок для выбора двух меток времени, вы увидите, что разница между ними отображается в строке состояния в нижней части страницы.  Это позволяет легко увидеть время, прошедшее между любыми двумя событиями, на экране \(включая запуск процесса\).  Можно открыть контекстное меню представления и выбрать различные полезные параметры, например, экспорт в файлы CSV или открытие Microsoft Excel для сохранения или обработки данных.  
  
 Повторяя процедуры для исходного приложения и версии, построенных с использованием цепочки инструментов [!INCLUDE[net_native](../../../includes/net-native-md.md)], можно сравнить разницу в производительности.  Приложения, построенные с использованием[!INCLUDE[net_native](../../../includes/net-native-md.md)], обычно запускаются быстрее, сем приложения, построенные без использования [!INCLUDE[net_native](../../../includes/net-native-md.md)].  Если вы заинтересованы в более глубокой информации, то PerfView также может определить части кода, на выполнение которых уходит больше всего времени.  Для получения дополнительной информации просмотрите [Учебники по PerfViews](http://channel9.msdn.com/Series/PerfView-Tutorial) или прочтите [запись блога Вэнс Моррисон](http://blogs.msdn.com/b/vancem/archive/2011/12/28/publication-of-the-perfview-performance-analysis-tool.aspx).  
  
## См. также  
 <xref:System.Diagnostics.Tracing.EventSource>