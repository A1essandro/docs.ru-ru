---
title: "Адреса конечных точек | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "адреса [WCF]"
  - "WCF [WCF], адреса"
  - "Windows Communication Foundation [WCF], адреса"
ms.assetid: 13f269e3-ebb1-433c-86cf-54fbd866a627
caps.latest.revision: 18
author: "Erikre"
ms.author: "erikre"
manager: "erikre"
caps.handback.revision: 18
---
# Адреса конечных точек
С каждой конечной точкой связан адрес, который используется для поиска и идентификации этой конечной точки.Этот адрес в первую очередь включает универсальный код ресурса \(URI\), задающий расположение конечной точки.Адрес конечной точки представляется в модели программирования [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] классом <xref:System.ServiceModel.EndpointAddress>, который содержит необязательное свойство <xref:System.ServiceModel.EndpointAddress.Identity%2A>, включающее проверку подлинности конечной точки другими конечными точками, с которыми она обменивается сообщениями, а также набор необязательных свойств <xref:System.ServiceModel.EndpointAddress.Headers%2A>, задающих другие заголовки SOAP, необходимые для получения доступа к службе.Необязательные заголовки содержат дополнительную и более подробную информацию для идентификации конечной точки службы и взаимодействия с ней.При передаче данных по каналам связи адрес конечной точки представляется ссылкой на конечную точку WS\-Addressing.  
  
## Структура универсального кода ресурса \(URI\) адреса  
 Универсальный код ресурса \(URI\) для большинства видов транспорта состоит из четырех частей.Например, код http:\/\/www.fabrikam.com:322\/mathservice.svc\/secureEndpoint можно разбить на части следующим образом.  
  
-   Схема: http:  
  
-   Компьютер: www.fabrikam.com  
  
-   \(необязательно\) Порт: 322  
  
-   Путь: \/mathservice.svc\/secureEndpoint  
  
## Определение адреса службы  
 Адрес конечной точки службы можно задать императивно с помощью кода или декларативно с помощью конфигурации.Определение конечных точек в коде обычно бывает непрактичным, поскольку привязки и адреса для развернутой службы чаще всего отличаются от привязок и адресов, используемых в процессе разработки службы.Обычно более целесообразно задать конечные точки службы в конфигурации, а не в коде.Если не указывать привязку и адрес в коде, их можно изменять, не выполняя повторную компиляцию или повторное развертывание приложения.  
  
### Определение адреса в файле конфигурации  
 Чтобы определить конечную точку в файле конфигурации, следует использовать элемент [\<конечная точка\>](../../../../docs/framework/configure-apps/file-schema/wcf/endpoint-element.md).Дополнительные сведения и пример см. в разделе [Задание адреса конечной точки](../../../../docs/framework/wcf/specifying-an-endpoint-address.md).  
  
### Определение адреса в коде  
 Адрес конечной точки можно создать в коде с помощью класса <xref:System.ServiceModel.EndpointAddress>.Дополнительные сведения и пример см. в разделе [Задание адреса конечной точки](../../../../docs/framework/wcf/specifying-an-endpoint-address.md).  
  
### Конечные точки на языке WSDL  
 Адрес конечной точки также может быть представлен на языке WSDL в виде элемента EPR WS\-Addressing в элементе `wsdl:port` соответствующей конечной точки.Элемент EPR содержит адрес конечной точки, а также все остальные свойства адреса.Дополнительные сведения и пример см. в разделе [Задание адреса конечной точки](../../../../docs/framework/wcf/specifying-an-endpoint-address.md).  
  
## Поддержка нескольких привязок служб IIS в платформе .NET Framework 3.5  
 Поставщики услуг Интернета часто размещают большое число приложений на одном сайте и сервере, чтобы повысить эффективность использования сайта и сократить совокупную стоимость владения.Эти приложения обычно привязываются к различным базовым адресам.Веб\-сайт служб IIS может содержать несколько приложений.Доступ к приложениям на сайте может осуществляться через одну или несколько привязок служб IIS.  
  
 Привязки IIS предоставляют два блока данных: протокол привязки и данные привязки.Протокол привязки определяет схему, посредством которой осуществляется связь, а данные привязки содержат сведения, используемые для доступа к сайту.  
  
 Ниже приведен пример элементов, которые могут присутствовать в привязке IIS.  
  
-   Протокол привязки: HTTP  
  
-   Данные привязки: IP\-адрес, порт, заголовок узла  
  
 Службы IIS поддерживают задание нескольких привязок для каждого сайта, что позволяет использовать несколько базовых адресов для каждой схемы.До появления [!INCLUDE[netfx35_short](../../../../includes/netfx35-short-md.md)] платформа [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] не поддерживала использование нескольких адресов для одной схемы, и, если они были заданы, во время активации создавалось исключение <xref:System.ArgumentException>.  
  
 [!INCLUDE[netfx35_short](../../../../includes/netfx35-short-md.md)] позволяет поставщикам услуг Интернета размещать на одном сайте несколько приложений с различными базовыми адресами в рамках одной схемы.  
  
 Например, сайт может содержать следующие базовые адреса:  
  
-   http:\/\/payroll.myorg.com\/Service.svc  
  
-   http:\/\/shipping.myorg.com\/Service.svc  
  
 Платформа [!INCLUDE[netfx35_short](../../../../includes/netfx35-short-md.md)] позволяет задать в файле конфигурации фильтр префикса на уровне домена приложения.Для этого следует воспользоваться элементом [\<baseAddressPrefixFilters\>](../../../../docs/framework/configure-apps/file-schema/wcf/baseaddressprefixfilters.md), который содержит список префиксов.Входящие базовые адреса, предоставляемые службами IIS, фильтруются с использованием необязательно списка префиксов.Если префикс не задан, по умолчанию пропускаются все адреса.При задании префикса разрешается прохождение данных только с соответствующего базового адреса для данной схемы.  
  
 Ниже приведен пример кода конфигурации, в котором используются фильтры префиксов.  
  
```  
<system.serviceModel>  
  <serviceHostingEnvironment>  
     <baseAddressPrefixFilters>  
        <add prefix="net.tcp://payroll.myorg.com:8000"/>  
        <add prefix="http://shipping.myorg.com:8000"/>  
    </baseAddressPrefixFilters>  
  </serviceHostingEnvironment>  
</system.serviceModel>  
```  
  
 В приведенном выше примере net.tcp:\/\/payroll.myorg.com:8000 и http:\/\/shipping.myorg.com:8000 являются единственными базовыми адресами для соответствующих схем, которые будут пропущены.  
  
 Элемент `baseAddressPrefixFilter` не поддерживает подстановочные знаки.  
  
 Среди базовых адресов, предоставляемых службами IIS, могут присутствовать адреса, привязанные к другим схемам, не представленным в списке `baseAddressPrefixFilters`.Эти адреса не отфильтровываются.  
  
## Поддержка нескольких привязок служб IIS в платформе .NET Framework 4 и более поздней  
 Начиная с .NET 4, в службах IIS можно включить поддержку нескольких привязок, при этом не требуется выбирать один базовый адрес. Для этого атрибуту <xref:System.ServiceModel.ServiceHostingEnvironment.MultipleSiteBindingsEnabled%2A> элемента <xref:System.ServiceModel.ServiceHostingEnvironment> необходимо задать значение true.Эта поддержка обеспечивается только для схем протокола HTTP.  
  
 Ниже приведен пример кода конфигурации, в котором используется атрибут multipleSiteBindingsEnabled элемента [\<serviceHostingEnvironment\>](../../../../docs/framework/configure-apps/file-schema/wcf/servicehostingenvironment.md).  
  
```  
  
<system.serviceModel>  
  <serviceHostingEnvironment multipleSiteBindingsEnabled=”true” >  
  </serviceHostingEnvironment>  
</system.serviceModel>  
```  
  
 Если с помощью этого параметра включены несколько привязок к узлам, все параметры baseAddressPrefixFilters не учитываются как для протокола HTTP, так и для других протоколов.  
  
 Дополнительные сведения и примеры см. в разделах [Поддержка нескольких привязок узла IIS](../../../../docs/framework/wcf/feature-details/supporting-multiple-iis-site-bindings.md) и <xref:System.ServiceModel.ServiceHostingEnvironment.MultipleSiteBindingsEnabled%2A>.  
  
## Расширение модели адресов в службах WCF  
 Модель адресов служб [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] по умолчанию использует коды URI адресов конечных точек для следующих целей:  
  
-   задание адреса ожидания передачи данных службы, т. е. расположения, по которому конечная точка ожидает сообщений;  
  
-   задание фильтра адресов SOAP, т. е. адреса, ожидаемого конечной точкой в качестве заголовка SOAP.  
  
 Значения в каждом из этих случаев могут задаваться отдельно, что позволяет реализовать несколько расширений модели адресов, которые можно использовать в следующих сценариях:  
  
-   посредники протокола SOAP: сообщение, отправляемое клиентом, проходит через одну или несколько дополнительных служб, обрабатывающих это сообщение, прежде чем оно достигнет конечной точки назначения.Посредники протокола SOAP могут выполнять с сообщениями различные задачи, например кэширование, маршрутизацию или проверку схемы.Этот сценарий также можно реализовать путем отправки сообщения по отдельному физическому адресу \(`via`\), нацеленному на посредник, а не просто по логическому адресу \(`wsa:To`\), который нацелен на конечную точку назначения;  
  
-   адрес ожидания передачи данных конечной точки является закрытым универсальным кодом ресурса \(URI\) и имеет значение, отличное от значения свойства `listenURI`.  
  
 Адрес транспорта, задаваемый параметром `via`, определяет расположение, через которое сообщение должно предварительно пройти по пути на какой\-либо другой удаленный адрес, задаваемый параметром `to` и определяющий расположение службы.В большинстве случаев работы через Интернет значение универсального кода ресурса \(URI\) `via` совпадает со значением свойства <xref:System.ServiceModel.EndpointAddress.Uri%2A> конечного адреса `to` службы.При осуществлении маршрутизации вручную приходится выбирать только между этими двумя адресами.  
  
### Заголовки адресов  
 Помимо базового универсального кода ресурса \(URI\) к конечной точке можно обратиться по одному или нескольким заголовкам SOAP.К сценариям, в которых это бывает удобно, относятся сценарии с посредниками протокола SOAP, в которых конечная точка требует, чтобы клиенты включали заголовки SOAP, нацеленные на посредники.  
  
 Пользовательские заголовки адресов можно определять двумя способами — с помощью кода или файла конфигурации:  
  
-   в коде создайте пользовательские заголовки адреса с помощью класса <xref:System.ServiceModel.Channels.AddressHeader>, а затем используйте их в конструкторе класса <xref:System.ServiceModel.EndpointAddress>;  
  
-   в файле конфигурации пользовательские значения [\<верхние колонтитулы\>](../../../../docs/framework/configure-apps/file-schema/wcf/headers.md)[\<endpoint\> задаются в качестве дочерних элементов элемента](http://msdn.microsoft.com/ru-ru/13aa23b7-2f08-4add-8dbf-a99f8127c017).  
  
 Обычно рекомендуется использовать не код, а файл конфигурации, поскольку в этом случае заголовки можно будет менять после развертывания.  
  
### Пользовательские адреса ожидания передачи данных  
 Можно задать адрес ожидания передачи данных, который отличается от универсального кода ресурса \(URI\) конечной точки.Это бывает удобно в сценариях с посредниками, когда предоставляемый адрес SOAP является адресом открытого посредника протокола SOAP, а адрес, по которому конечная точка ожидает передачи данных, является закрытым сетевым адресом.  
  
 Пользовательский адрес ожидания передачи данных можно задать с помощью кода или файла конфигурации:  
  
-   для задания пользовательского адреса ожидания передачи данных в коде необходимо добавить класс <xref:System.ServiceModel.Description.ClientViaBehavior> в коллекцию расширений функциональности конечной точки;  
  
-   в файле конфигурации необходимо задать пользовательский адрес ожидания передачи данных в атрибуте `ListenUri` элемента [\<endpoint\>](http://msdn.microsoft.com/ru-ru/13aa23b7-2f08-4add-8dbf-a99f8127c017) службы.  
  
### Пользовательский фильтр адресов SOAP  
 Свойство <xref:System.ServiceModel.EndpointAddress.Uri%2A> в сочетании со свойством <xref:System.ServiceModel.EndpointAddress.Headers%2A> позволяет определить фильтр адресов SOAP конечной точки \(<xref:System.ServiceModel.Dispatcher.EndpointDispatcher.AddressFilter%2A>\).По умолчанию этот фильтр проверяет, что заголовок `To` входящего сообщения совпадает с универсальным кодом ресурса \(URI\) конечной точки и что в сообщении имеются все обязательные заголовки конечной точки.  
  
 В некоторых сценариях конечная точка получает все сообщения, которые приходят через соответствующий транспорт, а не только те, у которых есть соответствующий заголовок `To`.Чтобы включить такой режим, можно воспользоваться классом <xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter>.  
  
## См. также  
 [Задание адреса конечной точки](../../../../docs/framework/wcf/specifying-an-endpoint-address.md)   
 [Идентификация и проверка подлинности службы](../../../../docs/framework/wcf/feature-details/service-identity-and-authentication.md)