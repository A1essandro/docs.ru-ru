---
title: "Изолированная сериализация JSON | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
caps.latest.revision: 32
author: "Erikre"
ms.author: "erikre"
manager: "erikre"
caps.handback.revision: 32
---
# Изолированная сериализация JSON
JSON \(JavaScript Object Notation, объектная нотация JavaScript\) — формат данных, предназначенный специально для использования JavaScript\-кодом, выполняемым на веб\-страницах внутри браузера.Этот формат данных используется по умолчанию в службах ASP.NET AJAX, созданных в [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].  
  
 Его также можно использовать при создании служб AJAX без интеграции с ASP.NET; в данном случае форматом по умолчанию является XML, однако можно выбрать и JSON.  
  
 Наконец, если требуется поддержка JSON, однако создаваемая служба не является службой AJAX, сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> позволяет непосредственно сериализовать объекты .NET в данные JSON и десериализовать такие данные обратно в экземпляры типов .NET.О том, как это сделать, см. в разделе [Как сериализовать и десериализовать данные JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).  
  
 При работе с JSON поддерживаются те же \(за некоторыми исключениями\) типы .NET, что поддерживаются сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>.Список поддерживаемых типов см. в разделе [Типы, поддерживаемые сериализатором контракта данных](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).К ним относится большинство примитивных типов, большинство типов массивов и коллекций, а также сложные типы, в которых используются атрибуты <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute>.  
  
## Сопоставление типов .NET типам JSON  
 В следующей таблице показано соответствие между типами .NET и типами JSON\/JavaScript, которое используется при сопоставлении в процедурах сериализации и десериализации.  
  
|Типы .NET|JSON\/JavaScript|Примечания|  
|---------------|----------------------|----------------|  
|Все числовые типы, например <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double>|Number|Специальные значения, такие как `Double.NaN`, `Double.PositiveInfinity` и `Double.NegativeInfinity`, не поддерживаются и приводят к получению недопустимых JSON\-данных.|  
|<xref:System.Enum>|Number|См. раздел «Перечисления и JSON» ниже.|  
|<xref:System.Boolean>|Boolean|\-\-|  
|<xref:System.String>, <xref:System.Char>|Строка|\-\-|  
|<xref:System.Timespan>, <xref:System.Guid>, <xref:System.Uri>|Строка|Формат этих типов в JSON идентичен формату в XML \(а именно: TimeSpan имеет формат длительности, описанный в ISO 8601, GUID имеет формат «12345678\-ABCD\-ABCD\-ABCD\-1234567890AB», а URI представляется в форме исходной строки, например «http:\/\/www.example.com»\).Точные сведения см. в разделе [Справочник по схеме контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).|  
|<xref:System.Xml.XmlQualifiedName>|String|Формат — «имя:пространство\_имен» \(все до первого двоеточия является именем\).Имя или пространство имен может отсутствовать.При отсутствии пространства имен можно также опустить двоеточие.|  
|<xref:System.Array> типа <xref:System.Byte>|Массив чисел|Каждое число представляет значение одного байта.|  
|<xref:System.Datetime>|DateTime или String|См. раздел «Даты\-времена и JSON» ниже.|  
|<xref:System.DatetimeOffset>|Сложный тип|См. раздел «Даты\-времена и JSON» ниже.|  
|Типы XML и ADO.NET \(<xref:System.Xml.XmlElement>,<br /><br /> <xref:System.Xml.Linq.XElement>.Массивы <xref:System.Xml.XmlNode>,<br /><br /> <xref:System.Runtime.Serialization.ISerializable>,<br /><br /> <xref:System.Data.DataSet>\).|Строка|См. раздел «Типы XML и JSON» ниже.|  
|<xref:System.DBNull>|Пустой сложный тип|\-\-|  
|Коллекции, словари и массивы|Array|См. раздел «Коллекции, словари и массивы» ниже.|  
|Сложные типы \(с примененным атрибутом <xref:System.Runtime.Serialization.DataContractAttribute> или <xref:System.SerializableAttribute>\)|Сложный тип|Члены данных становятся членами сложного типа JavaScript.|  
|Сложные типы \(реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>\)|Сложный тип|Сопоставляется аналогично другим сложным типам, однако некоторые типы <xref:System.Runtime.Serialization.ISerializable> не поддерживаются; см. раздел «Поддержка интерфейса ISerializable» ниже, в разделе «Дополнительные сведения для опытных пользователей».|  
|Значение `Null` для любого типа|Null|Типы, допускающие значение null, также поддерживаются и сопоставляются с JSON так же, как и типы, не допускающие значение null.|  
  
### Перечисления и JSON  
 Значения членов перечислений в JSON рассматриваются как числа, в отличие от контрактов данных, куда они включаются как имена членов.[!INCLUDE[crabout](../../../../includes/crabout-md.md)] об интерпретации контрактов данных см. в разделе [Типы перечислений в контрактах данных](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).  
  
-   Например, в случае перечисления `public enum Color {red, green, blue, yellow, pink}` при сериализации члена `yellow` получается число 3, а не строка "yellow".  
  
-   Все члены типа `enum` сериализуемы.Атрибуты <xref:System.Runtime.Serialization.EnumMemberAttribute> и <xref:System.NonSerializedAttribute> \(если они используются\) игнорируются.  
  
-   Также возможна десериализация несуществующего значения `enum` — например, значение 87 можно десериализовать в упомянутое выше перечисление Color, даже несмотря на отсутствие соответствующего определенного имени цвета.  
  
-   Флаговый тип `enum` не является особенным и рассматривается так же, как любой другой тип `enum`.  
  
### Даты\-времена и JSON  
 Формат JSON не предусматривает непосредственной поддержки дат и времен.Тем не менее, они очень часто используются, и в ASP.NET AJAX предусмотрена особая поддержка для этих типов.При использовании прокси\-объектов ASP.NET AJAX тип <xref:System.DateTime> в .NET полностью соответствует типу `DateTime` в JavaScript.  
  
-   Если ASP.NET не используется, тип <xref:System.DateTime> представляется в JSON в виде строки особого формата, который описан в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
-   <xref:System.DateTimeOffset> представляется в JSON как сложный тип: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.Член `offsetMinutes` — это смещение местного времени относительно времени по Гринвичу \(GMT, теперь также называемого временем в формате UTC\), связанное с местоположением интересующего события.Член `dateTime` представляет момент времени, когда произошло интересующее событие \(этот член тоже становится типом `DateTime` в JavaScript, когда используется ASP.NET AJAX, либо строкой, когда ASP.NET AJAX не используется\).При сериализации член `dateTime` всегда сериализуется в GMT.Так, если описывается время 3:00 по Нью\-Йорку, компонентом времени члена `dateTime` будет "8:00", а смещение в минутах `offsetMinutes` составит 300 \(минус 300 минут, или 5 часов, относительно GMT\).  
  
    > [!NOTE]
    >  В объектах <xref:System.DateTime> и <xref:System.DateTimeOffset> при сериализации в JSON информация сохраняется с точностью только до миллисекунд.Значения меньше миллисекунды \(микро\- и наносекунды\) при сериализации теряются.  
  
### Типы XML и JSON  
 Типы XML становятся строками JSON.  
  
-   Например, если элемент данных "q" типа XElement содержит \<abc\/\>, соответствующий фрагмент JSON будет иметь вид {"q":"\<abc\/\>"}.  
  
-   Существуют некоторые особые правила, определяющие, как XML\-данные заключаются в оболочку; более подробные сведения см. в разделе «Дополнительные сведения для опытных пользователей» ниже.  
  
-   Если при использовании ASP.NET AJAX вместо строк JavaScript необходимо использование модели DOM XML, присвойте значение «XML» свойству <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebGetAttribute> или свойству <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebInvokeAttribute>.  
  
### Коллекции, словари и массивы  
 Все коллекции, словари и массивы представляются в JSON в виде массивов.  
  
-   Все пользовательские типы с атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> в JSON\-представлении игнорируются.  
  
-   Словари не являются способом непосредственной работы с JSON.Словарь \<string,object\> может не поддерживаться так же, как в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], чего можно ожидать исходя из опыта работы с другими технологиями JSON.Например, если в словаре строка "abc" сопоставлена строке "xyz", а строка "def" строке 42, JSON\-представление будет иметь вид не {"abc":"xyz","def":42}, а \[{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}\].  
  
-   Если требуется работать непосредственно с JSON \(обращаться к ключам и значениям динамически, без предварительного определения жесткого контракта\), можно рассмотреть следующие варианты.  
  
    -   Использование примера [Сериализация слабо типизированных данных JSON \(AJAX\)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md).  
  
    -   Использование интерфейса <xref:System.Runtime.Serialization.ISerializable> и конструкторов десериализации — эти два механизма позволяют обращаться к парам "ключ\-значение" JSON при сериализации и десериализации соответственно, однако не работают в сценариях с частичным доверием.  
  
    -   Работа с [Сопоставление JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) вместо использования сериализатора.  
  
    -   Под *полиморфизмом* в контексте сериализации понимается возможность сериализовать производный тип там, где ожидается его базовый тип.Существуют особые \(только для JSON\) правила, применяющиеся при полиморфном использовании коллекций, например при присвоении коллекции объекту <xref:System.Object>.Этот вопрос более подробно рассмотрен в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
## Некоторые подробности  
  
### Порядок членов данных  
 Порядок членов данных при использовании JSON не имеет значения.В частности, даже если задан атрибут <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, JSON\-данные все равно можно сериализовать в любом порядке.  
  
### Типы JSON  
 Тип JSON при десериализации не обязательно должен соответствовать приведенной выше таблице.Например, тип `Int` обычно сопоставляется числу JSON, однако может быть успешно десериализован из строки JSON, при условии, что строка содержит допустимое число.То есть, и {"q":42}, и {"q":"42"} допустимы, если имеется член данных типа `Int` с именем "q".  
  
### Полиморфизм  
 Полиморфная сериализация состоит в возможности сериализовать производный тип там, где ожидается его базовый тип.Эта возможность поддерживается для сериализации JSON в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] аналогично тому, как поддерживается сериализация XML.Например, можно сериализовать тип `MyDerivedType` там, где ожидается тип `MyBaseType`, или сериализовать тип `Int` там, где ожидается тип `Object`.  
  
 При десериализации производного типа там, где ожидается базовый тип, информация типа может быть потеряна, за исключением случаев десериализации сложных типов.Например, при сериализации типа <xref:System.Uri> там, где ожидается тип <xref:System.Object>, будет получена строка JSON.Если эту строку затем десериализовать обратно в тип <xref:System.Object>, будет возвращен .NET\-тип <xref:System.String>.Десериализатор не знает, что строка изначально имела тип <xref:System.Uri>.Как правило, когда ожидается тип <xref:System.Object>, все строки JSON десериализуются как строки .NET, а все массивы JSON, используемые для сериализации коллекций, словарей и массивов .NET, десериализуются как .NET\-объекты <xref:System.Array> типа <xref:System.Object>, вне зависимости от того, какими были исходные типы.Логический тип JSON сопоставляется .NET\-типу <xref:System.Boolean>.Однако, когда ожидается тип <xref:System.Object>, числа JSON десериализуются в .NET\-типы <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double> \(наиболее подходящий тип выбирается автоматически\).  
  
 При десериализации в тип интерфейса <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> выполняет десериализацию так, как будто объявленный тип — объект.  
  
 При работе со своими собственными базовыми и производными типами обычно требуется использовать атрибуты <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> или эквивалентный механизм.Например, если имеется операция с возвращаемым значением типа `Animal` и эта операция на самом деле возвращает значение типа `Cat` \(наследуемого от типа `Animal`\), необходимо либо применить атрибут <xref:System.Runtime.Serialization.KnownTypeAttribute>, к типу `Animal`, либо применить атрибут <xref:System.ServiceModel.ServiceKnownTypeAttribute> к операции и задать в этих атрибутах тип `Cat`.Дополнительные сведения см. в разделе [Известные типы контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).  
  
 Подробное описание работы полиморфной сериализации и некоторых ограничений, которые необходимо принимать во внимание при ее использовании, см. в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
### Управление версиями  
 Функции управления версиями контрактов данных, включая интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>, полностью поддерживаются в JSON.Кроме того, в большинстве случаев можно десериализовать тип в один формат \(например, XML\) и затем сериализовать его в другой формат \(например, JSON\) и при этом сохранить данные в <xref:System.Runtime.Serialization.IExtensibleDataObject>.[!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Контракты данных, совместимые с любыми будущими изменениями](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).Следует помнить, что JSON не придает значения порядку, поэтому любая информация о порядке будет потеряна.Кроме того, JSON не поддерживает множественные пары "ключ\/значение" с одним и тем же именем ключа.Наконец, все операции над объектом <xref:System.Runtime.Serialization.IExtensibleDataObject> по своей природе полиморфны — то есть, их производные типы присваиваются типу <xref:System.Object>, базовому типу для всех типов.  
  
## JSON в URL\-адресах  
 При использовании конечных точек ASP.NET AJAX с командой GET HTTP \(с помощью атрибута <xref:System.ServiceModel.Web.WebGetAttribute>\), входящие параметры присутствуют в URL\-адресе запроса, а не в теле сообщения.JSON поддерживается даже в URL\-адресе запроса, поэтому в случае операции, принимающей тип `Int` с именем "number" и сложный тип `Person` с именем "p", URL\-адрес может выглядеть аналогично приведенному ниже.  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 При использовании диспетчера скриптов ASP.NET AJAX и прокси\-объекта для вызова службы этот URL\-адрес автоматически формируется прокси\-объектом, и увидеть его нельзя.JSON нельзя использовать в URL\-адресах на конечных точках, не являющихся конечными точками ASP.NET AJAX.  
  
## Дополнительные сведения для опытных пользователей  
  
### Поддержка интерфейса ISerializable  
  
#### Поддерживаемые и неподдерживаемые типы ISerializable  
 Как правило, типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>, полностью поддерживаются при сериализации\/десериализации JSON.Однако некоторые из этих типов \(включая некоторые типы платформы .NET Framework\) реализованы так, что некоторые аспекты, присущие именно сериализации в JSON, не позволяют им правильно десериализоваться:  
  
-   При использовании интерфейса <xref:System.Runtime.Serialization.ISerializable> тип отдельных членов данных никогда не известен заранее.Это ведет к полиморфной ситуации, аналогичной десериализации типов в объект.Как уже говорилось, это может привести к потере информации типов в JSON.Например, если тип сериализует в своей реализации <xref:System.Runtime.Serialization.ISerializable> тип `enum`, попытка десериализовать данные обратно в `enum` \(без надлежащих приведений\) завершится неудачей, поскольку тип `enum` сериализуется в JSON в виде чисел, а числа JSON десериализуются во встроенные числовые типы .NET \(Int32, Decimal или Double\).Поэтому тот факт, что число когда\-то было значением перечисления \(`enum`\), теряется.  
  
-   Тип с интерфейсом <xref:System.Runtime.Serialization.ISerializable>, конструктор десериализации которого основан на определенном порядке десериализации, также может выдать ошибку при десериализации некоторых JSON\-данных, поскольку большинство сериализаторов JSON не гарантируют никакого определенного порядка.  
  
#### Типы производства  
 В то время как интерфейс <xref:System.Runtime.Serialization.IObjectReference> в общем случае поддерживается в JSON, все типы, требующие возможности "типа производства" \(возвращения методом <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> экземпляра типа, отличного от типа, реализующего интерфейс\), не поддерживаются.  
  
### Формат DateTime при передаче по линиям связи  
 Значения типа <xref:System.DateTime> представляются строками JSON вида "\/Date\(700000\+0500\)\/", где первое число \(в данном случае 700000\) — это число миллисекунд в часовом поясе GMT по обычному \(не летнему\) времени, прошедшее с 1 января 1970 г.Это число может быть отрицательным для представления более раннего времени.Часть строки "\+0500" является необязательной и показывает, что это время в формате <xref:System.DateTimeKind>, т. е. при десериализации оно должно быть преобразовано в местный часовой пояс.Если эта часть строки отсутствует, время десериализуется как <xref:System.DateTimeKind>.Собственно число \(в данном случае "0500"\) и его знак \(\+ или \-\) игнорируются.  
  
 При сериализации времен формата <xref:System.DateTime>, <xref:System.DateTimeKind> и <xref:System.DateTimeKind> времена записываются со смещением, а время формата <xref:System.DateTimeKind> записывается без смещения.  
  
 JavaScript\-код клиента ASP.NET AJAX автоматически преобразует такие строки в экземпляры `DateTime` JavaScript.При наличии других строк аналогичного вида, не принадлежащих к типу <xref:System.DateTime> в .NET, они также преобразуются.  
  
 Преобразование происходит только при условии, что символы "\/" предваряются escape\-знаками \(т. е. JSON\-фрагмент выглядит так: "\\\/Date\(700000\+0500\)\\\/"\); по этой причине JSON\-кодировщик [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] \(реализуемый привязкой <xref:System.ServiceModel.WebHttpBinding>\) всегда предваряет символ "\/" escape\-знаком.  
  
### XML\-данные в строках JSON  
  
#### XmlElement  
 Тип <xref:System.Xml.XmlElement> сериализуется «как есть», без оболочки.Например, член данных "x" типа <xref:System.Xml.XmlElement>, содержащий \<abc\/\>, представляется следующим образом.  
  
```  
{"x":"<abc/>"}  
```  
  
#### Массивы типа XmlNode  
 Объекты <xref:System.Array> типа <xref:System.Xml.XmlNode> помещаются в элемент\-оболочку ArrayOfXmlNode в стандартном пространстве имен контракта данных для данного типа.Если "x" — массив, содержащий узел атрибута "N" в пространстве имен "ns", который содержит "value", и пустой узел элемента "M", представление выглядит следующим образом.  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 Атрибуты в пустом пространстве имен в начале массивов XmlNode \(перед другими элементами\) не поддерживаются.  
  
#### Типы IXmlSerializable, включая XElement и DataSet  
 Типы <xref:System.Runtime.Serialization.ISerializable> делятся на "типы содержимого", "типы DataSet" и "типы элементов".Определения этих типов см. в разделе [Типы XML и ADO.NET в контрактах данных](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).  
  
 Типы содержимого и типы "DataSet" сериализуются аналогично объектам <xref:System.Array> типа <xref:System.Xml.XmlNode>, рассмотренным в предыдущем разделе.Они помещаются в элемент\-оболочку, имя и пространство имен которого соответствует имени контракта данных и пространству имен сериализуемого типа.  
  
 Типы элементов, такие как <xref:System.Xml.Linq.XElement> сериализуются "как есть", аналогично рассмотренному выше типу <xref:System.Xml.XmlElement>.  
  
### Полиморфизм  
  
#### Сохранение информации типов  
 Как уже говорилось, полиморфизм поддерживается в JSON с некоторыми ограничениями.JavaScript — слабо типизированный язык, поэтому идентификация типа обычно не представляет проблем.Однако при использовании JSON для передачи данных между строго типизированной системой \(.NET\) и слабо типизированной системой \(JavaScript\) идентификацию типа желательно сохранять.Например, типы с именами контрактов данных "Square" и "Circle" наследуют от типа с именем контракта данных "Shape".Если тип Circle отправляется из .NET в JavaScript и затем возвращается в метод .NET, который ожидает тип Shape, то на стороне .NET желательно знать, что данный объект изначально принадлежал к типу Circle; в противном случае информация, присутствующая только в производном типе \(например элемент данных radius в типе Circle\), может быть потеряна.  
  
 Для сохранения удостоверения типа при сериализации в JSON сложных типов можно добавить "намек на тип", чтобы десериализатор распознавал этот намек и действовал соответствующим образом."Намек на тип" представляет собой пару "ключ\/значение" JSON, где имя ключа — "\_\_type" \(два символа подчеркивания и слово "type"\).Значение представляет собой строку JSON вида "DataContractName:DataContractNamespace" \(все до первого двоеточия является именем\).Продолжая предыдущий пример, тип "Circle" можно сериализовать следующим образом.  
  
```  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 Намек на тип очень похож на атрибут `xsi:type`, определенный в стандарте XML Schema Instance и используемый при сериализации\/десериализации XML.  
  
 Члены данных с именем "\_\_type" запрещены из\-за потенциального конфликта с намеком на тип.  
  
#### Уменьшение размера намеков на тип  
 Для уменьшения размера сообщений JSON префикс пространства имен контракта данных по умолчанию \(http:\/\/schemas.datacontract.org\/2004\/07\/\) заменяется символом "\#".\(Чтобы эта замена была обратимой, используется escape\-правило: если пространство имен начинается с символов "\#" или "\\", к ним добавляется дополнительный символ "\\"\).Таким образом, если "Circle" — тип в пространстве имен .NET "MyApp.Shapes", его пространство имен контракта данных по умолчанию будет http:\/\/schemas.datacontract.org\/2004\/07\/MyApp.Shapes, а его JSON\-представление будет иметь следующий вид.  
  
```  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 И усеченное \(\#MyApp.Shapes\), и полное \(http:\/\/schemas.datacontract.org\/2004\/07\/MyApp.Shapes\) имена распознаются при десериализации.  
  
#### Положение намека на тип в объектах JSON  
 Обратите внимание, что намек на тип в JSON\-представлении должен стоять на первом месте.Это единственный случай, когда порядок пар "ключ\/значение" в обработке JSON имеет значение.Например, следующий способ задания намека на тип допустимым не является.  
  
```  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 И сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, используемый в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], и клиентские страницы ASP.NET AJAX всегда сначала выдают намек на тип.  
  
#### Намеки на тип применяются только к сложным типам  
 Способа выдавать намек на тип для несложных типов не существует.Например, если операция имеет тип возвращаемого значения <xref:System.Object>, однако возвращает тип "Circle", JSON\-представление может выглядеть так, как показано выше, и информация типа сохраняется.Однако если возвращается универсальный код ресурса \(URI\), JSON\-представление будет строкой, и тот факт, что строка используется для представления URI, теряется.Это относится не только к примитивным типам, но также к коллекциям и массивам.  
  
#### Когда выдается намеки на тип  
 Намеки на тип могут значительно увеличить размер сообщения \(один из способов борьбы с этим — использовать более короткие пространства имен контрактов данных, если это возможно\).По этой причине выдача намеков на тип подчиняется следующим правилам.  
  
-   При использовании ASP.NET AJAX намеки на тип выдаются всегда, когда это возможно, даже при отсутствии присвоения базовый\/производный — например, даже если тип "Circle" присваивается типу "Circle".\(Это необходимо, чтобы в полной мере обеспечить возможность вызова из слабо типизированной среды JSON методов строго типизированной среды .NET без неожиданных потерь информации.\)  
  
-   При использовании служб AJAX без интеграции с ASP.NET намеки на тип выдаются только при наличии присвоения базовый\/производный — т. е. когда тип "Circle" присваивается типу "Shape" или типу <xref:System.Object>, но не при присвоении типа "Circle" типу "Circle".Это минимум информации, необходимый для правильной реализации клиента JavaScript, который повышает производительность, но не защищает от потери информации о типах в неверно спроектированных клиентах.Избегайте присвоений базовый\/производный на сервере в принципе, чтобы избежать необходимости решения этой проблемы на клиенте.  
  
-   При использовании типа <xref:System.Runtime.Serialization.DataContractSerializer> параметр конструктора `alwaysEmitTypeInformation` позволяет выбрать один из двух упомянутых выше режимов; по умолчанию используется значение "`false`" \(выдавать намеки на тип только тогда, когда это необходимо\).  
  
#### Повторяющиеся имена членов данных  
 Информация производного типа присутствует в одном объекте JSON вместе с информацией базового типа и может следовать в любом порядке.Например, тип `Shape` может быть представлен следующим образом.  
  
```  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 При этом тип "Circle" может быть представлен следующим образом.  
  
```  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 Если бы базовый тип `Shape` также содержал член данных с именем "`radius`", это привело бы к конфликту как при сериализации \(поскольку объекты JSON не могут иметь повторяющиеся имена ключей\), так и при десериализации \(поскольку не ясно, что понимается под "radius" — `Shape.radius` или `Circle.radius`\).Следовательно, тогда как использовать принцип "сокрытия свойств" \(члены данных с одинаковым именем в базовом и производном классах\) в классах контрактов данных обычно не рекомендуется, в случае с JSON его использование прямо запрещено.  
  
#### Полиморфизм и типы IXmlSerializable  
 Типы <xref:System.Xml.Serialization.IXmlSerializable> можно полиморфно присваивать друг другу как обычно, при условии выполнения требований "известных типов" в соответствии с обычными правилами контракта данных.Однако сериализация типа <xref:System.Xml.Serialization.IXmlSerializable> вместо типа <xref:System.Object> приводит к потере информации типа, поскольку результатом сериализации является строка JSON.  
  
#### Полиморфизм и некоторые типы интерфейсов  
 Запрещается сериализовать тип коллекции или тип, реализующий интерфейс <xref:System.Xml.Serialization.IXmlSerializable>, там, где ожидается не являющийся коллекцией тип, который не сериализуется с использованием <xref:System.Xml.Serialization.IXmlSerializable> \(за исключением <xref:System.Object>\).Например, пользовательский интерфейс `IMyInterface` и тип `MyType`, реализующие и интерфейс <xref:System.Collections.Generic.IEnumerable%601> типа `int`, и `IMyInterface`.Запрещается возвращать тип `MyType` из операции, тип возвращаемого значения которой — `IMyInterface`.Это связано с тем, что тип `MyType` должен сериализоваться как массив JSON и требует намека на тип, но, как говорилось выше, снабдить намеком на тип массив нельзя \(намеками на тип снабжаются только сложные типы\).  
  
#### Известные типы и конфигурация  
 Все механизмы "известных типов", используемые сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>, аналогичным образом поддерживаются сериализатором <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.Оба сериализатора считывают один и тот же элемент конфигурации — [\<dataContractSerializer\>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) в [\<system.runtime.serialization\>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md) — для получения известных типов, добавленных посредством файла конфигурации.  
  
#### Коллекции, присвоенные объекту  
 Коллекции, присвоенные объекту, сериализуются так, как будто они реализуют интерфейс <xref:System.Collections.Generic.IEnumerable%601>: в виде массива JSON, где каждая запись имеет намек на тип, если это сложный тип.Например, коллекция <xref:System.Collections.Generic.List%601> типа `Shape`, присвоенная объекту <xref:System.Object>, выглядит следующим образом.  
  
```  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 При десериализации обратно в <xref:System.Object>:  
  
-   тип `Shape` должен находиться в списке известных типов.Присутствие в списке известных типов коллекции <xref:System.Collections.Generic.List%601> типа `Shape` не учитывается.Обратите внимание, что вручную добавлять тип `Shape` в список известных типов при сериализации не требуется — это делается автоматически;  
  
-   коллекция десериализуется как объект <xref:System.Array> типа <xref:System.Object>, содержащий экземпляры типа `Shape`.  
  
#### Производные коллекции, присвоенные базовым коллекциям  
 При присвоении производной коллекции базовой коллекции коллекция обычно сериализуется так, как если бы она была коллекцией базового типа.В то же время тип элемента производной коллекции нельзя присвоить типу элемента базовой коллекции: вызывается исключение.  
  
#### Намеки на тип и словари  
 При присвоении словаря объекту <xref:System.Object> каждая запись "ключ" и "значение" в словаре рассматривается так, как если бы она была присвоена объекту <xref:System.Object>, и получает намек на тип.  
  
 При сериализации типов словарей на объект JSON, содержащий члены "Key" и "Value", не влияет значение параметра `alwaysEmitTypeInformation`: он содержит намек на тип только там, где этого требуют рассмотренные выше правила сериализации коллекций.  
  
### Допустимые имена ключей JSON  
 Сериализатор кодирует в XML имена ключей, не являющиеся допустимыми XML\-именами.Например, член данных с именем "123" будет иметь кодированное имя, такое как "\_x0031\_\_x0032\_\_x0033\_", поскольку "123" — недопустимое имя XML\-элемента \(начинается с цифры\).Аналогичная ситуация может возникнуть с некоторыми международными кодировками, которые не допускаются в XML\-именах.Рассмотрение влияния такого XML\-кодирования на обработку JSON см. в разделе [Сопоставление JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).  
  
## См. также  
 [Поддержка JSON и других форматов передачи данных](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)