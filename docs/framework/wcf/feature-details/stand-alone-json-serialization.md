---
title: "Автономная сериализация JSON"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
caps.latest.revision: "32"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 8583ac00f1216e68f95c3d41d8c896b555d0aa8d
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="stand-alone-json-serialization"></a>Автономная сериализация JSON
JSON (JavaScript Object Notation, объектная нотация JavaScript) - формат данных, предназначенный специально для использования JavaScript-кодом, выполняемым на веб-страницах внутри браузера. Этот формат данных используется по умолчанию в службах ASP.NET AJAX, созданных в [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)].  
  
 Его также можно использовать при создании служб AJAX без интеграции с ASP.NET; в данном случае форматом по умолчанию является XML, однако можно выбрать и JSON.  
  
 Наконец, если требуется поддержка JSON, однако создаваемая служба не является службой AJAX, сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> позволяет непосредственно сериализовать объекты .NET в данные JSON и десериализовать такие данные обратно в экземпляры типов .NET. Описание того, как это сделать, см. [как: сериализации и десериализации данных JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).  
  
 При работе с JSON поддерживаются те же (за некоторыми исключениями) типы .NET, что поддерживаются сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>. Список поддерживаемых типов см. в разделе [типы, поддерживаемые сериализатором контракта данных](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md). К ним относится большинство примитивных типов, большинство типов массивов и коллекций, а также сложные типы, в которых используются атрибуты <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute>.  
  
## <a name="mapping-net-types-to-json-types"></a>Сопоставление типов .NET типам JSON  
 В следующей таблице показано соответствие между типами .NET и типами JSON/JavaScript, используемое при сопоставлении в процедурах сериализации и десериализации.  
  
|Типы .NET|JSON/JavaScript|Примечания|  
|----------------|----------------------|-----------|  
|Все числовые типы, например <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double>|Число|Специальные значения, такие как `Double.NaN`, `Double.PositiveInfinity` и `Double.NegativeInfinity`, не поддерживаются и приводят к получению недопустимых JSON-данных.|  
|<xref:System.Enum>|Число|См. раздел «Перечисления и JSON» ниже.|  
|<xref:System.Boolean>|Boolean|--|  
|<xref:System.String>, <xref:System.Char>|String|--|  
|<xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri>|String|Формат этих типов в JSON идентичен формату в XML (а именно: TimeSpan имеет формат длительности, описанный в ISO 8601, GUID имеет формат «12345678-ABCD-ABCD-ABCD-1234567890AB», а URI представляется в форме исходной строки, например «http://www.example.com»). Точные сведения в разделе [Справочник по схеме контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).|  
|<xref:System.Xml.XmlQualifiedName>|String|Формат - «имя:пространство_имен» (все до первого двоеточия является именем). Имя или пространство имен может отсутствовать. При отсутствии пространства имен можно также опустить двоеточие.|  
|<xref:System.Array> типа <xref:System.Byte>|Массив чисел|Каждое число представляет значение одного байта.|  
|<xref:System.DateTime>|DateTime или String|См. раздел «Даты-времена и JSON» ниже.|  
|<xref:System.DateTimeOffset>|Сложный тип|См. раздел «Даты-времена и JSON» ниже.|  
|Типы XML и ADO.NET (<xref:System.Xml.XmlElement>,<br /><br /> <xref:System.Xml.Linq.XElement>. Массивы <xref:System.Xml.XmlNode>,<br /><br /> <xref:System.Runtime.Serialization.ISerializable>,<br /><br /> <xref:System.Data.DataSet>).|String|См. раздел «Типы XML и JSON» ниже.|  
|<xref:System.DBNull>|Пустой сложный тип|--|  
|Коллекции, словари и массивы|Массив|См. раздел «Коллекции, словари и массивы» ниже.|  
|Сложные типы (с примененным атрибутом <xref:System.Runtime.Serialization.DataContractAttribute> или <xref:System.SerializableAttribute>)|Сложный тип|Элементы данных становятся элементами сложного типа JavaScript.|  
|Сложные типы (реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>)|Сложный тип|Сопоставляется аналогично другим сложным типам, однако некоторые типы <xref:System.Runtime.Serialization.ISerializable> не поддерживаются; см. раздел «Поддержка интерфейса ISerializable» ниже, в разделе «Дополнительные сведения для опытных пользователей».|  
|Значение `Null` для любого типа|Null|Типы, допускающие значение null, также поддерживаются и сопоставляются с JSON так же, как и типы, не допускающие значение null.|  
  
### <a name="enumerations-and-json"></a>Перечисления и JSON  
 Значения элементов перечислений в JSON рассматриваются как числа в отличие от контрактов данных, куда они включаются как имена элементов. [!INCLUDE[crabout](../../../../includes/crabout-md.md)]Работа, контракта данных. в разделе [типы перечислений в контрактах данных](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).  
  
-   Например, в случае перечисления `public enum Color {red, green, blue, yellow, pink}` при сериализации члена `yellow` получается число 3, а не строка "yellow".  
  
-   Все члены типа `enum` сериализуемы. Атрибуты <xref:System.Runtime.Serialization.EnumMemberAttribute> и <xref:System.NonSerializedAttribute> (если они используются) игнорируются.  
  
-   Также возможна десериализация несуществующего значения `enum` - например, значение 87 можно десериализовать в упомянутое выше перечисление Color, даже несмотря на отсутствие соответствующего определенного имени цвета.  
  
-   Флаговый тип `enum` не является особенным и рассматривается так же, как любой другой тип `enum`.  
  
### <a name="datestimes-and-json"></a>Даты-времена и JSON  
 Формат JSON не предусматривает непосредственной поддержки дат и времен. Тем не менее, они очень часто используются, и в ASP.NET AJAX предусмотрена особая поддержка для этих типов. При использовании прокси-объектов ASP.NET AJAX тип <xref:System.DateTime> в .NET полностью соответствует типу `DateTime` в JavaScript.  
  
-   Если ASP.NET не используется, тип <xref:System.DateTime> представляется в JSON в виде строки особого формата, который описан в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
-   <xref:System.DateTimeOffset> представляется в JSON как сложный тип: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}. Член `offsetMinutes` - это смещение местного времени относительно времени по Гринвичу (GMT, теперь также называемого временем в формате UTC), связанное с местоположением интересующего события. Элемент `dateTime` представляет момент во времени, когда произошло интересующее событие (опять этот элемент становится типом `DateTime` в JavaScript, когда используется ASP.NET AJAX, и строкой, когда ASP.NET AJAX не используется). При сериализации член `dateTime` всегда сериализуется в GMT. Так, если описывается время 3:00 по Нью-Йорку, компонентом времени члена `dateTime` будет "8:00", а смещение в минутах `offsetMinutes` составит 300 (минус 300 минут, или 5 часов, относительно GMT).  
  
    > [!NOTE]
    >  В объектах <xref:System.DateTime> и <xref:System.DateTimeOffset> при сериализации в JSON информация сохраняется с точностью только до миллисекунд. Значения меньше миллисекунды (микро- и наносекунды) при сериализации теряются.  
  
### <a name="xml-types-and-json"></a>Типы XML и JSON  
 Типы XML становятся строками JSON.  
  
-   Например, если данные члена «q» типа XElement содержит \<abc / >, JSON-{«q»:»\<abc / >»}.  
  
-   Существуют некоторые особые правила, определяющие, как XML-данные заключаются в оболочку; более подробные сведения см. в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
-   При использовании ASP.NET AJAX, если вместо строк JavaScript требуется использовать модель DOM XML, присвойте значение «XML» свойству <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebGetAttribute> или свойству <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebInvokeAttribute>.  
  
### <a name="collections-dictionaries-and-arrays"></a>Коллекции, словари и массивы  
 Все коллекции, словари и массивы представляются в JSON в виде массивов.  
  
-   Все пользовательские типы с атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> в JSON-представлении игнорируются.  
  
-   Словари не являются способом непосредственной работы с JSON. Словарь\<строка, объект > может не поддерживаться так же как в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] должным образом работать с другими технологиями JSON. Например, если в словаре строка "abc" сопоставлена строке "xyz", а строка "def" строке 42, JSON-представление будет иметь вид не {"abc":"xyz","def":42}, а [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].  
  
-   Если требуется работать непосредственно с JSON (обращаться к ключам и значениям динамически, без предварительного определения жесткого контракта), можно рассмотреть следующие варианты.  
  
    -   Рассмотрите возможность использования [слабо типизированной сериализации JSON (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) образца.  
  
    -   Использование интерфейса <xref:System.Runtime.Serialization.ISerializable> и конструкторов десериализации - эти два механизма позволяют обращаться к парам "ключ-значение" JSON при сериализации и десериализации соответственно, однако не работают в сценариях с частичным доверием.  
  
    -   Рассмотрите возможность работы с [сопоставление между JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) вместо того чтобы использовать сериализатор.  
  
    -   *Полиморфизм* в контексте сериализации понимается возможность сериализовать производный тип там, где ожидается его базовый тип. Существуют особые (только для JSON) правила, применяющиеся при полиморфном использовании коллекций, например при присвоении коллекции объекту <xref:System.Object>. Этот вопрос более подробно рассмотрен в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
## <a name="additional-details"></a>Некоторые подробности  
  
### <a name="order-of-data-members"></a>Порядок членов данных  
 Порядок членов данных при использовании JSON не имеет значения. В частности, даже если задан атрибут <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, JSON-данные все равно можно сериализовать в любом порядке.  
  
### <a name="json-types"></a>Типы JSON  
 Тип JSON при десериализации не обязательно должен соответствовать приведенной выше таблице. Например, тип `Int` обычно сопоставляется числу JSON, однако может быть успешно десериализован из строки JSON, при условии, что строка содержит допустимое число. То есть, и {"q":42}, и {"q":"42"} допустимы, если имеется член данных типа `Int` с именем "q".  
  
### <a name="polymorphism"></a>Полиморфизм  
 Полиморфная сериализация состоит в возможности сериализовать производный тип там, где ожидается его базовый тип. Эта возможность поддерживается для сериализации JSON в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] аналогично тому, как поддерживается сериализация XML. Например, можно сериализовать `MyDerivedType` где `MyBaseType` ожидается или сериализовать `Int` где `Object` ожидается.  
  
 При десериализации производного типа там, где ожидается базовый тип, информация типа может быть потеряна, за исключением случаев десериализации сложных типов. Например, при сериализации типа <xref:System.Uri> там, где ожидается тип <xref:System.Object>, будет получена строка JSON. Если эту строку затем десериализовать обратно в тип <xref:System.Object>, будет возвращен .NET-тип <xref:System.String>. Десериализатор не знает, что строка изначально имела тип <xref:System.Uri>. Как правило, когда ожидается тип <xref:System.Object>, все строки JSON десериализуются как строки .NET, а все массивы JSON, используемые для сериализации коллекций, словарей и массивов .NET, десериализуются как .NET-объекты <xref:System.Array> типа <xref:System.Object>, вне зависимости от того, какими были исходные типы. Логический тип JSON сопоставляется .NET-типу <xref:System.Boolean>. Однако, когда ожидается тип <xref:System.Object>, числа JSON десериализуются в .NET-типы <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double> (наиболее подходящий тип выбирается автоматически).  
  
 При десериализации в тип интерфейса <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> выполняет десериализацию так, как будто объявленный тип - объект.  
  
 При работе со своими собственными базовыми и производными типами обычно требуется использовать атрибуты <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> или эквивалентный механизм. Например, если какая-либо операция с `Animal` возвращаемое значение и он фактически возвращает экземпляр `Cat` (производный от `Animal`), необходимо либо применить <xref:System.Runtime.Serialization.KnownTypeAttribute>в `Animal` типа или <xref:System.ServiceModel.ServiceKnownTypeAttribute> для операцию и укажите `Cat` типа в этих атрибутов. Дополнительные сведения см. в разделе [известные типы контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).  
  
 Подробное описание работы полиморфной сериализации и некоторых ограничений, которые необходимо принимать во внимание при ее использовании, см. в разделе "Дополнительные сведения для опытных пользователей" ниже.  
  
### <a name="versioning"></a>Управление версиями  
 Функции управления версиями контрактов данных, включая интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>, полностью поддерживаются в JSON. Кроме того, в большинстве случаев можно десериализовать тип в один формат (например, XML) и затем сериализовать его в другой формат (например, JSON) и при этом сохранить данные в <xref:System.Runtime.Serialization.IExtensibleDataObject>. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Контракты данных, совместимые с любыми будущими](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md). Следует помнить, что JSON не придает значения порядку, поэтому любая информация о порядке будет потеряна. Кроме того, JSON не поддерживает множественные пары "ключ/значение" с одним и тем же именем ключа. Наконец, все операции над объектом <xref:System.Runtime.Serialization.IExtensibleDataObject> по своей природе полиморфны - то есть, их производные типы присваиваются типу <xref:System.Object>, базовому типу для всех типов.  
  
## <a name="json-in-urls"></a>JSON в URL-адресах  
 При использовании конечных точек ASP.NET AJAX с командой GET HTTP (с помощью атрибута <xref:System.ServiceModel.Web.WebGetAttribute>), входящие параметры присутствуют в URL-адресе запроса, а не в теле сообщения. JSON поддерживается даже в URL-АДРЕСЕ запроса, поэтому, если какая-либо операция, которая принимает `Int` именем «number» и `Person` сложный тип с именем «p», URL-адрес может напоминать следующий URL-адрес.  
  
```  
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}  
```  
  
 При использовании диспетчера скриптов ASP.NET AJAX и прокси-объекта для вызова службы этот URL-адрес автоматически формируется прокси-объектом, и увидеть его нельзя. JSON нельзя использовать в URL-адресах на конечных точках, не являющихся конечными точками ASP.NET AJAX.  
  
## <a name="advanced-information"></a>Дополнительные сведения для опытных пользователей  
  
### <a name="iserializable-support"></a>Поддержка интерфейса ISerializable  
  
#### <a name="supported-and-unsupported-iserializable-types"></a>Поддерживаемые и неподдерживаемые типы ISerializable  
 Как правило, типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>, полностью поддерживаются при сериализации/десериализации JSON. Однако некоторые из этих типов (включая некоторые типы платформы .NET Framework) реализованы так, что некоторые аспекты, присущие именно сериализации в JSON, не позволяют им правильно десериализоваться:  
  
-   При использовании интерфейса <xref:System.Runtime.Serialization.ISerializable> тип отдельных членов данных никогда не известен заранее. Это ведет к полиморфной ситуации, аналогичной десериализации типов в объект. Как уже говорилось, это может привести к потере информации типов в JSON. Например, если тип сериализует в своей реализации `enum` тип <xref:System.Runtime.Serialization.ISerializable>, попытка десериализовать данные обратно в `enum` (без надлежащих приведений) завершится неудачей, поскольку тип `enum` сериализуется в JSON в виде чисел, а числа JSON десериализуются во встроенные числовые типы .NET (Int32, Decimal или Double). Поэтому тот факт, что число когда-то было значением перечисления (`enum`), теряется.  
  
-   Тип с интерфейсом <xref:System.Runtime.Serialization.ISerializable>, конструктор десериализации которого основан на определенном порядке десериализации, также может выдать ошибку при десериализации некоторых JSON-данных, поскольку большинство сериализаторов JSON не гарантируют никакого определенного порядка.  
  
#### <a name="factory-types"></a>Типы производства  
 В то время как интерфейс <xref:System.Runtime.Serialization.IObjectReference> в общем случае поддерживается в JSON, все типы, требующие возможности "типа производства" (возвращения методом <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> экземпляра типа, отличного от типа, реализующего интерфейс), не поддерживаются.  
  
### <a name="datetime-wire-format"></a>Формат DateTime при передаче по линиям связи  
 Значения типа <xref:System.DateTime> представляются строками JSON вида "/Date(700000+0500)/", где первое число (в данном случае 700000) - это число миллисекунд в часовом поясе GMT по обычному (не летнему) времени, прошедшее с 1 января 1970 г. Это число может быть отрицательным для представления более раннего времени. Часть строки "+0500" является необязательной и показывает, что это время в формате <xref:System.DateTimeKind.Local>, т. е. при десериализации оно должно быть преобразовано в местный часовой пояс. Если эта часть строки отсутствует, время десериализуется как <xref:System.DateTimeKind.Utc>. Собственно число (в данном случае "0500") и его знак (+ или -) игнорируются.  
  
 При сериализации времен формата <xref:System.DateTime>, <xref:System.DateTimeKind.Local> и <xref:System.DateTimeKind.Unspecified> времена записываются со смещением, а время формата <xref:System.DateTimeKind.Utc> записывается без смещения.  
  
 JavaScript-код клиента ASP.NET AJAX автоматически преобразует такие строки в экземпляры `DateTime` JavaScript. При наличии других строк аналогичного вида, не принадлежащих к типу <xref:System.DateTime> в .NET, они также преобразуются.  
  
 Преобразование происходит только если экранируются символы «/» (то есть JSON выглядит следующим образом "\\/Date(700000+0500)\\/») и по этой причине [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]в JSON-кодировщик (включаемые <xref:System.ServiceModel.WebHttpBinding>) всегда экранирует «/» символ.  
  
### <a name="xml-in-json-strings"></a>XML-данные в строках JSON  
  
#### <a name="xmlelement"></a>XmlElement  
 Тип <xref:System.Xml.XmlElement> сериализуется "как есть", без оболочки. Например, член данных «x» типа <xref:System.Xml.XmlElement> , содержащий \<abc / >, представляется следующим образом.  
  
```json  
{"x":"<abc/>"}  
```  
  
#### <a name="arrays-of-xmlnode"></a>Массивы типа XmlNode  
 Объекты <xref:System.Array> типа <xref:System.Xml.XmlNode> помещаются в элемент-оболочку ArrayOfXmlNode в стандартном пространстве имен контракта данных для данного типа. Если "x" - массив, содержащий узел атрибута "N" в пространстве имен "ns", который содержит "value", и пустой узел элемента "M", представление выглядит следующим образом.  
  
```  
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}  
```  
  
 Атрибуты в пустом пространстве имен в начале массивов XmlNode (перед другими элементами) не поддерживаются.  
  
#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a>Типы IXmlSerializable, включая XElement и DataSet  
 Типы <xref:System.Runtime.Serialization.ISerializable> делятся на "типы содержимого", "типы DataSet" и "типы элементов". Для определения этих типов см. в разделе [типы XML и ADO.NET в контрактах данных](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).  
  
 Типы содержимого и типы "DataSet" сериализуются аналогично объектам <xref:System.Array> типа <xref:System.Xml.XmlNode>, рассмотренным в предыдущем разделе. Они помещаются в элемент-оболочку, имя и пространство имен которого соответствует имени контракта данных и пространству имен сериализуемого типа.  
  
 Типы элементов, такие как <xref:System.Xml.Linq.XElement> сериализуются "как есть", аналогично рассмотренному выше типу <xref:System.Xml.XmlElement>.  
  
### <a name="polymorphism"></a>Полиморфизм  
  
#### <a name="preserving-type-information"></a>Сохранение информации типов  
 Как уже говорилось, полиморфизм поддерживается в JSON с некоторыми ограничениями. JavaScript - слабо типизированный язык, и идентификация типа обычно не представляет проблем. Однако при использовании JSON для передачи данных между строго типизированной системой (.NET) и слабо типизированной системой (JavaScript) желательно сохранять удостоверение типа. Например, типы с именами контрактов данных "Square" и "Circle" наследуют от типа с именем контракта данных "Shape". Если значение Circle передается из .NET в JavaScript и возвращается в метод .NET, ожидающий тип Shape, то в компоненте .NET желательно знать, что данный объект изначально принадлежал к типу Circle; в противном случае может быть потеряна информация, присутствующая только в производном типе (например, элемент данных radius в типе Circle).  
  
 Для сохранения удостоверения типа при сериализации в JSON сложных типов можно добавить "намек на тип", чтобы десериализатор распознавал этот намек и действовал соответствующим образом. "Намек на тип" представляет собой пару "ключ/значение" JSON, где имя ключа - "__type" (два символа подчеркивания и слово "type"). Значение представляет собой строку JSON вида "DataContractName:DataContractNamespace" (все до первого двоеточия является именем). Продолжая предыдущий пример, тип "Circle" можно сериализовать следующим образом.  
  
```json  
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}  
```  
  
 Намек на тип очень похож на атрибут `xsi:type`, определенный в стандарте XML Schema Instance и используемый при сериализации/десериализации XML.  
  
 Члены данных с именем "__type" запрещены из-за потенциального конфликта с намеком на тип.  
  
#### <a name="reducing-the-size-of-type-hints"></a>Уменьшение размера намеков на тип  
 Для уменьшения размера сообщений JSON префикс пространства имен контракта данных по умолчанию (http://schemas.datacontract.org/2004/07/) заменяется символом "#". (Чтобы эта замена обратимое, используется escape-правило: Если пространство имен начинается с «#» или "\\" символы, к ним добавляется дополнительный «\\» символ). Таким образом, если "Circle" - тип в пространстве имен .NET "MyApp.Shapes", его пространство имен контракта данных по умолчанию будет http://schemas.datacontract.org/2004/07/MyApp. Shapes, а его JSON-представление будет иметь следующий вид.  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}  
```  
  
 И усеченное (#MyApp.Shapes), и полное (http://schemas.datacontract.org/2004/07/MyApp.Shapes) имена распознаются при десериализации.  
  
#### <a name="type-hint-position-in-json-objects"></a>Положение намека на тип в объектах JSON  
 Обратите внимание, что намек на тип в JSON-представлении должен стоять на первом месте. Это единственный случай, когда порядок пар "ключ/значение" в обработке JSON имеет значение. Например, следующий способ задания намека на тип допустимым не является.  
  
```json  
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}  
```  
  
 И сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, используемый в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], и клиентские страницы ASP.NET AJAX всегда сначала выдают намек на тип.  
  
#### <a name="type-hints-apply-only-to-complex-types"></a>Намеки на тип применяются только к сложным типам  
 Способа выдавать намек на тип для несложных типов не существует. Например, если операция имеет тип возвращаемого значения <xref:System.Object>, однако возвращает тип "Circle", JSON-представление может выглядеть так, как показано выше, и информация типа сохраняется. Однако если возвращается универсальный код ресурса (URI), JSON-представление будет строкой, и тот факт, что строка используется для представления URI, теряется. Это относится не только к примитивным типам, но также к коллекциям и массивам.  
  
#### <a name="when-are-type-hints-emitted"></a>Когда выдается намеки на тип  
 Намеки на тип могут значительно увеличить размер сообщения (один из способов борьбы с этим - использовать более короткие пространства имен контрактов данных, если это возможно). По этой причине выдача намеков на тип подчиняется следующим правилам.  
  
-   При использовании ASP.NET AJAX намеки на тип выдаются всегда, когда это возможно, даже при отсутствии присвоения базовый/производный - например, даже если тип "Circle" присваивается типу "Circle". (Это необходимо, чтобы в полной мере обеспечить возможность вызова из слабо типизированной среды JSON методов строго типизированной среды .NET без неожиданных потерь информации.)  
  
-   При использовании служб AJAX без интеграции с ASP.NET намеки на тип выдаются только при наличии присвоения базовый/производный - т. е. когда тип "Circle" присваивается типу "Shape" или типу <xref:System.Object>, но не при присвоении типа "Circle" типу "Circle". Это минимум информации, необходимый для правильной реализации клиента JavaScript, что повышает производительность, но не защищает от потери информации о типах в неправильно спроектированных клиентах. Избегайте присвоений базовый/производный на сервере в принципе, чтобы избежать необходимости решения этой проблемы на клиенте.  
  
-   При использовании типа <xref:System.Runtime.Serialization.DataContractSerializer> параметр конструктора `alwaysEmitTypeInformation` позволяет выбрать один из двух упомянутых выше режимов; по умолчанию используется значение "`false`" (выдавать намеки на тип только тогда, когда это необходимо).  
  
#### <a name="duplicate-data-member-names"></a>Повторяющиеся имена членов данных  
 Информация производного типа присутствует в одном объекте JSON вместе с информацией базового типа и может следовать в любом порядке. Например `Shape` может быть представлен следующим образом.  
  
```json  
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}  
```  
  
 При этом тип "Circle" может быть представлен следующим образом.  
  
```json  
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}  
```  
  
 Если базовый `Shape` тип также содержал член данных с именем «`radius`», это привело бы к конфликту как при сериализации (поскольку объекты JSON не могут иметь повторяющиеся имена ключей) и десериализации (поскольку не ясно, что «radius» понимается `Shape.radius` или `Circle.radius`). Следовательно, тогда как использовать принцип "сокрытия свойств" (члены данных с одинаковым именем в базовом и производном классах) в классах контрактов данных обычно не рекомендуется, в случае с JSON его использование прямо запрещено.  
  
#### <a name="polymorphism-and-ixmlserializable-types"></a>Полиморфизм и типы IXmlSerializable  
 Типы <xref:System.Xml.Serialization.IXmlSerializable> можно полиморфно присваивать друг другу как обычно, при условии выполнения требований "известных типов" в соответствии с обычными правилами контракта данных. Однако сериализация типа <xref:System.Xml.Serialization.IXmlSerializable> вместо типа <xref:System.Object> приводит к потере информации типа, поскольку результатом сериализации является строка JSON.  
  
#### <a name="polymorphism-and-certain-interface-types"></a>Полиморфизм и некоторые типы интерфейсов  
 Запрещается сериализовать тип коллекции или тип, реализующий интерфейс <xref:System.Xml.Serialization.IXmlSerializable>, там, где ожидается не являющийся коллекцией тип, который не сериализуется с использованием <xref:System.Xml.Serialization.IXmlSerializable> (за исключением <xref:System.Object>). Например, пользовательский интерфейс с именем `IMyInterface` и тип `MyType` , реализующие и интерфейс <xref:System.Collections.Generic.IEnumerable%601> типа `int` и `IMyInterface`. Запрещается возвращать `MyType` из операции, тип возвращаемого значения является `IMyInterface`. Это вызвано `MyType` должны сериализоваться как массив JSON и требует намек на тип как говорилось не может включать намек на тип с массивами только со сложными типами.  
  
#### <a name="known-types-and-configuration"></a>Известные типы и конфигурация  
 Все механизмы "известных типов", используемые сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>, аналогичным образом поддерживаются сериализатором <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>. Оба сериализаторов чтения же элемент конфигурации, [ \<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) в [ \<system.runtime.serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), чтобы обнаружить известные типы, добавленные через файл конфигурации.  
  
#### <a name="collections-assigned-to-object"></a>Коллекции, присвоенные объекту  
 Коллекции, присвоенные объекту, сериализуются так, как будто они реализуют интерфейс <xref:System.Collections.Generic.IEnumerable%601>: в виде массива JSON, где каждая запись имеет намек на тип, если это сложный тип. Например <xref:System.Collections.Generic.List%601> типа `Shape` назначен <xref:System.Object> выглядит следующим образом.  
  
```json  
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},  
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},  
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]  
```  
  
 При десериализации обратно в <xref:System.Object>:  
  
-   `Shape`должен быть в списке известных типов. Наличие <xref:System.Collections.Generic.List%601> типа `Shape` в списке известных типов не оказывает влияния. Обратите внимание, что необходимо добавить `Shape` для известных типов при сериализации в данном случае - это выполняется автоматически.  
  
-   Коллекция десериализуется как <xref:System.Array> типа <xref:System.Object> , содержащий `Shape` экземпляров.  
  
#### <a name="derived-collections-assigned-to-base-collections"></a>Производные коллекции, присвоенные базовым коллекциям  
 При присвоении производной коллекции базовой коллекции коллекция обычно сериализуется так, как если бы она была коллекцией базового типа. В то же время тип элемента производной коллекции нельзя присвоить типу элемента базовой коллекции: вызывается исключение.  
  
#### <a name="type-hints-and-dictionaries"></a>Намеки на тип и словари  
 При присвоении словаря объекту <xref:System.Object> каждая запись "ключ" и "значение" в словаре рассматривается так, как если бы она была присвоена объекту <xref:System.Object>, и получает намек на тип.  
  
 При сериализации типов словарей на объект JSON, содержащий члены "Key" и "Value", не влияет значение параметра `alwaysEmitTypeInformation`: он содержит намек на тип только там, где этого требуют рассмотренные выше правила сериализации коллекций.  
  
### <a name="valid-json-key-names"></a>Допустимые имена ключей JSON  
 Сериализатор кодирует в XML имена ключей, не являющиеся допустимыми XML-именами. Например, в член данных с именем «123» будет иметь кодированное имя «_x0031\__x0032\__x0033\_", так как «123» является недопустимым именем элемента XML (начинается с цифры). Аналогичная ситуация может возникнуть с некоторыми международными кодировками, которые не допускаются в XML-именах. Объяснение этот эффект XML для обработки JSON. в разделе [сопоставление между JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).  
  
## <a name="see-also"></a>См. также  
 [Поддержка JSON и других форматов передачи данных](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
