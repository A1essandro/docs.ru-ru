---
title: "Синхронные сценарии с использованием HTTP, TCP или именованного канала"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 7e90af1b-f8f6-41b9-a63a-8490ada502b1
caps.latest.revision: "9"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 2e40669baadf27ee8d10d84961f27bfea3c997d1
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/02/2017
---
# <a name="synchronous-scenarios-using-http-tcp-or-named-pipe"></a>Синхронные сценарии с использованием HTTP, TCP или именованного канала
В этом разделе описываются действия и перенаправления для различных сценариев синхронных запросов/ответов (с однопотоковым клиентом, с использованием HTTP, TCP или именованного канала). В разделе [асинхронные сценарии с использованием HTTP, TCP или именованного канала](../../../../../docs/framework/wcf/diagnostics/tracing/asynchronous-scenarios-using-http-tcp-or-named-pipe.md) Дополнительные сведения о многопоточных запросов.  
  
## <a name="synchronous-requestreply-without-errors"></a>Синхронный запрос/ответ без ошибок  
 В этом разделе описываются действия и перенаправления для реального сценария синхронных запросов/ответов (с однопотоковым клиентом).  
  
### <a name="client"></a>Клиент  
  
#### <a name="establishing-communication-with-service-endpoint"></a>Установка связи с конечной точкой службы  
 Создается и открывается клиент. Для каждого из этих действий, внешнее действие (A) перенаправляется действию «Создать клиент» (B) и «Открыть клиент» (C) соответственно. Для каждого действия, которому оно перенаправляется, внешнее действие приостанавливается до момента обратного перенаправления (т. е. до выполнения кода ServiceModel).  
  
#### <a name="making-a-request-to-service-endpoint"></a>Создание запроса для конечной точки службы  
 Внешнее действие перенаправляется действию «ProcessAction» (D). В рамках этого действия отправляется сообщение запроса и принимается сообщение ответа. Действие прекращается, когда управление возвращается пользовательскому коду. Поскольку этот запрос является синхронным, внешнее действие приостанавливается до возврата управления.  
  
#### <a name="closing-communication-with-service-endpoint"></a>Закрытие связи с конечной точкой службы  
 Действие «закрыть» (I) клиента создается из внешнего действия. Оно идентично действиям "создать" и "открыть".  
  
### <a name="server"></a>Сервер  
  
#### <a name="setting-up-a-service-host"></a>Настройка узла службы  
 Действия «создать» и «открыть» (N и O) узла ServiceHost создаются из внешнего действия (M).  
  
 Действие прослушивания (P) создается при открывании узла ServiceHost для каждого прослушивателя. Действие прослушивания ожидает получения и обработки данных.  
  
#### <a name="receiving-data-on-the-wire"></a>Получение данных по сети  
 При получении данных по сети, действие «ReceiveBytes» создается в том случае, если он еще не существует (Q) для обработки полученных данных. Это действие можно использовать повторно для нескольких сообщений в пределах одного соединения или очереди.  
  
 Действие ReceiveBytes запускает действие ProcessMessage (R) при наличии достаточной информации для формирования сообщения действия SOAP.  
  
 При действии R обрабатываются заголовки сообщений и проверяется заголовок activityID. Если этот заголовок имеется, идентификатору действия присваивается значение ProcessAction. В противном случае создается новый идентификатор.  
  
 При обработке вызова создается действие ProcessAction (S), и выполняется перенаправление на это действие. Данное действие завершается при полном завершении обработки, связанной с входящим сообщением, включая выполнение пользовательского кода (T) и отправку ответного сообщения (если она предусмотрена).  
  
#### <a name="closing-a-service-host"></a>Закрытие узла службы  
 Действие "закрыть" (Z) узла ServiceHost создается из внешнего действия.  
  
 ![Синхронные сценарии с использованием HTTP &#47; TCP &#47; Именованные каналы](../../../../../docs/framework/wcf/diagnostics/tracing/media/sync.gif "синхронизации")  
  
 В \<A: name >, `A` содержится ссылочный символ, описывающий действие в приведенном выше тексте и в таблице 3. `Name` представляет собой сокращенное имя действия.  
  
 Если `propagateActivity` = `true`, Process Action на клиент и служба имеют одинаковый идентификатор действия.  
  
## <a name="synchronous-requestreply-with-errors"></a>Синхронный запрос/ответ с ошибками  
 Единственное отличие от предыдущего сценария заключается в том, что в качестве ответного сообщения возвращается сообщение об ошибке SOAP. Если `propagateActivity` = `true`, идентификатор действия сообщения запроса добавляется к сообщению об ошибке SOAP.  
  
## <a name="synchronous-one-way-without-errors"></a>Синхронная односторонняя связь без ошибок  
 Единственное отличие от первого сценария заключается в том, что на сервер не возвращается сообщение. Для протоколов, основанных на HTTP, на клиент все же возвращается состояние (допустимое или ошибка). Это объясняется тем, что HTTP - единственный протокол с семантикой запроса-ответа, принадлежащей к стеку протоколов [!INCLUDE[indigo2](../../../../../includes/indigo2-md.md)]. Поскольку обработка TCP скрыта от [!INCLUDE[indigo2](../../../../../includes/indigo2-md.md)], клиенту не отправляется подтверждение.  
  
## <a name="synchronous-one-way-with-errors"></a>Синхронная односторонняя связь с ошибками  
 Если произошла ошибка при обработке сообщения (Q или далее), клиенту не возвращается уведомление. Эта логика идентична сценарию «Синхронная односторонняя связь без ошибок». Если требуется получить сообщение об ошибке, использовать сценарий с односторонней связью не рекомендуется.  
  
## <a name="duplex"></a>Дуплекс  
 Отличие от предыдущих сценариев заключается в том, что клиент выполняет роль службы, создавая действия ReceiveBytes и ProcessMessage, подобно сценариям для асинхронной связи.
