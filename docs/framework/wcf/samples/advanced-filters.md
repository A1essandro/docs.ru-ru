---
title: Дополнительные фильтры
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 8d81590f-e036-4f96-824a-4a187f462764
caps.latest.revision: 23
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: a374765317751a5adc241941a0c0dc613a3ea2cc
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="advanced-filters"></a>Дополнительные фильтры
В этом образце демонстрируется служба маршрутизации [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]. Служба маршрутизации - это компонент [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], который упрощает включение маршрутизатора на основе содержимого в приложение. 'В этом образце стандартный образец [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] Calculator применяется для связи с использованием службы маршрутизации В этом образце показано определение логики маршрутизации на основе содержимого посредством использования фильтров сообщений и таблиц фильтров сообщений.  
  
> [!IMPORTANT]
>  Образцы уже могут быть установлены на компьютере. Перед продолжением проверьте следующий каталог (по умолчанию).  
>   
>  `<InstallDrive>:\WF_WCF_Samples`  
>   
>  Если этот каталог не существует, перейдите к [Windows Communication Foundation (WCF) и образцы Windows Workflow Foundation (WF) для .NET Framework 4](http://go.microsoft.com/fwlink/?LinkId=150780) Чтобы загрузить все [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] и [!INCLUDE[wf1](../../../../includes/wf1-md.md)] образцов. Этот образец расположен в следующем каталоге.  
>   
>  `<InstallDrive>:\WF_WCF_Samples\WCF\Basic\RoutingServices\AdvancedFilters`  
  
## <a name="sample-details"></a>Подробные сведения об образце  
 В следующей таблице представлены фильтры сообщений, которые добавляются в таблицу фильтров сообщений службы маршрутизации.  
  
|Фильтр|Правило|Приоритет|  
|------------|----------|--------------|  
|Если (имеет заголовок)|Округление|2|  
|Если (показан на Ep2)|Регулярное|1|  
|Если (показан с Address2)|Округление|1|  
|Если (RoundRobin1)|Регулярное|0|  
|Если (RoundRobin2)|Округление|0|  
  
 Фильтры сообщений и таблицы фильтров сообщений можно создавать и настраивать с помощью кода или в файле конфигурации приложения. Для этого образца есть фильтры сообщений и таблицы фильтров сообщений, определенные с помощью кода в файле RoutingService\routing.cs, а также определенные в файле конфигурации приложения RoutingService\App.config. В следующих абзацах описывается создание фильтров сообщений и таблиц фильтров сообщений для этого образца с помощью кода.  
  
 Сначала фильтр <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> ищет пользовательский заголовок. Следует отметить, что результатом <xref:System.ServiceModel.WSHttpBinding> является версия конверта с использованием SOAP 1.2, поэтому инструкция XPath настроена для использования пространства имен SOAP 1.2. Диспетчер пространств имен по умолчанию для <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> определяет пригодный для использования префикс для пространства имен SOAP 1.2, /s12. Однако диспетчер пространств имен по умолчанию не имеет пользовательского пространства имен, с помощью которого клиент определяет фактическое значение заголовка, поэтому необходимо задать префикс. Любое сообщение с этим заголовком будет соответствовать фильтру.  
  
```  
XPathMessageContext namespaceManager = new XPathMessageContext();  
namespaceManager.AddNamespace("custom", "http://my.custom.namespace/");  
  
XPathMessageFilter xpathFilter = new XPathMessageFilter("/s12:Envelope/s12:Header/custom:RoundingCalculator = 1", namespaceManager);  
```  
  
 Вторым фильтром является <xref:System.ServiceModel.Dispatcher.EndpointNameMessageFilter>, ему соответствует любое сообщение, полученное в конечной точке `calculatorEndpoint`. Имя конечной точки определяется при создании объекта конечной точки службы.  
  
```  
EndpointNameMessageFilter endpointNameFilter = new EndpointNameMessageFilter("calculatorEndpoint");  
```  
  
 Третьим фильтром является <xref:System.ServiceModel.Dispatcher.PrefixEndpointAddressMessageFilter>. Этому фильтру соответствует любое сообщение, поступающее в конечную точку, адрес которой соответствует указанному префиксу адреса (или передней части). В этом примере определяется префикс адреса «http://localhost/routingservice/router/rounding/». Это означает, что любые входящие сообщения, адресованные «http://localhost/routingservice/router/rounding/*» соответствует этому фильтру. В этом случае это сообщения, которые отображаются на конечную точку Округляющего калькулятора, который имеет адрес «http://localhost/routingservice/router/rounding/calculator».  
  
```  
PrefixEndpointAddressMessageFilter prefixAddressFilter = new PrefixEndpointAddressMessageFilter(new EndpointAddress("http://localhost/routingservice/router/rounding/"));  
```  
  
 Последние два фильтра сообщений являются пользовательскими <xref:System.ServiceModel.Dispatcher.MessageFilter>. В этом примере используется фильтр сообщений RoundRobin. Этот фильтр сообщений создан в предоставленном файле RoutingService\RoundRobinMessageFilter.cs. Собранные в одну группу, эти фильтры попеременно извещают о своем соответствии и несоответствии сообщению, при этом каждый раз только один из них возвращает значение `true`.  
  
```  
RoundRobinMessageFilter roundRobinFilter1 = new RoundRobinMessageFilter("group1");  
  
RoundRobinMessageFilter roundRobinFilter2 = new RoundRobinMessageFilter("group1");  
```  
  
 Затем все эти сообщения добавляются в таблицу <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>. При этом указываются приоритеты, в соответствии с которыми формируется порядок выполнения фильтров таблицей фильтров сообщений. Чем выше приоритет, тем скорее фильтр будет выполнен, чем ниже приоритет, тем позднее будет выполнен фильтр. Так, фильтр с приоритетом 2 выполняется перед выполнением фильтра с приоритетом 1. Если приоритет не указан, то уровень приоритета по умолчанию - 0. Таблица фильтров сообщений выполняет все фильтры на данном уровне приоритета, после чего переходит на следующий, более низкий уровень приоритета. Если на определенном уровне приоритета обнаружено совпадение, то таблица фильтров сообщений не продолжает поиск совпадений на следующем, более низком уровне приоритета.  
  
> [!NOTE]
>  Несмотря на то, что в этом примере показано, как использовать приоритеты фильтров сообщений, в целом для обеспечения большей производительности лучше проектировать и настраивать фильтры так, чтобы для правильной работы им не требовалось назначать приоритеты.  
  
 Первым добавляемым фильтром является фильтр XPath, ему устанавливается приоритет 2. Этот фильтр сообщений выполняется первым. Если он обнаруживает пользовательский заголовок, то сообщение направляется в конечную точку округляющего калькулятора независимо от результатов выполнения других фильтров.  
  
 На уровне приоритета 1 добавляются два фильтра. Опять-таки эти фильтры выполняются, только если сообщение не соответствует фильтру XPath с приоритетом 2. Эти два фильтра представляют два разных способа определения того, куда направлялось сообщение, когда оно появилось. Поскольку два этих фильтра, по сути, проверяют, пришло ли сообщение в одну из двух конечных точек, они могут выполняться на одном уровне приоритета, так как не могут одновременно возвратить значение `true`.  
  
 Наконец, на уровне приоритета 0 (самый низкий приоритет) выполняются фильтры сообщений RoundRobin. Поскольку фильтрам задается одинаковое имя группы, сообщение может одновременно соответствовать только одному из них. Поскольку все сообщения с пользовательским заголовком, а также все сообщения, адресованные определенным виртуализованным конечным точкам, перенаправлены, то фильтрами RoundRobin обрабатываются только те сообщения, которые были адресованы конечной точке маршрутизатора по умолчанию и которые не содержат пользовательского заголовка. Поскольку эти сообщения переключают сообщение для каждого вызова, половина операций переходит в конечную точку обычного калькулятора, а вторая половина - в конечную точку округляющего калькулятора.  
  
#### <a name="to-use-this-sample"></a>Использование этого образца  
  
1.  Откройте файл AdvancedFilters.sln с помощью [!INCLUDE[vs_current_long](../../../../includes/vs-current-long-md.md)].  
  
2.  Чтобы открыть **обозревателе решений**выберите **обозревателе решений** из **представление** меню.  
  
3.  В Visual Studio, нажмите клавишу F5 или CTRL + SHIFT + B.  
  
    1.  Если вы хотите автоматически загружались все необходимые проекты при нажатии клавиши F5, щелкните правой кнопкой мыши решение и выберите **свойства**. Выберите **запускаемый проект** узле **общие свойства** в левой области. Выберите **несколько запускаемых проектов** переключатель и задать все проекты, которые нужно иметь **запустить** действие.  
  
    2.  Если проект строится с помощью клавиш CTRL+SHIFT+B, необходимо запустить следующие приложения.  
  
        1.  Клиентская часть калькулятора (./CalculatorClient/bin/client.exe)  
  
        2.  Служба -калькулятора (./CalculatorService/bin/service.exe)  
  
        3.  Служба калькулятора с маршрутизацией (./RoundingCalcService/bin/service.exe)  
  
        4.  RoutingService (./RoutingService/bin/RoutingService.exe)  
  
4.  В консольном окне клиентской части калькулятора нажмите клавишу ВВОД, чтобы запустить клиент. Клиент возвращает список конечных точек назначения для выбора.  
  
5.  Выберите конечную точку назначения, введя соответствующую ей букву, и нажмите клавишу ВВОД.  
  
6.  Затем клиент спросит, требуется ли добавить пользовательский заголовок. Введите Y, чтобы сказать «Да», N, чтобы сказать «Нет», и нажмите клавишу ВВОД.  
  
7.  Результат будет зависеть от выбранных вариантов.  
  
    1.  Далее приведен вывод, возвращаемый при добавлении в сообщение пользовательского заголовка.  
  
        ```Output  
        Add(100,15.99) = 116  
        Subtract(145,76.54) = 68.5  
        Multiply(9,81.25) = 731.3  
        Divide(22,7) = 3.1  
        ```  
  
    2.  Далее приведен вывод, возвращаемый при выборе конечной точки округляющего калькулятора без пользовательского заголовка.  
  
        ```Output  
        Add(100,15.99) = 116  
        Subtract(145,76.54) = 68.5  
        Multiply(9,81.25) = 731.3  
        Divide(22,7) = 3.1  
        ```  
  
    3.  Далее приведен вывод, возвращаемый при выборе конечной точки обычного калькулятора без пользовательского заголовка.  
  
        ```Output  
        Add(100,15.99) = 115.99  
        Subtract(145,76.54) = 68. 46  
        Multiply(9,81.25) = 731.25  
        Divide(22,7) = 3.14285714285714  
        ```  
  
    4.  Далее приведен вывод, возвращаемый при выборе конечной точки маршрутизатора по умолчанию без пользовательского заголовка.  
  
        ```Output  
        Add(100,15.99) = 116  
        Subtract(145,76.54) = 68.46  
        Multiply(9,81.25) = 731.3  
        Divide(22,7) = 3.14285714285714  
        ```  
  
8.  Служба калькулятора и служба округляющего калькулятора также печатают журнал вызванных операций в соответствующих консольных окнах.  
  
9. В окне консоли клиента введите `quit` и нажмите клавишу ВВОД для выхода.  
  
10. Нажмите клавишу ВВОД в окнах консоли служб, чтобы завершить службы.  
  
## <a name="configurable-via-code-or-appconfig"></a>Настраивается в коде или в файле App.config  
 В поставляемой конфигурации образца поведение маршрутизатора определяется в файле App.config. Кроме того, можно изменить имя файла RoutingService\App.config на другое, чтобы он не был распознан, и удалить метки комментария с вызова метода `ConfigureRouterViaCode()` в файле RoutingService\routing.cs. Поведение маршрутизатора будет одинаковым для обоих методов.  
  
### <a name="scenario"></a>Сценарий  
 В этом образце показан маршрутизатор, работающий на основе содержимого и предоставляющий доступ к нескольким типам реализации служб через одну конечную точку.  
  
### <a name="real-world-scenario"></a>Реальный сценарий  
 Компания Contoso планирует провести виртуализацию всех служб, чтобы сделать общедоступной только одну конечную точку, через которую возможен доступ к нескольким различным типам служб. В этом случае применяются функции маршрутизации на основе содержимого, чтобы определить назначение для отправки входящих запросов.  
  
## <a name="see-also"></a>См. также  
 [Образцы размещения и сохраняемости образцы](http://go.microsoft.com/fwlink/?LinkId=193961)
