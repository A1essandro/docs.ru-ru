---
title: "Совместимость приложений в .NET Framework 4.5 | Документация Майкрософт"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- application compatibility, .NET Framework
- breaking changes [.NET Framework]
ms.assetid: 5c50747c-806c-44a9-ac58-5bbe12a284fa
caps.latest.revision: 76
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.translationtype: Human Translation
ms.sourcegitcommit: 19006cc5f24ffc66b92e53e8174c6bd33c249679
ms.openlocfilehash: 5f63c3217b6def96240447501247d22a1058cacf
ms.contentlocale: ru-ru
ms.lasthandoff: 05/22/2017

---
# <a name="application-compatibility-in-the-net-framework-45"></a>Совместимость приложений в .NET Framework 4.5
В этом разделе описываются проблемы совместимости приложений между .NET Framework 4 и 4.5, в том числе исправления и изменения, внесенные по отзывам пользователей. Большинство изменений не требуют каких-либо программных изменений в ваших приложениях. Те из них, которые могут потребовать внесения изменений в код, указаны в столбце "Последствия" таблиц.  
  
> [!IMPORTANT]
>  Обратите внимание, что [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] не поддерживается в [!INCLUDE[winxp](../../../includes/winxp-md.md)].  
  
 Сведения о проблемах совместимости между .NET Framework 4.5 и 4.5.1 см. в статье, посвященной [совместимости приложений в .NET Framework 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md).  
  
 Этот раздел описывает изменения в следующих областях.  
  
-   [Ядро](#core)  
  
-   [Данные](#sql)  
  
-   [Сеть](#network)  
  
-   [Сериализация](#serialize)  
  
-   [Печать](#Printing)  
  
-   [Инструменты и ресурсы](#tools)  
  
-   [ASP.NET](#asp)  
  
-   [ClickOnce](#ClickOnce)  
  
-   [Managed Extensibility Framework (MEF)](#mef)  
  
-   [Веб-приложения](#web)  
  
-   [Windows Communication Foundation (WCF)](#wcf)  
  
-   [Windows Forms](#winForms)  
  
-   [Windows Presentation Foundation (WPF)](#wpf)  
  
-   [Windows Workflow Foundation (WF)](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md#wwf)  
  
-   [XML, XSLT](#xml)  
  
 В этом разделе не рассматриваются типы и члены, объявленные устаревшими в [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Список этих элементов см. в разделе [What's Obsolete in the .NET Framework Class Library](../../../docs/framework/whats-new/whats-obsolete.md) (Устаревшие элементы библиотеки классов .NET Framework). Сведения о новых возможностях см. в статье [What's New in the .NET Framework](../../../docs/framework/whats-new/index.md) (Что нового в .NET Framework).  
  
<a name="core"></a>   
## <a name="core"></a>Ядро  
 Помимо следующих проблем совместимости приложений см. проблемы, связанные с сериализацией, в разделе [Сериализация](#serialize) .  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Методы <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> и <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>|Метод <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> больше не возвращает -1 и не вызывает исключение. Метод <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName> больше не вызывает исключение, если одна из коллекций помечена как завершенная.|Это изменение позволяет работать с коллекциями, если одна из коллекций пуста или завершена, но другая коллекция по-прежнему содержит элементы, которые можно извлечь.|  
|<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName>|Если сборка компилированных регулярных выражений создается с помощью [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] , но предназначена для [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], попытка использовать одно из регулярных выражений в этой сборке в системе с [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] создает исключение.|Чтобы обойти эту проблему, можно воспользоваться одним из следующих способов:<br /><br /> создать сборку, содержащую регулярные выражения, с помощью [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)];<br /><br /> использовать интерпретированное регулярное выражение.|  
|Удаление объектов <xref:System.Threading.Tasks.Task?displayProperty=fullName>|За исключением `Task.IAsyncResult.AsyncWaitHandle` методы <xref:System.Threading.Tasks.Task?displayProperty=fullName> больше не вызывают исключение <xref:System.ObjectDisposedException> после удаления объекта.|Это изменение обеспечивает возможность использования кэшированных задач. Например, метод может возвратить кэшированную задачу для представления уже выполненной операции вместо выделения новой задачи. В предыдущих версиях платформы .NET Framework это было невозможно, поскольку любой потребитель задачи мог удалить ее, что делало ее непригодной для использования.|  
|Ненаблюдаемые исключения в операциях <xref:System.Threading.Tasks.Task?displayProperty=fullName>|Поскольку класс <xref:System.Threading.Tasks.Task?displayProperty=fullName> представляет асинхронную операцию, он перехватывает все исключения невысокой серьезности, происходящие во время асинхронной обработки. В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], если исключение не наблюдается и код не ожидает задачу, исключение больше не распространяется на поток метода завершения и не приводит к сбою процесса во время сборки мусора.|Это изменение повышает надежность приложений, использующих класс <xref:System.Threading.Tasks.Task> для выполнения асинхронной обработки без наблюдения. Прежнее поведение можно восстановить, предоставив соответствующий обработчик для события <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=fullName>.|  
|Методы <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> с аргументами времени ожидания|В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] поведение этих методов было непоследовательным. По истечении времени ожидания, если одна или несколько задач были завершены или отменены до вызова метода, метод вызывал исключение <xref:System.AggregateException>. По истечении времени ожидания, если ни одна задача не была завершена или отменена до вызова метода, однако одна или несколько задач входили в эти состояния после вызова метода, метод возвращал значение `false`.<br /><br /> В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] эти перегрузки метода теперь возвращают `false`, если все задачи по-прежнему выполняются после истечения времени ожидания, и вызывают исключение <xref:System.AggregateException>, только если входная задача была отменена (независимо от того, была ли она отменена до или после вызова метода), а никакие другие задачи не выполняются.|Это изменение делает поведение метода последовательным. Тем не менее возможно (хотя и маловероятно), чтобы код приложения использовал перегрузки <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> с временем ожидания для вызова исключения, когда до истечения времени ожидания произошел сбой хотя бы одной задачи или хотя бы одна задача была отменена. В этом случае свойство <xref:System.Threading.Tasks.Task.IsCanceled%2A?displayProperty=fullName> может использоваться для той же цели.|  
|Поддержка переадресации типов при настройке для различных версий|Новая функция CodeDOM позволяет компилятору выполнять компиляцию для целевой версии mscorlib.dll вместо версии mscorlib.dll, соответствующей [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|Это изменение предотвращает появление предупреждений компилятора (и ошибок компиляции в случаях, когда предупреждения обрабатываются как ошибки), когда CodeDOM находит два определения для типов, для которых была выполнена переадресация типа. Это изменение может иметь непредвиденные побочные эффекты, только если в одном месте смешаны различные версии ссылочных сборок.|  
|<xref:System.Collections.Generic.List%601.ForEach%2A?displayProperty=fullName>|Перечислитель вызывает исключение <xref:System.InvalidOperationException>, если какой-либо элемент в коллекции изменен.|Это изменение относится только к приложениям, нацеленным на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], и не должно иметь отрицательных последствий. Оно способствует целостности данных и повышает вероятность выявления возможных состояний гонки.|  
|<xref:System.Uri?displayProperty=fullName>|Два изменения в синтаксическом анализе международных идентификаторов ресурсов (IRI) влияют на URI в приложениях, нацеленных на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]:<br /><br /> Элемент [\<iriParsing>](../../../docs/framework/configure-apps/file-schema/network/iriparsing-element-uri-settings.md) включен по умолчанию и не может быть отключен. Раньше по умолчанию он был отключен.<br /><br /> Форма нормализации Юникода C (NFC) больше не будет выполняться на частях URI, отличных от имени компьютера. Ранее, когда элемент `<iriParsing>` был включен, NFC выполнялась на всем URI.|URI, содержащие нормализованные имена файлов не по форме NFC (форма нормализации С), не будут нормализованы по форме NFC. Если при анализе IRI используются ненормализованные строки для доступа к файлам, имеющим нормализованные имена файлов, возможен сбой приложения. Это затрагивает только приложения, нацеленные на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Недопустимый URL-адрес `mailto:` вызывает исключение в конструкторе класса <xref:System.Uri>.|Это затрагивает только приложения, перекомпилированные и нацеленные на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|В приложениях, нацеленных на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], точки в конце сегмента пути в исходной строке URI (например, `http://www.proseware.com/LLC./About.aspx`) сохраняются. (Обратите внимание, что сегменты пути, которые состоят ровно из одной или двух точек, например `http://www.proseware.com/..` или `http://www.proseware.com/./default.htm`, удаляются, но сегменты пути, имеющие более двух последовательных точек (например, `http://localhost/dir1/.../dir2`), сохраняются.)|Это изменение затрагивает только приложения, нацеленные на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. В приложениях, в которых предполагается, что точки в конце сегментов удалены, могут возникать сбои.|  
|<xref:System.Uri?displayProperty=fullName>|В приложениях, предназначенных для [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], запросы с URI `file://` разрешены; символ ? не экранируется, так как он интерпретируется как часть пути.|Это изменение затрагивает только приложения, нацеленные на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. В приложениях, в которых используется экранирование символа ? могут возникать сбои.|  
|<xref:System.Uri?displayProperty=fullName>|В приложениях, нацеленных на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], управляющие символы Юникода от U+0080 до U+009F кодируются неправильно.|Как правило, управляющие символы Юникода не используются в URI.|  
|<xref:System.Uri.EscapeDataString%2A?displayProperty=fullName>, <xref:System.Uri.EscapeUriString%2A?displayProperty=fullName> и <xref:System.Uri.UnescapeDataString%2A?displayProperty=fullName>|Список зарезервированных и незарезервированных символов теперь поддерживает [RFC 3986](http://tools.ietf.org/html/rfc3986).|Конкретные изменения:<br /><br /> Метод <xref:System.Uri.EscapeDataString%2A> преобразует в escape-последовательность зарезервированные символы в соответствии с RFC 3986.<br /><br /> Метод <xref:System.Uri.EscapeUriString%2A> не преобразует в escape-последовательность зарезервированные символы.<br /><br /> Метод <xref:System.Uri.UnescapeDataString%2A> не создает исключение, если ему встречается неверная escape-последовательность.<br /><br /> Преобразование незарезервированных символов в escape-символы отменяется.|  
|<xref:System.Uri.IsWellFormedUriString%2A?displayProperty=fullName>|Начиная с .NET Framework 4.5, строки всегда считаются правильно сформированными в соответствии с [RFC 3986](http://tools.ietf.org/html/rfc3986) и [RFC 3987](http://tools.ietf.org/html/rfc3987). В предыдущих версиях .NET Framework строка считается как имеющая правильный формат в соответствии с RFC 3986 и RFC 3987 только в том случае, если включен синтаксический анализ URI и синтаксический анализ IDN.|Для приложений, предназначенных для .NET Framework 4.5 или более поздних версий, этот метод возвращает `false` для некоторых URI, которые считаются правильно сформированными для приложений, предназначенных для более ранних версий платформы .NET Framework. Например, относительный URI, который содержит двоеточие в первом сегменте (например, "2013.05.29_14:33:41"), больше не считается правильно сформированным.<br /><br /> Обратите внимание, что это изменение касается только приложений, предназначенных для .NET Framework 4.5 или более поздних версий.|  
|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> теперь может получить доступ к свойству <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>. Неправильные реализации <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> теперь могут привести к неопределенному поведению в вызовах метода <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>.|Результирующая задача не завершится, если реализация свойства <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> неправильно вернет значение `true`.|  
  
<a name="sql"></a>   
## <a name="data"></a>Данные  
  
### <a name="sqlclient"></a>SQLClient  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Возможность подключения к базе данных SQL Server из управляемого кода, работающего под [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|Существующий путь кода синхронного API был изменен для добавления поддержки асинхронных операций.|Наличие базовых поставщиков услуг Winsock, не относящихся к IFS, или многоуровневых поставщиков услуг может помешать возможности подключения к SQL Server. Дополнительные сведения см. в статье [SetFileCompletionNotificationModes API causes an I/O completion port not to work correctly if a non-IFS LSP is installed](http://go.microsoft.com/fwlink/p/?LinkId=256032) (API SetFileCompletionNotificationModes приводит к неправильной работе порта завершения ввода-вывода при установке многоуровневого поставщика услуг, отличного от IFS) на веб-сайте службы технической поддержки Microsoft.|  
|Тип <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Подключения к базам данных SQL Server 1997 больше не поддерживаются.|Приложения, работающие под [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], не смогут подключиться к базам данных SQL Server 1997.|  
|Тип <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Подключения к базам данных SQL Server с помощью протокола Virtual Interface Adapter (VIA) больше не поддерживаются.|Приложения, работающие под [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], не смогут подключиться к базам данных SQL Server 1997 с использованием VIA.|  
|Тип <xref:System.Data.SqlClient.SqlBulkCopy?displayProperty=fullName>|При вставке данных в столбец <xref:System.Data.SqlClient.SqlBulkCopy> использует кодировку целевого столбца, а не кодировку по умолчанию для типов `VARCHAR` и `CHAR`.|Это изменение исключает возможность повреждения данных, вызванного использованием кодировки по умолчанию, если в целевом столбце не используется кодировка по умолчанию. В редких случаях существующее приложение может создавать исключение <xref:System.Data.SqlClient.SqlException>, если при изменении кодировки создаются слишком большие для целевого столбца данные.|  
|Порядок сортировки <xref:System.Data.SqlClient?displayProperty=fullName>|В данных `sql_variant` используется сортировка `sql_variant`, а не сортировка базы данных.|Это изменение предотвращает возможное повреждение данных, если сортировка базы данных отличается от сортировки `sql_variant`. В приложениях, в которых предполагается, что данные будут повреждены, могут возникать сбои.|  
  
### <a name="entity-framework"></a>Entity Framework  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Файлы журналов, создаваемые методом <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName>|Если вы вызываете метод <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> напрямую или с помощью Code First, передавая в строке подключения поставщик SqlClient и значение `AttachDBFilename`, он создает файл журнала с именем *filename*_log.ldf вместо *filename*.ldf (где *filename* — имя файла, заданное значением `AttachDBFilename`).|Это изменение улучшает отладку, предоставляя файл журнала, имя которого соответствует спецификациям SQL Server. Непредвиденных побочных эффектов быть не должно.|  
|API-интерфейсы языка определения данных DDL|Поведение API-интерфейсов языка DDL при заданном значении `AttachDBFilename` изменилось следующим образом:<br /><br /> В строках подключения не требуется указывать значение `Initial Catalog`. Раньше и `AttatchDBFilename`, и `Initial Catalog` были обязательными.<br /><br /> Если указаны и `AttatchDBFilename`, и `Initial Catalog` и данный MDF-файл существует, метод <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> возвращает значение `true`. Раньше он возвращал значение `false`.<br /><br /> Если указаны и `AttatchDBFilename`, и `Initial Catalog` и данный MDF-файл существует, вызов метода <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> удаляет файлы.<br /><br /> При вызове метода <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName>, когда в строке подключения указано значение `AttachDBFilename` с несуществующим MDF-файлом и `Initial Catalog` не существует, этот метод вызывает исключение <xref:System.InvalidOperationException>. Раньше он вызывал исключение <xref:System.Data.SqlClient.SqlException>.|Эти изменения облегчают создание средств и приложений, в которых используются API-интерфейсы DDL. Эти изменения могут повлиять на совместимость приложений в следующих сценариях:<br /><br /> Пользователь пишет код, который выполняет команду `DROP DATABASE` напрямую, а не вызывает метод <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName>, если метод <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> возвращает значение `true`. Это нарушает логику существующего кода, если база данных не присоединена, но MDF-файл существует.<br /><br /> Пользователь пишет код, который ожидает, что метод <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> вызовет исключение <xref:System.Data.SqlClient.SqlException>, а не исключение <xref:System.InvalidOperationException>, когда `Initial Catalog` и MDF-файл не существуют.|  
|Методы <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName> и <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A?displayProperty=fullName>|Если создание объектов базы данных завершается сбоем после создания пустой базы данных, метод пытается удалить созданную базу данных и распространяет исходное исключение <xref:System.Data.SqlClient.SqlException>. Если попытка удаления базы данных завершается неудачей, метод вызывает исключение <xref:System.InvalidOperationException>.|Это изменение предотвращает создание пустой бесполезной базы данных. Обработка исключений может несколько измениться, поскольку при успешном удалении базы данных теперь распространяется исходное исключение <xref:System.Data.SqlClient.SqlException>.|  
|Методы <xref:System.Data.Objects.ObjectContext.Translate%2A?displayProperty=fullName> и <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A?displayProperty=fullName>|Если `T` является типом перечисления, этот метод правильно возвращает данные из базы данных.  Ранее типы перечисления не поддерживались, поэтому результат всегда приводился к нулю или преобразовывался в тип перечисления. Базовые типы, которые не поддерживаются Entity Framework, например <xref:System.UInt16>, <xref:System.UInt32> и <xref:System.UInt64>, по-прежнему возвращают нуль или преобразуются в тип перечисления с базовым значением нуль.|Поддержка перечислений — новая возможность в Entity Framework в [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Однако если код разработчика предполагает получение нулевого результата, может возникнуть ошибка приложения, в зависимости от конкретного кода.|  
  
### <a name="linq"></a>LINQ  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Метод <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>|Метод возвращает кэшированный внутренний экземпляр вместо возвращения нового типа <xref:System.Collections.Generic.IEnumerable%601>.|Это изменение позволяет повысить производительность. Однако в коде, в котором предполагается получение двух уникальных пустых типов из нескольких вызовов <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>, возникнет сбой.|  
  
<a name="network"></a>   
## <a name="networking"></a>Сетевое взаимодействие  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Типы и члены пространства имен <xref:System.Net.PeerToPeer.Collaboration?displayProperty=fullName>|Типы и члены не поддерживаются в [!INCLUDE[win8](../../../includes/win8-md.md)]. При попытке их вызова создается исключение <xref:System.PlatformNotSupportedException>.|Использовать эти типы и члены в приложениях в [!INCLUDE[win8](../../../includes/win8-md.md)] больше нельзя.|  
|Сериализация и десериализация объектов <xref:System.Net.Mail.MailMessage>.|В .NET Framework 4.5 сообщения электронной почты могут содержать символы, отличные от ASCII. В .NET Framework 4 поддерживаются только символы ASCII.|В .NET Framework 4 не могут быть десериализованы объекты <xref:System.Net.Mail.MailMessage>, содержащие отличные от ASCII символы и сериализованные в .NET Framework 4.5.|  
  
<a name="Printing"></a>   
## <a name="printing"></a>Печать  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|<xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>|Это свойство предоставляет поток задания печати и разрешает пользователю отправлять необработанные данные в компоненты печати базовой операционной системы путем записи в этот поток.<br /><br /> Начиная с .NET Framework 4.5 в Windows 8 и более поздних версиях операционной системы Windows данные, которые записываются в этот поток, должны быть в формате XPS, как поток пакета.|Для вывода содержимого печати выполните одно из следующих действий.<br /><br /> Используйте класс <xref:System.Windows.Xps.XpsDocumentWriter> класса для вывода содержимого печати. Это рекомендуемый вариант.<br /><br /> Убедитесь, что данные, отправляемые в поток, возвращенный свойством <xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>, находятся в формате XPS, как поток пакета.|  
  
<a name="serialize"></a>   
## <a name="serialization"></a>Сериализация  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Сериализация с помощью класса <xref:System.Xml.Serialization.XmlSerializer>|В WCF 4.5 класс <xref:System.Xml.Serialization.XmlSerializer> был оптимизирован для удаления зависимости от компилятора C#. Это изменение обеспечивает значительный прирост производительности в сценариях холодного запуска.|Это изменение может вызвать проблемы в XML-коде сериализации, который был скомпилирован в WCF 4, но работает в WCF 4.5. Если при запуске существующего XML-кода сериализации в WCF 4.5 возникают какие-либо проблемы, используйте следующий элемент конфигурации, чтобы вернуться к поведению XmlSerializer в WCF 4.<br /><br /> `<configuration>    <system.xml.serialization>    <xmlSerializer useLegacySerializerGeneration="true"/>    </system.xml.serialization> </configuration>`|  
|Сериализация и десериализация с использованием класса <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter?displayProperty=fullName>|Сериализация с использованием <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> позволяет закодировать внутреннее состояние объекта, которое не обязательно будет одинаковым в разных версиях платформы .NET Framework.  Если существуют различия, десериализация содержимого, сериализованного в одной версии платформы .NET Framework, может завершиться сбоем в других версиях.|Класс <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> не гарантирует совместимости с другими версиями. Используйте вместо него классы <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName> и <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=fullName>.|  
  
<a name="tools"></a>   
## <a name="tools-and-resources"></a>Инструменты и ресурсы  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|MSBuild|При запуске MSBuild в командной строке MSBuild учитывает файлы конфигурации решения, которые отключают сборки определенных проектов.|MSBuild ведет себя одинаково при вызове из Visual Studio и при запуске из командной строки. Не нужно создавать отдельные решения или удалять проекты из решения, чтобы собрать подмножество проектов в решении.|  
|MSBuild|Свойство `TreatAsLocalProperty` в файлах проектов MSBuild предотвращает переопределение на глобальном уровне определенных свойств, включая свойство `OutDir`.|Переопределения свойства `OutDir` могут привести к потенциальному сбою, если `OutDir` является глобальным свойством, которое переопределяется после импорта файла MS.Common.Targets.|  
|Отчеты об ошибках Windows: сегменты службы "Доктор Ватсон"|Управляемые сбои группируются в категории, основанные на ряде критериев, одним из которых была версия сборки. В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] вместо версии сборки используется версия файла.|Поскольку версия сборки меняется только от одного основного выпуска к другому, использование версии файла вместо версии сборки в качестве категории позволяет указать определенную версию сборки, которая фигурировала в управляемом сбое.|  
|MSBuild|Данные из проектов в коллекции <xref:Microsoft.Build.Evaluation.ProjectCollection?displayProperty=fullName> не уничтожаются при сборке мусора автоматически.|Если выполняется явная загрузка проекта в коллекцию <xref:Microsoft.Build.Evaluation.ProjectCollection>, необходимо вызвать метод <xref:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject%28Microsoft.Build.Evaluation.Project%29> для каждого члена коллекции.|  
  
<a name="asp"></a>   
## <a name="aspnet"></a>ASP.NET  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Средство регистрации IIS ASP.NET (aspnet_regiis.exe)|В [!INCLUDE[win8](../../../includes/win8-md.md)] параметры `–i` и `–u` для установки и удаления ASP.NET не поддерживаются.|Для установки или удаления ASP.NET 4.5 с IIS 8 используйте диалоговое окно **Turn Windows Features On/Off** (Включение и отключение компонентов Windows), инструмент Server Management или программу командной строки `dism.exe`.|  
|Элемент управления <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>|Событие <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName> больше не заставляет элемент управления <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName> вызывать привязку данных для изменений в параметрах создания/обновления/удаления.|Это изменение исключает лишнее обращение к базе данных, не допускает сброса значений элементов управления и позволяет получить поведение, согласованное с другими элементами управления данными, такими как <xref:System.Web.UI.WebControls.SqlDataSource> и <xref:System.Web.UI.WebControls.ObjectDataSource>. Это изменение дает другое поведение в том маловероятном случае, когда в приложении предполагается вызов привязки данных в событии <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>.|  
|Методы <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>, <xref:System.Net.WebUtility.UrlDecode%2A?displayProperty=fullName> и [System.Web.Helpers.Json.Decode](https://msdn.microsoft.com/library/system.web.helpers.json.decode.aspx)|По умолчанию методы декодирования больше не декодируют недопустимую входную последовательность в недопустимую строку UTF-16. Вместо этого они возвращают исходные входные данные.|Изменение в выходных данных декодера может иметь значение, только если в строках хранятся двоичные данные, а не данные UTF-16. Чтобы явно контролировать это поведение, присвойте атрибуту `aspnet:AllowRelaxedUnicodeDecoding` элемента [\<appSettings>](http://msdn.microsoft.com/en-us/0d65a3f1-c522-423d-89b6-44921b6daebb) значение `true`, чтобы разрешить устаревшее поведение, или значение `false`, чтобы разрешить текущее поведение.|  
|Метод <xref:System.Net.WebUtility.HtmlEncode%2A?displayProperty=fullName>|Для приложений, нацеленных на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], символы, не входящие в базовый многоязыковый набор кодировок (BMP), правильно передаются в оба конца, если они передаются методу <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>.|Это изменение никак не должно отразиться на текущих приложениях. Для восстановления исходного поведения задайте в атрибуте `targetFramework` элемента [\<httpRuntime>](http://msdn.microsoft.com/library/e1f13641\(v=vs.100\).aspx) строку, отличную от "4.5". Также можно задать атрибуты `unicodeEncodingConformance` и `unicodeDecodingConformance` элемента конфигурации `<webUtility>`, чтобы контролировать это поведение вне зависимости от целевой версии .NET Framework.|  
|Свойство <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=fullName>|Кодировка UTF-7 запрещена.|Данные для приложений, которые зависят от поступающих данных UTF-7, в некоторых случаях декодируются неверно. Такая ситуация должна возникать редко, однако вы можете восстановить устаревшее поведение с помощью атрибута `aspnet:AllowUtf7RequestContentEncoding` элемента [\<appSettings>](http://msdn.microsoft.com/en-us/0d65a3f1-c522-423d-89b6-44921b6daebb).|  
|<xref:System.Web.HttpUtility.JavaScriptStringEncode%2A?displayProperty=fullName>|Начиная с [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], метод экранирует символ амперсанда (&).|Если в приложении предполагается прежнее поведение этого метода, можно добавить параметр `aspnet:JavaScriptDoNotEncodeAmpersand` в [элемент appSettings ASP.NET](http://msdn.microsoft.com/en-us/bb60e711-0669-4118-a54d-8dd71e009a00) в файле конфигурации.|  
|Методы <xref:System.Web.Security.MachineKey.Encode%2A?displayProperty=fullName> и <xref:System.Web.Security.MachineKey.Decode%2A?displayProperty=fullName>|В настоящее время эти методы считаются устаревшими.|При компиляции кода, который вызывает эти методы, создается предупреждение компилятора. Взамен рекомендуется использовать <xref:System.Web.Security.MachineKey.Protect%2A?displayProperty=fullName> и <xref:System.Web.Security.MachineKey.Unprotect%2A?displayProperty=fullName>.|  
  
<a name="ClickOnce"></a>   
## <a name="clickonce"></a>ClickOnce  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Приложения опубликованы с помощью ClickOnce с использованием сертификата подписи кода SHA-256.|Исполняемый файл подписывается с помощью SHA256. Ранее он подписывался с помощью SHA1 независимо от того, какой использовался сертификат подписи кода: SHA-1 или SHA-256. Применение:<br /><br /> Все приложения, собранные с помощью Visual Studio 2012 или более поздней версии.<br /><br /> Приложения, собранные с помощью Visual Studio 2010 или более ранней версии в системах с установленной платформой .NET Framework 4.5.<br /><br /> Кроме того, при наличии .NET Framework 4.5 или более поздней версии манифест ClickOnce также подписывается с помощью SHA-256 для сертификатов SHA-256 независимо от версии .NET Framework, в которой проводилась компиляция.|Изменение подписи исполняемого файла ClickOnce влияет только на системы Windows Server 2003; потребуется установка компонента из [статьи базы знаний 938397](http://support.microsoft.com/kb/938397) .<br /><br /> Изменение подписи манифеста с SHA-256, даже если целевая платформа приложения — .NET Framework 4 или более ранней версии, вводит зависимость среды выполнения для .NET Framework 4.5 или более поздней версии. Эта проблема устранена в обновлении Visual Studio 2013 Update 3 и в [!INCLUDE[net_v46](../../../includes/net-v46-md.md)]. Решение для [!INCLUDE[net_v46](../../../includes/net-v46-md.md)] см. в статье [Runtime Changes in the .NET Framework 4.6](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-6.md) (Изменения среды выполнения в .NET Framework 4.6).|  
  
<a name="mef"></a>   
## <a name="managed-extensibility-framework-mef"></a>Managed Extensibility Framework (MEF)  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|<xref:System.ComponentModel.Composition.Primitives.ComposablePartCatalog?displayProperty=fullName> и производные классы|Начиная с [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], каталоги MEF реализуют <xref:System.Collections.IEnumerable> и поэтому больше не могут использоваться для создания сериализатора (объекта <xref:System.Xml.Serialization.XmlSerializer>).|При попытке сериализации каталога MEF происходит вызов исключения.|  
  
<a name="web"></a>   
## <a name="web-applications"></a>Веб-приложения  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Размещение управляемых элементов управления .NET Framework 1.1 и 2.0 в браузере|Размещение этих элементов управления в Internet Explorer блокируется.|Internet Explorer не сможет запустить приложение, в котором используются управляемые элементы управления, размещенные в браузере. Прежнее поведение можно восстановить путем назначения параметру EnableIEHosting в подразделе реестра HKLM/SOFTWARE/MICROSOFT/.NETFramework значения 1 для систем x86 и для 32-разрядных процессов в системах x64, а также путем назначения параметру EnableIEHosting в подразделе реестра HKLM/SOFTWARE/Wow6432Node/Microsoft/.NETFramework значения 1 для 64-разрядных процессов в системах x64.|  
  
<a name="wcf"></a>   
## <a name="windows-communication-foundation-wcf"></a>Windows Communication Foundation (WCF)  
 Помимо следующих проблем совместимости приложений см. проблемы, связанные с сериализацией, в разделе [Сериализация](#serialize).  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Сообщения в веб-службах WCF, размещенных в службах IIS или ASP.NET Development Server, в которых превышены значения `maxRequestLength` (ASP.NET) или `maxReceivedMessageSize` (WCF)|Код состояния HTTP изменился с 400 (Недопустимый запрос) на 413 (Слишком большой объект запроса), и сообщения, в которых превышено значение `maxRequestLength` или `maxReceivedMessageSize`, вызывают исключение <xref:System.ServiceModel.ProtocolException>. Сюда входят случаи, в которых режимом передачи является <xref:System.ServiceModel.TransferMode>.|Это изменение облегчает отладку в тех случаях, когда длина сообщения превышает ограничения, установленные ASP.NET или WCF.<br /><br /> Необходимо внести изменения во весь код, который выполняет обработку на основании кода состояния HTTP 400.|  
|`Replace` в URL-адресах OData|Метод `Replace` в URL-адресах OData по умолчанию отключен.|Когда метод `Replace` в OData отключен (теперь по умолчанию), пользовательский запрос вызовет исключение и завершится сбоем.|  
|<xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>|Объект <xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName> теперь не добавляет конечную точку по умолчанию, если в коде приложения явным образом добавлена конечная точка.|Если клиентское приложение пытается подключиться к конечной точке, которая больше не добавляется по умолчанию, возникает ошибка HTTP.|  
  
<a name="winForms"></a>   
## <a name="windows-forms"></a>Windows Forms  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|System.Drawing.dll|Свойству `CheckForOverflowUnderflow` для сборки устанавливается значение `true`.|Раньше при переполнениях результат усекался без уведомления. Теперь создается исключение <xref:System.OverflowException>,|  
|Конструктор <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>|Этот конструктор не рекомендуется к использованию.|Конструктор не работает на 64-разрядных системах. Взамен рекомендуется использовать конструктор <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Drawing.Imaging.EncoderParameterValueType%2CSystem.IntPtr%29?displayProperty=fullName>.|  
  
<a name="wpf"></a>   
## <a name="windows-presentation-foundation-wpf"></a>Windows Presentation Foundation (WPF)  
 Помимо следующих проблем совместимости приложений см. проблемы, связанные с сериализацией, в разделе [Сериализация](#serialize).  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Свойство <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A?displayProperty=fullName>|Ограничение по умолчанию максимального количества операций отмены для классов <xref:System.Windows.Controls.TextBox> и <xref:System.Windows.Controls.RichTextBox> изменилось с -1 (без ограничений) на 100.|Это изменение не должно иметь никаких отрицательных последствий. Однако можно явно задать свойство <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> после создания экземпляра элемента управления.|  
|Перечисление <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>|В перечисление были добавлены члены <xref:System.Windows.Controls.PageRangeSelection> и <xref:System.Windows.Controls.PageRangeSelection>.|Это изменение не должно никак отразиться на существующих приложениях. Значением по умолчанию для существующих элементов, использующих это перечисление, является <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>.|  
|Элементы <xref:System.Windows.DataTemplate>|Элементы <xref:System.Windows.DataTemplate> теперь отображаются в представлении элементов управления дерева автоматизации ИП (UIA).|Это изменение повышает доступность. Однако оно имеет последствия для средств тестирования, в которых используется прежняя структура дерева автоматизации ИП для обнаружения соседских элементов.|  
|Синхронизация свойства <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> и свойства, к которому оно привязано|В некоторых случаях свойство <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> отражает предыдущее значение привязанного к данным свойства, если свойство изменяется во время операции записи с привязкой к данным.|Это не должно иметь отрицательных последствий. Однако можно восстановить прежнее поведение, установив свойству <xref:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty%2A?displayProperty=fullName> значение `false`.|  
|Свойство <xref:System.Windows.Controls.TextBox?displayProperty=fullName>|Если элемент управления <xref:System.Windows.Controls.TextBox?displayProperty=fullName> неактивен, выбранный текст внутри поля отображается цветом, отличным от используемого, когда текстовое поле активно.|Восстановить прежнее поведение можно путем установки свойству <xref:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported%2A?displayProperty=fullName> значения `false`.|  
|<xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>|Если элемент управления, производный от <xref:System.Windows.Controls.Primitives.MultiSelector> с <xref:System.Windows.Controls.Primitives.MultiSelector.CanSelectMultipleItems%2A> и имеющий значение `true`, содержит повторяющиеся значения в своей коллекции <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, повторяющиеся элементы появляются более одного раза. Удаление этих элементов из источника данных (например, путем вызова `Items.Clear`) не приведет к их удалению из коллекции <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>. Будет удален только первый экземпляр.<br /><br /> Последующее использование коллекции <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, например вызов `SelectedItems.Clear`, может вызвать проблемы, например <xref:System.ArgumentException>, так как коллекция <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> содержит элементы, которые отсутствуют в источнике данных.|Эта проблема была устранена в [!INCLUDE[net_v462](../../../includes/net-v462-md.md)]. Если коллекция <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> содержит повторяющиеся элементы, удалите их из источника данных, а чтобы продолжить работу с коллекцией <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, выполните обновление до [!INCLUDE[net_v462](../../../includes/net-v462-md.md)].|  
|<xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>|В [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] этот метод возвращает ссылку на текущий экземпляр. В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] он возвращает новый экземпляр.|Код, в котором предполагаются, что равные ссылки указывают на то, что выполняющий поток находится в правильном контексте, теперь будет выполняться правильно. Однако из-за изменения код, который вызывает метод <xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>, необходимо протестировать.|  
|Добавлена возможность отслеживания сообщений `WM_POWERBROADCAST` с помощью обработчика путем вызова метода <xref:System.Windows.Interop.HwndSource.AddHook%2A?displayProperty=fullName>.|Окно необходимо явно зарегистрировать для получения уведомлений `WM_POWERBROADCAST`, передав его дескриптор в функцию [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx). До версии [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] система WPF автоматически выполняла регистрацию для всех окон. Начиная с версии [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], WPF автоматически регистрирует одно специальное окно, но не регистрирует большинство окон приложений.|Код, который обрабатывает уведомления `WM_POWERBROADCAST`, не выполняется.<br /><br /> Чтобы продолжить получать уведомления `WM_POWERBROADCAST`, вызовите функцию [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx) для регистрации окна WPF (как правило, главного окна приложения) для отправки уведомлений `WM_POWERBROADCAST`. В приложениях WPF, разрабатываемых с помощью C#, для этого также необходимо установить флажок **Разрешить небезопасный код** в свойствах проекта на вкладке **Сборка**.<br /><br /> Кроме того, если вы регистрируете окно, которое не сохраняется до завершения работы приложения, необходимо отменить его регистрацию путем вызова функции [UnregisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373237.aspx) и передачи в нее дескриптора `HPOWERNOTIFY`, возвращенного вызовом функции [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx).|  
  
<a name="wwf"></a>   
## <a name="windows-workflow-foundation-wf"></a>Windows Workflow Foundation (WF)  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Безопасность System.Activities.dll|Сборка помечена атрибутом <xref:System.Security.AllowPartiallyTrustedCallersAttribute>.|Производные классы не могут быть помечены атрибутом <xref:System.Security.SecurityCriticalAttribute>. Раньше производные типы должны были быть помечены атрибутом <xref:System.Security.SecurityCriticalAttribute>. Однако это изменение не должно иметь никаких реальных последствий.|  
|Типы и члены WF 3.0|Типы и члены WF 3.0 теперь помечены как устаревшие.|При попытке скомпилировать исходный код, в котором используются типы или члены WF 3.0, возникнет ошибка компилятора. Необходимо использовать типы и члены WF 4 в пространствах имен <xref:System.Activities>.|  
|Класс <xref:System.Activities.Presentation.DragDropHelper?displayProperty=fullName>|Класс <xref:System.Activities.Presentation.DragDropHelper> включает в себя новые методы, поддерживающие операции перетаскивания с несколькими объектами. Существующие методы перетаскивания, которые поддерживают перетаскивание одного объекта, являются устаревшими. (Дополнительные сведения см. в разделе [What's Obsolete in the .NET Framework Class Library](../../../docs/framework/whats-new/whats-obsolete.md) (Устаревшие элементы библиотеки классов .NET Framework).)|Хотя старые методы являются нерекомендуемыми, они по-прежнему поддерживаются как компилятором, так и средой CLR. Однако новые методы предоставляют более обширную функциональность. Ниже указаны рекомендуемые замены для некоторых из существующих методов:<br /><br /> Используйте <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName> вместо <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName>.<br /><br /> Используйте <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Activities.Presentation.WorkflowViewElement%29> вместо <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Windows.DragEventArgs%29>.<br /><br /> Используйте <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItems%28System.Windows.DragEventArgs%29> вместо <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItem%28System.Windows.DragEventArgs%29>.<br /><br /> Используйте <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObjects%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29> вместо <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObject%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29>.|  
|Разрешение перегрузок вызовов метода <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>|В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] добавлены новые перегрузки, включающие параметр типа <xref:System.Action?displayProperty=fullName>. Если существующий код перекомпилируется, компиляторы могут разрешить вызовы методов <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>, имеющие параметр <xref:System.Delegate>, как вызовы методов <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> с параметром <xref:System.Action?displayProperty=fullName>.|Если вызов перегрузки <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> с параметром <xref:System.Delegate> разрешается как вызов перегрузки <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> с параметром <xref:System.Action?displayProperty=fullName>, возможны следующие различия в поведении:<br /><br /> При возникновении исключения события <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter?displayProperty=fullName> и <xref:System.Windows.Threading.Dispatcher.UnhandledException?displayProperty=fullName> не вызываются. Вместо этого исключения обрабатываются событием <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>.<br /><br /> Вызовы некоторых членов, например свойства <xref:System.Windows.Threading.DispatcherOperation.Result%2A?displayProperty=fullName>, блокируются до тех пор, пока операция не будет завершена.|  
|Класс <xref:System.Activities.Expressions.Literal%601?displayProperty=fullName>|Связанный объект <xref:System.Windows.Markup.ValueSerializer> преобразует объект <xref:System.DateTime> или <xref:System.DateTimeOffset>, компоненты `Second` и `Millisecond` которого не равны нулю и (для значения <xref:System.DateTime>) свойство <xref:System.DateTime.Kind%2A?displayProperty=fullName> которого не равно <xref:System.DateTimeKind>, в синтаксис элемента свойства вместо строки.|Это изменение позволяет передавать значения <xref:System.DateTime> и <xref:System.DateTimeOffset> в оба конца. Пользовательские средства синтаксического анализа XAML, в которых предполагается, что входные данные XAML имеют синтаксис атрибутов, не будут работать правильно.|  
  
<a name="xml"></a>   
## <a name="xml-xslt"></a>XML, XSLT  
  
|Функция|Изменение|Последствия|  
|-------------|------------|------------|  
|Метод `XDocument.Validate`|Если значение <xref:System.Xml.Linq.LoadOptions?displayProperty=fullName> передается методу <xref:System.Xml.Linq.XDocument.Load%2A> и возникает ошибка проверки, свойства <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> и <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> теперь содержат сведения о строке.|Код обработки исключений, который зависит от свойств <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> и <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName>, больше не будет работать.|  
|Загрузка XML-файлов с помощью <xref:System.Xml.XmlTextReader?displayProperty=fullName>|Развертывание сущностей DTD не может превышать 10 000 000 знаков.|Загрузка XML-файлов без развертывания сущностей DTD или с ограниченным развертыванием сущностей DTD не изменяется. Файлы с сущностями DTD, которые развертываются до более чем 10 000 000 символов, не загружаются и теперь вызывают исключение.|  
|Режим прямой совместимости для класса <xref:System.Xml.Xsl.XslCompiledTransform?displayProperty=fullName>|В [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] XSLT 1.0 имелись следующие проблемы с прямой совместимостью:<br /><br /> Загрузка таблицы стилей завершалась сбоем, если ее версия была установлена равной 2.0, и средство синтаксического анализа обнаруживало нераспознанную конструкцию XSLT 1.0.<br /><br /> Конструкции `xsl:sort` не удавалось сортировать данные, если версия таблицы стилей была установлена равной 1.1.<br /><br /> В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] эти проблемы исправлены, и режим прямой совместимости с XSLT 1.0 работает нормально.|Режим прямой совместимости с XSLT 1.0 теперь работает так, как раньше.|  
|Сообщения об исключении, когда XSLT-файл слишком сложный|В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] текст сообщения об ошибке, вызванной тем, что XSLT-файл является слишком сложным, выглядит так: "Слишком сложная таблица стилей". В предыдущих версиях сообщение об ошибке имело вид "Ошибка компиляции XSLT".|Код приложений, который зависит от текста сообщения об ошибке, больше не будет работать. Однако типы исключений остаются теми же, поэтому это изменение не должно иметь никаких реальных последствий.|  
|Проверка схемы XML для xsd:anyURI|В [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] проверка схемы XML является более строгой. При использовании xsd:anyURI для проверки URI, такого как протокол MailTo, при наличии пробелов в URI возникает сбой проверки. В предыдущих версиях .NET Framework проверка проходила успешно.|Изменение затрагивает только приложения, нацеленные на [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
  
## <a name="see-also"></a>См. также  
 [Устаревшие классы библиотеки классов](../../../docs/framework/whats-new/whats-obsolete.md)   
 [Новые возможности](../../../docs/framework/whats-new/index.md)   
 [Совместимость приложений](../../../docs/framework/migration-guide/application-compatibility.md)   
 [Совместимость приложений в 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md)   
 [Совместимость приложений в 4.5.2](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-2.md)
