---
title: "Указание полных имен типов"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- names [.NET Framework], fully qualified type names
- reflection, fully qualified type names
- names [.NET Framework], assemblies
- tokens
- BNF
- assemblies [.NET Framework], names
- Backus-Naur form
- languages, BNF grammar
- fully qualified type names
- type names
- special characters
- IDENTIFIER
ms.assetid: d90b1e39-9115-4f2a-81c0-05e7e74e5580
caps.latest.revision: "11"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 6759e7b62f4083f6d53663385398baf098f2676f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="specifying-fully-qualified-type-names"></a><span data-ttu-id="61c2d-102">Указание полных имен типов</span><span class="sxs-lookup"><span data-stu-id="61c2d-102">Specifying Fully Qualified Type Names</span></span>
<span data-ttu-id="61c2d-103">Для выполнения различных операций отражения необходимо задавать имена типов.</span><span class="sxs-lookup"><span data-stu-id="61c2d-103">You must specify type names to have valid input to various reflection operations.</span></span> <span data-ttu-id="61c2d-104">Полное имя типа состоит из спецификации имени сборки, спецификации пространства имен и имени типа.</span><span class="sxs-lookup"><span data-stu-id="61c2d-104">A fully qualified type name consists of an assembly name specification, a namespace specification, and a type name.</span></span> <span data-ttu-id="61c2d-105">Спецификации имен типов используются такими методами, как <xref:System.Type.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType> и <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61c2d-105">Type name specifications are used by methods such as <xref:System.Type.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
## <a name="backus-naur-form-grammar-for-type-names"></a><span data-ttu-id="61c2d-106">Форма Бэкуса-Наура для имен типов</span><span class="sxs-lookup"><span data-stu-id="61c2d-106">Backus-Naur Form Grammar for Type Names</span></span>  
 <span data-ttu-id="61c2d-107">Форма Бэкуса-Наура (БНФ) определяет синтаксис формальных языков.</span><span class="sxs-lookup"><span data-stu-id="61c2d-107">The Backus-Naur form (BNF) defines the syntax of formal languages.</span></span> <span data-ttu-id="61c2d-108">Приведенная ниже таблица содержит список лексических правил БНФ, описывающих порядок распознавания допустимых входных данных.</span><span class="sxs-lookup"><span data-stu-id="61c2d-108">The following table lists BNF lexical rules that describe how to recognize a valid input.</span></span> <span data-ttu-id="61c2d-109">Терминальные слова (элементы, дальнейшее сокращение которых невозможно) отображаются прописными буквами.</span><span class="sxs-lookup"><span data-stu-id="61c2d-109">Terminals (those elements that are not further reducible) are shown in all uppercase letters.</span></span> <span data-ttu-id="61c2d-110">Нетерминальные слова (допускающие сокращение) содержат прописные буквы вместе со строчными или заключены в одинарные кавычки, причем одинарные кавычки (') не являются частью синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="61c2d-110">Nonterminals (those elements that are further reducible) are shown in mixed-case or singly quoted strings, but the single quote (') is not a part of the syntax itself.</span></span> <span data-ttu-id="61c2d-111">Символ вертикальной черты (&#124;) обозначает правила, у которых есть подправила.</span><span class="sxs-lookup"><span data-stu-id="61c2d-111">The pipe character (&#124;) denotes rules that have subrules.</span></span>  
  
|<span data-ttu-id="61c2d-112">Грамматика БНФ для полных имен типов</span><span class="sxs-lookup"><span data-stu-id="61c2d-112">BNF grammar of fully qualified type names</span></span>|  
|-----------------------------------------------|  
|<span data-ttu-id="61c2d-113">TypeSpec                          :=   ReferenceTypeSpec</span><span class="sxs-lookup"><span data-stu-id="61c2d-113">TypeSpec                          :=   ReferenceTypeSpec</span></span><br /><br /> <span data-ttu-id="61c2d-114">|     SimpleTypeSpec</span><span class="sxs-lookup"><span data-stu-id="61c2d-114">&#124;     SimpleTypeSpec</span></span>|  
|<span data-ttu-id="61c2d-115">ReferenceTypeSpec            :=   SimpleTypeSpec '&'</span><span class="sxs-lookup"><span data-stu-id="61c2d-115">ReferenceTypeSpec            :=   SimpleTypeSpec '&'</span></span>|  
|<span data-ttu-id="61c2d-116">SimpleTypeSpec                :=   PointerTypeSpec</span><span class="sxs-lookup"><span data-stu-id="61c2d-116">SimpleTypeSpec                :=   PointerTypeSpec</span></span><br /><br /> <span data-ttu-id="61c2d-117">|     ArrayTypeSpec</span><span class="sxs-lookup"><span data-stu-id="61c2d-117">&#124;     ArrayTypeSpec</span></span><br /><br /> <span data-ttu-id="61c2d-118">|     TypeName</span><span class="sxs-lookup"><span data-stu-id="61c2d-118">&#124;     TypeName</span></span>|  
|<span data-ttu-id="61c2d-119">PointerTypeSpec                :=   SimpleTypeSpec '*'</span><span class="sxs-lookup"><span data-stu-id="61c2d-119">PointerTypeSpec                :=   SimpleTypeSpec '*'</span></span>|  
|<span data-ttu-id="61c2d-120">ArrayTypeSpec                  :=   SimpleTypeSpec '[ReflectionDimension]'</span><span class="sxs-lookup"><span data-stu-id="61c2d-120">ArrayTypeSpec                  :=   SimpleTypeSpec '[ReflectionDimension]'</span></span><br /><br /> <span data-ttu-id="61c2d-121">|     SimpleTypeSpec '[ReflectionEmitDimension]'</span><span class="sxs-lookup"><span data-stu-id="61c2d-121">&#124;     SimpleTypeSpec '[ReflectionEmitDimension]'</span></span>|  
|<span data-ttu-id="61c2d-122">ReflectionDimension           :=   '*'</span><span class="sxs-lookup"><span data-stu-id="61c2d-122">ReflectionDimension           :=   '*'</span></span><br /><br /> <span data-ttu-id="61c2d-123">|     ReflectionDimension ',' ReflectionDimension</span><span class="sxs-lookup"><span data-stu-id="61c2d-123">&#124;     ReflectionDimension ',' ReflectionDimension</span></span><br /><br /> <span data-ttu-id="61c2d-124">|     NOTOKEN</span><span class="sxs-lookup"><span data-stu-id="61c2d-124">&#124;     NOTOKEN</span></span>|  
|<span data-ttu-id="61c2d-125">ReflectionEmitDimension    :=   '*'</span><span class="sxs-lookup"><span data-stu-id="61c2d-125">ReflectionEmitDimension    :=   '*'</span></span><br /><br /> <span data-ttu-id="61c2d-126">|     Number '..'</span><span class="sxs-lookup"><span data-stu-id="61c2d-126">&#124;     Number '..'</span></span> <span data-ttu-id="61c2d-127">Число</span><span class="sxs-lookup"><span data-stu-id="61c2d-127">Number</span></span><br /><br /> <span data-ttu-id="61c2d-128">|     Number '…'</span><span class="sxs-lookup"><span data-stu-id="61c2d-128">&#124;     Number '…'</span></span><br /><br /> <span data-ttu-id="61c2d-129">|     ReflectionDimension ',' ReflectionDimension</span><span class="sxs-lookup"><span data-stu-id="61c2d-129">&#124;     ReflectionDimension ',' ReflectionDimension</span></span><br /><br /> <span data-ttu-id="61c2d-130">|     NOTOKEN</span><span class="sxs-lookup"><span data-stu-id="61c2d-130">&#124;     NOTOKEN</span></span>|  
|<span data-ttu-id="61c2d-131">Number                            :=   [0-9]+</span><span class="sxs-lookup"><span data-stu-id="61c2d-131">Number                            :=   [0-9]+</span></span>|  
|<span data-ttu-id="61c2d-132">TypeName                         :=   NamespaceTypeName</span><span class="sxs-lookup"><span data-stu-id="61c2d-132">TypeName                         :=   NamespaceTypeName</span></span><br /><br /> <span data-ttu-id="61c2d-133">|     NamespaceTypeName ',' AssemblyNameSpec</span><span class="sxs-lookup"><span data-stu-id="61c2d-133">&#124;     NamespaceTypeName ',' AssemblyNameSpec</span></span>|  
|<span data-ttu-id="61c2d-134">NamespaceTypeName        :=   NestedTypeName</span><span class="sxs-lookup"><span data-stu-id="61c2d-134">NamespaceTypeName        :=   NestedTypeName</span></span><br /><br /> <span data-ttu-id="61c2d-135">|    NamespaceSpec '.' NestedTypeName</span><span class="sxs-lookup"><span data-stu-id="61c2d-135">&#124;     NamespaceSpec '.' NestedTypeName</span></span>|  
|<span data-ttu-id="61c2d-136">NestedTypeName               :=   IDENTIFIER</span><span class="sxs-lookup"><span data-stu-id="61c2d-136">NestedTypeName               :=   IDENTIFIER</span></span><br /><br /> <span data-ttu-id="61c2d-137">|     NestedTypeName '+' IDENTIFIER</span><span class="sxs-lookup"><span data-stu-id="61c2d-137">&#124;     NestedTypeName '+' IDENTIFIER</span></span>|  
|<span data-ttu-id="61c2d-138">NamespaceSpec                 :=   IDENTIFIER</span><span class="sxs-lookup"><span data-stu-id="61c2d-138">NamespaceSpec                 :=   IDENTIFIER</span></span><br /><br /> <span data-ttu-id="61c2d-139">|    NamespaceSpec '.' ИДЕНТИФИКАТОР</span><span class="sxs-lookup"><span data-stu-id="61c2d-139">&#124;     NamespaceSpec '.' IDENTIFIER</span></span>|  
|<span data-ttu-id="61c2d-140">AssemblyNameSpec           :=   IDENTIFIER</span><span class="sxs-lookup"><span data-stu-id="61c2d-140">AssemblyNameSpec           :=   IDENTIFIER</span></span><br /><br /> <span data-ttu-id="61c2d-141">|     IDENTIFIER ',' AssemblyProperties</span><span class="sxs-lookup"><span data-stu-id="61c2d-141">&#124;     IDENTIFIER ',' AssemblyProperties</span></span>|  
|<span data-ttu-id="61c2d-142">AssemblyProperties            :=   AssemblyProperty</span><span class="sxs-lookup"><span data-stu-id="61c2d-142">AssemblyProperties            :=   AssemblyProperty</span></span><br /><br /> <span data-ttu-id="61c2d-143">|     AssemblyProperties ',' AssemblyProperty</span><span class="sxs-lookup"><span data-stu-id="61c2d-143">&#124;     AssemblyProperties ',' AssemblyProperty</span></span>|  
|<span data-ttu-id="61c2d-144">AssemblyProperty              :=   AssemblyPropertyName '=' AssemblyPropertyValue</span><span class="sxs-lookup"><span data-stu-id="61c2d-144">AssemblyProperty              :=   AssemblyPropertyName '=' AssemblyPropertyValue</span></span>|  
  
## <a name="specifying-special-characters"></a><span data-ttu-id="61c2d-145">Указание специальных символов</span><span class="sxs-lookup"><span data-stu-id="61c2d-145">Specifying Special Characters</span></span>  
 <span data-ttu-id="61c2d-146">В имени типа IDENTIFIER — любое допустимое имя, определяемое правилами языка.</span><span class="sxs-lookup"><span data-stu-id="61c2d-146">In a type name, IDENTIFIER is any valid name determined by the rules of a language.</span></span>  
  
 <span data-ttu-id="61c2d-147">Приведенные ниже лексемы при использовании в составе IDENTIFIER отделяются escape-символом в виде обратной косой черты (\\).</span><span class="sxs-lookup"><span data-stu-id="61c2d-147">Use the backslash (\\) as an escape character to separate the following tokens when used as part of IDENTIFIER.</span></span>  
  
|<span data-ttu-id="61c2d-148">Токен</span><span class="sxs-lookup"><span data-stu-id="61c2d-148">Token</span></span>|<span data-ttu-id="61c2d-149">Значение</span><span class="sxs-lookup"><span data-stu-id="61c2d-149">Meaning</span></span>|  
|-----------|-------------|  
|<span data-ttu-id="61c2d-150">\\,</span><span class="sxs-lookup"><span data-stu-id="61c2d-150">\\,</span></span>|<span data-ttu-id="61c2d-151">Разделитель сборок.</span><span class="sxs-lookup"><span data-stu-id="61c2d-151">Assembly separator.</span></span>|  
|\\+|<span data-ttu-id="61c2d-152">Разделитель вложенных типов.</span><span class="sxs-lookup"><span data-stu-id="61c2d-152">Nested type separator.</span></span>|  
|\\&|<span data-ttu-id="61c2d-153">Ссылочный тип.</span><span class="sxs-lookup"><span data-stu-id="61c2d-153">Reference type.</span></span>|  
|\\*|<span data-ttu-id="61c2d-154">Тип указателя.</span><span class="sxs-lookup"><span data-stu-id="61c2d-154">Pointer type.</span></span>|  
|<span data-ttu-id="61c2d-155">\\[</span><span class="sxs-lookup"><span data-stu-id="61c2d-155">\\[</span></span>|<span data-ttu-id="61c2d-156">Ограничитель размерности массива.</span><span class="sxs-lookup"><span data-stu-id="61c2d-156">Array dimension delimiter.</span></span>|  
|<span data-ttu-id="61c2d-157">\\]</span><span class="sxs-lookup"><span data-stu-id="61c2d-157">\\]</span></span>|<span data-ttu-id="61c2d-158">Ограничитель размерности массива.</span><span class="sxs-lookup"><span data-stu-id="61c2d-158">Array dimension delimiter.</span></span>|  
|<span data-ttu-id="61c2d-159">\\.</span><span class="sxs-lookup"><span data-stu-id="61c2d-159">\\.</span></span>|<span data-ttu-id="61c2d-160">Обратная косая черта ставится перед точкой только в том случае, если точка включена в спецификацию массива.</span><span class="sxs-lookup"><span data-stu-id="61c2d-160">Use the backslash before a period only if the period is used in an array specification.</span></span> <span data-ttu-id="61c2d-161">Для точек в спецификации NamespaceSpec обратная косая черта не требуется.</span><span class="sxs-lookup"><span data-stu-id="61c2d-161">Periods in NamespaceSpec do not take the backslash.</span></span>|  
|\\\|<span data-ttu-id="61c2d-162">Обратная косая черта, если она используется в качестве строкового литерала.</span><span class="sxs-lookup"><span data-stu-id="61c2d-162">Backslash when needed as a string literal.</span></span>|  
  
 <span data-ttu-id="61c2d-163">Следует заметить, что для всех компонентов спецификации TypeSpec, кроме AssemblyNameSpec, пробелы существенны.</span><span class="sxs-lookup"><span data-stu-id="61c2d-163">Note that in all TypeSpec components except AssemblyNameSpec, spaces are relevant.</span></span> <span data-ttu-id="61c2d-164">В AssemblyNameSpec пробелы перед разделителем "," существенны, а пробелы после "," игнорируются.</span><span class="sxs-lookup"><span data-stu-id="61c2d-164">In the AssemblyNameSpec, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="61c2d-165">Классы отражения, такие как <xref:System.Type.FullName%2A?displayProperty=nameWithType>, возвращают искаженное имя, которое можно использовать при вызове метода <xref:System.Type.GetType%2A>, например `MyType.GetType(myType.FullName)`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-165">Reflection classes, such as <xref:System.Type.FullName%2A?displayProperty=nameWithType>, return the mangled name so that the returned name can be used in a call to <xref:System.Type.GetType%2A>, as in `MyType.GetType(myType.FullName)`.</span></span>  
  
 <span data-ttu-id="61c2d-166">Например, полное имя типа может иметь следующий вид: `Ozzy.OutBack.Kangaroo+Wallaby,MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-166">For example, the fully qualified name for a type might be `Ozzy.OutBack.Kangaroo+Wallaby,MyAssembly`.</span></span>  
  
 <span data-ttu-id="61c2d-167">Если бы использовалось пространство имен `Ozzy.Out+Back`, перед плюсом должна была бы стоять обратная косая черта.</span><span class="sxs-lookup"><span data-stu-id="61c2d-167">If the namespace were `Ozzy.Out+Back`, then the plus sign must be preceded by a backslash.</span></span> <span data-ttu-id="61c2d-168">В противном случае синтаксический анализатор интерпретировал бы плюс как разделитель вложений.</span><span class="sxs-lookup"><span data-stu-id="61c2d-168">Otherwise, the parser would interpret it as a nesting separator.</span></span> <span data-ttu-id="61c2d-169">Отражение порождает эту строку в следующем виде: `Ozzy.Out\+Back.Kangaroo+Wallaby,MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-169">Reflection emits this string as `Ozzy.Out\+Back.Kangaroo+Wallaby,MyAssembly`.</span></span>  
  
## <a name="specifying-assembly-names"></a><span data-ttu-id="61c2d-170">Указание имен сборок</span><span class="sxs-lookup"><span data-stu-id="61c2d-170">Specifying Assembly Names</span></span>  
 <span data-ttu-id="61c2d-171">Единственным обязательным компонентом спецификации имени сборки является текстовое имя сборки (IDENTIFIER).</span><span class="sxs-lookup"><span data-stu-id="61c2d-171">The minimum information required in an assembly name specification is the textual name (IDENTIFIER) of the assembly.</span></span> <span data-ttu-id="61c2d-172">За ним может следовать список разделенных запятыми пар "свойство/значение", как показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="61c2d-172">You can follow the IDENTIFIER by a comma-separated list of property/value pairs as described in the following table.</span></span> <span data-ttu-id="61c2d-173">Имя IDENTIFIER должно удовлетворять правилам именования файлов.</span><span class="sxs-lookup"><span data-stu-id="61c2d-173">IDENTIFIER naming should follow the rules for file naming.</span></span> <span data-ttu-id="61c2d-174">Регистр символов в имени IDENTIFIER не учитывается.</span><span class="sxs-lookup"><span data-stu-id="61c2d-174">The IDENTIFIER is case-insensitive.</span></span>  
  
|<span data-ttu-id="61c2d-175">Имя свойства.</span><span class="sxs-lookup"><span data-stu-id="61c2d-175">Property name</span></span>|<span data-ttu-id="61c2d-176">Описание</span><span class="sxs-lookup"><span data-stu-id="61c2d-176">Description</span></span>|<span data-ttu-id="61c2d-177">Допустимые значения</span><span class="sxs-lookup"><span data-stu-id="61c2d-177">Allowable values</span></span>|  
|-------------------|-----------------|----------------------|  
|<span data-ttu-id="61c2d-178">**Версия**</span><span class="sxs-lookup"><span data-stu-id="61c2d-178">**Version**</span></span>|<span data-ttu-id="61c2d-179">Номер версии сборки</span><span class="sxs-lookup"><span data-stu-id="61c2d-179">Assembly version number</span></span>|<span data-ttu-id="61c2d-180">*Major.Minor.Build.Revision*, где *Major*, *Minor*, *Build* и *Revision* являются целочисленными значениями в диапазоне от 0 до 65 535 включительно.</span><span class="sxs-lookup"><span data-stu-id="61c2d-180">*Major.Minor.Build.Revision*, where *Major*, *Minor*, *Build*, and *Revision* are integers between 0 and 65535 inclusive.</span></span>|  
|<span data-ttu-id="61c2d-181">**PublicKey**</span><span class="sxs-lookup"><span data-stu-id="61c2d-181">**PublicKey**</span></span>|<span data-ttu-id="61c2d-182">Полный открытый ключ</span><span class="sxs-lookup"><span data-stu-id="61c2d-182">Full public key</span></span>|<span data-ttu-id="61c2d-183">Строковое значение полного открытого ключа в шестнадцатеричном формате.</span><span class="sxs-lookup"><span data-stu-id="61c2d-183">String value of full public key in hexadecimal format.</span></span> <span data-ttu-id="61c2d-184">Чтобы явным образом описать сборку как закрытую, необходимо задать пустую ссылку (**Nothing** в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="61c2d-184">Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly.</span></span>|  
|<span data-ttu-id="61c2d-185">**PublicKeyToken**</span><span class="sxs-lookup"><span data-stu-id="61c2d-185">**PublicKeyToken**</span></span>|<span data-ttu-id="61c2d-186">Токен открытого ключа (8-байтовый хэш-код полного открытого ключа)</span><span class="sxs-lookup"><span data-stu-id="61c2d-186">Public key token (8-byte hash of the full public key)</span></span>|<span data-ttu-id="61c2d-187">Строковое значение токена открытого ключа в шестнадцатеричном формате.</span><span class="sxs-lookup"><span data-stu-id="61c2d-187">String value of public key token in hexadecimal format.</span></span> <span data-ttu-id="61c2d-188">Чтобы явным образом описать сборку как закрытую, необходимо задать пустую ссылку (**Nothing** в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="61c2d-188">Specify a null reference (**Nothing** in Visual Basic) to explicitly indicate a private assembly.</span></span>|  
|<span data-ttu-id="61c2d-189">**Язык и региональные параметры**</span><span class="sxs-lookup"><span data-stu-id="61c2d-189">**Culture**</span></span>|<span data-ttu-id="61c2d-190">Язык и региональные параметры сборки</span><span class="sxs-lookup"><span data-stu-id="61c2d-190">Assembly culture</span></span>|<span data-ttu-id="61c2d-191">Язык и региональные параметры сборки в формате RFC-1766 или нейтральная среда для сборок, независимых от языков (не сопутствующих).</span><span class="sxs-lookup"><span data-stu-id="61c2d-191">Culture of the assembly in RFC-1766 format, or "neutral" for language-independent (nonsatellite) assemblies.</span></span>|  
|<span data-ttu-id="61c2d-192">**Пользовательский**</span><span class="sxs-lookup"><span data-stu-id="61c2d-192">**Custom**</span></span>|<span data-ttu-id="61c2d-193">Пользовательский BLOB-объект.</span><span class="sxs-lookup"><span data-stu-id="61c2d-193">Custom binary large object (BLOB).</span></span> <span data-ttu-id="61c2d-194">В настоящее время используется только в сборках, созданных [генератором образов в машинном коде (Ngen)](../../../docs/framework/tools/ngen-exe-native-image-generator.md).</span><span class="sxs-lookup"><span data-stu-id="61c2d-194">This is currently used only in assemblies generated by the [Native Image Generator (Ngen)](../../../docs/framework/tools/ngen-exe-native-image-generator.md).</span></span>|<span data-ttu-id="61c2d-195">Настраиваемая строка, с помощью которой генератор образов в машинном коде уведомляет кэш сборок о том, что устанавливаемая сборка является образом в машинном коде и должна быть установлена в кэш образов в машинном коде.</span><span class="sxs-lookup"><span data-stu-id="61c2d-195">Custom string used by the Native Image Generator tool to notify the assembly cache that the assembly being installed is a native image, and is therefore to be installed in the native image cache.</span></span> <span data-ttu-id="61c2d-196">Также называется zap-строкой.</span><span class="sxs-lookup"><span data-stu-id="61c2d-196">Also called a zap string.</span></span>|  
  
 <span data-ttu-id="61c2d-197">В приведенном ниже примере демонстрируется спецификация **AssemblyName** для сборки с простым именем, а также заданными по умолчанию языком и региональными параметрами.</span><span class="sxs-lookup"><span data-stu-id="61c2d-197">The following example shows an **AssemblyName** for a simply named assembly with default culture.</span></span>  
  
```csharp  
com.microsoft.crypto, Culture=""   
```  
  
 <span data-ttu-id="61c2d-198">В приведенном ниже примере показана полностью определенная ссылка на сборку со строгим именем, для которой установлены язык и региональные параметры —"en".</span><span class="sxs-lookup"><span data-stu-id="61c2d-198">The following example shows a fully specified reference for a strongly named assembly with culture "en".</span></span>  
  
```csharp  
com.microsoft.crypto, Culture=en, PublicKeyToken=a5d015c7d5a0b012,  
    Version=1.0.0.0   
```  
  
 <span data-ttu-id="61c2d-199">В каждом из приведенных ниже примеров приводится частично определенное имя **AssemblyName**, которое подходит для сборки как с простым, так и со строгим именем.</span><span class="sxs-lookup"><span data-stu-id="61c2d-199">The following examples each show a partially specified **AssemblyName**, which can be satisfied by either a strong or a simply named assembly.</span></span>  
  
```csharp  
com.microsoft.crypto  
com.microsoft.crypto, Culture=""  
com.microsoft.crypto, Culture=en   
```  
  
 <span data-ttu-id="61c2d-200">В каждом из приведенных ниже примеров приводится частично определенное имя **AssemblyName**, которое подходит только для сборки с простым именем.</span><span class="sxs-lookup"><span data-stu-id="61c2d-200">The following examples each show a partially specified **AssemblyName**, which must be satisfied by a simply named assembly.</span></span>  
  
```csharp  
com.microsoft.crypto, Culture="", PublicKeyToken=null   
com.microsoft.crypto, Culture=en, PublicKeyToken=null  
```  
  
 <span data-ttu-id="61c2d-201">В каждом из приведенных ниже примеров приводится частично определенное имя **AssemblyName**, которое подходит только для сборки со строгим именем.</span><span class="sxs-lookup"><span data-stu-id="61c2d-201">The following examples each show a partially specified **AssemblyName**, which must be satisfied by a strongly named assembly.</span></span>  
  
```csharp  
com.microsoft.crypto, Culture="", PublicKeyToken=a5d015c7d5a0b012  
com.microsoft.crypto, Culture=en, PublicKeyToken=a5d015c7d5a0b012,  
    Version=1.0.0.0  
```  
  
## <a name="specifying-pointers"></a><span data-ttu-id="61c2d-202">Определение указателей</span><span class="sxs-lookup"><span data-stu-id="61c2d-202">Specifying Pointers</span></span>  
 <span data-ttu-id="61c2d-203">Спецификация SimpleTypeSpec* представляет неуправляемый указатель.</span><span class="sxs-lookup"><span data-stu-id="61c2d-203">SimpleTypeSpec* represents an unmanaged pointer.</span></span> <span data-ttu-id="61c2d-204">Например, для получения указателя на тип MyType можно использовать вызов метода `Type.GetType("MyType*")`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-204">For example, to get a pointer to type MyType, use `Type.GetType("MyType*")`.</span></span> <span data-ttu-id="61c2d-205">Для получения указателя на указатель на тип MyType используется вызов `Type.GetType("MyType**")`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-205">To get a pointer to a pointer to type MyType, use `Type.GetType("MyType**")`.</span></span>  
  
## <a name="specifying-references"></a><span data-ttu-id="61c2d-206">Указание ссылок</span><span class="sxs-lookup"><span data-stu-id="61c2d-206">Specifying References</span></span>  
 <span data-ttu-id="61c2d-207">Спецификация SimpleTypeSpec & представляет управляемый указатель или ссылку.</span><span class="sxs-lookup"><span data-stu-id="61c2d-207">SimpleTypeSpec & represents a managed pointer or reference.</span></span> <span data-ttu-id="61c2d-208">Например, для получения ссылки на тип MyType можно использовать вызов `Type.GetType("MyType &")`.</span><span class="sxs-lookup"><span data-stu-id="61c2d-208">For example, to get a reference to type MyType, use `Type.GetType("MyType &")`.</span></span> <span data-ttu-id="61c2d-209">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</span><span class="sxs-lookup"><span data-stu-id="61c2d-209">Note that unlike pointers, references are limited to one level.</span></span>  
  
## <a name="specifying-arrays"></a><span data-ttu-id="61c2d-210">Указание массивов</span><span class="sxs-lookup"><span data-stu-id="61c2d-210">Specifying Arrays</span></span>  
 <span data-ttu-id="61c2d-211">В БНФ спецификация ReflectionEmitDimension применяется только в отношении неполных определений типов, полученных с использованием метода <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61c2d-211">In the BNF Grammar, ReflectionEmitDimension only applies to incomplete type definitions retrieved using <xref:System.Reflection.Emit.ModuleBuilder.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="61c2d-212">К неполным определениям типов относятся объекты <xref:System.Reflection.Emit.TypeBuilder>, созданные с помощью метода <xref:System.Reflection.Emit?displayProperty=nameWithType>, но для которых не был выполнен вызов <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61c2d-212">Incomplete type definitions are <xref:System.Reflection.Emit.TypeBuilder> objects constructed using <xref:System.Reflection.Emit?displayProperty=nameWithType> but on which <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> has not been called.</span></span> <span data-ttu-id="61c2d-213">Спецификацию ReflectionDimension можно использовать для получения любого полного определения типа, то есть типа, который уже загружен.</span><span class="sxs-lookup"><span data-stu-id="61c2d-213">ReflectionDimension can be used to retrieve any type definition that has been completed, that is, a type that has been loaded.</span></span>  
  
 <span data-ttu-id="61c2d-214">Доступ к массиву при отражении осуществляется путем указания размерности массива:</span><span class="sxs-lookup"><span data-stu-id="61c2d-214">Arrays are accessed in reflection by specifying the rank of the array:</span></span>  
  
-   <span data-ttu-id="61c2d-215">`Type.GetType("MyArray[]")` — получение одномерного массива с нижней границей 0.</span><span class="sxs-lookup"><span data-stu-id="61c2d-215">`Type.GetType("MyArray[]")` gets a single-dimension array with 0 lower bound.</span></span>  
  
-   <span data-ttu-id="61c2d-216">`Type.GetType("MyArray[*]")` — получение одномерного массива с неизвестной нижней границей.</span><span class="sxs-lookup"><span data-stu-id="61c2d-216">`Type.GetType("MyArray[*]")` gets a single-dimension array with unknown lower bound.</span></span>  
  
-   <span data-ttu-id="61c2d-217">`Type.GetType("MyArray[][]")` — получение массива двумерных массивов.</span><span class="sxs-lookup"><span data-stu-id="61c2d-217">`Type.GetType("MyArray[][]")` gets a two-dimensional array's array.</span></span>  
  
-   <span data-ttu-id="61c2d-218">`Type.GetType("MyArray[*,*]")` и `Type.GetType("MyArray[,]")` — получение прямоугольного двумерного массива с неизвестными нижними границами.</span><span class="sxs-lookup"><span data-stu-id="61c2d-218">`Type.GetType("MyArray[*,*]")` and `Type.GetType("MyArray[,]")` gets a rectangular two-dimensional array with unknown lower bounds.</span></span>  
  
 <span data-ttu-id="61c2d-219">Обратите внимание, что с точки зрения среды выполнения `MyArray[] != MyArray[*]`, но для многомерных массивов эти обозначения эквивалентны.</span><span class="sxs-lookup"><span data-stu-id="61c2d-219">Note that from a runtime point of view, `MyArray[] != MyArray[*]`, but for multidimensional arrays, the two notations are equivalent.</span></span> <span data-ttu-id="61c2d-220">Другими словами, выражение `Type.GetType("MyArray [,]") == Type.GetType("MyArray[*,*]")` дает значение **true**.</span><span class="sxs-lookup"><span data-stu-id="61c2d-220">That is, `Type.GetType("MyArray [,]") == Type.GetType("MyArray[*,*]")` evaluates to **true**.</span></span>  
  
 <span data-ttu-id="61c2d-221">Для метода **ModuleBuilder.GetType** `MyArray[0..5]` указывает одномерный массив размером 6 с нижней границей 0.</span><span class="sxs-lookup"><span data-stu-id="61c2d-221">For **ModuleBuilder.GetType**, `MyArray[0..5]` indicates a single-dimension array with size 6, lower bound 0.</span></span> <span data-ttu-id="61c2d-222">`MyArray[4…]` указывает одномерный массив неизвестного размера с нижней границей 4.</span><span class="sxs-lookup"><span data-stu-id="61c2d-222">`MyArray[4…]` indicates a single-dimension array of unknown size and lower bound 4.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="61c2d-223">См. также</span><span class="sxs-lookup"><span data-stu-id="61c2d-223">See Also</span></span>  
 <xref:System.Reflection.AssemblyName>  
 <xref:System.Reflection.Emit.ModuleBuilder>  
 <xref:System.Reflection.Emit.TypeBuilder>  
 <xref:System.Type.FullName%2A?displayProperty=nameWithType>  
 <xref:System.Type.GetType%2A?displayProperty=nameWithType>  
 <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="61c2d-224">Просмотр сведений о типах</span><span class="sxs-lookup"><span data-stu-id="61c2d-224">Viewing Type Information</span></span>](../../../docs/framework/reflection-and-codedom/viewing-type-information.md)
