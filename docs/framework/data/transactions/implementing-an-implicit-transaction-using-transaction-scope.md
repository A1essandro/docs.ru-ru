---
title: "Реализация неявной транзакции с использованием области транзакции"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: 49d1706a-1e0c-4c85-9704-75c908372eb9
caps.latest.revision: "4"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 0b75091739b0ea97b63b35830f4946a78e49ff8f
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="implementing-an-implicit-transaction-using-transaction-scope"></a>Реализация неявной транзакции с использованием области транзакции
Класс <xref:System.Transactions.TransactionScope> предоставляет простой способ пометки блока кода как участвующего в транзакции без необходимости взаимодействия с самой транзакцией. Область транзакции может автоматически выбирать внешнюю транзакцию и управлять ей. В целях обеспечения простоты использования и эффективности при разработке транзакционного приложения рекомендуется использовать класс <xref:System.Transactions.TransactionScope>.  
  
 Кроме того, явно зачислять ресурсы в транзакцию не требуется. Любой диспетчер ресурсов <xref:System.Transactions> (например SQL Server 2005) может обнаружить существование внешней транзакции, созданной областью, и автоматически зачислиться в эту транзакцию.  
  
## <a name="creating-a-transaction-scope"></a>Создание области транзакции  
 Ниже представлен простой пример использования класса <xref:System.Transactions.TransactionScope>.  
  
 [!code-csharp[TransactionScope#1](../../../../samples/snippets/csharp/VS_Snippets_Remoting/TransactionScope/cs/ScopeWithSQL.cs#1)]
 [!code-vb[TransactionScope#1](../../../../samples/snippets/visualbasic/VS_Snippets_Remoting/TransactionScope/vb/ScopeWithSQL.vb#1)]  
  
 Область транзакции запускается после создания нового <xref:System.Transactions.TransactionScope> объекта.  Как показано в следующем образце кода, рекомендуется создать областей с **с помощью** инструкции. **С помощью** инструкция доступна как в C# и Visual Basic, и работает как **try... finally** блок, чтобы убедиться, что область удаляется должным образом.  
  
 При создании экземпляра <xref:System.Transactions.TransactionScope> диспетчер транзакций определяет, в какой транзакции следует участвовать. После определения область всегда участвует в этой транзакции. Решение на основе двух факторов: присутствует ли внешнюю транзакцию и значение **TransactionScopeOption** параметр в конструкторе. Внешняя транзакция - это транзакция, в рамках которой выполняется ваш код. Ссылку на внешнюю транзакцию можно получить, вызвав статическое свойство <xref:System.Transactions.Transaction.Current%2A?displayProperty=nameWithType> класса <xref:System.Transactions.Transaction>. Дополнительные сведения об использовании этого параметра см. в разделе [управление потока транзакций с помощью TransactionScopeOption](#ManageTxFlow) этого раздела.  
  
## <a name="completing-a-transaction-scope"></a>Завершение области транзакции  
 Когда приложение завершает все операции, подлежащие выполнению в транзакции, следует вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A?displayProperty=nameWIthType> только один раз, чтобы информировать диспетчер транзакций о возможности фиксации данной транзакции. Очень хорошо рекомендуется разместить вызова <xref:System.Transactions.TransactionScope.Complete%2A> в последнем операторе в **с помощью** блока.  
  
 Если вызвать этот метод, транзакция прерывается, поскольку диспетчер транзакций интерпретирует это как сбой системы или эквивалентен исключение, которое создается в пределах области транзакции. Однако вызов этого метода не гарантирует, что транзакция будет зафиксирована. Это просто способ информирования диспетчера транзакций о состоянии. После вызова метода <xref:System.Transactions.TransactionScope.Complete%2A> доступ к внешней транзакции с помощью свойства <xref:System.Transactions.Transaction.Current%2A> невозможен. При попытке такого доступа возникает исключение.  
  
 Если <xref:System.Transactions.TransactionScope> объекта, изначально создана транзакция происходит фактические трудозатраты фиксации транзакции диспетчером транзакций после последней строки кода в **с помощью** блока. Если транзакция создана не этим объектом, фиксация происходит при каждом вызове метода <xref:System.Transactions.CommittableTransaction.Commit%2A> владельцем объекта <xref:System.Transactions.CommittableTransaction>. На этом этапе диспетчер транзакций вызывает диспетчеры ресурсов и о том, для фиксации или отката, в зависимости от <xref:System.Transactions.TransactionScope.Complete%2A> метод был вызван для <xref:System.Transactions.TransactionScope> объекта.  
  
 **С помощью** гарантирует, что инструкция <xref:System.Transactions.TransactionScope.Dispose%2A> метод <xref:System.Transactions.TransactionScope> вызывается даже при возникновении исключения. Вызов метода <xref:System.Transactions.TransactionScope.Dispose%2A> отмечает конец области транзакции. Исключения, возникающие после вызова данного метода, могут не воздействовать на транзакцию. Данный метод также восстанавливает предыдущее состояние внешней транзакции.  
  
 Если область создает транзакцию и эта транзакция прерывается, возникает исключение <xref:System.Transactions.TransactionAbortedException>. Если диспетчер транзакций не может принять решение о фиксации, возникает исключение <xref:System.Transactions.TransactionInDoubtException>. В случае фиксации транзакции исключения не возникают.  
  
## <a name="rolling-back-a-transaction"></a>Откат транзакции  
 Если требуется откатить транзакцию, не следует вызывать метод <xref:System.Transactions.TransactionScope.Complete%2A> в пределах области транзакции. Например, можно вызвать исключение в пределах области. При этом будет выполнен откат транзакции, в которой участвует область.  
  
##  <a name="ManageTxFlow"></a>Управление потока транзакций с помощью TransactionScopeOption  
 Область транзакции можно сделать вложенной, вызвав метод, использующий объект <xref:System.Transactions.TransactionScope>, из метода, использующего собственную область, как в случае метода `RootMethod` в следующем примере.  
  
```csharp  
void RootMethod()  
{  
     using(TransactionScope scope = new TransactionScope())  
     {  
          /* Perform transactional work here */  
          SomeMethod();  
          scope.Complete();  
     }  
}  
  
void SomeMethod()  
{  
     using(TransactionScope scope = new TransactionScope())  
     {  
          /* Perform transactional work here */  
          scope.Complete();  
     }  
}  
```  
  
 Самая верхняя область транзакции называется корневой областью.  
  
 Класс <xref:System.Transactions.TransactionScope> предоставляет несколько перегруженных конструкторов, принимающих перечисление <xref:System.Transactions.TransactionScopeOption>, которое определяет поведение области транзакции.  
  
 Предусмотрено три варианта поведения объекта <xref:System.Transactions.TransactionScope>:  
  
-   присоединиться к внешней транзакции или создать новую транзакцию, если она не существует;  
  
-   стать новой корневой областью, т. е. запустить новую транзакцию, представляющую собой новую внешнюю транзакцию внутри собственной области;  
  
-   не принимать участие в транзакции, в результате внешняя транзакция отсутствует.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Required> и внешняя транзакция существует, область присоединяется к этой транзакции. Если внешняя транзакция отсутствует, область создает новую транзакцию и становится корневой областью. Это значение по умолчанию. В случае использования значения <xref:System.Transactions.TransactionScopeOption.Required> поведение кода, находящегося внутри области, должно быть одинаковым в обоих случаях: область является корневой или область только присоединяется к транзакции.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.RequiresNew>, она является корневой областью. Область запускает новую транзакцию, которая становится новой внешней транзакцией внутри области.  
  
 Если область создана со значением <xref:System.Transactions.TransactionScopeOption.Suppress>, она не принимает участие в транзакции независимо от существования внешней транзакции. Область, экземпляр которого создается без это значение всегда имеют **null** как его внешней транзакции.  
  
 Сводка рассмотренных выше значений представлена в следующей таблице.  
  
|TransactionScopeOption|Внешняя транзакция|Транзакция, в которой участвует область|  
|----------------------------|-------------------------|-----------------------------|  
|Обязательно|Нет|Новая транзакция (область станет корневой)|  
|RequiresNew|Нет|Новая транзакция (область станет корневой)|  
|Suppress|Нет|Транзакция отсутствует|  
|Обязательно|Да|Внешняя транзакция|  
|RequiresNew|Да|Новая транзакция (область станет корневой)|  
|Suppress|Да|Транзакция отсутствует|  
  
 После присоединения объекта <xref:System.Transactions.TransactionScope> к существующей внешней транзакции удаление объекта области может не привести к завершению транзакции, если только область не прервет транзакцию. Если внешняя транзакция была создана корневой областью, метод <xref:System.Transactions.CommittableTransaction.Commit%2A> вызывается для транзакции только после удаления корневой области. Если транзакция была создана вручную, она завершается в случае прерывания или в случае фиксации ее создателем.  
  
 В следующем примере показан объект <xref:System.Transactions.TransactionScope>, создающий три вложенных объекта области с разными значениями перечисления <xref:System.Transactions.TransactionScopeOption>.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())   
//Default is Required   
{   
     using(TransactionScope scope2 = new   
      TransactionScope(TransactionScopeOption.Required))   
     {  
     ...  
     }   
  
     using(TransactionScope scope3 = new TransactionScope(TransactionScopeOption.RequiresNew))   
     {  
     ...  
     }   
  
     using(TransactionScope scope4 = new   
        TransactionScope(TransactionScopeOption.Suppress))   
    {  
     ...  
    }   
}  
```  
  
 В примере показан блок кода без внешней транзакции, создающий новую область (`scope1`) со значением <xref:System.Transactions.TransactionScopeOption.Required>. Область `scope1` является корневой, поскольку она создает новую транзакцию (транзакцию A) и делает ее внешней транзакцией. Затем `Scope1` создает три дополнительных объекта с разными значениями <xref:System.Transactions.TransactionScopeOption>. Например, объект `scope2` создается со значением <xref:System.Transactions.TransactionScopeOption.Required>; поскольку существует внешняя транзакция, этот объект присоединяется к первой транзакции, созданной объектом `scope1`. Обратите внимание, что `scope3` является корневой областью новой транзакции, а `scope4` не имеет внешней транзакции.  
  
 Несмотря на то что значение по умолчанию <xref:System.Transactions.TransactionScopeOption> является наиболее часто используемым значением перечисления <xref:System.Transactions.TransactionScopeOption.Required>, каждое из остальных значений имеет свое уникальное назначение.  
  
 Значение <xref:System.Transactions.TransactionScopeOption.Suppress> полезно использовать, если требуется сохранить операции, выполняемые разделом кода, и не прерывать внешнюю транзакцию в случае сбоя этих операций (например, если требуется выполнить операции аудита или ведения журнала либо опубликовать события для подписчиков независимо от результата завершения внешней транзакции [фиксация или откат]). Это значение позволяет использовать раздел кода, не относящийся к транзакции, внутри области транзакции, как показано в следующем примере.  
  
```csharp  
using(TransactionScope scope1 = new TransactionScope())  
{  
     try  
     {  
          //Start of non-transactional section   
          using(TransactionScope scope2 = new  
             TransactionScope(TransactionScopeOption.Suppress))  
          {  
               //Do non-transactional work here  
          }  
          //Restores ambient transaction here  
   }  
     catch  
     {}  
   //Rest of scope1  
}  
```  
  
### <a name="voting-inside-a-nested-scope"></a>Голосование во вложенной области  
 Несмотря на то что вложенная область может присоединяться к внешней транзакции корневой области, вызов метода <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области не оказывает воздействия на корневую область. Транзакция будет зафиксирована, только если все области из корневой области вплоть до последней вложенной области проголосуют за фиксацию транзакции. Если не вызвать метод <xref:System.Transactions.TransactionScope.Complete%2A> во вложенной области, то включающая транзакция будет немедленно прекращена, что отразится на корневой области.  
  
## <a name="setting-the-transactionscope-timeout"></a>Задание времени ожидания для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают значение типа <xref:System.TimeSpan>, которое используется для контроля времени ожидания транзакции. Нулевое значение указывает на бесконечное время ожидания. Значение бесконечного времени ожидания в основном полезно использовать при отладке, когда требуется изолировать проблему в бизнес-логике путем пошагового выполнения кода, но не требуется, чтобы истекло время ожидания отлаживаемой транзакции, пока осуществляется поиск проблемы. При использовании значения бесконечного времени ожидания во всех остальных случаях будьте чрезвычайно осторожны, поскольку оно переопределяет механизмы защиты от взаимоблокировок транзакций.  
  
 Как правило, при задании времени ожидания для объекта <xref:System.Transactions.TransactionScope> значения, отличные от значения по умолчанию, используются в двух случаях. Первый случай относится к процессу разработки, когда требуется проверить, как приложение обрабатывает прерванные транзакции. Задав малое значение времени ожидания (например, равное одной миллисекунде), можно вызвать прерывание транзакции и проверить код обработки ошибки. Второй случай относится к проверке участия области в состязании за ресурсы, приводящем к взаимоблокировкам; эта проверка заключается в задании времени ожидания, которое меньше значения по умолчанию. В этом случае требуется как можно скорее прервать транзакцию без ожидания истечения времени ожидания по умолчанию.  
  
 Если область присоединяется к внешней транзакции и задает время ожидания, меньшее заданного для внешней транзакции, к объекту <xref:System.Transactions.TransactionScope> применяется новое (меньшее) значение времени ожидания; при этом область должна завершиться в указанное время, иначе транзакция будет прервана автоматически. Если значение времени ожидания вложенной области превышает значение времени ожидания внешней транзакции, первое не оказывает никакого воздействия.  
  
## <a name="setting-the-transactionscope-isolation-level"></a>Задание уровня изоляции для объекта TransactionScope  
 Некоторые перегруженные конструкторы объекта <xref:System.Transactions.TransactionScope> принимают структуру типа <xref:System.Transactions.TransactionOptions>, позволяющую задать уровень изоляции в дополнение к значению времени ожидания. По умолчанию транзакция выполняется со значением уровня изоляции <xref:System.Transactions.IsolationLevel.Serializable>. Значения, отличные от <xref:System.Transactions.IsolationLevel.Serializable>, обычно используются в случае систем, в которых преобладают операции чтения. Это требует глубокого понимания теории обработки транзакций и семантики транзакций, проблем параллелизма, а также последствий, влияющих на целостность системы.  
  
 Кроме того, не все диспетчеры ресурсов поддерживают все уровни изоляции; диспетчеры ресурсов могут решить участвовать в транзакции на более высоком уровне, чем настроенный.  
  
 Каждый уровень изоляции, кроме <xref:System.Transactions.IsolationLevel.Serializable>, сопряжен с проблемой нарушения целостности, возникающей в результате доступа других транзакций к тем же самым данным. Разница между различными уровнями изоляции заключается в порядке использования блокировок для чтения и блокировок для записи. Блокировка может действовать только во время доступа транзакции к данным в диспетчере ресурсов или пока транзакция не будет зафиксирована или прервана. Первый вариант обеспечивает более высокую производительность, второй - более высокую согласованность. Два вида блокировок и два вида операций (чтение/запись) образуют четыре базовых уровня изоляции. Дополнительные сведения см. в разделе <xref:System.Transactions.IsolationLevel>.  
  
 При использовании вложенных объектов <xref:System.Transactions.TransactionScope> все вложенные области следует настроить на использование строго одного уровня изоляции, если им необходимо присоединиться к внешней транзакции. Если при попытке присоединения вложенного объекта <xref:System.Transactions.TransactionScope> к внешней транзакции обнаруживается, что для него задан другой уровень изоляции, возникает исключение <xref:System.ArgumentException>.  
  
## <a name="interop-with-com"></a>Взаимодействие с транзакциями COM+  
 Чтобы задать способ взаимодействия с транзакциями COM+ при создании нового экземпляра <xref:System.Transactions.TransactionScope>, можно использовать перечисление <xref:System.Transactions.EnterpriseServicesInteropOption> в одном из конструкторов. Дополнительные сведения см. в разделе [взаимодействие с Enterprise Services и транзакции COM +](../../../../docs/framework/data/transactions/interoperability-with-enterprise-services-and-com-transactions.md).  
  
## <a name="see-also"></a>См. также  
 <xref:System.Transactions.Transaction.Clone%2A>  
 <xref:System.Transactions.TransactionScope>
