---
title: "Идентификация объекта | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-ado"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: c788f2f9-65cc-4455-9907-e8388a268e00
caps.latest.revision: 2
author: "JennieHubbard"
ms.author: "jhubbard"
manager: "jhubbard"
caps.handback.revision: 2
---
# Идентификация объекта
Во время выполнения объекты получают уникальные идентификаторы.  Две переменные, которые ссылаются на один объект, в действительности ссылаются на один экземпляр этого объекта.  По этой причине изменения, произведенные посредством одной переменной, немедленно отображаются через вторую.  
  
 Строки в таблице реляционной базы данных не имеют уникальных идентификаторов.  Поэтому каждой строке присвоен уникальный первичный ключ, который не совпадает с ключами других строк.  Однако этот факт применим только к содержимому таблицы базы данных.  
  
 В действительности данные зачастую извлекаются из базы данных и отправляются на другой уровень, на котором с ними работает приложение.  Именно такая модель поддерживается технологией [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].  Когда данные извлекаются из базы данных в виде строк, пользователь не может сделать никаких предположений относительного того, что две строки, представляющие идентичные данные, в действительности соответствуют одному экземпляру строки.  Если дважды запросить определенный клиент, будут получены две строки данных. Сведения в этих строках будут идентичны.  
  
 В случае объектов процесс осуществляется совершенно иначе.  Можно ожидать, что, несколько раз отправляя классу <xref:System.Data.Linq.DataContext> запрос на получений одной и той же информации, в действительности будет получен один и тот же экземпляр объекта.  Это поведение реализуется по той причине, что объекты имеют особое значение для приложения и полученные данные ведут себя как объекты.  Объекты создаются как иерархии или графы.  Пользователь может быть уверен, что объекты будут извлечены именно в этом качестве. Он не получит множество реплицированных экземпляров только потому, что отправил несколько запросов на одни и те же сведения.  
  
 В [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] идентификациями объектов управляет класс <xref:System.Data.Linq.DataContext>.  При получении новой строки из базы данных строка регистрируется в таблице идентификаций по своему первичному ключу и создается новый объект.  При извлечении той же строки приложение отправляется исходный экземпляр объекта.  Таким образом, класс <xref:System.Data.Linq.DataContext> преобразует понятие идентификации в контексте базы данных \(то есть первичные ключи\) в понятие идентификации в контексте языка программирования \(то есть экземпляры\).  Объект представляется приложению только в состоянии, в котором он находился при первом получении.  Если новые данные оказываются другими, они удаляются.  Для получения дополнительной информации см. [Получение объектов из кэша идентификации](../../../../../../docs/framework/data/adonet/sql/linq/retrieving-objects-from-the-identity-cache.md).  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] использует этот подход, чтобы обеспечивать целостность локальных объектов в целях поддержки обновлений оптимистичного параллелизма.  Поскольку все изменения, происходящие после первого создания объекта, выполняются приложением, действия приложения строго определены.  Если во время работы приложения изменения производятся из\-за пределов его области действия, эти изменения определяются в момент вызова метода `SubmitChanges()`.  
  
> [!NOTE]
>  Если запрашиваемый объект легко определить как уже извлеченный, то запрос не выполняется.  Таблица идентификаций действует как кэш всех ранее извлеченных объектов.  
  
## Примеры  
  
### Пример кэширования объекта 1  
 В данном примере, если дважды выполнить один и тот же запрос, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#1)]
 [!code-vb[DLinqObjectIdentity#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#1)]  
  
### Пример кэширования объекта 2  
 В данном примере, если дважды выполнить разные запросы, которые возвращают одну и ту же строку базы данных, каждый раз будет получена ссылка на один и тот же объект в памяти.  
  
 [!code-csharp[DLinqObjectIdentity#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqObjectIdentity/cs/Program.cs#2)]
 [!code-vb[DLinqObjectIdentity#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqObjectIdentity/vb/Module1.vb#2)]  
  
## См. также  
 [Дополнительные сведения](../../../../../../docs/framework/data/adonet/sql/linq/background-information.md)