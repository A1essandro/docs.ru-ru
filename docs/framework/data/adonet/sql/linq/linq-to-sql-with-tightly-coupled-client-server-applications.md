---
title: LINQ to SQL и тесно связанные клиентские/серверные приложения
ms.date: 03/30/2017
ms.assetid: e083d805-dcf6-459d-b9af-9ef0563f2dd7
ms.openlocfilehash: 9c36fc1f402d3791611af47a3a6d997db4f31167
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2018
ms.locfileid: "43521884"
---
# <a name="linq-to-sql-with-tightly-coupled-client-server-applications"></a>LINQ to SQL и тесно связанные клиентские/серверные приложения
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] может использоваться на среднем уровне с тесно связанными интеллектуальными клиентами на уровень представления данных. Реализация сценариев, в которых используется доступ к данным только для чтения и не выполняются проверки оптимистического параллелизма на основе исходных значений или меток времени, представляет собой не более сложную задачу, чем сценарии без удаленного взаимодействия. Однако, если база данных требует выполнения проверки оптимистического параллелизма на основе исходных значений, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не предоставляет того уровня поддержки кругового пути данных, который обеспечивается DataSets. Тем не менее, средний уровень [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] может обмениваться данными с клиентами на любой платформе.  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] в [!INCLUDE[vs_orcas_long](../../../../../../includes/vs-orcas-long-md.md)] не предоставляет инфраструктуру для отслеживания состояния сущностей после их сериализации на клиенте. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] позволяет ориентированных на службы архитектуры, в которых взаимодействия между уровнями данных и представлений невелики и относительно атомарны, но не выполняет никаких обратных преобразований исходных значений. Поэтому, если вместе с [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] требуется использовать тесно связанный интеллектуальный клиент, а в базе данных используются проверки оптимистического параллелизма на основе исходных значений, необходимо реализовать собственный механизм обмена изменениями между уровнем представления данных и средним уровнем. Стоит ли выполнять эту дополнительную работу ради преимуществ, которые предоставляет [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] на среднем уровне, должен решить разработчик системы. С другой стороны, если в базе данных содержатся метки времени, то нет необходимости разрабатывать пользовательскую логику отслеживания изменений.  
  
## <a name="see-also"></a>См. также  
 [N-уровневые и удаленные приложения и LINQ to SQL](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)  
 [N-уровневое использование LINQ to SQL с веб-службами](../../../../../../docs/framework/data/adonet/sql/linq/linq-to-sql-n-tier-with-web-services.md)  
 [Работа с наборами данных в N-уровневых приложениях](/visualstudio/data-tools/work-with-datasets-in-n-tier-applications)
