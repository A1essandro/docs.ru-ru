---
title: LINQ to SQL и тесно связанные клиентские/серверные приложения
ms.date: 03/30/2017
ms.assetid: e083d805-dcf6-459d-b9af-9ef0563f2dd7
ms.openlocfilehash: f094bb319a4ca5241e60993770c9c49c3151635c
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="linq-to-sql-with-tightly-coupled-client-server-applications"></a>LINQ to SQL и тесно связанные клиентские/серверные приложения
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] может использоваться на среднем уровне с тесно связанными интеллектуальными клиентами на уровне представления данных. Реализация сценариев, в которых используется доступ к данным только для чтения и не выполняются проверки оптимистического параллелизма на основе исходных значений или меток времени, представляет собой не более сложную задачу, чем сценарии без удаленного взаимодействия. Однако, если база данных требует выполнения проверки оптимистического параллелизма на основе исходных значений, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не предоставляет того уровня поддержки кругового пути данных, который обеспечивается DataSets. Тем не менее, средний уровень [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] может обмениваться данными с клиентами на любой платформе.  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] в [!INCLUDE[vs_orcas_long](../../../../../../includes/vs-orcas-long-md.md)] не предоставляет инфраструктуру для отслеживания состояния сущностей после их сериализации в клиента. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] включает ориентированных на службы архитектуры, в где взаимодействия между уровнями данных и представлений невелики и относительно атомарны, но не выполняет никаких обратных преобразований исходных значений. Поэтому, если вместе с [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] требуется использовать тесно связанный интеллектуальный клиент, а в базе данных используются проверки оптимистического параллелизма на основе исходных значений, необходимо реализовать собственный механизм обмена изменениями между уровнем представления данных и средним уровнем. Стоит ли выполнять эту дополнительную работу ради преимуществ, которые предоставляет [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] на среднем уровне, должен решить разработчик системы. С другой стороны, если в базе данных содержатся метки времени, то нет необходимости разрабатывать пользовательскую логику отслеживания изменений.  
  
## <a name="see-also"></a>См. также  
 [N-уровневые и удаленные приложения и LINQ to SQL](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)  
 [N-уровневое использование LINQ to SQL с веб-службами](../../../../../../docs/framework/data/adonet/sql/linq/linq-to-sql-n-tier-with-web-services.md)  
 [Работа с наборами данных в N-уровневых приложениях](http://msdn.microsoft.com/library/f6ae2ee0-ea5f-4a79-8f4b-e21c115afb20)
