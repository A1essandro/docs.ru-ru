---
title: "Вопросы производительности (платформа Entity Framework) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-ado"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
caps.latest.revision: 6
author: "JennieHubbard"
ms.author: "jhubbard"
manager: "jhubbard"
caps.handback.revision: 6
---
# Вопросы производительности (платформа Entity Framework)
В этом подразделе описаны характеристики производительности платформы ADO.NET Entity Framework, а также приведены соображения по повышению производительности приложений платформы Entity Framework.  
  
## Этапы выполнения запросов  
 Чтобы лучше понять специфику производительности запросов платформы Entity Framework, необходимо разобраться с операциями, которые совершаются при выполнении запроса к концептуальной модели и при возврате данных в виде объектов.  В следующей таблице описан этот ряд операций.  
  
|Операция|Относительные затраты|Частота|Комментарии|  
|--------------|---------------------------|-------------|-----------------|  
|Загрузка метаданных|Средняя|По одному разу в каждом домене приложения.|Метаданные модели и сопоставления, используемые платформой Entity Framework, загружаются в <xref:System.Data.Metadata.Edm.MetadataWorkspace>.  Эти метаданные собираются глобально и доступны другим экземплярам <xref:System.Data.Objects.ObjectContext> в том же домене приложения.|  
|Открытие подключения базы данных|Средняя<sup>1</sup>|При необходимости.|Поскольку открытое соединение с базой данных является весьма ресурсоемким, [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] открывает и закрывает его только при необходимости.  Кроме того, соединение можно открыть явно.  Для получения дополнительной информации см. [Managing Connections and Transactions](http://msdn.microsoft.com/ru-ru/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).|  
|Создание представлений...|High|По одному разу в каждом домене приложения.  \(могут создаваться предварительно.\)|Прежде чем платформа Entity Framework сможет выполнять запросы к концептуальной модели или сохранять изменения в источнике данных, ей необходимо создать набор локальных представлений запросов для доступа к базе данных.  В связи с высокими затратами на создание этих представлений их можно создать заранее и добавить в проект во время разработки.  Для получения дополнительной информации см. [How to: Pre\-Generate Views to Improve Query Performance](http://msdn.microsoft.com/ru-ru/b18a9d16-e10b-4043-ba91-b632f85a2579).|  
|Подготовка запроса|Средняя<sup>2</sup>|Один раз для каждого уникального запроса.|Включает затраты на создание команды запроса, создание дерева команд на базе метаданных модели и сопоставления, а также определение вида возвращаемых данных.  Теперь как команды запросов Entity SQL, так и запросы LINQ кэшируются, поэтому при последующем выполнении один и тот же запрос занимает еще меньше времени.  Можно по\-прежнему использовать скомпилированные запросы LINQ для снижения затрат при последующем выполнении, и скомпилированные запросы могут быть более эффективными, чем запросы LINQ, которые автоматически сохраняются в кэше.  Для получения дополнительной информации см. [Скомпилированные запросы \(LINQ to Entities\)](../../../../../docs/framework/data/adonet/ef/language-reference/compiled-queries-linq-to-entities.md).  Общие сведения о выполнении запросов LINQ см. в разделе [LINQ to Entities](../../../../../docs/framework/data/adonet/ef/language-reference/linq-to-entities.md). **Note:**  Тем не менее запросы LINQ to Entities, которые применяют оператор `Enumerable.Contains` к коллекции в памяти, автоматически не кэшируются.  Также в скомпилированных запросах LINQ не допускаются коллекции в памяти с параметрами.|  
|Выполнение запроса|Низкий<sup>2</sup>|Один раз для каждого запроса.|Затраты на выполнение команды к источнику данных с помощью поставщика данных ADO.NET.  Поскольку большинство источников данных кэширует планы запросов, при последующем выполнении один и тот же запрос может занимать меньше времени.|  
|Загрузка и проверка типов|Низкий<sup>3</sup>|Один раз для каждого элемента <xref:System.Data.Objects.ObjectContext>.|Типы загружаются и проверяются относительно типов, определенных в концептуальной модели.|  
|Отслеживание|Низкий<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом.  <sup>4</sup>|Если запрос использует параметр слияния <xref:System.Data.Objects.MergeOption>, то этот шаг не влияет на производительность.<br /><br /> Если запрос использует параметры слияния <xref:System.Data.Objects.MergeOption>, <xref:System.Data.Objects.MergeOption> или <xref:System.Data.Objects.MergeOption>, то результаты запроса отслеживаются в <xref:System.Data.Objects.ObjectStateManager>.  Для каждого отслеживаемого объекта, возвращаемого запросом, создается ключ <xref:System.Data.EntityKey>, который используется для создания <xref:System.Data.Objects.ObjectStateEntry> в <xref:System.Data.Objects.ObjectStateManager>.  Если для <xref:System.Data.EntityKey> можно найти существующий объект <xref:System.Data.Objects.ObjectStateEntry>, то возвращается существующий объект.  Если используется параметр <xref:System.Data.Objects.MergeOption> или <xref:System.Data.Objects.MergeOption>, то объект обновляется до возвращения.<br /><br /> Для получения дополнительной информации см. [Identity Resolution, State Management, and Change Tracking](http://msdn.microsoft.com/ru-ru/3bd49311-0e72-4ea4-8355-38fe57036ba0).|  
|Материализация объектов|Средняя<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом.  <sup>4</sup>|Процесс считывания возвращенного объекта <xref:System.Data.Common.DbDataReader>, создания объектов и установки значений свойств, основанных на значениях в каждом экземпляре класса <xref:System.Data.Common.DbDataRecord>.  Если объект уже существует в классе <xref:System.Data.Objects.ObjectContext> и в запросе используются параметры слияния <xref:System.Data.Objects.MergeOption> или <xref:System.Data.Objects.MergeOption>, то этот шаг не влияет на производительность.  Для получения дополнительной информации см. [Identity Resolution, State Management, and Change Tracking](http://msdn.microsoft.com/ru-ru/3bd49311-0e72-4ea4-8355-38fe57036ba0).|  
  
 <sup>1</sup> Если в поставщике источника данных реализована организация пулов соединений, то затраты на открытие одного соединения распределяются по всему пулу.  Поставщик .NET для SQL Server поддерживает организацию пулов соединений.  
  
 <sup>2</sup> Затраты возрастают с повышением сложности запросов.  
  
 <sup>3</sup> Общие затраты возрастают пропорционально числу объектов, возвращенных запросом.  
  
 <sup>4</sup> Эти накладные расходы не являются обязательными для запросов EntityClient, поскольку они вместо объектов возвращают <xref:System.Data.EntityClient.EntityDataReader>.  Для получения дополнительной информации см. [Поставщик EntityClient для платформы Entity Framework](../../../../../docs/framework/data/adonet/ef/entityclient-provider-for-the-entity-framework.md).  
  
## Дополнительные сведения  
 Ниже приведены дополнительные соображения по факторам, способным влиять на производительность приложений Entity Framework.  
  
### Выполнение запроса  
 Поскольку запросы могут быть ресурсоемкими, учитывайте, в каком участке кода и на каком компьютере выполняется запрос.  
  
#### Отложенное или немедленное выполнение  
 При создании запроса <xref:System.Data.Objects.ObjectQuery%601> или LINQ запрос может выполняться не сразу.  Выполнение запроса откладывается до тех пор, пока не понадобятся его результаты, например результаты перечисления `foreach` \(C\#\) или `For Each` \(Visual Basic\), либо если запрос должен заполнить коллекцию <xref:System.Collections.Generic.List%601>.  Выполнение запроса начинается немедленно при вызове метода <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> в <xref:System.Data.Objects.ObjectQuery%601> либо при вызове метода LINQ, возвращающего одноэлементный запрос, например <xref:System.Linq.Enumerable.First%2A> или <xref:System.Linq.Enumerable.Any%2A>.  Дополнительные сведения см. в разделе [Object Queries](http://msdn.microsoft.com/ru-ru/0768033c-876f-471d-85d5-264884349276) и [Выполнение запросов \(язык LINQ to Entities\)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).  
  
#### Выполнение запросов LINQ на стороне клиента  
 Хотя запрос LINQ выполняется на том компьютере, где размещен источник данных, некоторые части запроса LINQ могут обрабатываться на клиентском компьютере.  Дополнительные сведения см. в подразделе «Выполнение в хранилище» раздела [Выполнение запросов \(язык LINQ to Entities\)](../../../../../docs/framework/data/adonet/ef/language-reference/query-execution.md).  
  
### Сложность запросов и сопоставления  
 Сложность отдельных запросов и сопоставления в модели сущности значительно влияет на производительность запросов.  
  
#### Сложность сопоставления  
 Модели, более сложные, чем простое однозначное сопоставление между сущностями в концептуальной модели и таблицах в режиме хранилища, приводят к созданию более сложных команд, чем модели с однозначным сопоставлением.  
  
#### Сложность запросов  
 Запросы, требующие большого числа соединений в командах, выполняемых с источником данных или возвращающих большой объем данных, могут влиять на производительность следующим образом:  
  
-   Запросы к концептуальной модели, которые кажутся простыми, могут приводить к выполнению более сложных запросов к источнику данных.  Это может происходить как следствие преобразования платформой Entity Framework запроса к концептуальной модели в эквивалентный запрос к источнику данных.  Если один набор сущностей, заданный в концептуальной модели, сопоставляется с несколькими таблицами источника данных либо если связь между сущностями сопоставлена с соединяемой таблицей, то команда запроса к источнику данных может потребовать одного или нескольких соединений.  
  
    > [!NOTE]
    >  Чтобы просмотреть команды, выполняемые по источнику данных для данного запроса, воспользуйтесь методом <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> классов <xref:System.Data.Objects.ObjectQuery%601> или <xref:System.Data.EntityClient.EntityCommand>.  Для получения дополнительной информации см. [How to: View the Store Commands](http://msdn.microsoft.com/ru-ru/f9771c6e-3b62-4b24-a5d4-55d68e14fa79).  
  
-   Вложенные запросы Entity SQL могут создавать соединения на сервере, а также возвращать большое количество строк.  
  
     Далее приведен пример вложенного запроса в предложении проекции:  
  
    ```  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     Кроме того, подобные запросы заставляют конвейер запросов создавать одиночный запрос с дублированием объектов во вложенных запросах.  В результате одиночный столбец может дублироваться несколько раз.  В некоторых базах данных, в том числе SQL Server, это может приводить к чрезмерному значительному разрастанию таблицы TempDB, что снижает производительность сервера.  Вложенные запросы следует выполнять с осторожностью.  
  
-   Любые запросы, возвращающие большие объемы данных, могут снижать производительность, если клиент выполняет операции, использующие ресурсы пропорционально объему результирующего набора.  В таких случаях, возможно, стоит ограничить объем данных, возвращаемых запросом.  Для получения дополнительной информации см. [How to: Page Through Query Results](http://msdn.microsoft.com/ru-ru/ffc0f920-e7de-42e0-9b12-ef356421d030).  
  
 Любые команды, автоматически созданные платформой Entity Framework, могут оказываться сложнее аналогичных команд, написанных вручную разработчиком базы данных.  Если требуется явный контроль над командами, выполняемыми с источником данных, подумайте об определении сопоставления с возвращающей табличное значение функцией или хранимой процедурой.  
  
#### Отношения  
 Для оптимальной производительности запросов необходимо определить связи между сущностями как в виде ассоциаций в модели сущности, так и в виде логических связей в источнике данных.  
  
### Пути запроса  
 По умолчанию при выполнении запроса <xref:System.Data.Objects.ObjectQuery%601> связанные объекты не возвращаются \(хотя возвращаются объекты, представляющие сами связи\).  Связанные объекты можно загрузить одним из трех способов.  
  
1.  Задайте путь запроса до выполнения <xref:System.Data.Objects.ObjectQuery%601>.  
  
2.  Вызовите метод `Load` для свойства навигации, доступного для объекта.  
  
3.  Установите параметр <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> объекта <xref:System.Data.Objects.ObjectContext> в значение `true`.  Обратите внимание, что это будет сделано автоматически при формировании кода уровня объектов с помощью [Entity Data Model Designer](http://msdn.microsoft.com/ru-ru/4ccd7ad6-b934-4f7c-82a0-cfd2d4a95faf).  Дополнительные сведения см. в разделе [Generated Code Overview](http://msdn.microsoft.com/ru-ru/6a88ea38-6a90-4107-bc33-531b79ce5b6a).  
  
 При выборе параметра помните, что придется соблюдать баланс между числом запросов к базе данных и объемом данных, возвращаемых в одном запросе.  Для получения дополнительной информации см. [Loading Related Objects](http://msdn.microsoft.com/ru-ru/452347d2-7b3b-44cd-9001-231299a28cb1).  
  
#### Использование путей запроса  
 Пути запроса определяют граф объектов, возвращаемых запросом.  При указании пути запроса для возврата всех определенных в нем объектов требуется только один запрос к базе данных.  Использование путей запроса может привести к тому, что над источником данных будут выполняться сложные команды из, на первый взгляд, простых запросов к объектам.  Происходит это потому, что для возвращения связанных объектов в рамках одного запроса требуется одно или несколько соединений.  Сложность будет выше в запросах к сложным моделям сущностей, таким как, например, сущность с наследованием или путь, содержащий связи «многие ко многим».  
  
> [!NOTE]
>  Используйте метод <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>, чтобы увидеть команду, которая будет сформирована методом <xref:System.Data.Objects.ObjectQuery%601>.  Для получения дополнительной информации см. [How to: View the Store Commands](http://msdn.microsoft.com/ru-ru/f9771c6e-3b62-4b24-a5d4-55d68e14fa79).  
  
 Когда путь запроса содержит слишком много связанных объектов или эти объекты содержат слишком много строковых данных, источник данных может оказаться не в состоянии выполнить запрос.  Это происходит, если запросу требуется промежуточное временное хранилище, которое превышает возможности источника данных.  В этом случае можно снизить сложность запроса к источнику данных путем явной загрузки связанных объектов.  
  
#### Явная загрузка связанных объектов  
 Явно загрузить связанные объекты можно, вызвав метод `Load` для свойства навигации, возвращающего <xref:System.Data.Objects.DataClasses.EntityCollection%601> или <xref:System.Data.Objects.DataClasses.EntityReference%601>.  При явной загрузке объектов требуется выполнять цикл обмена данными с базой данных при каждом вызове метода `Load`.  
  
> [!NOTE]
>  Если при циклической обработке коллекции возвращенных объектов, например при использовании инструкции `foreach` \(`For Each` в Visual Basic\), вызывается метод `Load`, поставщик для каждого конкретного источника данных должен поддерживать несколько активных результирующих наборов на одном соединении.  Для базы данных SQL Server в строке подключения поставщика необходимо указать значение `MultipleActiveResultSets = true`.  
  
 Можно также использовать метод <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, если сущности не имеют свойств <xref:System.Data.Objects.DataClasses.EntityCollection%601> и <xref:System.Data.Objects.DataClasses.EntityReference%601>.  Это может оказаться полезным в том случае, если используются сущности POCO.  
  
 Хотя явная загрузка связанных объектов сократит число соединений и объем избыточных данных, метод `Load` потребует повторного соединения к базе данных, что может привести к повышении накладных расходов при загрузке большого числа объектов.  
  
### Сохранение изменений  
 При вызове метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для <xref:System.Data.Objects.ObjectContext> для каждого добавленного, обновленного или удаленного объекта в контексте создается отдельная команда создания, обновления или удаления.  Эти команды выполняются для источника данных в единой транзакции.  Как и в случае с запросами, производительность операций создания, обновления и удаления зависит от сложности сопоставления в концептуальной модели.  
  
### Распределенные транзакции  
 Операции в явной транзакции, требующие ресурсов, управляемых координатором распределенных транзакций \(DTC\), будут гораздо затратнее, чем схожая операция, не требующая его использования.  Повышение уровня явных транзакций до DTC будет происходить в следующих случаях.  
  
-   Явная транзакция с операцией для базы данных SQL Server 2000 или другого источника данных, который всегда повышает уровень явных транзакций до DTC.  
  
-   Явная транзакция с операцией для SQL Server 2005, если соединение управляется [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)].  Причина этого заключается в том, что SQL Server 2005 передает транзакцию в DTC при каждом закрытии и повторном открытии соединения в пределах одной транзакции, что является поведением [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] по умолчанию.  Такое повышение уровня DTC не происходит при использовании SQL Server 2008. Чтобы избежать такого повышения уровня при работе с SQL Server 2005, необходимо явно открывать и закрывать соединение в пределах одной транзакции.  Для получения дополнительной информации см. [Managing Connections and Transactions](http://msdn.microsoft.com/ru-ru/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 Явная транзакция используется, если в пределах транзакции <xref:System.Transactions> выполняется одна или несколько операций.  Для получения дополнительной информации см. [Managing Connections and Transactions](http://msdn.microsoft.com/ru-ru/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
## Стратегии повышения производительности  
 Ниже перечислены методики, позволяющие повысить общую производительность запросов платформы Entity Framework.  
  
#### Предварительное создание представлений  
 Создание представлений на базе модели сущностей \- это значительная статья расходов при первом выполнении запроса приложением.  С помощью программы EdmGen.exe можно заранее создавать представления в виде файлов с кодом Visual Basic или C\#, которые будут добавляться в проект во время проектирования.  Можно также использовать средства преобразования текстовых шаблонов для создания представлений до компиляции.  Предварительно созданные представления во время выполнения будут проверяться на согласованность с текущей версией указанной модели сущностей.  Дополнительные сведения см. в разделах [How to: Pre\-Generate Views to Improve Query Performance](http://msdn.microsoft.com/ru-ru/b18a9d16-e10b-4043-ba91-b632f85a2579) и [Изоляция производительности для представлений до компиляции или до создания в Entity Framework 4](http://go.microsoft.com/fwlink/?LinkID=201337&clcid=0x409).  
  
 При работе с очень большими моделями нужно принимать во внимание следующие соображения.  
  
 Формат метаданных .NET ограничивает число символов пользовательской строки в заданном двоичном блоке до 16 777 215 \(0xFFFFFF\).  Если при создании представлений для очень большой модели файл представления достигает ограничения размера, будет выдана ошибка компиляции «Недостаточно логического пространства для создания пользовательских строк».  Это ограничение имеет силу для всех управляемых библиотек.  Дополнительные сведения см. в [блоге](http://go.microsoft.com/fwlink/?LinkId=201476), в котором описывается, как избежать ошибок при работе с большими и сложными моделями.  
  
#### Рассмотрите возможность использования параметра слияния NoTracking для запросов  
 Для отслеживания возвращаемых объектов в контексте объекта требуются определенные затраты.  Для распознавания изменений в объектах и гарантии того, что несколько запросов к одной логической сущности возвратят один экземпляр объекта, требуется, чтобы объекты были присоединены к экземпляру <xref:System.Data.Objects.ObjectContext>.  Если не планируется обновление и удаление объектов, а также управление идентификаторами, попробуйте воспользоваться параметрами слияния <xref:System.Data.Objects.MergeOption> при выполнении запросов.  
  
#### Возвращение правильного объема данных  
 В некоторых случаях указание пути запроса с помощью метода <xref:System.Data.Objects.ObjectQuery%601.Include%2A> выполняется гораздо быстрее, поскольку требуется меньше циклов обмена данными с базой данных.  Однако в других сценариях дополнительные циклы обмена данными с базой данных при загрузке связанных объектов могут выполняться быстрее, поскольку более простые запросы с меньшим количеством соединений ведут к меньшей избыточности данных.  В связи с этим рекомендуется проверять производительность разных способов получения связанных объектов.  Для получения дополнительной информации см. [Loading Related Objects](http://msdn.microsoft.com/ru-ru/452347d2-7b3b-44cd-9001-231299a28cb1).  
  
 Чтобы избежать возвращения слишком большого объема данных в одном запросе, можно прибегнуть к подкачке страниц результатов запроса, что даст более простые в управлении группы.  Для получения дополнительной информации см. [How to: Page Through Query Results](http://msdn.microsoft.com/ru-ru/ffc0f920-e7de-42e0-9b12-ef356421d030).  
  
#### Ограничение области объекта ObjectContext  
 В большинстве случаев следует создавать экземпляр <xref:System.Data.Objects.ObjectContext> внутри инструкции `using` \(`Using…End Using` в Visual Basic\).  Это может повысить производительность, поскольку гарантирует автоматическое удаление ресурсов, связанных с контекстом объекта, при выходе из блока инструкции в коде.  Однако, если элементы управления привязаны к объектам, управляемым контекстом объекта, экземпляр <xref:System.Data.Objects.ObjectContext> следует сохранять до тех пор, пока требуется привязка, а удалять его \- вручную.  Для получения дополнительной информации см. [Managing Connections and Transactions](http://msdn.microsoft.com/ru-ru/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
#### Рассмотрите возможность подключения базы данных вручную  
 Если приложение выполняет серию запросов объектов или часто вызывает метод <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для сохранения операций создания, обновления или удаления в источнике данных, то [!INCLUDE[adonet_ef](../../../../../includes/adonet-ef-md.md)] приходится постоянно открывать и закрывать соединение с источником данных.  В таких случаях следует попробовать вручную открывать соединение в начале этих операций и либо закрывать, либо удалять соединение по их завершении.  Для получения дополнительной информации см. [Managing Connections and Transactions](http://msdn.microsoft.com/ru-ru/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
## Данные производительности  
 Некоторые данные производительности платформы Entity Framework опубликованы в приведенных ниже сообщениях [блога группы разработчиков ADO.NET](http://go.microsoft.com/fwlink/?LinkId=91905):  
  
-   [Обзор производительности платформы ADO.NET Entity Framework — Часть 1](http://go.microsoft.com/fwlink/?LinkId=123907)  
  
-   [Обзор производительности платформы ADO.NET Entity Framework — Часть 2](http://go.microsoft.com/fwlink/?LinkId=123909)  
  
-   [Сравнение производительности платформы ADO.NET Entity Framework](http://go.microsoft.com/fwlink/?LinkID=123913)  
  
## См. также  
 [Вопросы разработки и развертывания](../../../../../docs/framework/data/adonet/ef/development-and-deployment-considerations.md)