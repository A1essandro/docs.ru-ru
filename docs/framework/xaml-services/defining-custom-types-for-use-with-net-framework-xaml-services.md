---
title: "Определение пользовательских типов для использования со службами XAML .NET Framework"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: 
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: c7cce479c7c7a5f6c7112f08f1e15f3bc7e4d366
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a>Определение пользовательских типов для использования со службами XAML .NET Framework
При определении пользовательских типов, которые являются бизнес-объектов или являются типами, которые имеют зависимости от определенной платформы, существуют определенные рекомендации для XAML, можно выполнить. При выполнении этих рекомендаций служб XAML .NET Framework и средств чтения и записи XAML можно выяснить характеристики XAML пользовательского типа и предоставить ему соответствующее представление в потоке узлов XAML, с помощью системы типов XAML. В этом разделе приводятся рекомендации для определения типов, определения членов и присвоение атрибутов CLR типов или членов.  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a>Шаблоны конструктора и определения типов для XAML  
 Для создания экземпляра объекта в качестве элемента XAML, пользовательский класс должен соответствовать следующим требованиям:  
  
-   Пользовательский класс должен быть открытым и должен предоставлять открытый конструктор по умолчанию (без параметров). (Примечания о структурах см. в следующем разделе.)  
  
-   Пользовательский класс не должен быть вложенным классом. Лишние «точка» в пути полного имени делает неоднозначных имен класса деления и мешает другим возможностям XAML, таких как вложенные свойства.  
  
 Если объект могут быть созданы как объектный элемент, созданный объект может заполнить форму элемента все свойства, которые используют этот объект как базовый тип свойства.  
  
 По-прежнему можно предоставить значения объекта для типов, которые не удовлетворяют этим критериям, если включение преобразователя значений. Дополнительные сведения см. в разделе [преобразователи типов или расширения разметки для XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  
  
### <a name="structures"></a>Структуры  
 Структуры являются всегда следует создавать в XAML, по определению среды CLR. Это потому, что компилятор CLR неявно создает конструктор по умолчанию для структуры. Этот конструктор инициализирует значения свойств по умолчанию.  
  
 В некоторых случаях поведение конструктора по умолчанию для структуры является нежелательным. Возможно, структура предназначено для заполнения значения и функция, по существу, как объединение. Значения могут обладать взаимоисключающие union, и таким образом, ни один из его свойства могут задаваться. Примером такой структуры в словаре WPF является <xref:System.Windows.GridLength>. Таких структурах необходимо реализовать преобразователь типов, чтобы значения можно представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры. Структура также должна реализовывать аналогичное поведение для конструкции кода с помощью конструктора, не являющегося конструктором по умолчанию.  
  
### <a name="interfaces"></a>интерфейсов,  
 Интерфейсы можно использовать как базовые типы членов. Система типов XAML проверяет список может быть назначен и ожидает, объект, предоставляемый как значение может быть присвоен интерфейсу. Не используется понятие интерфейса должен быть представления как тип XAML при условии, что соответствующий присваиваемый тип поддерживает требования к созданию XAML.  
  
### <a name="factory-methods"></a>Фабричные методы  
 Фабричные методы являются возможностью XAML 2009. Они модифицируют принцип XAML, что объекты должны иметь конструкторы по умолчанию. В этом разделе фабричные методы не документированы. В разделе [директива x: FactoryMethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md).  
  
## <a name="enumerations"></a>Перечисления  
 Перечисления иметь поведение преобразования собственного типа XAML. Имена констант перечисления, указанные в XAML разрешении относительно базового типа перечисления и возвращают значение перечисления средству записи объектов XAML.  
  
 XAML поддерживает использование стиля флаги перечисления с <xref:System.FlagsAttribute> применения. Дополнительные сведения см. в разделе [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md). ([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) адресован WPF, но большая часть сведений в этом разделе относятся только к XAML, который не относится к конкретной платформе реализации.)  
  
## <a name="member-definitions"></a>Определения элементов  
 Типы можно определить элементы для использования XAML. Это возможно для типов, которые определяют элементы, которые могут использоваться в XAML, даже если этого конкретного типа не может использоваться в XAML. Это возможно благодаря наследованию CLR. При условии, что некоторый тип, наследующий член поддерживает использование XAML как тип, а в поддерживает использование XAML для своего базового типа, или имеет собственный синтаксис XAML, этот элемент, можно использовать для XAML.  
  
### <a name="properties"></a>Свойства  
 При определении свойств в качестве открытого свойства среды CLR с помощью обычной CLR `get` и `set` шаблонов доступа и соответствующих языку, в системе типов XAML может сообщать указанное свойство как элемент с соответствующими данными для <xref:System.Xaml.XamlMember> свойства, такие как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A>.  
  
 Некоторые свойства могут включать текстовый синтаксис путем применения <xref:System.ComponentModel.TypeConverterAttribute>. Дополнительные сведения см. в разделе [преобразователи типов или расширения разметки для XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).  
  
 В отсутствие текстового синтаксиса или собственного преобразования XAML и в отсутствие дальнейшей косвенности, таких как использование расширения разметки, тип свойства (<xref:System.Xaml.XamlMember.TargetType%2A> системе типов XAML) должен иметь возможность получить экземпляр средство записи объектов XAML, рассматривая t конечный тип как тип CLR.  
  
 При использовании XAML 2009, [расширение разметки x: Reference](../../../docs/framework/xaml-services/x-reference-markup-extension.md) может использоваться для предоставления значений, если не выполняются указанные выше требования; тем не менее, это скорее вопрос использования, чем проблема определения типа.  
  
### <a name="events"></a>События  
 При определении событий в качестве открытого события CLR система типов XAML может сообщать о событии как член с <xref:System.Xaml.XamlMember.IsEvent%2A> как `true`. Привязка обработчиков событий не входит в область возможностей служб XAML .NET Framework. Это отводится отдельным платформам и реализации.  
  
### <a name="methods"></a>Методы  
 Встроенный код для методов не возможностей XAML по умолчанию. В большинстве случаев вы не используйте прямые ссылки метод членов из XAML, и методы в языке XAML — только для предоставления поддержки для отдельных шаблонов XAML. [Директива x: FactoryMethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md) является исключением.  
  
### <a name="fields"></a>Поля  
 Рекомендации по проектированию CLR не рекомендуем нестатического поля. Для статических полей, значения статических полей можно использовать только с использованием [расширение разметки x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md); в этом случае не производится ничего особенного, в определении CLR, чтобы открыть поле для [x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) варианты использования.  
  
## <a name="attachable-members"></a>Прикрепляемые члены  
 Прикрепляемые члены доступны в XAML через шаблона метода доступа на определяющем типе. Сам определяющий тип не требуется для использования XAML, как объект. Фактически, распространенным шаблоном является объявление класса службы, цель которого — содержать присоединяемый член и реализовывать соответствующие поведения, но обслуживать никаких других функций, таких как представление пользовательского интерфейса. В следующих разделах заполнитель *PropertyName* представляет имя пользовательского присоединяемого члена. Это имя должно быть допустимым в [Грамматика XamlName](../../../docs/framework/xaml-services/xamlname-grammar.md).  
  
 Тщательно конфликты имен между этими шаблонами и другие методы типа. Если существует элемент, соответствующий одному из шаблонов, он интерпретируется как путь использования присоединяемого члена обработчиком XAML даже если не желает.  
  
#### <a name="the-getpropertyname-accessor"></a>Метод доступа GetИмяСвойства  
 Сигнатура для метода доступа `Get`*ИмяСвойства* должна быть следующей.  
  
 `public static object Get` *ИмяСвойства* `(object` `target` `)`  
  
-   Объект `target` можно указать как более конкретный тип в реализации. Это можно использовать для определения границ использования присоединяемого члена; Использование за пределами этих границ вызовет исключения недопустимого приведения, которые затем отображаются ошибку синтаксического анализа XAML. Имя параметра `target` не является обязательным, но называется `target` по соглашению в большинстве реализаций.  
  
-   Возвращаемое значение можно указать как более конкретный тип в реализации.  
  
 Для поддержки <xref:System.ComponentModel.TypeConverter> включена текстовый синтаксис для использования атрибутов присоединяемого члена, применяются <xref:System.ComponentModel.TypeConverterAttribute> для `Get` *PropertyName* метода доступа. Применение к `get` вместо `set` может показаться неинтуитивным; Однако это соглашение может поддерживать понятие объекта только для чтения присоединяемых членов, которые могут быть сериализованы, это полезно в сценариях разработчика.  
  
#### <a name="the-setpropertyname-accessor"></a>Метод доступа SetИмяСвойства  
 Подпись для набора*PropertyName* метод доступа должен быть:  
  
 `public static void Set` *ИмяСвойства* `(object` `target` `, object` `value` `)`  
  
-   `target` Объекта можно указать как более конкретный тип в реализации, с таким же логика и последствия, как описано в предыдущем разделе.  
  
-   Объект `value` можно указать как более конкретный тип в реализации.  
  
 Помните, что значение для этого метода является входные данные, поступающие от использования XAML, обычно в виде атрибута. Из формы атрибута должно быть поддержка преобразователя значения для текстового синтаксиса и атрибут `Get` *PropertyName* метода доступа.  
  
### <a name="attachable-member-stores"></a>Хранилища присоединяемых членов  
 Методы доступа, обычно не достаточно, чтобы обеспечивать для размещения значений присоединяемого члена в граф объектов или извлечения значений из графа объектов и надлежащей их сериализации. Для поддержки этой функции `target` объекты в предыдущих сигнатурах метода доступа должны быть способны хранить значения. Механизм хранения должно быть согласовано с принципом присоединяемого члена, член может быть присоединен к целевым объектам, когда присоединяемого члена не содержится в списке элементов. Службы XAML .NET framework предоставляют методику реализации хранилищ присоединяемых членов через API <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices>. <xref:System.Xaml.IAttachedPropertyStore>используется средствами записи XAML для обнаружения реализации хранилища и должен быть реализован в типе, который является `target` методов доступа. Статический <xref:System.Xaml.AttachablePropertyServices> API-интерфейсы используются внутри тела методов доступа и ссылаться на присоединяемого члена, его <xref:System.Xaml.AttachableMemberIdentifier>.  
  
## <a name="xaml-related-clr-attributes"></a>Атрибуты среды CLR, связанные с XAML  
 Правильное назначение атрибутов типов, членов и сборки является очень важным для сообщения сведений системы типов XAML служб XAML .NET Framework. Это применимо, если вы типы предназначены для использования с системами XAML напрямую на основе средства чтения XAML служб XAML .NET Framework и средства записи XAML, или определяется или используется платформа, использующая XAML, который основан на этих средств чтения и записи XAML.  
  
 Список каждого атрибута, связанные с XAML, который относится к поддержке XAML для пользовательских типов см. в разделе [XAML-Related атрибуты среды CLR для пользовательских типов и библиотек](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).  
  
## <a name="usage"></a>Использование  
 Использование пользовательских типов требует, что автор разметки необходимо сопоставить префикс для сборки и пространства имен CLR, содержащие пользовательского типа. Эта процедура не описаны в этом разделе.  
  
## <a name="access-level"></a>Уровень доступа  
 XAML предоставляет механизм для загрузки и создания экземпляров типов, имеющих `internal` уровень доступа. Эта возможность предоставляется, чтобы пользовательский код может определять собственные типы и затем создавать экземпляры этих классов из разметки, которое также является частью той же области кода пользователя.  
  
 Пример из WPF — всякий раз, когда пользовательский код определяет <xref:System.Windows.Controls.UserControl> , предназначенного способ рефакторинга поведения пользовательского интерфейса, а не как часть любого возможного механизма расширения, могло бы подразумевать объявление поддерживающего класса с `public` уровень доступа. Такие <xref:System.Windows.Controls.UserControl> может быть объявлен с `internal` доступ, если резервное копирование код компилируется в сборку, от которого он упоминается как типа XAML.  
  
 Для приложения, которое загружает XAML-код в режиме полного доверия и использует <xref:System.Xaml.XamlObjectWriter>, загрузка классов с `internal` уровень доступа всегда включен.  
  
 Для приложения, которое загружает XAML-код в режиме частичного доверия, характеристиками уровня доступа можно управлять с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API. Кроме того механизмы отсрочки (такие как система шаблонов WPF) должен уметь распространить все разрешения уровня доступа и сохранять их для вычисления оценки во время выполнения; Это производится внутренне путем передачи <xref:System.Xaml.Permissions.XamlAccessLevel> сведения.  
  
### <a name="wpf-implementation"></a>Реализация WPF  
 XAML в WPF используется модель доступа частичного доверия, где Если BAML загружается в режиме частичного доверия, ограничен доступ к <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> для сборки, которая является источником BAML. Для отсрочки WPF использует <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> в качестве механизма для передачи информации об уровне доступа.  
  
 В терминах WPF XAML *внутренний тип* — тип, который определен в сборке, который также включает ссылающейся XAML. Такой тип может быть сопоставлен через пространство имен XAML, который намеренно опущен сборки = часть сопоставления, например, `xmlns:local="clr-namespace:WPFApplication1"`.  Если BAML ссылается на внутренний тип и этот тип имеет `internal` обращаться к уровню, это приводит к возникновению ошибки `GeneratedInternalTypeHelper` класса для сборки. Если вы хотите избежать `GeneratedInternalTypeHelper`, необходимо либо использовать `public` обращаться к уровню, или необходимо выделить соответствующий класс в отдельную сборку и делать эту сборку зависимой.  
  
## <a name="see-also"></a>См. также  
 [Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [Службы XAML](../../../docs/framework/xaml-services/index.md)
