---
title: "Using the Assert Method | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "granting permissions, overriding security checks"
  - "code access security, overriding security checks"
  - "overriding security checks"
  - "security [.NET Framework], overriding security checks"
  - "security [.NET Framework], assertions"
  - "asserted permissions"
  - "Assert method"
  - "caller security checks"
  - "permissions [.NET Framework], overriding security checks"
  - "permissions [.NET Framework], assertions"
ms.assetid: 1e40f4d3-fb7d-4f19-b334-b6076d469ea9
caps.latest.revision: 20
author: "mairaw"
ms.author: "mairaw"
manager: "wpickett"
caps.handback.revision: 18
---
# Using the Assert Method
<xref:System.Security.CodeAccessPermission.Assert%2A> представляет собой метод, который может вызываться для классов разрешений доступа к коду и для класса <xref:System.Security.PermissionSet>.  Можно использовать **Assert**, чтобы разрешить коду \(и подчиненным вызывающим объектам\) выполнять действия, разрешения на выполнение которых есть у кода, но могут отсутствовать у вызывающих объектов.  Утверждение безопасности изменяет нормальный ход процесса, которому следует среда выполнения при проверке безопасности.  Когда вы утверждаете разрешение, система безопасности не проверяет вызывающие объекты кода на наличие утвержденного разрешения.  
  
> [!CAUTION]
>  Используйте утверждения осторожно, так как они могут открывать бреши в системе безопасности и подорвать работу механизма применения ограничений безопасности в среде выполнения.  
  
 Утверждения удобны в ситуациях, когда библиотека вызывает неуправляемый код или совершает вызов, требующий разрешение, связь которого с назначением библиотеки не очевидна.  Например, весь управляемый код, который выполняет вызовы неуправляемого кода, должен иметь **SecurityPermission** с заданным флагом **UnmanagedCode**.  Код, источником которого не является локальный компьютер, например код, скачанный из локальной интрасети, не получает это разрешение по умолчанию.  Таким образом, чтобы код, скачанный из локальной интрасети, мог вызывать библиотеку, использующую неуправляемый код, он должен иметь утвержденное библиотекой разрешение.  Кроме того, некоторые библиотеки могут выполнять вызовы, которые не видны вызывающим объектам и требуют специальных разрешений.  
  
 Утверждения также можно использовать в ситуациях, когда код обращается к ресурсу способом, полностью скрытым от вызывающих объектов.  Предположим, например, что ваша библиотека получает сведения из базы данных, но в процессе также считывает информацию из реестра компьютера.  Так как у разработчиков, использующих эту библиотеку, нет доступа к вашему источнику, они никак не могут узнать, что для использования вашего кода их код должен иметь **RegistryPermission**.  Если в такой ситуации вы решите, что неразумно или нерационально требовать наличия разрешения на доступ к реестру у вызывающих ваш код объектов, можно утвердить разрешение на чтение из реестра.  В данном случае уместно утвердить разрешение для библиотеки, чтобы ее могли использовать вызывающие объекты без разрешения **RegistryPermission**.  
  
 Утверждение влияет на обход стека только в том случае, если утвержденное разрешение и разрешение, затребованное подчиненным вызывающим объектом, имеют один и тот же тип, а запрошенное разрешение является подмножеством утвержденного разрешения.  Например, если вы утверждаете разрешение **FileIOPermission** для чтения всех файлов на диске , а подчиненный вызывающий объект запрашивает разрешение **FileIOPermission** для чтения файлов в папке C:\\Temp, утверждение может повлиять на обход стека, однако если было запрошено разрешение **FileIOPermission** для записи на диск C, утверждение не окажет никакого влияния.  
  
 Для выполнения утверждений коду должно быть назначено как разрешение, которое вы утверждаете, так и разрешение <xref:System.Security.Permissions.SecurityPermission>, представляющее право на выполнение утверждений.  Хотя вы и можете утвердить разрешение, которое не было предоставлено коду, такое утверждение будет бессмысленным, так как проверка безопасности завершится со сбоем до того, как такое утверждение могло бы поспособствовать ее успешному завершению.  
  
 На следующем рисунке показано, что происходит при использовании **Assert**.  Предположим, что справедливы следующие утверждения о сборках A, B, C, E и F, а также разрешениях P1 и P1A:  
  
-   P1A предоставляет право чтения TXT\-файлов на диске C.  
  
-   P1 предоставляет право чтения всех файлов на диске C.  
  
-   Как P1A, так и P1 относятся к типу **FileIOPermission**, а P1A является подмножеством P1.  
  
-   Сборкам E и F назначено разрешение P1A.  
  
-   Сборке C назначено разрешение P1.  
  
-   Сборкам A и B не назначено ни разрешение P1, ни разрешение P1A.  
  
-   Метод A содержится в сборке A, метод B содержится в сборке B и т. д.  
  
 ![](../../../docs/framework/misc/media/assert.png "assert")  
Использование утверждения  
  
 В этом сценарии, метод A вызывает B, B вызывает C, C вызывает E и E вызывает F.  Метод C утверждает разрешение на чтение файлов на диске C \(разрешение P1\), а метод E запрашивает разрешения на чтение TXT\-файлов на диске C \(разрешение P1A\).  Когда запрос из сборки F обнаруживается во время выполнения, выполняется обход стека для проверки разрешений всех вызывающих объектов F, начиная с E.  Сборке E было назначено разрешение P1A, поэтому обход стека продолжается для проверки разрешений у C, где обнаруживается утверждение.  Так как запрошенное разрешение \(P1A\) является подмножеством утвержденного разрешения \(P1\), обход стека останавливается, а проверка безопасности завершается успешно.  То, что разрешение P1A не было назначено сборкам A и B, не имеет никакого значения.  Утверждая P1, метод C позволяет вызывающим объектам обращаться к ресурсу, защищенному при помощи P1, даже если вызывающие объекты не имеют разрешения на доступ к этому ресурсу.  
  
 Если вы разрабатываете библиотеку классов и класс обращается к защищенному ресурсу, в большинстве случаев следует реализовать требование безопасности относительно наличия у вызывающих объектов этого класса соответствующего разрешения.  Если затем класс выполняет операцию, для которой у большинства вызывающих объектов не будет разрешения, и вы готовы принять на себя ответственность за предоставление этим вызывающим объектам возможности вызова вашего кода, можно утвердить разрешение, вызвав метод **Assert** для объекта разрешения, который представляет выполняемую кодом операцию.  Используя **Assert** подобным образом, вы позволяете вызывающим объектам вызывать ваш код, что они не могли бы сделать в обычных условиях.  Таким образом, если вы утверждаете разрешение, следует обязательно заранее выполнить соответствующие проверки безопасности, чтобы предотвратить неправильное использование вашего компонента.  
  
 Например, предположим, что ваш в высшей степени доверенный класс библиотеки содержит метод, удаляющий файлы.  Он обращается к файлу путем вызова неуправляемой функции Win32.  Вызывающий объект вызывает метод **Delete** кода, передавая имя удаляемого файла для удаления: C:\\Test.txt.  В методе **Удаление** код создает объект <xref:System.Security.Permissions.FileIOPermission>, представляющий доступ на запись к файлу C:\\Test.txt.  \(Для удаления файла требуется доступ на запись.\) После этого код запускает принудительную проверку безопасности, вызвав метод **Demand** объекта **FileIOPermission**.  Если один из вызывающих объектов в стеке вызовов не имеет этого разрешения, возникает исключение <xref:System.Security.SecurityException>.  Если исключение не выдается, вы можете быть уверены в том, что все вызывающие объекты имеют право доступа к C:\\Test.txt.  Так как предполагается, что большинство вызывающих объектов не будет иметь разрешение на доступ к неуправляемому коду, код создает объект <xref:System.Security.Permissions.SecurityPermission>, представляющий право вызова неуправляемого кода, и вызывает метод **Assert** объекта.  Наконец он вызывает неуправляемую функцию Win32 для удаления файла C:\\Text.txt и возвращает управление вызывающему объекту.  
  
> [!CAUTION]
>  Необходимо убедиться, что код не использует утверждения в ситуациях, когда ваш код может использоваться другим кодом для доступа к ресурсу, защищенному утверждаемым вами разрешением.  Например, в коде, который записывает данные в файл, имя которого указывается вызывающим объектом в виде параметра, не следует утверждать разрешение **FileIOPermission** на запись в файлы, так как код будет открыт для неправильного использования третьей стороной.  
  
 При использовании принудительного синтаксиса безопасности вызов метода **Assert** для нескольких разрешений в одном методе приводит к возникновению исключения безопасности.  Вместо этого следует создать объект **PermissionSet**, передать ему отдельные разрешения, которые необходимо вызвать, а затем вызвать метод **Assert** объекта **PermissionSet**.  При использовании декларативного синтаксиса безопасности метод **Assert** можно вызывать несколько раз.  
  
 В следующем примере показан декларативный синтаксис для переопределения проверок безопасности при помощи метода **Assert**.  Обратите внимание, что синтаксис **FileIOPermissionAttribute** принимает два значения: перечисление <xref:System.Security.Permissions.SecurityAction> и расположение файла или каталога, для которого предоставляется разрешение.  Вызов **Assert** обеспечивает успешное выполнение запросов на доступ к `C:\Log.txt` несмотря на то, что вызывающие объекты не проверяются на разрешение доступа к файлу.  
  
```vb  
Option Explicit  
Option Strict  
  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
  
      End Sub  
  
     <FileIOPermission(SecurityAction.Assert, All := "C:\Log.txt")> Public Sub   
      MakeLog()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now) '  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      [FileIOPermission(SecurityAction.Assert, All = @"C:\Log.txt")]  
      public void MakeLog()  
      {     
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}   
```  
  
 В следующих фрагментах кода показан принудительный синтаксис для переопределения проверок безопасности при помощи метода **Assert**.  В этом примере объявлен экземпляр объекта **FileIOPermission**.  Его конструктору передается **FileIOPermissionAccess.AllAccess** для определения типа разрешенного доступа, а затем строка, описывающая расположение файла.  После определения объекта **FileIOPermission** необходимо просто вызвать метод **Assert** для переопределения проверки безопасности.  
  
```vb  
Option Explicit  
Option Strict  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
      End Sub 'New  
  
      Public Sub MakeLog()  
         Dim FilePermission As New FileIOPermission(FileIOPermissionAccess.AllAccess, "C:\Log.txt")  
         FilePermission.Assert()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now)  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      public void MakeLog()  
      {  
         FileIOPermission FilePermission = new FileIOPermission(FileIOPermissionAccess.AllAccess,@"C:\Log.txt");   
         FilePermission.Assert();  
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}  
```  
  
## См. также  
 <xref:System.Security.PermissionSet>   
 <xref:System.Security.Permissions.SecurityPermission>   
 <xref:System.Security.Permissions.FileIOPermission>   
 <xref:System.Security.Permissions.SecurityAction>   
 [Атрибуты](../../../docs/standard/attributes/index.md)   
 [Code Access Security](../../../docs/framework/misc/code-access-security.md)