---
title: "Code Access Security Basics | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "security [.NET Framework], code access security"
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
caps.latest.revision: 21
author: "mairaw"
ms.author: "mairaw"
manager: "wpickett"
caps.handback.revision: 19
---
# Code Access Security Basics
Каждое приложение, ориентированное на среду CLR \(то есть каждое управляемое приложение\), должно взаимодействовать с ее системой безопасности. Когда управляемое приложение загружается, его узел автоматически предоставляет ему набор разрешений. Эти разрешения определяются параметрами локальной безопасности узла или изоляцией приложения. В зависимости от этих разрешений приложение либо запускается, либо вызывает исключение безопасности.  
  
 Узел по умолчанию для классических приложений позволяет коду выполняться в режиме полного доверия. По этой причине, если приложение предназначено для настольных компьютеров, оно имеет неограниченный набор разрешений. Другие узлы или "песочницы" предоставляют ограниченный набор разрешений для приложений. Набор разрешений может меняться от узла к узлу, поэтому приложение должно быть разработано для использования только тех разрешений, которые допускаются целевым узлом.  
  
 Чтобы писать эффективные приложения, нацеленные на среду CLR, нужно быть знакомым с приведенными ниже принципами управления доступом для кода.  
  
-   **Типобезопасный код**. Типобезопасный код — это код, осуществляющий доступ к типам только строго определенными, допустимыми способами. Например, имея действительную ссылку на объект, типобезопасный код может осуществлять доступ к памяти по фиксированным смещениям, соответствующим реальным членам\-полям. Если код производит доступ к памяти по произвольным смещениям за пределами диапазона памяти, принадлежащего открытым полям этого объекта, он не является типобезопасным. Чтобы иметь возможность пользоваться преимуществами управления доступом для кода, необходимо использовать компилятор, создающий проверяемый типобезопасный код. Подробнее см. в разделе [Написание проверяемого типобезопасного кода](#typesafe_code).  
  
-   **Принудительный и декларативный синтаксис**. Код, нацеленный на среду CLR, может взаимодействовать с системой безопасности путем запроса разрешений, требования определенных разрешений от вызывающих объектов, а также путем переопределения некоторых параметров безопасности \(при наличии достаточных полномочий\). Можно использовать две различные формы синтаксиса для программного взаимодействия с системой безопасности .NET Framework: декларативный синтаксис и принудительный синтаксис. Декларативные вызовы выполняются с использованием атрибутов; принудительные вызовы выполняются с использованием новых экземпляров классов в вашем коде. Некоторые вызовы могут выполняться только принудительно, другие — только декларативно, а некоторые — любым способом.  
  
-   **Безопасные библиотеки классов**. Безопасная библиотека классов использует требования безопасности для обеспечения наличия у вызывающих объектов разрешений на доступ к ресурсам, предоставляемым библиотекой. Например, безопасная библиотека классов может содержать метод для создания файлов, который будет требовать, чтобы вызывающие его объекты обладали разрешениями на создание файлов. Платформа .NET Framework включает в себя безопасные библиотеки классов. Вам необходимо учитывать разрешения, требуемые для доступа к любой библиотеке, используемой кодом. Подробнее см. в подразделе [Использование безопасных библиотек классов](#secure_library) далее в этом разделе.  
  
-   **Прозрачный код**. В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] и более поздних версиях в дополнение к определению соответствующих разрешений нужно определить, должен ли код выполняться как прозрачный с точки зрения безопасности. Прозрачный с точки зрения безопасности код не может вызывать типы или члены, которые определены как критические с точки зрения безопасности. Это правило относится к приложениям как с полным, так и с частичным доверием. Для получения дополнительной информации см. [Security\-Transparent Code](../../../docs/framework/misc/security-transparent-code.md).  
  
> [!CAUTION]
>  Управление доступом для кода и частично доверенный код  
>   
>  Платформа .NET Framework предоставляет механизм для принудительного применения различных уровней доверия к разным частям кода, выполняемым в одном и том же приложении. Этот механизм называется управлением доступом для кода.  Управление доступом для кода в .NET Framework не следует использовать в качестве средства безопасности при работе с частично доверенным кодом, особенно кодом неизвестного происхождения. Мы не рекомендуем загружать и выполнять код из неизвестных источников, не предприняв дополнительные меры безопасности.  
>   
>  Эта политика действует в отношении всех версий платформы .NET Framework, кроме платформы .NET Framework в составе Silverlight.  
  
<a name="typesafe_code"></a>   
## Написание проверяемого типобезопасного кода  
 JIT\-компиляция выполняет процесс проверки, который анализирует код и пытается определить, является ли он типобезопасным. Код, который в процессе проверки признается типобезопасным, называется *проверяемым типобезопасным кодом*. Код может быть типобезопасным, но не проверяемым типобезопасным из\-за ограничений процесса проверки его компилятором. Не все языки являются типобезопасными, и компиляторы некоторых языков, таких как Microsoft Visual C\+\+, не могут создавать проверяемый типобезопасный код. Чтобы определить, создает ли компилятор языка, который вы используете, проверяемый типобезопасный код, нужно свериться с документацией по компилятору. Если вы используете компилятор языка, создающий проверяемый типобезопасный код только в случае, если вы избегаете определенных конструкций языка, возможно, вы захотите воспользоваться [средством PEVerify](../../../docs/framework/tools/peverify-exe-peverify-tool.md), чтобы определить, является ли ваш код проверяемым типобезопасным.  
  
 Код, не являющийся проверяемым типобезопасным, может осуществить попытку выполнения, если политика безопасности позволяет коду обойти проверку. Однако, так как строгая типизация является неотъемлемой частью механизма среды выполнения для изоляции сборок, безопасность не может уверенно соблюдаться, если код нарушает правила типобезопасности. По умолчанию код, не являющийся типобезопасным, допускается к выполнению, только если его источником является локальный компьютер. Поэтому мобильный код должен быть типобезопасным.  
  
<a name="secure_library"></a>   
## Использование безопасных библиотек классов  
 Если код запрашивает и получает разрешения, требуемые библиотекой классов, ему будет разрешен доступ к библиотеке и ресурс будет защищен от несанкционированного доступа. Если же код не будет обладать соответствующими разрешениями, он не сможет получить доступ к библиотеке и вредоносный код не сможет воспользоваться вашим кодом для непрямого доступа к защищенным ресурсам. Даже если ваш код получит разрешение на доступ к библиотеке, его запуск не будет разрешен, если код, вызвавший его, также не обладает разрешением на доступ к этой библиотеке.  
  
 Управление доступом для кода не исключает вероятности человеческой ошибки при написании кода. Но если приложение использует безопасные библиотеки классов для доступа к защищенным ресурсам, риск для безопасности кода приложения снижается, так как библиотеки классов тщательно изучаются на предмет потенциальных проблем безопасности.  
  
## Декларативная безопасность  
 Декларативный синтаксис безопасности использует [атрибуты](../../../docs/standard/attributes/index.md) для размещения информации о безопасности в [метаданных](../../../docs/standard/metadata-and-self-describing-components.md) кода. Атрибуты могут быть указаны на уровне сборки, класса или члена для указания типа запроса, требования или переопределения, которые необходимо использовать. Запросы используются в приложениях, нацеленных на среду CLR, для информирования системы безопасности среды выполнения о разрешениях, которые нужны или не нужны вашему приложению. Требования и переопределения используются в библиотеках для защиты ресурсов от вызывающих объектов или переопределения поведения системы безопасности по умолчанию.  
  
> [!NOTE]
>  В версии [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] произошли серьезные изменения в терминологии и модели безопасности .NET Framework. Дополнительные сведения об этих изменениях см. в разделе [Изменения системы безопасности](../../../docs/framework/security/security-changes.md).  
  
 Чтобы использовать декларативные вызовы безопасности, необходимо инициализировать данные состояния объекта разрешения таким образом, чтобы они представляли определенную форму необходимого разрешения. Каждое встроенное разрешение имеет атрибут, которому передается перечисление <xref:System.Security.Permissions.SecurityAction> для описания типа операции безопасности, которую нужно выполнить. Однако разрешения также принимают собственные параметры, являющиеся для них исключительными.  
  
 В приведенном ниже фрагменте кода показано использование декларативного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. В этом примере декларативный вызов помещен непосредственно перед определением класса, указывая, что разрешение применяется на уровне класса. Атрибуту передается структура **SecurityAction.Demand** для указания на то, что вызывающие объекты должны обладать этим разрешением для выполнения.  
  
```vb  
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1 Public Sub New() 'The constructor is protected by the security call. End Sub Public Sub MyMethod() 'This method is protected by the security call. End Sub Public Sub YourMethod() 'This method is protected by the security call. End Sub End Class  
  
```  
  
```csharp  
[MyPermission(SecurityAction.Demand, Unrestricted = true)] public class MyClass { public MyClass() { //The constructor is protected by the security call. } public void MyMethod() { //This method is protected by the security call. } public void YourMethod() { //This method is protected by the security call. } }  
```  
  
## Принудительная безопасность  
 Принудительный синтаксис безопасности производит вызов безопасности, создавая экземпляр объекта разрешения, который нужно вызвать. Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.  
  
 Прежде чем осуществить вызов безопасности, необходимо инициализировать данные состояния объекта разрешения, чтобы они представляли определенную форму необходимого разрешения. Например, создавая объект <xref:System.Security.Permissions.FileIOPermission>, можно использовать конструктор для инициализации объекта **FileIOPermission**, чтобы он предоставлял неограниченный доступ ко всем файлам или же запрещал доступ к файлам. Вы также можете использовать другой объект **FileIOPermission**, передав параметры, указывающие тип доступа, который должен предоставлять объект \(т. е. чтение, добавление или запись\), и то, какие файлы должен защищать объект.  
  
 Помимо вызова отдельного объекта безопасности, принудительный синтаксис безопасности можно использовать для инициализации группы разрешений, называемой набором разрешений. Например, такой способ является единственным для надежного выполнения вызовов [assert](../../../docs/framework/misc/using-the-assert-method.md) для нескольких разрешений в одном методе. Используйте классы <xref:System.Security.PermissionSet> и <xref:System.Security.NamedPermissionSet> для создания группы разрешений, после чего вызовите соответствующий метод для выполнения желаемого вызова безопасности.  
  
 Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов. Вы можете использовать принудительный синтаксис для требований и переопределений вместо декларативного синтаксиса, когда информация, необходимая для инициализации состояния разрешения, становится известна только во время выполнения. Например, если нужно обеспечить наличие у вызывающих объектов разрешений на чтение определенного файла, но его имя неизвестно до запуска, используйте принудительное требование. Вы также можете выбрать использование принудительных проверок вместо декларативных, когда нужно во время выполнения определить, имеет ли место некоторое условие, и на основании результата проверки предъявить \(или же не предъявлять\) требование безопасности.  
  
 В приведенном ниже фрагменте кода показано использование принудительного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. Экземпляр `MyPermision` создается в методе `MyMethod`, защищая вызовом безопасности только этот метод.  
  
```vb  
Public Class MyClass1 Public Sub New() End Sub Public Sub MyMethod() 'MyPermission is demanded using imperative syntax. Dim Perm As New MyPermission() Perm.Demand() 'This method is protected by the security call. End Sub Public Sub YourMethod() 'YourMethod 'This method is not protected by the security call. End Sub End Class  
  
```  
  
```csharp  
public class MyClass { public MyClass(){ } public void MyMethod() { //MyPermission is demanded using imperative syntax. MyPermission Perm = new MyPermission(); Perm.Demand(); //This method is protected by the security call. } public void YourMethod() { //This method is not protected by the security call. } }  
```  
  
## Использование управляемых классов\-оболочек  
 Большинство приложений и компонентов \(кроме безопасных библиотек\) не должны напрямую вызывать неуправляемый код. Для этого есть несколько причин. Если код вызывает неуправляемый код напрямую, во многих ситуациях ему не будет разрешено выполняться, потому что он должен обладать высоким уровнем доверия, чтобы вызывать машинный код. Если политика будет изменена с целью разрешить запуск подобного приложения, это может заметно ослабить безопасность системы, так как приложение сможет выполнять практически любые операции.  
  
 Кроме того, код, имеющий разрешение на доступ к неуправляемому коду, может выполнить почти любую операцию, вызвав неуправляемый интерфейс API. Например, коду, имеющему разрешение на вызов неуправляемого кода, не нужно разрешение <xref:System.Security.Permissions.FileIOPermission> для доступа к файлу. Он может просто напрямую вызвать неуправляемый \(Win32\) интерфейс API доступа к файлам, обойдя управляемый интерфейс API доступа к файлам, требующий наличия разрешения **FileIOPermission**. Если управляемый код имеет разрешение на вызов неуправляемого кода и производит его прямой вызов, система безопасности не может уверенно обеспечивать ограничения безопасности, так как среда выполнения не может применять эти ограничения к неуправляемому коду.  
  
 Если необходимо, чтобы приложение выполняло операции, требующие доступа к неуправляемому коду, оно должно делать это через доверенный управляемый класс, предоставляющий оболочку для требуемой функциональности \(если такой класс существует\). Не создавайте класс\-оболочку самостоятельно, если он уже имеется в безопасной библиотеке классов. Класс\-оболочка, которому нужно предоставить высокий уровень доверия, чтобы он мог вызывать неуправляемый код, отвечает за обеспечение наличия у вызывающих объектов соответствующих разрешений. Если вы используете класс\-оболочку, коду необходимо запросить и получить только те разрешения, которые требуются этому классу.  
  
## См. также  
 <xref:System.Security.PermissionSet>   
 <xref:System.Security.Permissions.FileIOPermission>   
 <xref:System.Security.NamedPermissionSet>   
 <xref:System.Security.Permissions.SecurityAction>   
 [Assert](../../../docs/framework/misc/using-the-assert-method.md)   
 [Code Access Security](../../../docs/framework/misc/code-access-security.md)   
 [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md)   
 [Атрибуты](../../../docs/standard/attributes/index.md)   
 [Метаданные и компоненты с самоописанием](../../../docs/standard/metadata-and-self-describing-components.md)