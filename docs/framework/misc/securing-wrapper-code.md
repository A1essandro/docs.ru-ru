---
title: "Securing Wrapper Code | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "security [.NET Framework], wrapper code"
  - "wrapper code, securing"
  - "secure coding, wrapper code"
  - "code security, wrapper code"
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
caps.latest.revision: 11
author: "mairaw"
ms.author: "mairaw"
manager: "wpickett"
caps.handback.revision: 9
---
# Securing Wrapper Code
Код программы\-оболочки, особенно когда она имеет более высокий уровень доверия, чем код, который ее использует, может открыть уникальный набор уязвимостей системы безопасности. Все, что делается от имени вызывающего объекта, когда его ограниченные разрешения не включаются в соответствующую проверку безопасности, является потенциальной уязвимостью и может быть использовано злоумышленником.  
  
 Никогда не позволяйте осуществлять с помощью программы\-оболочки действия, которые вызывающий объект не может выполнить самостоятельно. Особую опасность представляют действия, подразумевающие ограниченную проверку безопасности, в отличие от требования полного обхода стека. При использовании одноуровневых проверок внедрение кода программы\-оболочки между настоящим вызывающим объектом и элементом API может легко привести к успешному прохождению проверки безопасности, когда это не должно было произойти, что ослабляет защиту.  
  
> [!CAUTION]
>  Управление доступом для кода и частично доверенный код  
>   
>  Платформа .NET Framework предоставляет механизм для принудительного применения различных уровней доверия к разным частям кода, выполняемым в одном и том же приложении. Этот механизм называется управлением доступом для кода.  Управление доступом для кода в .NET Framework не следует использовать в качестве средства безопасности при работе с частично доверенным кодом, особенно кодом неизвестного происхождения. Мы не рекомендуем загружать и выполнять код из неизвестных источников, не предприняв дополнительные меры безопасности.  
>   
>  Эта политика действует в отношении всех версий платформы .NET Framework, кроме платформы .NET Framework в составе Silverlight.  
  
## Делегаты  
 Защита делегатов различается в разных версиях .NET Framework.  В этом разделе описывается различное поведение делегатов и соответствующие вопросы безопасности.  
  
### В .NET Framework версий 1.0 и 1.1  
 В .NET Framework версий 1.0 и 1.1 с создателем делегата и вызывающим делегат объектом выполняются следующие действия по обеспечению безопасности.  
  
-   При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
-   При вызове делегата выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
 Каждый раз, когда код принимает <xref:System.Delegate> из менее доверенного кода, который может вызывать его, убедитесь, что менее доверенному коду не разрешено повышать уровень своих разрешений. Если делегат принимается, но используется позже, то код, создавший делегат, не находится в стеке вызовов, и его разрешения не будут проверяться, если код на уровне делегата или ниже попытается выполнить защищенную операцию. Если ваш код и код вызывающего объекта обладают более высокими привилегиями, чем создатель, то создатель может управлять путем вызова, не являясь частью стека вызовов.  
  
### В .NET Framework версии 2.0 и более поздних версий  
 В отличие от предыдущих версий, начиная с версии 2.0, .NET Framework выполняет действие по обеспечению безопасности по отношению к создателю делегата при создании и вызове делегата.  
  
-   При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
-   Набор прав создателя делегата также собирается при создании делегата и сохраняется с делегатом.  
  
-   При вызове делегата сохраненный набор прав создателя делегата сначала оценивается по отношению ко всем требованиям в текущем контексте, если создатель делегата и вызывающий делегат объект принадлежат разным сборкам.  Затем выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
## Требования связывания и программы\-оболочки  
 В инфраструктуре безопасности особая защита была усилена с помощью требований связывания, но она по\-прежнему является источником уязвимости в коде.  
  
 Если полностью доверенный код вызывает свойство, событие или метод, защищенный с помощью [LinkDemand](../../../docs/framework/misc/link-demands.md), то вызов выполняется успешно, если проверка разрешений **LinkDemand** для вызывающего объекта выполнена успешно. Кроме того, если полностью доверенный код предоставляет класс, который принимает имя свойства и вызывает его метод доступа **get** с помощью отражения, этот вызов метода доступа **get** успешно выполняется, даже если пользовательский код не имеет прав на доступ к этому свойству. Это происходит потому, что **LinkDemand** проверяет только непосредственный вызывающий код, который является полностью доверенным кодом. По существу полностью доверенный код выполняет привилегированный вызов от имени пользовательского кода, не убедившись в том, что пользовательский код имеет права для выполнения такого вызова.  
  
 Для предотвращения таких уязвимостей в системе безопасности среда CLR расширяет проверку до требования полного обхода стека при любом непрямом вызове метода, конструктора, свойства или события, защищенного с помощью **LinkDemand**. Такая защита влечет за собой некоторое снижение производительности, а также меняет семантику проверки безопасности; требование полного обхода стека может завершиться ошибкой там, где была бы пройдена более быстрая одноуровневая проверка.  
  
> [!NOTE]
>  В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] частично доверенный код стал называться прозрачным кодом. Модель прозрачности проводит барьер между кодом, который может выполнять привилегированные действия \(критически важный код\), таким как машинный код, и кодом, который не может \(прозрачный код\). Прозрачность заменяет использование <xref:System.Security.Permissions.SecurityAction> с полным доверием для определения полностью доверенного кода с помощью <xref:System.Security.SecurityCriticalAttribute>. Дополнительные сведения об этом и других изменениях см. в разделе [Изменения системы безопасности](../../../docs/framework/security/security-changes.md).  
  
## Программы\-оболочки, загружающие сборки  
 Некоторые методы, используемые для загрузки управляемого кода, включая <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>, загружают сборки со свидетельством вызывающего объекта. Если включить в программу\-оболочку любой из этих методов, система безопасности может использовать для загрузки сборки предоставленные вашему коду разрешения вместо разрешений объекта, вызывающего вашу программу\-оболочку. Не следует разрешать менее доверенному коду загружать код, который имеет более высокий уровень разрешений, чем объект, вызывающий вашу программу\-оболочку.  
  
 Таким образом может быть ослаблена безопасность любого кода с полным уровнем доверия или значительно более высоким уровнем доверия, чем у потенциального вызывающего объекта \(включая вызывающий объект уровня Интернет\-разрешений\). Если ваш код содержит открытый метод, который принимает массив байтов и передает их в **Assembly.Load**, тем самым создавая сборку от имени вызывающего объекта, безопасность может быть нарушена.  
  
 Эта проблема относится к следующим элементам API:  
  
-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=fullName>  
  
-   <xref:System.AppDomain.Load%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName>  
  
-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>  
  
## Demand и  LinkDemand  
 Декларативная безопасность предлагает два вида проверки безопасности, которые похожи, но выполняют совершенно разные проверки. Проанализируйте обе формы, так как неправильный выбор может привести к ослаблению безопасности или потере производительности.  
  
 Декларативная безопасность предлагает следующие проверки безопасности.  
  
-   Проверка <xref:System.Security.Permissions.SecurityAction> указывает обход стека управления доступом для кода. Для прохождения этой проверки все вызывающие объекты в стеке должны иметь указанное разрешение или удостоверение.**Demand** происходит при каждом вызове, так как стек может содержать различные вызывающие объекты. Если метод вызывается многократно, данная проверка безопасности происходит каждый раз.**Demand** является хорошей защитой от атак с заманиванием; неавторизованный код, пытающийся пройти через эту защиту, будет обнаружен.  
  
-   Проверка [LinkDemand](../../../docs/framework/misc/link-demands.md) \(требование связывания\) происходит во время JIT\-компиляции и проверяет только непосредственно вызывающий объект. Эта проверка безопасности не проверяет вызывающий объект вызывающего объекта. После того как эта проверка пройдена, никакие дополнительные проверки не выполняются, независимо от того, сколько раз вызывающий объект может выполнять вызов. Однако эта проверка не обеспечивает защиту от атак с заманиванием. При использовании **LinkDemand** любой код, прошедший проверку и могущий ссылаться на ваш код, может нарушить безопасность, позволив вредоносному коду осуществлять вызовы с использованием авторизованного кода. Таким образом, не следует использовать проверку **LinkDemand**, если не все возможные слабые места могут быть полностью защищены.  
  
    > [!NOTE]
    >  В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] требования связывания были заменены атрибутом <xref:System.Security.SecurityCriticalAttribute> в сборках <xref:System.Security.SecurityRuleSet>. Атрибут <xref:System.Security.SecurityCriticalAttribute> эквивалентен требованию связывания для полного доверия; однако он также влияет на правила наследования. Дополнительные сведения об этом изменении см. в разделе [Security\-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).  
  
 Дополнительные меры предосторожности, необходимые при использовании **LinkDemand**, должны программироваться в индивидуальном порядке; система безопасности, может помочь с их применением. Любая ошибка приводит к возникновению уязвимости в системе безопасности. Любой авторизованный код, использующий ваш код, должен отвечать за реализацию дополнительных мер защиты, выполняя следующие действия.  
  
-   Ограничение доступа вызывающего кода к классу или сборке.  
  
-   Размещение тех же проверок безопасности в вызывающем коде, который появляется в вызываемом коде, и принуждение вызывающих его объектов делать это. Например, если вы пишете код, вызывающий метод, который защищен с помощью **LinkDemand**, для разрешения <xref:System.Security.Permissions.SecurityPermission> с указанным флагом <xref:System.Security.Permissions.SecurityPermissionFlag>, ваш метод также должен выполнять проверку **LinkDemand** \(или **Demand**, которая надежнее\) для данного разрешения. Исключением является случай, когда ваш код использует защищенный с помощью **LinkDemand** метод ограниченным способом, который вы считаете безопасным с учетом других механизмов обеспечения безопасности \(например, требований\) в коде. В этом исключительном случае вызывающий объект несет ответственность за понижение степени защиты в базовом коде.  
  
-   Обеспечение, чтобы вызывающие ваш код объекты не могли заставить его вызывать защищенный код от их имени. Другими словами, вызывающие объекты не должны иметь возможность заставить авторизованный код передавать определенные параметры в защищенный код или получить результаты из него.  
  
### Интерфейсы и требования связывания  
 Если виртуальный метод, свойство или событие с проверкой **LinkDemand** переопределяет метод базового класса, этот метод базового класса также должен иметь ту же проверку **LinkDemand**, чтобы обеспечить эффективность переопределенного метода. Вредоносный код может выполнить обратное приведение к базовому типу и вызвать метод базового класса. Также обратите внимание, что требования связывания могут добавляться неявно в сборки, в которых отсутствует атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> уровня сборки.  
  
 Рекомендуется защищать реализации методов с помощью требований связывания, когда методы интерфейса также имеют требования связывания. Обратите внимание на следующие аспекты использования требований связывания с интерфейсами.  
  
-   Атрибут **AllowPartiallyTrustedCallersAttribute** также применяется к интерфейсам.  
  
-   Можно помещать требования связывания в интерфейсы для выборочной защиты определенных интерфейсов от использования кодом с частичным доверием, например при использовании атрибута **AllowPartiallyTrustedCallersAttribute** .  
  
-   Если имеется интерфейс, определенный в сборке, в которой отсутствует атрибут **AllowPartiallyTrustedCallersAttribute** , можно реализовать этот интерфейс в частично доверенном классе.  
  
-   Если поместить проверку **LinkDemand** в открытый метод класса, который реализует метод интерфейса, **LinkDemand** не будет выполняться, если вы затем выполняете приведение к интерфейсу и вызываете метод. В этом случае, поскольку выполнялось связывание с интерфейсом, обрабатывается только **LinkDemand** в интерфейсе.  
  
 Изучите следующие элементы проблем безопасности.  
  
-   Явные требования связывания в методах интерфейса. Убедитесь, что эти требования связывания обеспечивают ожидаемую защиту. Определите, может ли вредоносный код использовать приведение, чтобы обойти требования связывания, как описано выше.  
  
-   Виртуальные методы с примененными требованиями связывания.  
  
-   Типы и интерфейсы, которые они реализуют. Они должны согласованно использовать требования связывания.  
  
## См. также  
 [Secure Coding Guidelines](../../../docs/standard/security/secure-coding-guidelines.md)