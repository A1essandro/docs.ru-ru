---
title: "WSTrustChannelFactory и WSTrustChannel | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 96cec467-e963-4132-b18b-7d0b3a2e979f
caps.latest.revision: 9
author: "BrucePerlerMS"
ms.author: "bruceper"
manager: "mbaldwin"
caps.handback.revision: 9
---
# WSTrustChannelFactory и WSTrustChannel
Если вы уже знакомы с Windows Communication Foundation \(WCF\), известно, что клиент WCF уже федерация осведомленная.  При настройке клиента WCF с <xref:System.ServiceModel.WSFederationHttpBinding> или аналогичной пользовательской привязкой, можно включить федеративную проверку подлинности в службе.  
  
 Получает токен WCF, выдается службой маркеров безопасности \(STS\) в фоновом режиме и использует этот токен для проверки подлинности в службе.  Основное ограничение для этого подхода является то, что не видимость в взаимодействия клиента с сервером.  WCF автоматически создает маркер безопасности \(RST\) запроса к службе маркеров безопасности на основе выданных параметрах токена привязки.  Это означает, что клиент не может изменяться параметры RST один запрос, чтобы проверить ответ \(RSTR\) маркера безопасности запроса для получения сведений, например, отображения и кэширует его для использования в будущем.  
  
 В настоящее время, клиент WCF подходит для базовых сценариях федерации.  Однако один из основных сценариев, которые являются основой \(WIF\) идентификатора Windows поддерживает необходим элемент управления над RST на уровне, легко WCF не допускается.  Поэтому WIF добавляет функции, предоставляющие более элементов управления с сообщением со службой маркеров безопасности.  
  
 WIF поддерживает следующие сценарии федерации.  
  
-   С помощью клиента WCF без каких\-либо WIF зависимостей, чтобы проверить подлинность в федеративной службе  
  
-   Предоставление WIF на стороне клиента WCF вставить элемент ActAs или OnBehalfOf RST в службе маркеров безопасности  
  
-   С помощью WIF отдельно, чтобы получить токен от службы маркеров безопасности и затем позволить проверить подлинность клиента WCF с этим токеном.  Пример Дополнительные сведения см. в [ClaimsAwareWebService](http://go.microsoft.com/fwlink/?LinkID=248406).  
  
 Первый сценарий понятен без объяснений. Существующих клиентов WCF продолжат работать с проверяющими сторонами и службами маркеров безопасности WIF.  В этом разделе обсуждаются оставшиеся 2 сценария.  
  
## Улучшение существующего клиента WCF с ActAs\/OnBehalfOf  
 В типичном сценарии делегирования идентификатора, клиент вызывает службу среднего уровня, которая затем вызывает конечная служба.  Служба среднего уровня функционирует как или работает, от имени клиента.  
  
> [!TIP]
>  , Что разница между ActAs и OnBehalfOf?  
>   
>  С точки зрения procotol WS\- доверия.  
>   
>  1.  Элемент ActAs RST означает, что запросившая сторона хочет токен, содержащий выдачи об определенных сущностях: 2 запросившая сторона и внешняя сущность токеном значения в элементе ActAs.  
> 2.  Элемент OnBehalfOf RST означает, что запросившая сторона хочет токен, который содержит только служба примерно одна сущность. внешняя сущность токеном значения в элементе OnBehalfOf.  
>   
>  Функция ActAs обычно используется в сценариях, требующих составного делегирования, где конечный получатель выданного токена может проверить всю цепочку делегирования и просматривать не только клиента, только всех посредников.  Это позволяет ему запуска элемента управления доступом, аудит и другие связанные действия на основе всей цепочке делегирования идентификатора.  Функция ActAs часто используется в этих системах для проверки подлинности и передавать сведения об идентификаторах между уровнями без соблюсти эти сведения в приложение или уровень бизнес\-логики.  
>   
>  Функция OnBehalfOf используется в сценариях, где только идентификатор исходного клиента важен, фактически совпадает с функцией олицетворения идентификатора доступная в Windows.  При OnBehalfOf используется, конечный получатель выданного токенов могут только просматривать, изначально о клиенте и не сохраняются сведения о посредниках.  Один общий шаблон, функция OnBehalfOf используется шаблон прокси, когда клиент не может получить доступ к службе маркеров безопасности, а вместо этого взаимодействует через шлюз прокси\-сервера.  Шлюз прокси\-сервера проверку подлинности вызывающий и помещает сведения о вызывающем объекте в элемент OnBehalfOf сообщения RST, после чего отправляет в реальной службе маркеров безопасности при обработке.  Результирующий токен содержит только служба, относящиеся к прокси клиента, что прокси\-сервер полностью прозрачным к приемнику выданного токена. Обратите внимание, что WIF не \<wsse:SecurityTokenReference\> поддерживает или \<wsa:EndpointReferences\> как дочерний элемент \<wst:OnBehalfOf\>.  Спецификация WS\- доверия позволяет для 3 способов указания исходного запрашивающего пользователя \(от имени кому прокси\-сервер выполняет\).  Эти особые значения приведены ниже.  
>   
>  -   Ссылку маркера безопасности.  Ссылка на токен, или в сообщении, или возможно, полученного из полосы\).  
> -   Ссылка конечной точки.  Используется в качестве ключа, чтобы искать данные, снова вне полосы.  
> -   Маркер безопасности.  Определяет исходный запрашивающего пользователя напрямую.  
>   
>  WIF поддерживает только маркеры безопасности или зашифрованные или незашифрованные напрямую, как дочерний элемент \<wst:OnBehalfOf\>.  
  
 Эти сведения транспортированы в эмитенту WS\- доверия с использованием элементов токен ActAs и OnBehalfOf в RST.  
  
 WCF предоставляет точку расширяемости для привязки, которая позволяет выполнять произвольные XML\-элементы, добавляемый к RST.  Однако поскольку точка расширяемости связана с привязкой, сценарии, требующих содержимое RST, которые должны различаться для каждого вызова нужно будет создать заново клиента для каждого вызова, что снижает производительность.  WIF используются методы расширения в классе `ChannelFactory`, чтобы разрешить разработчикам вложить любой токен, полученных из полосы в RST.  В следующем примере кода показано, как получить токен, представляющий X.509 клиента \(например, имя пользователя, или токен Markup Language \(SAML\) утверждения безопасности\) и вложение в RST, которое отправляется в эмитенту.  
  
```  
IHelloService serviceChannel = channelFactory.CreateChannelActingAs<IHelloService>( clientSamlToken );  
serviceChannel.Hello(“Hi!”);  
```  
  
 WIF обеспечивает следующие преимущества:  
  
-   RST можно изменить на канал. поэтому службы среднего уровня не требуется повторно создать фабрику каналов для каждого клиента, который повышает производительность.  
  
-   Это работает с существующими клиентами WCF, что позволяет легко вариант обновления возможной среднего уровня для существующих служб WCF, которым необходимо включить семантику делегирования идентификатора.  
  
 Однако все еще нет видимость в возможности клиента со службой маркеров безопасности.  Рекомендуется рассмотрим это в третьем сценарии.  
  
## Эмитентом и непосредственно взаимодействовать с помощью выданного токена для проверки подлинности  
 Для некоторых сложных сценариев увеличение клиента WCF не достаточно.  Разработчики, использующие только сообщение использования WCF обычно в\/контракты сообщений, и обрабатывают клиентский анализ ответа эмитента вручную.  
  
 WIF представление классов <xref:System.ServiceModel.Security.WSTrustChannelFactory> и <xref:System.ServiceModel.Security.WSTrustChannel>, чтобы позволить клиенту непосредственно взаимодействовать с эмитентом WS\- доверия.  Классы <xref:System.ServiceModel.Security.WSTrustChannelFactory> и <xref:System.ServiceModel.Security.WSTrustChannel> включают строго типизированные объекты RST и RSTR в поток между клиентом и эмитентом, как показано в следующем примере кода.  
  
```  
WSTrustChannelFactory trustChannelFactory = new WSTrustChannelFactory( stsBinding, stsAddress );  
WSTrustChannel channel = (WSTrustChannel) trustChannelFactory.CreateChannel();  
RequestSecurityToken rst = new RequestSecurityToken(RequestTypes.Issue);  
rst.AppliesTo = new EndpointAddress(serviceAddress);  
RequestSecurityTokenResponse rstr = null;  
SecurityToken token = channel.Issue(rst, out rstr);  
```  
  
 Обратите внимание, что параметр `out` в методе <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A> обеспечивает доступ к RSTR для клиентской проверки.  
  
 До сих пор мы видели только как получение токена.  Токен, который возвращается из объекта <xref:System.ServiceModel.Security.WSTrustChannel>`GenericXmlSecurityToken`, содержит все сведения, необходимые для проверки подлинности в проверяющей стороне.  В следующем примере показано, как использовать этот токен.  
  
```  
IHelloService serviceChannel = channelFactory.CreateChannelWithIssuedToken<IHelloService>( token ); serviceChannel.Hello(“Hi!”);  
```  
  
 Метод расширения <xref:System.ServiceModel.ChannelFactory%601.CreateChannelWithIssuedToken%2A> объекта `ChannelFactory` указывает на WIF, которые получали токен вне полосы, и она должна быть остановлена обычный вызов WCF в эмитенту и вместо этого использовать токен, можно получить для проверки подлинности в проверяющей стороне.  Это имеет следующие преимущества:  
  
-   Он обеспечивает полный контроль над процессом выпуска токена.  
  
-   Он поддерживает сценарии ActAs\/OnBehalfOf непосредственно устанавливать эти свойства в исходящем RST.  
  
-   Содержит динамические клиентские решения о доверии обновляться на основе содержимого RSTR.  
  
-   Это позволяет кэшировать и повторно использовать токен, который возвращается из метода <xref:System.ServiceModel.Security.WSTrustChannel.Issue%2A>.  
  
-   <xref:System.ServiceModel.Security.WSTrustChannelFactory> и <xref:System.ServiceModel.Security.WSTrustChannel> позволяют для элемента управления кэширования канала, ошибок и семантики восстановления в соответствии с рекомендациями WCF.  
  
## См. также  
 [Возможности WIF](../../../docs/framework/security/wif-features.md)