---
title: "Управление сеансами WIF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
caps.latest.revision: 7
author: "BrucePerlerMS"
ms.author: "bruceper"
manager: "mbaldwin"
caps.handback.revision: 7
---
# Управление сеансами WIF
Когда клиент сначала пытается получить доступ к защищенному ресурсу, хозяйничается проверяющей стороной, клиент должен сначала пройти проверку подлинности в службе маркеров безопасности \(sts\), доверена проверяющей стороной.  Затем служба маркеров безопасности выдает маркер безопасности клиенту.  Этот клиент представляет токен в проверяющей стороне, которая затем предоставляет клиентский доступ к защищенному ресурсу.  Однако не следует re\- проверки подлинности клиента в службе маркеров безопасности для каждого запроса, тем более, что даже не может находиться на том же компьютере или в том же домене, что и проверяющая сторона.  Вместо этого основу идентификатора Windows \(WIF\) имеет клиента и проверяющую сторону установить сеанс, в котором клиент использует дескриптор безопасности сеанса, чтобы проверить подлинность проверяющей стороне для всех запросов после первого запроса.  Проверяющая сторона может использовать этот маркер безопасности сеанса, который хранится в cookie, чтобы восстановить <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=fullName> клиента.  
  
 Служба маркеров безопасности указывает, какую проверку подлинности, клиент должен предоставить.  Однако клиент может иметь несколько учетных данных, с которыми он может проходить проверку подлинности в службе маркеров безопасности.  Например, он может получить маркер от Windows в реальном времени, имя пользователя и пароль, сертификат, smartkey.  В этом случае служба маркеров безопасности предоставляет клиенту несколько идентификаторов с каждым идентификатором, соответствующие одной из учетных данных, которые он представляет.  Проверяющая сторона может использовать один или несколько из этих идентификаторов, когда он определяет, какой уровень доступа для предоставления клиента.  
  
 <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=fullName> используется для восстановления <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=fullName> клиента, который содержит идентификаторы всех клиентов в <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.  Каждое <xref:System.Security.Claims.ClaimsIdentity?displayProperty=fullName> в коллекции содержит токены начальной загрузки, которые сопоставлены с этим идентификатором.  
  
 Если новый маркер выдан сеанса с идентификатором сеанса исходной токена сеанса, то <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=fullName> не обновляет маркер сеанса в кэше токена.  Всегда создает экземпляр токен сеанса с уникальным идентификатором сеанса.  
  
> [!NOTE]
>  Session.SecurityTokenHandler.ReadToken создает исключение, если оно получает <xref:System.Xml.XmlException> недопустимые входные данные. например, если файл cookie, содержащий токен сеанса поврежден.  Рекомендуется перехватывать это исключение предусматриваем конкретного приложения и расширения функциональности.  
  
 Если защищенная страница содержит много ресурсов \(например, изображений\), которые также небольшие в защищенном домене, клиент должен пройти проверку подлинности re\- в проверяющей стороне, чтобы загрузить каждый из этих ресурсов.  Использование проверки подлинности токена сеанса избежать необходимости проходить проверку подлинности в службе маркеров безопасности для каждого запроса, но по\-прежнему означает, что много файлов cookie отправить.  Возможно, потребуется настроить страницу, чтобы важные данные и ресурсы сохраняются в защищенном домене, пока вспомогательные элементы хранятся в незащищенном домене и связаны в результате в основном странице.  Кроме того, задайте путь к файлу cookie, чтобы ссылаться только на защищенный домен.  
  
 Чтобы работать в режиме ссылки, корпорация Майкрософт рекомендует предоставить обработчик для события <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> в файле **global.asax.cs** и задать свойство **IsReferenceMode** на маркер, переданный для свойства <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A>.  Эти обновления обеспечат, что токен сеанса работает в режиме ссылки для каждого запроса и предпочтение над просто установить свойство <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> в модуле проверки подлинности сеанса.  
  
## Расширяемость  
 Можно раскрыть механизм управления сеансами.  Одна из причин для этого была бы увеличить производительность.  Например, можно создать пользовательский обработчик cookie, convert или оптимизируют маркер безопасности сеанса между своим состоянием в\- памяти и переходит в файле cookie.  Для этого можно настроить свойство <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=fullName><xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=fullName> для использования пользовательского обработчика cookie, производный от <xref:System.IdentityModel.Services.CookieHandler?displayProperty=fullName>.  <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=fullName> используемый по умолчанию обработчик cookie, потому что файлы cookie, превышает допустимый размер для HTTP\-протокола \(HTTP\); если используется пользовательский обработчик cookie вместо этого необходимо реализовать фрагментации.  
  
 Дополнительные сведения см. в разделе [ClaimsAwareWebFarm](http://go.microsoft.com/fwlink/?LinkID=248408) http:\/\/go.microsoft.com\/fwlink\/?LinkID\=248408\) \(образец.  Этот образец показывает ферме готовый кэш сеанса \(в отличие от tokenreplycache\), чтобы можно было использовать сеансы по ссылке вместо обмена большие файлы cookie. этот образец также демонстрирует более простой способ предоставления файлы cookie в ферме.  Кэш сеанса WCF\-основан.  Относительно сеанса, предоставляющий, образец демонстрирует новую возможность преобразования в WIF 4,5 cookie на основе MachineKey, которое может быть активировано просто вставить соответствующий фрагмент в web.config.  "Не фермером" пример демонстрирует, что сама, но она требуется для создания приложения ферм\- готовой.