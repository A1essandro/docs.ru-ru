---
title: Профилировщик среды CLR и приложений для магазина Windows
ms.date: 03/30/2017
dev_langs:
- csharp
applies_to:
- Windows 10
- Windows 8
helpviewer_keywords:
- profiling API
- profiling API [.NET Framework]
- profiling managed code
- profiling managed code [Windows Store Apps]
ms.assetid: 1c8eb2e7-f20a-42f9-a795-71503486a0f5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 20a1ed9b6b613b1e4d3e5363ab9995cc81295091
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="clr-profilers-and-windows-store-apps"></a>Профилировщик среды CLR и приложений для магазина Windows
Здесь описывается, что необходимо рассматривать при написание средств диагностики анализа управляемого кода, выполняемым внутри приложения для магазина Windows.  Он также предоставляет инструкции для изменения существующих средств разработки, они продолжают работать при запуске для приложений для магазина Windows.  Чтобы понять эту информацию, она лучше всего подходит, если вы знакомы с общий язык времени выполнения профилирования API, вы уже использовали этот интерфейс API в диагностическое средство, будет работать правильно с настольных приложений Windows и вы являетесь теперь вам интересны изменение средство для правильной работы для приложений для магазина Windows.  
  
 В этом разделе:  
  
 [Введение](#Intro)  
 [Архитектура и терминология](#Arch)  
 [Устройства Windows RT](#RT)  
[Использование API среды выполнения Windows](#Consuming)  
[Загрузка DLL профилировщика](#Loading)  
 [Общие рекомендации для запуска и присоединения загрузок](#Common)  
 [При запуске нагрузки](#Startup)  
 [Присоединение нагрузки](#Attach)  
[Выполняется внутри приложения магазина Windows](#Running)  
 [Придерживайтесь API-интерфейсов приложений магазина Windows](#APIs)  
 [Ограниченными разрешениями](#Permissions)  
 [Межпроцессное взаимодействие](#Interprocess)  
 [Нет уведомлений завершения работы](#Shutdown)  
[Файлы метаданных среды выполнения Windows](#Metadata)  
 [Управляемые и неуправляемые файлы Winmd](#WMDs)  
 [WinMD-файлов выглядеть модулей среды CLR](#CLRModules)  
 [Чтение метаданных из файлы Winmd](#Reading)  
 [Изменение метаданных из файлы Winmd](#Modifying)  
 [Разрешение ссылок на сборки с файлы Winmd](#Resolving)  
[Профилировщики памяти](#Profilers)  
 [ForceGC создает управляемый поток](#ForceGC)  
 [ConditionalWeakTableReferences](#WeakTable)  
[Заключение](#Conclusion)  
[Ресурсы](#Resources)  
  
<a name="Intro"></a>   
## <a name="introduction"></a>Вступление  
 Если были внесены за вводный абзац, вы уже знакомы с API профилирования среды CLR.  Вы уже написаны диагностическое средство, которое работает хорошо для управляемых приложений рабочего стола.  Теперь интересно что делать, чтобы анализатор с управляемым приложением магазина Windows.  Возможно вы уже пытались обеспечить работоспособность и заметили, что он не является простой задачей.  На самом деле существует ряд соображений, которые могут быть неявными разработчикам средств.  Пример:  
  
-   В контексте с серьезными ограниченными разрешениями запуска приложений для магазина Windows.  
  
-   Файлы метаданных Windows имеют уникальные характеристики по сравнению с традиционной управляемых модулей.  
  
-   Приложения для магазина Windows имеют привычка приостановки сами при интерактивность выходит из строя.  
  
-   Ваш механизмы межпроцессного взаимодействия может перестать работать по различным причинам.  
  
 В этом разделе перечислены задачи, которые необходимо иметь в виду и как работать с ними должным образом.  
  
 Если вы не знакомы с API профилирования среды CLR, перейдите к ресурсам в конце этого раздела для лучшего вводные сведения.  
  
 Также предоставляет подробные сведения о конкретных API-интерфейсов Windows и описание их использования, выходит за пределы данного раздела.  Рассмотрим в этом разделе отправной точки и ссылаться на MSDN для получения дополнительных сведений о любой указанный здесь API-интерфейсов Windows.  
  
<a name="Arch"></a>   
## <a name="architecture-and-terminology"></a>Архитектура и терминология  
 Как правило средство диагностики имеет архитектуру, как показано на следующем рисунке. Она использует термин «профилировщик», но такие средства перейдите намного больше, чем обычно производительности или профилирования памяти в областях, таких как объем протестированного кода, создания объектов платформы, — переход во времени отладки приложения, мониторинга и т. д.  Для простоты в этом разделе будет продолжать относятся к этим средствам как профилировщики.  
  
 В этом разделе используется следующая терминология:  
  
 Приложение  
 Это приложение, которое анализирует профилировщика.  Как правило разработчик приложения использует профилировщик для диагностики проблем с приложением.  В большинстве случаев это приложение будет настольных приложений Windows, но в этом разделе мы ожидаем от приложений для магазина Windows.  
  
 Библиотека DLL профилировщика  
 Это компонент, который загружает в пространство процесса приложения выполняется анализ.  Этот компонент также называется «агент», профилировщик реализует [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)[интерфейс ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md)(2,3, т. д.) интерфейсов и использует [ ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)(2,3, т. д.) интерфейсы для сбора данных о проанализированных приложения и, возможно, изменения поведения приложения.  
  
 Профилировщик пользовательского интерфейса  
 Это настольное приложение, пользователь профилировщика взаимодействует с.  Он отвечает за отображение состояния приложения для пользователя и предоставления пользователю возможность управлять поведением проанализированные приложения.  Этот компонент всегда выполняется в отдельной области процесса, отдельно от пространство процесса профилируемым приложением.  Профилировщик пользовательского интерфейса могут действовать как «присоединения» триггера, которые — это процесс, который вызывает [ICLRProfiling::AttachProfiler](../../../../docs/framework/unmanaged-api/profiling/iclrprofiling-attachprofiler-method.md) метода, чтобы привести к загрузке библиотеки DLL профилировщика в тех случаях, когда библиотека DLL профилировщика не проанализированные приложения загружать при запуске.  
  
> [!IMPORTANT]
>  Профилировщик пользовательского интерфейса должны оставаться настольных приложений Windows, даже в том случае, если он используется для управления и отчеты по приложению для магазина Windows.  Вряд ли будет иметь возможность упаковки и отправки вашего средства диагностики в магазине Windows.  Средства необходимо решать, приложений для магазина Windows не может выполнять и многие из этих условий расположены внутри профилировщик пользовательского интерфейса.  
  
 В этом документе в примере кода предполагается, что:  
  
-   Библиотека DLL профилировщика написанного на языке C++, так как он должен быть собственная библиотека DLL, согласно требованиям API профилирования среды CLR.  
  
-   Профилировщик пользовательского интерфейса, написанные на C#.  Это не является обязательным, но так как нет требований на язык для пользовательского интерфейса профилировщика процесса, почему нельзя выбрать язык, который является быстрый и простой?  
  
<a name="RT"></a>   
### <a name="windows-rt-devices"></a>Устройства Windows RT  
 Устройства Windows RT довольно блокированы.  Профилировщики сторонних просто невозможно загрузить на таких устройствах.  В этом документе рассматриваются на компьютерах под управлением Windows 8.  
  
<a name="Consuming"></a>   
## <a name="consuming-windows-runtime-apis"></a>Использование API среды выполнения Windows  
 В нескольких сценариях, рассмотренных в следующих разделах приложения для настольных компьютеров пользовательского интерфейса в профилировщик должен использовать некоторые новые интерфейсы API среды выполнения Windows.  Может потребоваться обратитесь к документации, чтобы определить, какие API среды выполнения Windows можно использовать из приложений для настольных компьютеров и их поведение отличается ли при вызове из настольных систем и приложений магазина Windows приложения.  
  
 Если профилировщик пользовательского интерфейса, написанных на управляемом коде, будет несколько шагов, которые необходимо предпринять, чтобы использование этих API среды выполнения Windows легко.  В разделе [управляемые Классические приложения и среды выполнения Windows](http://go.microsoft.com/fwlink/?LinkID=271858) для получения дополнительных сведений.  
  
<a name="Loading"></a>   
## <a name="loading-the-profiler-dll"></a>Загрузка DLL профилировщика  
 В этом разделе описывается, как пользовательский Интерфейс профилировщик вызывает приложений для магазина Windows для загрузки библиотеки DLL профилировщика.  Код в этом разделе описываются принадлежит в приложении для настольных систем профилировщик пользовательского интерфейса и таким образом решается с помощью Windows API, которые безопасна для классических приложений, но не обязательно безопасном приложений для магазина Windows.  
  
 Пользовательский Интерфейс профилировщик может вызвать DLL профилировщика будет загружаться в пространство процесса приложения двумя способами:  
  
-   При запуске приложения, управляет переменными среды.  
  
-   Путем присоединения к приложению после завершения запуска путем вызова [ICLRProfiling::AttachProfiler](../../../../docs/framework/unmanaged-api/profiling/iclrprofiling-attachprofiler-method.md) метод.  
  
 Одно из первого препятствий. будет использоваться для получения Загрузка и присоединить загрузка библиотеки DLL профилировщика для правильной работы с приложениями для магазина Windows.  Обе формы загрузки общими некоторые особенности, поэтому начнем с ними.  
  
<a name="Common"></a>   
### <a name="common-considerations-for-startup-and-attach-loads"></a>Общие рекомендации для запуска и присоединения загрузок  
 **Подписи библиотеки DLL профилировщика**  
 При попытке загрузить библиотеку DLL профилировщика Windows, он проверяет, что библиотеки DLL профилировщика подписан должным образом.  В противном случае происходит сбой загрузки по умолчанию. Это можно сделать двумя способами.  
  
-   Убедитесь, что ваша библиотека DLL профилировщика подписан.  
  
-   Сообщите пользователю, что им требуется установить лицензию разработчика на компьютерах Windows 8 перед использованием средства.  Это можно сделать автоматически из Visual Studio, или вручную из командной строки.  Дополнительные сведения см. в разделе [получение лицензии разработчика](https://msdn.microsoft.com/library/windows/apps/Hh974578.aspx).  
  
 **Разрешения файловой системы**  
 Приложения для магазина Windows должен иметь разрешение на загрузку и выполнение библиотеки DLL профилировщика от места в файловой системе, в котором он находится.  По умолчанию приложения для магазина Windows не имеет такого разрешения на большинстве каталоги и Неудачная попытка загрузки библиотеки DLL профилировщика будет создавать запись в журнале событий приложений Windows, который выглядит примерно следующим образом:  
  
```Output  
NET Runtime version 4.0.30319.17929 - Loading profiler failed during CoCreateInstance.  Profiler CLSID: '{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}'.  HRESULT: 0x80070005.  Process ID (decimal): 4688.  Message ID: [0x2504].  
```  
  
 Как правило приложений для магазина Windows разрешены только для доступа к ограниченным набором расположения на диске.  Каждое приложение магазина Windows можно использовать папки данных приложения, а также несколько других областей в файловой системы, для которых доступ предоставляется все приложения для магазина Windows.  Рекомендуется установить библиотеки DLL профилировщика и его зависимостей, где-нибудь в Program Files или Program Files (x86), поскольку все приложения для магазина Windows разрешения read и execute существует по умолчанию.  
  
<a name="Startup"></a>   
### <a name="startup-load"></a>При запуске нагрузки  
 Как правило, в настольном приложении профилировщик пользовательский Интерфейс предлагает нагрузки загрузки библиотеки DLL профилировщика путем инициализации блок среды, содержащую необходимые переменные среды, API профилирования среды CLR (т. е. `COR_PROFILER`, `COR_ENABLE_PROFILING`, и `COR_PROFILER_PATH`), и Затем выполняется создание нового процесса с этого блока среды.  Это же справедливо и для магазина Windows, но отличаются механизмы.  
  
 **Не запускать с повышенными привилегиями**  
 Если процесс пытается создать приложение для магазина Windows B процесса процесс A должна запускаться на средний уровень целостности уровня, не на уровне высоким уровнем целостности (который не с повышенными правами).  Это означает, что профилировщик пользовательского интерфейса должна быть запущена с уровнем целостности, средний, либо его необходимо создать другого процесса рабочего стола на уровне средним уровнем целостности, отвечающий за запуск приложений для магазина Windows.  
  
 **Выбор приложения магазина Windows в профиль**  
 Во-первых необходимо запросить у пользователя вашего профилировщика какие приложения для магазина Windows для запуска.  Для классических приложений возможно будет показывать диалоговое окно обзора и пользователь может найти и выбрать файл .exe.  Но различаются приложений для магазина Windows, а с помощью диалогового окна обзора не имеет смысла.  Вместо этого лучше показать пользователю список установленные для этого пользователя выбрать из приложения магазина Windows.  
  
 Можно использовать [PackageManager класса](https://msdn.microsoft.com/library/windows/apps/windows.management.deployment.packagemanager.aspx) для создания этого списка.  `PackageManager` Представляет класс среды выполнения Windows, которая доступна для классических приложений, а на самом деле это *только* для классических приложений.  
  
 В следующем примере код продукта из гипотетической пользовательского интерфейса профилировщика записаны в виде классического приложения в C# yses `PackageManager` для создания списка приложений Windows:  
  
```csharp  
string currentUserSID = WindowsIdentity.GetCurrent().User.ToString();  
IAppxFactory appxFactory = (IAppxFactory) new AppxFactory();  
PackageManager packageManager = new PackageManager();  
IEnumerable<Package> packages = packageManager.FindPackagesForUser(currentUserSID);  
```  
  
 **Указание блок пользовательской среды**  
 Новый интерфейс COM, [IPackageDebugSettings](https://msdn.microsoft.com/library/hh438393\(v=vs.85\).aspx), предоставляет возможность настройки поведения выполнения приложений для магазина Windows для упрощения диагностики некоторые формы.  Один из его методов [EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=vs.85\).aspx), позволяют передавать блок среды приложений для магазина Windows, при запуске, а также другие полезные эффекты, как отключить автоматический процесс приостановки.  Блок среды важно, так как это, когда необходимо указать переменные среды (`COR_PROFILER`, `COR_ENABLE_PROFILING`, и `COR_PROFILER_PATH)`) используется в среде CLR для загрузки библиотеки DLL профилировщика.  
  
 Рассмотрим следующий фрагмент кода:  
  
```csharp  
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();  
pkgDebugSettings.EnableDebugging(packgeFullName, debuggerCommandLine,   
                                                                 (IntPtr)fixedEnvironmentPzz);  
```  
  
 Существует несколько элементов, которые понадобятся для получения правильных:  
  
-   `packageFullName` можно определить во время прохода по пакеты и перехватывая `package.Id.FullName`.  
  
-   `debuggerCommandLine` — немного интереснее.  Чтобы передать блок среды пользовательских приложений для магазина Windows, необходимо написать собственный, упрощенный фиктивный отладчика.  Приложения для магазина Windows включает в себя Windows приостановлена и затем Присоединяет отладчик, запустив отладчик с помощью командной строки, как в этом примере:  
  
    ```Output  
    MyDummyDebugger.exe -p 1336 -tid 1424  
    ```  
  
     где `-p 1336` означает 1336 идентификатор процесса, приложений для магазина Windows и `-tid 1424` означает 1424 идентификатор поток является потоком, приостанавливается.  Фиктивный отладчик будет проанализировать ThreadID из командной строки, возобновить этот поток и завершает работу.  
  
     Вот некоторые примеры кода C++ для этого (не забудьте добавить проверку ошибок!):  
  
    ```cpp  
    int wmain(int argc, wchar_t* argv[])  
    {      
        // …  
        // Parse command line here  
        // …  
  
        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,   
                                                                  FALSE /* bInheritHandle */, nThreadID);  
        ResumeThread(hThread);  
        CloseHandle(hThread);  
        return 0;  
    }  
    ```  
  
     Вам потребуется развернуть этот фиктивный отладчик в рамках установки средства диагностики, а затем укажите путь к этот отладчик в `debuggerCommandLine` параметра.  
  
 **Запуск приложений для магазина Windows**  
 Наконец пришло время для запуска приложений для магазина Windows. Если вы уже уже пытались это самостоятельно, возможно, вы заметили, [CreateProcess](https://msdn.microsoft.com/library/windows/desktop/ms682425\(v=vs.85\).aspx) не показано, как создать процесс приложения магазина Windows.  Вместо этого необходимо использовать [IApplicationActivationManager::ActivateApplication](https://msdn.microsoft.com/library/windows/desktop/Hh706903\(v=vs.85\).aspx) метод.  Чтобы сделать это, необходимо получить идентификатор модели пользователя приложения для приложений для магазина Windows, вы начинаете.  А это означает, что необходимо сделать немного углубиться помощью манифеста.  
  
 Во время прохода по пакетам (в разделе «Выбор хранилища приложений для профиля Windows» в [запуска нагрузочного](#Startup) статьи ранее), может потребоваться захватить набор приложений, содержащихся в манифесте текущего пакета:  
  
```csharp  
string manifestPath = package.InstalledLocation.Path + "\\AppxManifest.xml";  
  
AppxPackaging.IStream manifestStream;  
SHCreateStreamOnFileEx(  
                    manifestPath,  
                    0x00000040,     // STGM_READ | STGM_SHARE_DENY_NONE  
                    0,              // file creation attributes  
                    false,          // fCreate  
                    null,           // reserved  
                    out manifestStream);  
  
IAppxManifestReader manifestReader = appxFactory.CreateManifestReader(manifestStream);  
  
IAppxManifestApplicationsEnumerator appsEnum = manifestReader.GetApplications();  
```  
  
 Да, один пакет может применяться несколько приложений, и каждое приложение имеет собственный идентификатор модели пользователя приложения.  Поэтому имеет смысл попросить пользователя приложение, в котором в профиль и захватите идентификатор модели пользователя приложения из данного конкретного приложения:  
  
```csharp  
while (appsEnum.GetHasCurrent() != 0)  
{  
    IAppxManifestApplication app = appsEnum.GetCurrent();  
    string appUserModelId = app.GetAppUserModelId();  
…  
```  
  
 Наконец теперь у вас есть необходимые для запуска приложений для магазина Windows:  
  
```csharp  
IApplicationActivationManager appActivationMgr = new ApplicationActivationManager();  
appActivationMgr.ActivateApplication(appUserModelId, appArgs, ACTIVATEOPTIONS.AO_NONE, out pid);  
```  
  
 **Помните, что необходимо вызвать DisableDebugging**  
 При вызове [IPackageDebugSettings::EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=VS.85\).aspx), сделанные объект promise, который вы бы Очистка после самостоятельно путем вызова [IPackageDebugSettings::DisableDebugging](https://msdn.microsoft.com/library/hh438394\(v=vs.85\).aspx) метод, поэтому следует обязательно сделать Когда превышает сеанса профилирования.  
  
<a name="Attach"></a>   
### <a name="attach-load"></a>Присоединение нагрузки  
 Когда пользовательский профилировщик хочет присоединить его DLL профилировщика к приложению, который уже запущен, он использует [ICLRProfiling::AttachProfiler](../../../../docs/framework/unmanaged-api/profiling/iclrprofiling-attachprofiler-method.md).  То же самое справедливо в отношении приложений для магазина Windows.  Однако помимо Общие рекомендации, приведенные выше, убедитесь, что целевое приложение магазина Windows не был приостановлен.  
  
 **EnableDebugging**  
 Как и в случае запуска загрузки, вызовите [IPackageDebugSettings::EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=VS.85\).aspx) метод.  Это не требуется для передачи блок среды, но требуется один из его других функций: отключение автоматического процесса приостановки.  В противном случае, когда пользовательский Интерфейс профилировщик вызывает [AttachProfiler](../../../../docs/framework/unmanaged-api/profiling/iclrprofiling-attachprofiler-method.md), целевое приложение магазина Windows может быть приостановлен.  На самом деле это скорее всего, если пользователь теперь взаимодействует с профилировщиком пользовательского интерфейса и приложений для магазина Windows не активна на всех экранах пользователя.  И если в магазине Windows приложение приостановлено, он не будет отвечать на любые указывают, что среда CLR отправляет ей для присоединения к библиотеке DLL профилировщика.  
  
 Поэтому имеет смысл сделать нечто подобное:  
  
```csharp  
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();  
pkgDebugSettings.EnableDebugging(packgeFullName, null /* debuggerCommandLine */,   
                                                                 IntPtr.Zero /* environment */);  
```  
  
 Это же вызовов, которые можно производить в случае запуска нагрузки за исключением того, не указан в командной строке отладчика или блок среды.  
  
 **DisableDebugging**  
 Как всегда, не забудьте вызвать [IPackageDebugSettings::DisableDebugging](https://msdn.microsoft.com/library/hh438394\(v=vs.85\).aspx) после завершения сеанса профилирования.  
  
<a name="Running"></a>   
## <a name="running-inside-the-windows-store-app"></a>Выполняется внутри приложения магазина Windows  
 Поэтому приложений для магазина Windows и, наконец загрузил библиотеку DLL профилировщика.  Теперь ваша библиотека DLL профилировщика должна изучаться как воспроизвести, различные правила, необходимые для магазина Windows, включая которого разрешены API-интерфейсов и запуск с ограниченными разрешениями.  
  
<a name="APIs"></a>   
### <a name="stick-to-the-windows-store-app-apis"></a>Придерживайтесь API-интерфейсов приложений магазина Windows  
 При просмотре Windows API, можно заметить, что каждый API описано как применимо для классических приложений и приложений для магазина Windows.  Например **требования** раздел документации для [InitializeCriticalSectionAndSpinCount](https://msdn.microsoft.com/library/windows/desktop/ms683476\(v=vs.85\).aspx) функции указывает, что функция применяется только для настольных приложений. Напротив [InitializeCriticalSectionEx](https://msdn.microsoft.com/library/windows/desktop/ms683477\(v=vs.85\).aspx) функция доступна для классических приложений и приложений для магазина Windows.  
  
 При разработке библиотеки DLL профилировщика, обработать его, как будто это приложение для магазина Windows и использовать только API, которые описаны как доступные для приложения для магазина Windows.  Проанализировать зависимости (например, можно выполнить `link /dump /imports` для библиотеки DLL профилировщика для аудита), затем найдите в документации для просмотра зависимостей, являющихся ОК, а что нет.  В большинстве случаев вашей нарушений можно устранить, просто заменить их новой формы из API, который описан как надежный (например, заменив [InitializeCriticalSectionAndSpinCount](https://msdn.microsoft.com/library/windows/desktop/ms683476\(v=vs.85\).aspx) с [ InitializeCriticalSectionEx](https://msdn.microsoft.com/library/windows/desktop/ms683477\(v=vs.85\).aspx)).  
  
 Можно заметить, что библиотеки DLL профилировщика вызывает некоторые интерфейсы API, относящиеся к только для настольных приложений, а еще они действуют даже тогда, когда библиотека DLL профилировщика загружается внутри приложения для магазина Windows.  Имейте в виду, что это рискованно для использования любого API, не описанной для использования с приложениями магазина Windows в библиотеке DLL профилировщика при загрузке в процесс приложения магазина Windows:  
  
-   Такие интерфейсы API не будут гарантированно работать при вызове в уникальный контекст, который приложения для магазина Windows выполняются в.  
  
-   Такие интерфейсы API могут не работать согласованно, при вызове из в различных процессов приложения для магазина Windows.  
  
-   Такие интерфейсы API может показаться нормально работать и в приложениях для магазина Windows в текущей версии Windows, но может быть поврежден или отключить в будущих версиях Windows.  
  
 Устраните все нарушения и избежать риска является рекомендациям.  
  
 Может оказаться абсолютно невозможно делать без конкретный API и не может найти замену подходит для приложений для магазина Windows.  В этом случае, по крайней мере:  
  
-   Проверить, тестировать, тестирования daylights динамичный за пределы использования этого API-интерфейса.  
  
-   Понимание API может неожиданно прервать или исчезнуть при вызове из внутри магазина Windows приложения в будущих версиях Windows.  Это не будет считаться проблема совместимости корпорацией Майкрософт, и поддержки его использования не будет иметь приоритет.  
  
<a name="Permissions"></a>   
### <a name="reduced-permissions"></a>Ограниченными разрешениями  
 Он выходит за рамки этого раздела, чтобы вывести список всех разрешений для приложений магазина Windows, отличаются от настольных приложений методах.  Но определенно поведение будет отличаться каждый раз, библиотеки DLL профилировщика (при загрузке в приложении для магазина Windows по сравнению с классического приложения) пытается получить доступ к любым ресурсам.  Файловая система является наиболее распространенным.  Существует, но некоторые накладывает на диск, который может получить доступ, приложении магазина Windows (в разделе [доступ и разрешения файлов (приложения для среды выполнения Windows](https://msdn.microsoft.com/library/windows/apps/hh967755.aspx)), и библиотека DLL профилировщика будут находиться в те же ограничения.  Тщательно протестируйте кода.  
  
<a name="Interprocess"></a>   
### <a name="inter-process-communication"></a>Межпроцессное взаимодействие  
 Как показано на диаграмме в начале этой статьи, библиотеки DLL профилировщика (загрузить в пространство процесса приложения магазина Windows) скорее всего, потребуется соединиться с профилировщик пользовательского интерфейса (в пространстве процесса отдельные классического приложения под управлением) через свой собственный пользовательский процесс между канал взаимодействия (IPC).  Пользовательский Интерфейс профилировщика отправляет сигналы DLL профилировщика для изменения поведения и DLL профилировщика отправляет данные из проанализированных приложений для магазина Windows обратно в Интерфейсе профилировщика для последующей обработки и отображения пользователю профилировщика.  
  
 Большинство Профилировщики должны работать таким образом, но ваш выбор для механизмов IPC более ограничены при загрузке библиотеки DLL профилировщика в приложении для магазина Windows.  Например именованные каналы не входят приложения для магазина Windows SDK, поэтому их нельзя использовать.  
  
 Но, разумеется, файлы все еще являются, хотя и образом более ограничен.  Также доступны события.  
  
 **Посредством файлов**  
 Большая часть данных скорее всего будет передавать между библиотекой DLL профилировщика и пользовательского интерфейса в профилировщик через файлы.  Ключ — это выбирается расположение файла, прочитаны профилировщик пользовательского интерфейса и библиотека DLL профилировщика (в контексте приложения для магазина Windows) и записи.  Например расположен путь к временной папке DLL профилировщика и пользовательского интерфейса в профилировщик может получить доступ к, но не пакет приложения магазина Windows можно получить доступ к (обеспечивая защиту любые данные, которые журналов из других пакетов приложений для магазина Windows).  
  
 Библиотека DLL профилировщика и пользовательского интерфейса в профилировщик можно независимо определить этот путь.  Профилировщик пользовательского интерфейса, когда он проходит через все пакеты, установленные для текущего пользователя (см. в образце кода в более ранних версий), получает доступ к `PackageId` класс, из которого путь к временной папке могут быть получены с помощью кода, чтобы этот фрагмент.  (Как обычно, проверка ошибок для краткости опущена.)  
  
```csharp  
// C# code for the Profiler UI.  
ApplicationData appData =  
    ApplicationDataManager.CreateForPackageFamily(  
        packageId.FamilyName);  
  
tempDir = appData.TemporaryFolder.Path;  
```  
  
 В свою очередь, библиотеки DLL профилировщика можно по сути действуют одинаково, хотя его можно более легко получить [ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx) класса с помощью [ApplicationData.Current](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.current.aspx) свойство.  
  
 **Посредством событий**  
 Если требуется простой сигнальных семантику между пользовательским Интерфейсом профайлера и библиотека DLL профилировщика, можно использовать события в приложениях для магазина Windows, а также приложениях для настольных систем.  
  
 Из библиотеки DLL профилировщика, можно просто вызвать [CreateEventEx](https://msdn.microsoft.com/library/windows/desktop/ms682400\(v=vs.85\).aspx) функции для создания именованного события с любое имя.  Пример:  
  
```cpp  
// Profiler DLL in Windows Store app (C++).  
CreateEventEx(   
    NULL,  // Not inherited  
    "MyNamedEvent"  
    CREATE_EVENT_MANUAL_RESET, /* explicit ResetEvent() required; leave initial state unsignaled */  
    EVENT_ALL_ACCESS);  
```  
  
 Затем профилировщик пользовательского интерфейса должен найти этого события с заданным именем в пространстве имен приложения магазина Windows.  Например, пользовательский Интерфейс профилировщик может вызвать [CreateEventEx](https://msdn.microsoft.com/library/windows/desktop/ms682400\(v=vs.85\).aspx), указав имя, события  
  
 `AppContainerNamedObjects\<acSid>\MyNamedEvent`  
  
 `<acSid>` равно идентификатору безопасности AppContainer приложения магазина Windows.  Предыдущем разделе этой статьи показано, как проходить по пакеты, установленные для текущего пользователя.  В этот пример кода вы можете получить packageId.  И в packageId, вы можете получить `<acSid>` с помощью кода примерно следующего содержания:  
  
```csharp  
IntPtr acPSID;  
DeriveAppContainerSidFromAppContainerName(packageId.FamilyName, out acPSID);  
  
string acSid;  
ConvertSidToStringSid(acPSID, out acSid);  
  
string acDir;  
GetAppContainerFolderPath(acSid, out acDir);  
```  
  
<a name="Shutdown"></a>   
### <a name="no-shutdown-notifications"></a>Нет уведомлений завершения работы  
 При выполнении в приложении для магазина Windows, библиотеки DLL профилировщика не должен полагаться на либо [ICorProfilerCallback::Shutdown](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-shutdown-method.md) или даже [DllMain](https://msdn.microsoft.com/library/windows/desktop/ms682583\(v=vs.85\).aspx) (с `DLL_PROCESS_DETACH`) вызывается для уведомления профилировщика DLL что выполняется выход из приложения для магазина Windows.  На самом деле следует ожидать, что они никогда не вызывается.  Исторически многие библиотеки DLL профилировщика использовали этих уведомлений как удобный окружение для очистки кэша на диске, закрытие файлов, отправки уведомлений профилировщик пользовательского интерфейса, и т. д.  Но теперь библиотеки DLL профилировщика должна быть организована немного по-разному.  
  
 Библиотека DLL профилировщика должен быть сведения о ведении журнала, поскольку он выполняется.  Из соображений производительности может потребоваться пакета данные из памяти и сбрасывает его на диск пакета при увеличении размера за определенным пороговым значением.  Однако предположим, что все сведения, еще не сохранена на диске могут быть потеряны.  Это означает, что вы захотите выбрать порог центрах и необходимость фиксации для работы с неполные данные, записанные в библиотеке DLL профилировщика профилировщика пользовательского интерфейса.  
  
<a name="Metadata"></a>   
## <a name="windows-runtime-metadata-files"></a>Файлы метаданных среды выполнения Windows  
 Он выходит за рамки настоящего документа подробно на метаданные среды выполнения Windows (WinMD), файлы.    В этом разделе ограничено реакцией API профилирования среды CLR при загрузке файлов WinMD приложением магазина Windows, которое анализ библиотеки DLL профилировщика.  
  
<a name="WMDs"></a>   
### <a name="managed-and-non-managed-winmds"></a>Управляемые и неуправляемые файлы Winmd  
 Если разработчик использует Visual Studio для создания нового проекта компонента среды выполнения Windows, построение этого проекта создает WinMD-файл, описывающий метаданные (описания типов классов, интерфейсов, т. д.), созданный разработчиком.  Если этот проект является проектом управляемом языке, написанных на языке C# или VB, что WinMD-файл также содержит реализацию этих типов (это значит, что он содержит все IL, скомпилированные из исходного кода для разработчиков).  Такие файлы называются управляемого WinMD-файлов.  Они интерес, в том, что они содержат метаданные среды выполнения Windows и базовой реализации.  
  
 Напротив Если разработчик создает проект компонента среды выполнения Windows для C++, сборки этого проекта создает файл WinMD, который содержит только метаданные и реализация компилируется в отдельной DLL с машинным кодом.  Аналогичным образом файлы WinMD, которые поставляются в Windows SDK содержит только метаданные с реализацией, компилируются в отдельном собственных библиотек DLL, которые входят в состав Windows.  
  
 Приводимые ниже сведения применимы для обеих управляемого файлы Winmd, которые содержат метаданные и реализацию, и неуправляемых файлы Winmd, в которой содержат только метаданные.  
  
<a name="CLRModules"></a>   
### <a name="winmd-files-look-like-clr-modules"></a>WinMD-файлов выглядеть модулей среды CLR  
 С точки зрения обеспечения среды CLR, все файлы WinMD, модули.  API профилирования среды CLR, поэтому указывает библиотеку DLL профилировщика при загрузке WinMD-файлов и их идентификаторов ModuleID Каковы, таким же образом, как и для других управляемых модулей.  
  
 Библиотека DLL профилировщика различает WinMD-файлов из других модулей, вызвав [ICorProfilerInfo3::GetModuleInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo3-getmoduleinfo2-method.md) метод и проверив `pdwModuleFlags` выходной параметр для [COR_PRF_MODULE_WINDOWS_ Среда ВЫПОЛНЕНИЯ](../../../../docs/framework/unmanaged-api/profiling/cor-prf-module-flags-enumeration.md) флаг.  (Он имеет значение только в том случае, если ModuleID представляет winmd-файлом.)  
  
<a name="Reading"></a>   
### <a name="reading-metadata-from-winmds"></a>Чтение метаданных из файлы Winmd  
 WinMD-файлов, таких как обычные модули содержат метаданные, которые могут считываться через [API-интерфейсы метаданных](../../../../docs/framework/unmanaged-api/metadata/index.md).  Однако среда CLR сопоставляет типы среды выполнения Windows с типами .NET Framework при считывании файлы WinMD, чтобы разработчикам программировать в управляемом коде и использовать WinMD-файл может иметь более естественным опыт программирования.  Некоторые примеры этих сопоставлений см. [.NET Framework поддержка для приложений магазина Windows и среды выполнения Windows](../../../../docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).  
  
 Поэтому представление ваш профилировщик получит при использовании интерфейсов API метаданных: базовое представление среды выполнения Windows или сопоставленного представления .NET Framework?  Ответ: именно вам.  
  
 При вызове [ICorProfilerInfo::GetModuleMetaData](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getmodulemetadata-method.md) метод WinMD для получения на интерфейс метаданных, таких как [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md), вы можете задать [ofNoTransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md)в `dwOpenFlags` параметр, чтобы отключить это сопоставление.  В противном случае по умолчанию будет включено сопоставление.  Как правило профилировщик сохранит сопоставление включено, строки, библиотеки DLL профилировщика из метаданных WinMD (например, имена типов) выглядел знакомых и естественным пользователю профилировщика.  
  
<a name="Modifying"></a>   
### <a name="modifying-metadata-from-winmds"></a>Изменение метаданных из файлы Winmd  
 Изменения метаданных в файлы Winmd не поддерживается.  При вызове метода [ICorProfilerInfo::GetModuleMetaData](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getmodulemetadata-method.md) метод для WinMD файла и укажите [ofWrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) в `dwOpenFlags` параметр или запрашивает интерфейс для записи метаданных, таких как [ IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md), [GetModuleMetaData](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getmodulemetadata-method.md) завершится ошибкой.  Это очень важен для перезаписи IL профилировщики, которые требуются для изменения метаданных для поддержки их инструментария (например, чтобы добавить AssemblyRefs или новые методы).  Поэтому необходимо проверить наличие [COR_PRF_MODULE_WINDOWS_RUNTIME](../../../../docs/framework/unmanaged-api/profiling/cor-prf-module-flags-enumeration.md) сначала (как описано в предыдущем разделе) и не передавайте запрашиваются интерфейсы для записи метаданных для таких модулей.  
  
<a name="Resolving"></a>   
### <a name="resolving-assembly-references-with-winmds"></a>Разрешение ссылок на сборки с файлы Winmd  
 Многие Профилировщики должны для разрешения ссылок на метаданные вручную для помощи в инструментирование или типа проверки.  Такие Профилировщики должны учитывать как среда CLR разрешает ссылки на сборки, которые указывают на файлы Winmd, так как эти ссылки разрешаются в совершенно иначе, чем стандартные ссылки на сборки.  
  
<a name="Profilers"></a>   
## <a name="memory-profilers"></a>Профилировщики памяти  
 Сборщик мусора и управляемой кучи не существенно различается в приложении для магазина Windows и классического приложения.  Однако существуют некоторые небольшие отличия, которые разработчики профилировщика должны иметь в виду.  
  
<a name="ForceGC"></a>   
### <a name="forcegc-creates-a-managed-thread"></a>ForceGC создает управляемый поток  
 При выполнении профилирования памяти, библиотеки DLL профилировщика обычно создает отдельный поток, из которой вызывается [метод ForceGC](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-forcegc-method.md) метод.  Это ничего нового.  Но что может быть неожиданным, само действие сбора мусора внутри приложения магазина Windows может преобразования вашего потока в управляемом потоке (например, API профилирования ThreadID будут создаваться для этого потока).  
  
 Чтобы понять последствия этого, важно понимать различия между синхронными и асинхронными вызовами в соответствии с определением API профилирования среды CLR. Обратите внимание, что этот процесс сильно отличается от концепции асинхронные вызовы в приложениях для магазина Windows.  См. в записи блога [почему у нас есть CORPROF_E_UNSUPPORTED_CALL_SEQUENCE](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) для получения дополнительной информации.  
  
 Соответствующие происходит что вызовов, сделанных на потоки, созданные вашим профилировщиком всегда считаются синхронным, даже если такие вызовы будут осуществляться за пределами реализацию одной библиотеки DLL профилировщика [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) методы.  Используется по крайней мере, который относится к.  Теперь, когда среда CLR отключил ваш профилировщик потока в управляемом потоке из-за при вызове [метод ForceGC](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-forcegc-method.md), поток больше не считается ваш профилировщик потока.  Таким образом, среда CLR обеспечивает более строгое определение что определяет, как синхронный, для этого потока, а именно, вызов должен инициироваться внутри одного из библиотеки DLL профилировщика [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) методы для определения, как синхронный.  
  
 Что это означает на практике?  Большинство [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) методы только безопасно вызываться синхронно и произойдет немедленно в противном случае.  Таким образом, если библиотека DLL профилировщика повторно использует ваш [метод ForceGC](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-forcegc-method.md) потока для других вызовов обычно выполняется в потоках, созданных профилировщика (к примеру, чтобы [RequestProfilerDetach](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo3-requestprofilerdetach-method.md), [RequestReJIT](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo4-requestrejit-method.md), или [RequestRevert](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo4-requestrevert-method.md)), вы собираетесь будет повторяться.  Даже асинхронной safe такой функции, как [DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) есть специальные правила, при вызове из управляемых потоков. (См. в записи блога [проверка стека профилировщика: основы и более](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) подробнее.)  
  
 Таким образом, рекомендуется, чтобы любой поток, который создает библиотеки DLL профилировщика для вызова [метод ForceGC](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-forcegc-method.md) следует использовать *только* с целью запуска сборки мусора и затем отвечает на обратные вызовы сборки Мусора.  Его не следует вызывать API профилирования для выполнения других задач, например стеке выборки или отсоединение.  
  
<a name="WeakTable"></a>   
### <a name="conditionalweaktablereferences"></a>ConditionalWeakTableReferences  
 Начиная с .NET Framework 4.5, имеется новый сборщик Мусора обратный вызов, [ConditionalWeakTableElementReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback5-conditionalweaktableelementreferences-method.md), которое содержит профилировщик более полную информацию о *зависимых дескрипторов*. Эти маркеры эффективно добавить ссылку из исходного объекта для целевого объекта с целью управления жизненным циклом сборки Мусора.  Зависимые дескрипторы являются ничего нового, и разработчиков, использующих в управляемом коде была возможность создавать свои собственные дескрипторы зависимых с помощью <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> класса еще до Windows 8 и .NET Framework 4.5.  
  
 Тем не менее управляемых приложений для магазина Windows XAML теперь делают сложным использование зависимых дескрипторов.  В частности среда CLR использует их для помощи в управлении циклов ссылку между управляемыми объектами и неуправляемые объекты среды выполнения Windows.  Это означает, что более важно, теперь чем когда-либо для профилировщиков памяти иметь представление о эти зависимые маркеры, чтобы они могут быть визуализированы вместе с остальными границ в графе кучи.  Следует использовать библиотеку DLL профилировщика [RootReferences2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectreferences-method.md), и [ConditionalWeakTableElementReferences](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback5-conditionalweaktableelementreferences-method.md) вместе для формирования полного представления о графе кучи .  
  
<a name="Conclusion"></a>   
## <a name="conclusion"></a>Заключение  
 Можно использовать API профилирования среды CLR для анализа управляемого кода, запущенного в приложениях для магазина Windows.  На самом деле можно воспользоваться существующей профилировщика, которое вы разрабатываете и внести определенные изменения, чтобы приложения для магазина Windows могут работать.   Пользовательский Интерфейс профилировщика следует использовать новые интерфейсы API для активации приложения для магазина Windows в режиме отладки.  Убедитесь, что библиотека DLL профилировщика необходим только тех интерфейсов API применимо для приложений для магазина Windows.  Механизм взаимодействия между DLL профилировщика и пользовательского интерфейса в профилировщик должен быть записан с ограничения API приложения магазина Windows в виду и осведомленность о ограниченные разрешения на месте для магазина Windows.  Библиотеки DLL профилировщика, помните о том, как среда CLR рассматривает файлы Winmd, и как сборщик мусора поведение отличается по отношению к управляемых потоков.  
  
<a name="Resources"></a>   
## <a name="resources"></a>Ресурсы  
 **Общеязыковая среда выполнения**  
 -   [Справочник по API профилирования среды CLR](../../../../docs/framework/unmanaged-api/profiling/index.md)  
  
-   [Справочник по API метаданных среды CLR](../../../../docs/framework/unmanaged-api/metadata/index.md)  
  
 **Среде CLR взаимодействия со средой выполнения Windows**  
 [Поддержка платформы .NET Framework для приложений магазина Windows и среды выполнения Windows](../../../../docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)  
  
 **Приложения для Магазина Windows**  
 -   [Доступ к файлам и разрешения (приложения среды выполнения Windows](https://msdn.microsoft.com/library/windows/apps/hh967755.aspx)  
  
-   [Получить лицензию разработчика](https://msdn.microsoft.com/library/windows/apps/Hh974578.aspx)  
  
-   [Интерфейс IPackageDebugSettings](https://msdn.microsoft.com/library/hh438393\(v=vs.85\).aspx)  
  
## <a name="see-also"></a>См. также  
 [Профилирование](../../../../docs/framework/unmanaged-api/profiling/index.md)
