---
title: "Метод ICorProfilerInfo2::DoStackSnapshot"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: reference
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
caps.latest.revision: 
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 5548254eb160547643a874fd2e31a085ec6f3ecb
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a>Метод ICorProfilerInfo2::DoStackSnapshot
Пошаговое описание управляемые фреймы в стеке для заданного потока и отправляет сведения профилировщику посредством обратного вызова.  
  
## <a name="syntax"></a>Синтаксис  
  
```  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
#### <a name="parameters"></a>Параметры  
 `thread`  
 [in] Идентификатор целевой поток.  
  
 Передача значения null в `thread` создается моментальный снимок текущего потока. Если `ThreadID` из другого потока, передается, общеязыковой среды выполнения (CLR) приостанавливает этот поток, делает моментальный снимок и возобновляет работу.  
  
 `callback`  
 [in] Указатель на реализацию [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) метод, который вызывается средой CLR для предоставления информации для каждого управляемого кадра и каждом запуске неуправляемого кадра профилировщика.  
  
 `StackSnapshotCallback` Метод реализуется модулем записи профилировщика.  
  
 `infoFlags`  
 [in] Значение [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) перечисления, который определяет объем данных будет передан обратно для каждого кадра, `StackSnapshotCallback`.  
  
 `clientData`  
 [in] Указатель на данные клиента, который передается непосредственно в `StackSnapshotCallback` функции обратного вызова.  
  
 `context`  
 [in] Указатель на объект Win32 `CONTEXT` структуру, которая используется в качестве начального прохода стека. Win32 `CONTEXT` структуры содержит значения, регистров, ЦП и представляет состояние ЦП в определенный момент времени.  
  
 Начальное значение позволяет среде CLR определить, откуда следует начинать обход стека, если на вершине стека расположен вспомогательный неуправляемый код; в противном случае начальное значение игнорируется. Для асинхронного прохода необходимо указать начальное значение. При выполнении синхронного прохода начальное значение не требуется.  
  
 `context` Параметр допустим только в том случае, если переданный флаг COR_PRF_SNAPSHOT_CONTEXT `infoFlags` параметра.  
  
 `contextSize`  
 [in] Размер `CONTEXT` структуры, который ссылается `context` параметра.  
  
## <a name="remarks"></a>Примечания  
 Передача значения null для `thread` создается моментальный снимок текущего потока. Моментальные снимки можно создавать других потоков, только в том случае, если целевой поток приостанавливается на время.  
  
 Если профилировщик хочет обход стека, он вызывает `DoStackSnapshot`. Прежде чем среда CLR возвращается из вызова, он вызывает вашей `StackSnapshotCallback` несколько раз, один раз для каждого управляемого кадра (или запуска кадров неуправляемого кода) в стеке. При появлении кадров неуправляемого кода, должны пройти их самостоятельно.  
  
 Порядок, в котором выполняется проход стека является как кадры были переданы в стек в обратном направлении: последнего конечные (отправить последней) во-первых, основной (первый переданный) фрейма.  
  
 Дополнительные сведения о программировании профилировщика для обхода управляемых стеков см. в разделе [проверка стека профилировщика в .NET Framework 2.0: основы и другие сведения](http://go.microsoft.com/fwlink/?LinkId=73638).  
  
 Обход стека могут быть синхронными или асинхронными, как описано в следующих разделах.  
  
## <a name="synchronous-stack-walk"></a>Синхронные стека  
 Синхронные стека включает в себя анализ стека текущего потока в ответ на обратный вызов. Он не требует заполнения или приостановка.  
  
 Вносимые синхронного вызова, когда, в ответ на среду CLR, вызова одного из вашего профилировщика [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (или [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) вызовите методы, `DoStackSnapshot` для прохода по стеку текущий поток. Это полезно, если вы хотите немедленно отображается стек на уведомление о таких как [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md). Просто вызвать `DoStackSnapshot` внутри вашей `ICorProfilerCallback` метод, передавая значение null в `context` и `thread` параметров.  
  
## <a name="asynchronous-stack-walk"></a>Обход стека асинхронного  
 Обход стека асинхронного влечет за собой прохода по стеку другого потока или проходу стека текущего потока не в ответ на обратный вызов, а путем перехвата указателя инструкций текущего потока. Для асинхронного прохода требуется исходное значение, если неуправляемый код, который не является частью платформы находится вверху стека вызова (PInvoke) или вызов COM, но вспомогательный код в самой среде CLR. Например код, который собирает just-in-time (JIT) при компиляции или сборки мусора — вспомогательный код.  
  
 Вы получите начальное значение самостоятельно приостановить целевой поток и пройти по стеку вручную, пока не будет найден самый верхний кадр управляемого кода. После целевой поток приостанавливается и получите текущий контекст регистра целевого потока. Проверьте, указывает ли контекста регистра в неуправляемый код, вызвав [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) , если он возвращает `FunctionID` равен нулю, кадр является неуправляемым кодом. Теперь обход стека, пока не достигнете кадр управляемого, а затем вычислить контекст начального значения, исходя из контекста регистра для этого кадра.  
  
 Вызовите `DoStackSnapshot` с контекстом начального значения для начала асинхронной проверки стека. Если не указать начальное значение, `DoStackSnapshot` пропустит кадры управляемого кода в верхней части стека и, следовательно, предоставит неполный проход стека. Если указать начальное значение, оно должно указывать на JIT-компиляции или собственного генератором образов (Ngen.exe)-сформированного кода; в противном случае `DoStackSnapshot` возвращает код ошибки CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.  
  
 Стека можно легко вызвать взаимоблокировку или нарушение прав доступа, если придерживайтесь следующих правил:  
  
-   При непосредственной приостановке потоков следует помните, что приостановить другой поток может только поток, не выполненных управляемого кода.  
  
-   Всегда блока в вашей [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) обратного вызова до момента завершения этого потока стека.  
  
-   Не блокируйте во время обращения профилировщика к функции среды CLR, который может инициировать сборку мусора. То есть не удерживать блокировку, если собственный поток может осуществить вызов, который запускает сборку мусора.  
  
 Есть также риск взаимоблокировки при вызове метода `DoStackSnapshot` из потока, создавшего вашего профилировщика, чтобы для прохода по стеку из конкретного целевого потока. Первый раз был создан поток входит в определенных `ICorProfilerInfo*` методы (включая `DoStackSnapshot`), среда CLR будет выполнять, связанных с CLR инициализацию потоков в том же потоке. Если профилировщик приостановил целевой поток, стек которого вы пытаетесь выполнить проход, и если этот целевой поток является владельцем блокировки, необходимой для выполнения инициализации каждого потока, произойдет взаимоблокировка. Чтобы избежать этой взаимоблокировки, выполните исходный вызов в `DoStackSnapshot` из вашего потока, созданного профилировщиком для прохода по целевой поток отдельно, но снимает целевой поток сначала. Исходный вызов гарантирует, что инициализацию потоков может завершиться без взаимоблокировки. Если `DoStackSnapshot` успешно выполняется и выдает по крайней мере один кадр после этой точки будет использоваться для этого потока, созданного профилировщиком для приостановки любой целевой поток и вызовите `DoStackSnapshot` на обход стека этого целевого потока.  
  
## <a name="requirements"></a>Требования  
 **Платформы:** разделе [требования к системе для](../../../../docs/framework/get-started/system-requirements.md).  
  
 **Заголовок:** CorProf.idl, CorProf.h  
  
 **Библиотека:** CorGuids.lib  
  
 **Версии платформы .NET framework:**[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  
  
## <a name="see-also"></a>См. также  
 [Интерфейс ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)  
 [Интерфейс ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
