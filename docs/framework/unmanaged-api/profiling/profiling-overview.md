---
title: Общие сведения о профилировании
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
author: mairaw
ms.author: mairaw
ms.openlocfilehash: dd0fef0e8a2c4b94cd5dd7beb140e669c52a07a8
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2018
ms.locfileid: "43554032"
---
# <a name="profiling-overview"></a><span data-ttu-id="ff897-102">Общие сведения о профилировании</span><span class="sxs-lookup"><span data-stu-id="ff897-102">Profiling Overview</span></span>
<a name="top"></a> <span data-ttu-id="ff897-103">Профилировщик — это средство, которое наблюдает за выполнением другого приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="ff897-104">Профилировщик среды CLR — это библиотека DLL, содержащая функции, которые получают сообщения из среды CLR и отправляют сообщения в среду CLR с помощью API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="ff897-105">Библиотека DLL профилировщика загружается средой CLR во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ff897-105">The profiler DLL is loaded by the CLR at run time.</span></span>  
  
 <span data-ttu-id="ff897-106">Традиционные средства профилирования основное внимание уделяют измерению выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="ff897-107">То есть они измеряют время, затраченное на каждую функцию, или использование памяти приложением за период времени.</span><span class="sxs-lookup"><span data-stu-id="ff897-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="ff897-108">API профилирования предназначен для более широкого класса диагностических средств, таких как служебные программы с покрытием кода и расширенные средства отладки.</span><span class="sxs-lookup"><span data-stu-id="ff897-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="ff897-109">Сфера их применения — вся диагностика в природе.</span><span class="sxs-lookup"><span data-stu-id="ff897-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="ff897-110">API профилирования не только измеряет, но также наблюдает за выполнением приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="ff897-111">По этой причине API профилирования никогда не должен использоваться самим приложением, и выполнение приложения не должно ни зависеть от профилировщика, ни подвергаться его влиянию.</span><span class="sxs-lookup"><span data-stu-id="ff897-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>  
  
 <span data-ttu-id="ff897-112">Для профилирования приложения среды CLR требуется дополнительная поддержка по сравнению с профилированием стандартно скомпилированного машинного кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="ff897-113">Это объясняется тем, что в среде CLR вводятся такие понятия, как домены приложений, сборка мусора, обработка управляемых исключений, JIT-компиляция кода (преобразование кода MSIL в машинный код) и другие аналогичные возможности.</span><span class="sxs-lookup"><span data-stu-id="ff897-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="ff897-114">Механизмы традиционного профилирования не могут обнаруживать эти возможности или предоставлять полезные сведения о них.</span><span class="sxs-lookup"><span data-stu-id="ff897-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="ff897-115">API профилирования эффективно предоставляет эти отсутствующие сведения с минимальным влиянием на производительность среды CLR и профилируемого приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>  
  
 <span data-ttu-id="ff897-116">JIT-компиляция во время выполнения обеспечивает прекрасные возможности для профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="ff897-117">API профилирования позволяет профилировщику вносить изменения потока кода MSIL в памяти для подпрограммы перед ее JIT-компиляцией.</span><span class="sxs-lookup"><span data-stu-id="ff897-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="ff897-118">Таким образом, профилировщик может динамически добавлять код инструментирования в определенные подпрограммы, требующие более глубокого анализа.</span><span class="sxs-lookup"><span data-stu-id="ff897-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="ff897-119">Хотя такой подход возможен в обычных сценариях, его гораздо проще реализовать для среды CLR с помощью API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>  
  
 <span data-ttu-id="ff897-120">Этот обзор состоит из следующих разделов.</span><span class="sxs-lookup"><span data-stu-id="ff897-120">This overview consists of the following sections:</span></span>  
  
-   [<span data-ttu-id="ff897-121">API профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-121">The Profiling API</span></span>](#profiling_api)  
  
-   [<span data-ttu-id="ff897-122">Поддерживаемые функции</span><span class="sxs-lookup"><span data-stu-id="ff897-122">Supported Features</span></span>](#support)  
  
-   [<span data-ttu-id="ff897-123">Потоки уведомлений</span><span class="sxs-lookup"><span data-stu-id="ff897-123">Notification Threads</span></span>](#notification_threads)  
  
-   [<span data-ttu-id="ff897-124">Безопасность</span><span class="sxs-lookup"><span data-stu-id="ff897-124">Security</span></span>](#security)  
  
-   [<span data-ttu-id="ff897-125">Объединение управляемого и неуправляемого кода в Profiler кода</span><span class="sxs-lookup"><span data-stu-id="ff897-125">Combining Managed and Unmanaged Code in a Code Profiler</span></span>](#combining_managed_unmanaged)  
  
-   [<span data-ttu-id="ff897-126">Профилирование неуправляемого кода</span><span class="sxs-lookup"><span data-stu-id="ff897-126">Profiling Unmanaged Code</span></span>](#unmanaged)  
  
-   [<span data-ttu-id="ff897-127">С помощью COM</span><span class="sxs-lookup"><span data-stu-id="ff897-127">Using COM</span></span>](#com)  
  
-   [<span data-ttu-id="ff897-128">Стеки вызовов</span><span class="sxs-lookup"><span data-stu-id="ff897-128">Call stacks</span></span>](#call_stacks)  
  
-   [<span data-ttu-id="ff897-129">Обратные вызовы и глубина стека вызовов</span><span class="sxs-lookup"><span data-stu-id="ff897-129">Callbacks and Stack Depth</span></span>](#callbacks)  
  
-   [<span data-ttu-id="ff897-130">Связанные разделы</span><span class="sxs-lookup"><span data-stu-id="ff897-130">Related Topics</span></span>](#related_topics)  
  
<a name="profiling_api"></a>   
## <a name="the-profiling-api"></a><span data-ttu-id="ff897-131">API профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-131">The Profiling API</span></span>  
 <span data-ttu-id="ff897-132">Как правило, API профилирования используется для записи *профилировщик кода*, который представляет собой программу, осуществляющую мониторинг выполнения управляемого приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-132">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>  
  
 <span data-ttu-id="ff897-133">API профилирования используется библиотекой DLL профилировщика, которая загружается в один процесс с профилируемым приложением.</span><span class="sxs-lookup"><span data-stu-id="ff897-133">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="ff897-134">Библиотека DLL профилировщика реализует интерфейс обратного вызова ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) в .NET Framework версий 1.0 и 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) в версии 2.0 и более поздние версии).</span><span class="sxs-lookup"><span data-stu-id="ff897-134">The profiler DLL implements a callback interface ([ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="ff897-135">Среда CLR вызывает методы этого интерфейса для уведомления профилировщика о событиях в процессе профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-135">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="ff897-136">Профилировщик может выполнять обратный вызов в среду выполнения с помощью методов в [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) и [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) интерфейсов для получения сведений о состоянии профилируемого приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-136">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff897-137">В одном процессе с профилируемым приложением должна запускаться только часть решения профилировщика, отвечающая за сбор данных.</span><span class="sxs-lookup"><span data-stu-id="ff897-137">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="ff897-138">Весь анализ пользовательского интерфейса и данных должен выполняться в отдельном процессе.</span><span class="sxs-lookup"><span data-stu-id="ff897-138">All user interface and data analysis should be performed in a separate process.</span></span>  
  
 <span data-ttu-id="ff897-139">На следующем рисунке показано, как библиотека DLL профилировщика взаимодействует с профилируемым приложением и средой CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-139">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>  
  
 <span data-ttu-id="ff897-140">![Архитектура профилирования](../../../../docs/framework/unmanaged-api/profiling/media/profilingarch.png "ProfilingArch")</span><span class="sxs-lookup"><span data-stu-id="ff897-140">![Profiling Architecture](../../../../docs/framework/unmanaged-api/profiling/media/profilingarch.png "ProfilingArch")</span></span>  
<span data-ttu-id="ff897-141">Архитектура профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-141">Profiling architecture</span></span>  
  
### <a name="the-notification-interfaces"></a><span data-ttu-id="ff897-142">Интерфейсы уведомлений</span><span class="sxs-lookup"><span data-stu-id="ff897-142">The Notification Interfaces</span></span>  
 <span data-ttu-id="ff897-143">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) и [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) можно считать интерфейсами уведомлений.</span><span class="sxs-lookup"><span data-stu-id="ff897-143">[ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="ff897-144">Эти интерфейсы содержат методы, такие как [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), и [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span><span class="sxs-lookup"><span data-stu-id="ff897-144">These interfaces consist of methods such as [ClassLoadStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="ff897-145">Каждый раз, когда среда CLR загружает или выгружает класс, компилирует функцию и т. д., она вызывает соответствующий метод в интерфейсе `ICorProfilerCallback` или `ICorProfilerCallback2` профилировщика.</span><span class="sxs-lookup"><span data-stu-id="ff897-145">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>  
  
 <span data-ttu-id="ff897-146">Например, профилировщик может измерять производительность кода с помощью двух функций уведомлений: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) и [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="ff897-146">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) and [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md).</span></span> <span data-ttu-id="ff897-147">Он просто устанавливает метки времени для каждого уведомления, собирает результаты и выводит список, в котором указывается, на какие функции было затрачено больше ресурсов ЦП или физического времени во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-147">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>  
  
### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="ff897-148">Интерфейсы для извлечения сведений</span><span class="sxs-lookup"><span data-stu-id="ff897-148">The Information Retrieval Interfaces</span></span>  
 <span data-ttu-id="ff897-149">Других основных интерфейсов, необходимых для профилирования, [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) и [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span><span class="sxs-lookup"><span data-stu-id="ff897-149">The other main interfaces involved in profiling are [ICorProfilerInfo](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md) and [ICorProfilerInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="ff897-150">Профилировщик вызывает эти интерфейсы по мере необходимости для получения дополнительных сведений, помогающих выполнить анализ.</span><span class="sxs-lookup"><span data-stu-id="ff897-150">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="ff897-151">Например, каждый раз, когда среда CLR вызывает [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) функция, она предоставляет ее идентификатор.</span><span class="sxs-lookup"><span data-stu-id="ff897-151">For example, whenever the CLR calls the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="ff897-152">Профилировщик может получить дополнительные сведения о функции путем вызова [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) метод обнаружения родительский класс функции, ее имя и т. д.</span><span class="sxs-lookup"><span data-stu-id="ff897-152">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>  
  
 [<span data-ttu-id="ff897-153">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-153">Back to top</span></span>](#top)  
  
<a name="support"></a>   
## <a name="supported-features"></a><span data-ttu-id="ff897-154">Поддерживаемые компоненты</span><span class="sxs-lookup"><span data-stu-id="ff897-154">Supported Features</span></span>  
 <span data-ttu-id="ff897-155">API профилирования предоставляет сведения о различных событиях и действиях, которые происходят в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-155">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="ff897-156">Эти сведения можно использовать для мониторинга внутренней работы процессов и анализа производительности приложения .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ff897-156">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>  
  
 <span data-ttu-id="ff897-157">API профилирования извлекает сведения о следующих действиях и событиях, происходящих в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-157">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>  
  
-   <span data-ttu-id="ff897-158">События запуска и завершения работы среды CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-158">CLR startup and shutdown events.</span></span>  
  
-   <span data-ttu-id="ff897-159">События создания и завершения работы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-159">Application domain creation and shutdown events.</span></span>  
  
-   <span data-ttu-id="ff897-160">События загрузки и выгрузки сборки.</span><span class="sxs-lookup"><span data-stu-id="ff897-160">Assembly loading and unloading events.</span></span>  
  
-   <span data-ttu-id="ff897-161">События загрузки и выгрузки модуля.</span><span class="sxs-lookup"><span data-stu-id="ff897-161">Module loading and unloading events.</span></span>  
  
-   <span data-ttu-id="ff897-162">События создания и удаления таблицы VTable COM.</span><span class="sxs-lookup"><span data-stu-id="ff897-162">COM vtable creation and destruction events.</span></span>  
  
-   <span data-ttu-id="ff897-163">События JIT-компиляции и пошагового выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-163">Just-in-time (JIT) compilation and code-pitching events.</span></span>  
  
-   <span data-ttu-id="ff897-164">События загрузки и выгрузки класса.</span><span class="sxs-lookup"><span data-stu-id="ff897-164">Class loading and unloading events.</span></span>  
  
-   <span data-ttu-id="ff897-165">События создания и удаления потока.</span><span class="sxs-lookup"><span data-stu-id="ff897-165">Thread creation and destruction events.</span></span>  
  
-   <span data-ttu-id="ff897-166">События входа и выхода функции.</span><span class="sxs-lookup"><span data-stu-id="ff897-166">Function entry and exit events.</span></span>  
  
-   <span data-ttu-id="ff897-167">Исключения.</span><span class="sxs-lookup"><span data-stu-id="ff897-167">Exceptions.</span></span>  
  
-   <span data-ttu-id="ff897-168">Переходы между выполнением управляемого и неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-168">Transitions between managed and unmanaged code execution.</span></span>  
  
-   <span data-ttu-id="ff897-169">Переходы между различными контекстами среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="ff897-169">Transitions between different runtime contexts.</span></span>  
  
-   <span data-ttu-id="ff897-170">Сведения о приостановках среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="ff897-170">Information about runtime suspensions.</span></span>  
  
-   <span data-ttu-id="ff897-171">Сведения о действиях сборки мусора и кучи в памяти времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="ff897-171">Information about the runtime memory heap and garbage collection activity.</span></span>  
  
 <span data-ttu-id="ff897-172">API профилирования можно вызывать из любого (неуправляемого) языка, совместимого с COM.</span><span class="sxs-lookup"><span data-stu-id="ff897-172">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>  
  
 <span data-ttu-id="ff897-173">Этот API является эффективным с точки зрения потребления ресурсов ЦП и памяти.</span><span class="sxs-lookup"><span data-stu-id="ff897-173">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="ff897-174">Профилирование не влечет за собой изменения профилируемого приложения, которые могут привести к недостоверным результатам.</span><span class="sxs-lookup"><span data-stu-id="ff897-174">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>  
  
 <span data-ttu-id="ff897-175">API профилирования полезен для профилировщиков как с выборкой, так и без выборки.</span><span class="sxs-lookup"><span data-stu-id="ff897-175">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="ff897-176">Объект *выборки профилировщик* проверяет профиль через регулярные интервалы, скажем, через каждые 5 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="ff897-176">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="ff897-177">Объект *профилировщик без выборки* информируется о событии синхронно с потоком, который вызывает событие.</span><span class="sxs-lookup"><span data-stu-id="ff897-177">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>  
  
### <a name="unsupported-functionality"></a><span data-ttu-id="ff897-178">Неподдерживаемые функциональные возможности</span><span class="sxs-lookup"><span data-stu-id="ff897-178">Unsupported Functionality</span></span>  
 <span data-ttu-id="ff897-179">API профилирования не поддерживает следующие функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="ff897-179">The profiling API does not support the following functionality:</span></span>  
  
-   <span data-ttu-id="ff897-180">Неуправляемый код, который необходимо профилировать с помощью стандартных методов Win32.</span><span class="sxs-lookup"><span data-stu-id="ff897-180">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="ff897-181">Однако профилировщик среды CLR включает события переходов для определения границ между управляемым и неуправляемым кодом.</span><span class="sxs-lookup"><span data-stu-id="ff897-181">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>  
  
-   <span data-ttu-id="ff897-182">Самоизменяющиеся приложения, которые изменяют собственный код приложения, которые изменяют собственный код, например в целях аспектно-ориентированного программирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-182">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>  
  
-   <span data-ttu-id="ff897-183">Проверка привязок, поскольку API профилирования не предоставляет эти сведения.</span><span class="sxs-lookup"><span data-stu-id="ff897-183">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="ff897-184">Среда CLR предоставляет существенную поддержку для проверки границ всего управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-184">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>  
  
-   <span data-ttu-id="ff897-185">Удаленное профилирование, которое не поддерживается по следующим причинам.</span><span class="sxs-lookup"><span data-stu-id="ff897-185">Remote profiling, which is not supported for the following reasons:</span></span>  
  
    -   <span data-ttu-id="ff897-186">Удаленное профилирование увеличивает время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ff897-186">Remote profiling extends execution time.</span></span> <span data-ttu-id="ff897-187">При использовании интерфейсов профилирования необходимо минимизировать время выполнения, чтобы оно не слишком сильно сказывалось на результатах профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-187">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="ff897-188">Это особенно важно при мониторинге производительности.</span><span class="sxs-lookup"><span data-stu-id="ff897-188">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="ff897-189">Тем не менее удаленное профилирование не является ограничением при использовании интерфейсов профилирования для мониторинга использования памяти или для получения сведений времени выполнения о кадрах стека, объектах и т. п.</span><span class="sxs-lookup"><span data-stu-id="ff897-189">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>  
  
    -   <span data-ttu-id="ff897-190">Профилировщик кода среды CLR должен зарегистрировать один или несколько интерфейсов обратного вызова в среде выполнения на локальном компьютере, на котором выполняется профилируемое приложение.</span><span class="sxs-lookup"><span data-stu-id="ff897-190">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="ff897-191">Это ограничивает возможность создания удаленного профилировщика кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-191">This limits the ability to create a remote code profiler.</span></span>  
  
-   <span data-ttu-id="ff897-192">Профилирование в производственных средах с требованиями высокой доступности.</span><span class="sxs-lookup"><span data-stu-id="ff897-192">Profiling in production environments with high-availability requirements.</span></span> <span data-ttu-id="ff897-193">API профилирования создавался для поддержки диагностики во время разработки.</span><span class="sxs-lookup"><span data-stu-id="ff897-193">The profiling API was created to support development-time diagnostics.</span></span> <span data-ttu-id="ff897-194">Он не проходил строгие испытания, необходимые для поддержки производственных сред.</span><span class="sxs-lookup"><span data-stu-id="ff897-194">It has not undergone the rigorous testing required to support production environments.</span></span>  
  
 [<span data-ttu-id="ff897-195">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-195">Back to top</span></span>](#top)  
  
<a name="notification_threads"></a>   
## <a name="notification-threads"></a><span data-ttu-id="ff897-196">Потоки уведомлений</span><span class="sxs-lookup"><span data-stu-id="ff897-196">Notification Threads</span></span>  
 <span data-ttu-id="ff897-197">В большинстве случаев поток, который создает событие, также выполняет уведомления.</span><span class="sxs-lookup"><span data-stu-id="ff897-197">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="ff897-198">Такие уведомления (например, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) и [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) не требуется предоставлять явные `ThreadID`.</span><span class="sxs-lookup"><span data-stu-id="ff897-198">Such notifications (for example, [FunctionEnter](../../../../docs/framework/unmanaged-api/profiling/functionenter-function.md) and [FunctionLeave](../../../../docs/framework/unmanaged-api/profiling/functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="ff897-199">Кроме того, профилировщик может использовать локальное хранилище потока для хранения и обновления своих блоков анализа вместо индексирования этих блоков в глобальном хранилище на основе `ThreadID` затронутого потока.</span><span class="sxs-lookup"><span data-stu-id="ff897-199">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>  
  
 <span data-ttu-id="ff897-200">Обратите внимание, что эти обратные вызовы не сериализуются.</span><span class="sxs-lookup"><span data-stu-id="ff897-200">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="ff897-201">Пользователи должны защищать свой код, путем создания потокобезопасных структур данных и путем блокировки кода профилировщика в тех случаях, когда необходимо предотвратить параллельный доступ из нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="ff897-201">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="ff897-202">Таким образом, в некоторых случаях можно получить необычную последовательность обратных вызовов.</span><span class="sxs-lookup"><span data-stu-id="ff897-202">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="ff897-203">Например, предположим, что управляемое приложение порождает два потока, выполняющие идентичный код.</span><span class="sxs-lookup"><span data-stu-id="ff897-203">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="ff897-204">В этом случае можно получать [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) событий для некоторой функции из одного потока и `FunctionEnter` обратного вызова из другого потока до получения [ ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="ff897-204">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="ff897-205">В этом случае пользователь получит обратный вызов `FunctionEnter` для функции, которая могла быть не полностью JIT-скомпилирована.</span><span class="sxs-lookup"><span data-stu-id="ff897-205">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>  
  
 [<span data-ttu-id="ff897-206">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-206">Back to top</span></span>](#top)  
  
<a name="security"></a>   
## <a name="security"></a><span data-ttu-id="ff897-207">Безопасность</span><span class="sxs-lookup"><span data-stu-id="ff897-207">Security</span></span>  
 <span data-ttu-id="ff897-208">Библиотека DLL профилировщика — это неуправляемая библиотека DLL, которая выполняется в рамках подсистемы выполнения среды CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-208">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="ff897-209">В результате на код в библиотеке DLL профилировщика DLL не налагаются ограничения управления доступом для управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-209">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="ff897-210">Для библиотеки DLL профилировщика действуют только ограничения, накладываемые операционной системой на пользователя, запускающего профилируемое приложение.</span><span class="sxs-lookup"><span data-stu-id="ff897-210">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>  
  
 <span data-ttu-id="ff897-211">Разработчики профилировщика должны принять соответствующие меры предосторожности, чтобы избежать проблем, связанных с безопасностью.</span><span class="sxs-lookup"><span data-stu-id="ff897-211">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="ff897-212">Например, во время установки библиотека DLL профилировщика должна добавляться в список управления доступом (ACL), чтобы злоумышленник не мог изменить ее.</span><span class="sxs-lookup"><span data-stu-id="ff897-212">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>  
  
 [<span data-ttu-id="ff897-213">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-213">Back to top</span></span>](#top)  
  
<a name="combining_managed_unmanaged"></a>   
## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="ff897-214">Объединение управляемого и неуправляемого кода в коде профилировщика</span><span class="sxs-lookup"><span data-stu-id="ff897-214">Combining Managed and Unmanaged Code in a Code Profiler</span></span>  
 <span data-ttu-id="ff897-215">Неправильно написанный профилировщик может вызвать циклические ссылки на себя, что приводит к непредсказуемому поведению.</span><span class="sxs-lookup"><span data-stu-id="ff897-215">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>  
  
 <span data-ttu-id="ff897-216">Обзор API профилирования среды CLR может создать впечатление, что можно написать профилировщик, содержащий управляемые и неуправляемые компоненты, которые вызывают друг друга посредством COM-взаимодействия или непрямых вызовов.</span><span class="sxs-lookup"><span data-stu-id="ff897-216">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>  
  
 <span data-ttu-id="ff897-217">Хотя это возможно с точки зрения проектирования, API профилирования не поддерживает управляемые компоненты.</span><span class="sxs-lookup"><span data-stu-id="ff897-217">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="ff897-218">Профилировщик среды CLR должен быть полностью неуправляемым.</span><span class="sxs-lookup"><span data-stu-id="ff897-218">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="ff897-219">Попытки объединить управляемый и неуправляемый код в профилировщике среды CLR могут привести к нарушениям прав доступа, сбоям программы или взаимоблокировкам.</span><span class="sxs-lookup"><span data-stu-id="ff897-219">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="ff897-220">Управляемые компоненты профилировщика будут возвращать события обратно их неуправляемым компонентам, что будет затем вызывать управляемые компоненты снова, и таким образом будут создаваться циклические ссылки.</span><span class="sxs-lookup"><span data-stu-id="ff897-220">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>  
  
 <span data-ttu-id="ff897-221">Единственное место, где профилировщик CLR может безопасно вызывать управляемый код, это текст MSIL в теле метода.</span><span class="sxs-lookup"><span data-stu-id="ff897-221">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="ff897-222">Для изменения текста MSIL рекомендуется использовать методы JIT-перекомпиляции в [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) интерфейс.</span><span class="sxs-lookup"><span data-stu-id="ff897-222">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback4-interface.md) interface.</span></span>  
  
 <span data-ttu-id="ff897-223">Кроме того, для изменения MSIL можно использовать старые методы инструментирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-223">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="ff897-224">До завершения just-in-time (JIT) компиляции функции профилировщик может вставить управляемые вызовы в текст MSIL метода, а затем JIT-компиляцию его (см. в разделе [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) метод).</span><span class="sxs-lookup"><span data-stu-id="ff897-224">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="ff897-225">Этот способ можно успешно использовать для выборочного инструментирования управляемого кода или для сбора статистики и данных производительности касательно JIT.</span><span class="sxs-lookup"><span data-stu-id="ff897-225">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>  
  
 <span data-ttu-id="ff897-226">Кроме того, профилировщик кода может вставлять собственные обработчики в текст MSIL любой управляемой функции, которая вызывает неуправляемый код.</span><span class="sxs-lookup"><span data-stu-id="ff897-226">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="ff897-227">Этот способ можно использовать для инструментирования и покрытия.</span><span class="sxs-lookup"><span data-stu-id="ff897-227">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="ff897-228">Например, профилировщик кода может вставить обработчики инструментирования после каждого блока MSIL для обеспечения выполнения блока.</span><span class="sxs-lookup"><span data-stu-id="ff897-228">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="ff897-229">Изменение текста MSIL метода следует выполнять очень аккуратно и принимать во внимание множество факторов.</span><span class="sxs-lookup"><span data-stu-id="ff897-229">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>  
  
 [<span data-ttu-id="ff897-230">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-230">Back to top</span></span>](#top)  
  
<a name="unmanaged"></a>   
## <a name="profiling-unmanaged-code"></a><span data-ttu-id="ff897-231">Профилирование неуправляемого кода</span><span class="sxs-lookup"><span data-stu-id="ff897-231">Profiling Unmanaged Code</span></span>  
 <span data-ttu-id="ff897-232">API профилирования среды CLR предоставляет минимальную поддержку профилирования неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="ff897-232">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="ff897-233">Предоставляются следующие функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="ff897-233">The following functionality is provided:</span></span>  
  
-   <span data-ttu-id="ff897-234">Перечисление цепочек стека.</span><span class="sxs-lookup"><span data-stu-id="ff897-234">Enumeration of stack chains.</span></span> <span data-ttu-id="ff897-235">Эта функция позволяет профилировщику кода определить границу между управляемым и неуправляемым кодом.</span><span class="sxs-lookup"><span data-stu-id="ff897-235">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>  
  
-   <span data-ttu-id="ff897-236">Определение, соответствует ли цепочка стека управляемому коду или машинному коду.</span><span class="sxs-lookup"><span data-stu-id="ff897-236">Determination whether a stack chain corresponds to managed code or native code.</span></span>  
  
 <span data-ttu-id="ff897-237">В .NET Framework версий 1.0 и 1.1 эти методы доступны через внутрипроцессное подмножество API отладки среды CLR.</span><span class="sxs-lookup"><span data-stu-id="ff897-237">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="ff897-238">Они определяются в файле CorDebug.idl.</span><span class="sxs-lookup"><span data-stu-id="ff897-238">They are defined in the CorDebug.idl file.</span></span>  
  
 <span data-ttu-id="ff897-239">В .NET Framework 2.0 и более поздних версиях можно использовать [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) метод для использования этой функции.</span><span class="sxs-lookup"><span data-stu-id="ff897-239">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>  
  
 [<span data-ttu-id="ff897-240">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-240">Back to top</span></span>](#top)  
  
<a name="com"></a>   
## <a name="using-com"></a><span data-ttu-id="ff897-241">Использование модели COM</span><span class="sxs-lookup"><span data-stu-id="ff897-241">Using COM</span></span>  
 <span data-ttu-id="ff897-242">Хотя интерфейсы профилирования определяются как COM-интерфейсы, среда CLR в действительности не инициализирует модель COM для использования этих интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="ff897-242">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="ff897-243">Причина заключается в том, чтобы избежать необходимости установки потоковой модели с помощью [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) функционировать до того, как управляемое приложение возможность задать нужный такую модель.</span><span class="sxs-lookup"><span data-stu-id="ff897-243">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="ff897-244">Аналогично, сам профилировщик не должен вызывать `CoInitialize`, поскольку он может выбрать потоковую модель, несовместимую с профилируемым приложением, что может привести к сбою приложения.</span><span class="sxs-lookup"><span data-stu-id="ff897-244">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>  
  
 [<span data-ttu-id="ff897-245">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-245">Back to top</span></span>](#top)  
  
<a name="call_stacks"></a>   
## <a name="call-stacks"></a><span data-ttu-id="ff897-246">Стеки вызовов</span><span class="sxs-lookup"><span data-stu-id="ff897-246">Call Stacks</span></span>  
 <span data-ttu-id="ff897-247">API профилирования предоставляет два способа получения стеков вызова: метод моментальных снимков стека, который позволяет реже выполнять сбор стеков вызовов, и метод теневого стека, который отслеживает стек вызовов в каждый момент времени.</span><span class="sxs-lookup"><span data-stu-id="ff897-247">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>  
  
### <a name="stack-snapshot"></a><span data-ttu-id="ff897-248">Моментальный снимок стека</span><span class="sxs-lookup"><span data-stu-id="ff897-248">Stack Snapshot</span></span>  
 <span data-ttu-id="ff897-249">Моментальный снимок стека — это трассировка стека потока в момент времени.</span><span class="sxs-lookup"><span data-stu-id="ff897-249">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="ff897-250">API профилирования поддерживает трассировку управляемых функций в стеке, но оставляет трассировку неуправляемых функций собственному обходчику стека профилировщика.</span><span class="sxs-lookup"><span data-stu-id="ff897-250">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>  
  
 <span data-ttu-id="ff897-251">Дополнительные сведения о программировании профилировщика для обхода управляемых стеков см. в разделе [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) метод в этом комплекте документации и [Profiler, анализ стека в .NET Framework 2.0: Основы и за его пределами](https://go.microsoft.com/fwlink/?LinkId=73638).</span><span class="sxs-lookup"><span data-stu-id="ff897-251">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://go.microsoft.com/fwlink/?LinkId=73638).</span></span>
  
### <a name="shadow-stack"></a><span data-ttu-id="ff897-252">Теневой стек</span><span class="sxs-lookup"><span data-stu-id="ff897-252">Shadow Stack</span></span>  
 <span data-ttu-id="ff897-253">Слишком частое использование метода моментального снимка может быстро создавать проблемы производительности.</span><span class="sxs-lookup"><span data-stu-id="ff897-253">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="ff897-254">Если вы хотите часто получать трассировки стека, ваш профилировщик должен вместо этого построить теневой стек с помощью [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), и [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) обратных вызовов исключения.</span><span class="sxs-lookup"><span data-stu-id="ff897-254">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](../../../../docs/framework/unmanaged-api/profiling/functionenter2-function.md), [FunctionLeave2](../../../../docs/framework/unmanaged-api/profiling/functionleave2-function.md), [FunctionTailcall2](../../../../docs/framework/unmanaged-api/profiling/functiontailcall2-function.md), and [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="ff897-255">Теневой стек всегда является текущим, и его можно быстро скопировать в хранилище каждый раз, когда требуется моментальный снимок стека.</span><span class="sxs-lookup"><span data-stu-id="ff897-255">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>  
  
 <span data-ttu-id="ff897-256">Теневой стек может получать аргументы функций, возвращать значения и сведения об универсальных экземплярах.</span><span class="sxs-lookup"><span data-stu-id="ff897-256">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="ff897-257">Эти сведения доступны только посредством теневого стека и могут быть получены, когда управление передается в функцию.</span><span class="sxs-lookup"><span data-stu-id="ff897-257">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="ff897-258">Однако эти сведения могут оказаться недоступны позднее, во время выполнения функции.</span><span class="sxs-lookup"><span data-stu-id="ff897-258">However, this information may not be available later during the run of the function.</span></span>  
  
 [<span data-ttu-id="ff897-259">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-259">Back to top</span></span>](#top)  
  
<a name="callbacks"></a>   
## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="ff897-260">Обратные вызовы и глубина стека вызовов</span><span class="sxs-lookup"><span data-stu-id="ff897-260">Callbacks and Stack Depth</span></span>  
 <span data-ttu-id="ff897-261">Обратные вызовы профилировщика могут осуществляться в условиях очень ограниченного стека, и переполнение стека в обратном вызове профилировщика приведет к немедленному завершению выполнения процесса.</span><span class="sxs-lookup"><span data-stu-id="ff897-261">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="ff897-262">В ответ на обратные вызовы профилировщик должен гарантированно использовать минимально возможный стек.</span><span class="sxs-lookup"><span data-stu-id="ff897-262">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="ff897-263">Если профилировщик предназначен для использования в процессах, устойчивых к переполнению стека, сам профилировщик должен также избегать активации переполнения стека.</span><span class="sxs-lookup"><span data-stu-id="ff897-263">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>  
  
 [<span data-ttu-id="ff897-264">К началу</span><span class="sxs-lookup"><span data-stu-id="ff897-264">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="ff897-265">См. также</span><span class="sxs-lookup"><span data-stu-id="ff897-265">Related Topics</span></span>  
  
|<span data-ttu-id="ff897-266">Заголовок</span><span class="sxs-lookup"><span data-stu-id="ff897-266">Title</span></span>|<span data-ttu-id="ff897-267">Описание</span><span class="sxs-lookup"><span data-stu-id="ff897-267">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="ff897-268">Настройка среды профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-268">Setting Up a Profiling Environment</span></span>](../../../../docs/framework/unmanaged-api/profiling/setting-up-a-profiling-environment.md)|<span data-ttu-id="ff897-269">В этом разделе объясняется, как можно инициализировать профилировщик, установить уведомления о событиях и профилировать службу Windows.</span><span class="sxs-lookup"><span data-stu-id="ff897-269">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|  
|[<span data-ttu-id="ff897-270">Интерфейсы профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-270">Profiling Interfaces</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-interfaces.md)|<span data-ttu-id="ff897-271">В этом разделе описываются неуправляемые интерфейсы, которые использует API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-271">Describes the unmanaged interfaces that the profiling API uses.</span></span>|  
|[<span data-ttu-id="ff897-272">Глобальные статические функции профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-272">Profiling Global Static Functions</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-global-static-functions.md)|<span data-ttu-id="ff897-273">В этом разделе описываются неуправляемые глобальные статистические функции, которые использует API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-273">Describes the unmanaged global static functions that the profiling API uses.</span></span>|  
|[<span data-ttu-id="ff897-274">Перечисления профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-274">Profiling Enumerations</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-enumerations.md)|<span data-ttu-id="ff897-275">В этом разделе описываются неуправляемые перечисления, которые использует API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-275">Describes the unmanaged enumerations that the profiling API uses.</span></span>|  
|[<span data-ttu-id="ff897-276">Структуры профилирования</span><span class="sxs-lookup"><span data-stu-id="ff897-276">Profiling Structures</span></span>](../../../../docs/framework/unmanaged-api/profiling/profiling-structures.md)|<span data-ttu-id="ff897-277">В этом разделе описываются неуправляемые структуры, которые использует API профилирования.</span><span class="sxs-lookup"><span data-stu-id="ff897-277">Describes the unmanaged structures that the profiling API uses.</span></span>|
