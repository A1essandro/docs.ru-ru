---
title: "Деревья в WPF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "дерево элементов"
  - "логическое дерево"
  - "визуальное дерево"
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
caps.latest.revision: 20
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 19
---
# Деревья в WPF
Во многих технологиях элементы и компоненты организованы в форме древовидной структуры, и разработчики могут напрямую управлять узлами объекта в дереве, чтобы повлиять на отрисовку или поведение приложения.  В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] часто используется несколько метафор древовидных структур, чтобы определить отношения между программными элементами.  Для большей части WPF разработчики могут создать приложение в коде или определить части приложения в XAML и при этом концептуально думать о метафоре дерева объектов, но для этого им потребуется вызвать определенный интерфейс API или использовать конкретную разметку, а не интерфейс API управления деревом некоторых общих объектов, какой можно использовать в XML DOM.  WPF предоставляет два вспомогательных класса, обеспечивающих представление метафоры дерева: <xref:System.Windows.LogicalTreeHelper> и <xref:System.Windows.Media.VisualTreeHelper>.  Термины "логическое дерево" и "визуальное дерево" также используются в документации WPF, поскольку эти же деревья помогают понять поведение определенных ключевых функций WPF.  В этом разделе описано, что представляют визуальное дерево и логическое дерево, обсуждается, как эти деревья связаны с понятием общего дерева объектов, и вводятся классы <xref:System.Windows.LogicalTreeHelper> <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
<a name="element_tree"></a>   
## Деревья в WPF  
 Самой полной древовидной структурой в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является дерево объектов.  При определении страницы приложения в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и последующей загрузке [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] древовидная структура создается на основе отношений вложенности элементов в разметке.  При определении приложения или части приложения в коде древовидная структура создается в зависимости от того, как присваиваются значения свойствам, которые реализуют модель содержимого для данного объекта.  В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] существует два способа концептуализации и передачи в открытый интерфейс API полного дерева объектов: в виде логического дерева и в виде визуального дерева.  Различия между логическими деревьями и визуальными деревьями не всегда важны, но иногда они могут вызвать проблемы с некоторыми подсистемами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и повлиять на изменения, внесенные в разметку или код.  
  
 Несмотря на то, что управление логическим деревом или визуальным деревом не всегда происходит напрямую, понимание концепций взаимодействия деревьев позволяет понять WPF как технологию.  Рассмотрение WPF как некоторой метафоры дерева также важно для понимания того, как в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] осуществляется наследование свойств и маршрутизация событий.  
  
> [!NOTE]
>  Поскольку дерево объектов — это более широкое понятие, чем фактический интерфейс API, еще одним способом представить себе концепцию является граф объекта.  На практике отношения между объектами можно наблюдать во время выполнения, когда метафора дерева разделяется.  Тем не менее, особенно в пользовательском интерфейсе, определенном XAML, метафора дерева достаточно релевантна, и в большей части документации WPF используется термин "дерево объекта" при ссылке на это общее понятие.  
  
<a name="logical_tree"></a>   
## Логическое дерево  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержимое добавляется в элементы пользовательского интерфейса путем задания свойств объектов, которые поддерживают эти элементы.  Например, можно добавить элементы в элемент управления <xref:System.Windows.Controls.ListBox> с помощью его свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>.  При этом элементы помещаются в <xref:System.Windows.Controls.ItemCollection>, который является значением свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>.  Аналогично, для добавления объектов в <xref:System.Windows.Controls.DockPanel> используется значение свойства <xref:System.Windows.Controls.Panel.Children%2A>.  В этом случае происходит добавление объектов в <xref:System.Windows.Controls.UIElementCollection>.  Пример кода см. в разделе [Add an Element Dynamically](http://msdn.microsoft.com/ru-ru/d00f258a-7973-4de7-bc54-a3fc1f638419).  
  
 В [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] при помещении элементов списка в <xref:System.Windows.Controls.ListBox> или элементов управления либо других элементов пользовательского интерфейса в <xref:System.Windows.Controls.DockPanel> можно также использовать свойства <xref:System.Windows.Controls.ItemsControl.Items%2A> и <xref:System.Windows.Controls.Panel.Children%2A>, явным или неявным образом, как показано в следующем примере.  
  
 [!code-xml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Если бы этот XAML обрабатывался как XML в объектной модели документов, и если бы были включены теги, закомментированные как неявные \(были бы допустимы\), полученное дерево XML DOM включало бы элементы для `<ListBox.Items>` и другие неявные элементы.  Но XAML не выполняет такую обработку при чтении разметки и записи в объекты, полученный граф объекта не включает `ListBox.Items` в буквальном смысле.  Однако он имеет свойство <xref:System.Windows.Controls.ListBox> с именем `Items`, содержащее <xref:System.Windows.Controls.ItemCollection>, и этот <xref:System.Windows.Controls.ItemCollection> инициализируется, но является пустым при обработке XAML <xref:System.Windows.Controls.ListBox>.  Затем каждый дочерний элемент объекта, существующий как содержимое для <xref:System.Windows.Controls.ListBox>, добавляется в <xref:System.Windows.Controls.ItemCollection> путем вызова `ItemCollection.Add` анализатором.  Этот пример обработки XAML в дереве объектов на первый взгляд похож на пример, в котором созданное дерево объектов по сути является логическим деревом.  
  
 Однако логическое дерево не является полным графом объекта, существующим в пользовательском интерфейсе приложения во время выполнения, даже когда неявные элементы синтаксиса XAML факторизованы.  Основная причина этого — визуальные элементы и шаблоны.  Например, рассмотрим <xref:System.Windows.Controls.Button>.  Логическое дерево сообщает об объекте <xref:System.Windows.Controls.Button> и его строке `Content`.  Но в дереве объектов времени выполнения имеется больше сведений об этой кнопке.  В частности, кнопка отображается на экране только в данном виде, поскольку был применен определенный шаблон элемента управления <xref:System.Windows.Controls.Button>.  Сведения о визуальных элементах, полученных из примененного шаблона \(таких как определенный шаблоном объект <xref:System.Windows.Controls.Border> темно\-серого участка вокруг визуальной кнопки\), не указываются в логическом дереве даже при просмотре логического дерева во время выполнения \(например, обработки события ввода из видимого пользовательского интерфейса и последующего чтения логического дерева\).  Чтобы найти визуальные элементы шаблона, необходимо проверить визуальное дерево.  
  
 Дополнительные сведения о сопоставлении синтаксиса [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] с созданным графом объекта и неявным синтаксисом в XAML см. в разделе [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) или [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>   
### Назначение логического дерева  
 Логическое дерево существует для того, чтобы модели содержимого имели возможность пройти по своим доступным дочерним объектам, а также для их расширяемости.  Кроме того, логическое дерево предоставляет оболочку для некоторых уведомлений, например, при загрузке всех объектов логического дерева.  По существу, логическое дерево является подобием графа объекта времени выполнения на уровне оболочки, исключающем визуальные элементы, но подходит для большинства операций запросов для собственной композиции приложения времени выполнения.  
  
 Кроме того, ссылки как статического, так и динамического ресурса определяются путем перехода по логическому дереву по восходящей для коллекций <xref:System.Windows.FrameworkElement.Resources%2A> в исходном запрашивающем объекте, а также дальнейшего перехода по логическому дереву по восходящей и проверки каждого объекта <xref:System.Windows.FrameworkElement> \(или <xref:System.Windows.FrameworkContentElement>\) на наличие еще одного значения `Resources`, содержащего <xref:System.Windows.ResourceDictionary>, который возможно содержит такой ключ.  Логическое дерево используется для просмотра ресурсов при наличии логического дерева и визуального дерева.  Дополнительные сведения о словарях ресурсов и поиске см. в разделе [Ресурсы XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
<a name="composition"></a>   
### Композиция логического дерева  
 Логическое дерево определено на [уровне среды WPF](GTMT). Это значит, что базовый элемент WPF, который наиболее подходит для операций логического дерева, является либо <xref:System.Windows.FrameworkElement>, либо <xref:System.Windows.FrameworkContentElement>.  Однако, как можно видеть, если фактически используется интерфейс API <xref:System.Windows.LogicalTreeHelper>, логическое дерево иногда содержит узлы, которые не являются ни <xref:System.Windows.FrameworkElement>, ни <xref:System.Windows.FrameworkContentElement>.  Например, логическое дерево сообщает о значении <xref:System.Windows.Controls.TextBlock.Text%2A> объекта <xref:System.Windows.Controls.TextBlock>, которое представляет собой строку.  
  
<a name="override_logical_tree"></a>   
### Переопределение логического дерева  
 Авторы дополнительных элементов управления могут переопределить логическое дерево, переопределив несколько [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], которые определяют то, как основная модель объекта или содержимого добавляет или удаляет объекты логического дерева.  Пример переопределения логического дерева содержится в разделе [Переопределение логического дерева](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>   
### Наследование значения свойства  
 Наследование значения свойств действует через гибридное дерево.  Фактические метаданные, содержащие свойство<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>, позволяющее наследование свойств, является классом <xref:System.Windows.FrameworkPropertyMetadata>[уровня платформы WPF](GTMT).  Таким образом, и родительский объект, содержащий исходное значение, и дочерний объект, наследующий это значение, должны быть <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, и оба должны быть частью некоторого логического дерева.  Однако для существующих свойств WPF, поддерживающих наследование свойств, наследование значений свойств способно принять промежуточный объект, которого нет в логическом дереве.  Как правило, это распространяется на элементы шаблона, использующие все унаследованные значения свойств, заданные как в экземпляре, который является шаблоном, так и на более высоких уровнях композиции уровня страницы и, следовательно, выше в логическом дереве.  Чтобы наследование значений свойств осуществлялось согласованно в таких пределах, наследуемое свойство должно быть зарегистрировано как вложенное свойство, кроме того, необходимо следовать этому шаблону, если требуется определить пользовательское свойство зависимостей с поведением наследования свойств.  Точное дерево, используемое для наследования свойств, не может быть полностью предсказано вспомогательным служебным методом класса даже во время выполнения.  Дополнительные сведения см. в разделе [Наследование значения свойства](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="two_trees"></a>   
## Визуальное дерево  
 В дополнение к концепции логического дерева в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] также существует концепция [визуального дерева](GTMT).  Визуальное дерево описывает структуру визуальных объектов, предоставленных базовым классом <xref:System.Windows.Media.Visual>.  При написании шаблона для элемента управления следует определить или переопределить визуальное дерево, применяемое для данного элемента управления.  Визуальное дерево также представляет интерес для разработчиков, заинтересованных в контроле рисования на нижнем уровне по соображениям производительности и оптимизации.  Слабым местом визуального дерева как части программирования стандартных приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является то, что маршруты событий для [перенаправленного события](GTMT) в большинстве случаев проходят по визуальному дереву, а не по логическому.  Эта тонкость поведения маршрутизируемого события может быть неочевидна, если вы не являетесь автором элемента управления.  Маршрутизация событий по визуальному дереву позволяет элементам управления, которые реализуют композицию на визуальном уровне, обрабатывать события или создавать установщики событий.  
  
<a name="trees_content"></a>   
## Деревья, элементы содержимого и узлы содержимого  
 Элементы содержимого \(классы, производные от <xref:System.Windows.ContentElement>\) не являются частью визуального дерева; они не наследуют от <xref:System.Windows.Media.Visual> и не имеют визуального представления.  Чтобы полностью отобразиться в пользовательском интерфейсе, <xref:System.Windows.ContentElement> должен быть размещен в хранилище содержимого, которое одновременно является и <xref:System.Windows.Media.Visual>, и участником логического дерева.  Обычно таким объектом является <xref:System.Windows.FrameworkElement>.  Можно представить сайт содержимого в качестве «браузера» содержимого, который выбирает способ отображения содержимого в пределах области экрана, управляемой сайтом.  При размещении содержимого оно может стать участником некоторых процессов дерева, которые обычно связаны с визуальным деревом.  Как правило, узловой класс <xref:System.Windows.FrameworkElement> содержит код реализации, в котором любой размещенный <xref:System.Windows.ContentElement> добавляется к маршруту события через подузлы логического дерева содержимого, даже если размещенное содержимое не является частью действительного визуального дерева.  Это необходимо для того, чтобы <xref:System.Windows.ContentElement> мог получить маршрутизируемое событие, которое маршрутизирует к любому элементу, кроме самого себя.  
  
<a name="tree_traversal"></a>   
## Прохождение по дереву  
 Класс <xref:System.Windows.LogicalTreeHelper> предоставляет методы <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A> и <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> для прохождения по логическому дереву.  В большинстве случаев не следует проходить по логическому дереву существующих элементов управления, так как эти элементы управления почти всегда предоставляют свои логические дочерние элементы в качестве выделенного свойства коллекции, которое поддерживает доступ к коллекции, например `Add`, индексатор и т. д.  Обход дерева обычно используется авторами элемента управления, которые отказались от создания элементов управления, производных от предполагаемых шаблонов элемента управления, например, <xref:System.Windows.Controls.ItemsControl> или <xref:System.Windows.Controls.Panel>, где свойства коллекции уже определены, и которые планируют поддержку собственных свойств коллекции.  
  
 Визуальное дерево также поддерживает вспомогательный класс для прохождения визуального дерева — <xref:System.Windows.Media.VisualTreeHelper>.  Визуальное дерево не так удобно предоставляется из свойств определенного элемента управления. Таким образом, класс <xref:System.Windows.Media.VisualTreeHelper> является рекомендуемым способом прохода визуального дерева, если это необходимо для программного скрипта.  Дополнительные сведения см. в разделе [Общие сведения об отрисовке графики в WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
>  Иногда необходимо проверять визуальное дерево применяемого шаблона.  Необходимо соблюдать осторожность при использовании этого метода.  Даже при проходе по визуальному дереву в поиске элемента управления, в котором определен шаблон, потребитель элемента управления всегда может изменить шаблон, задав свойство <xref:System.Windows.Controls.Control.Template%2A> в экземплярах, и даже конечный пользователь может повлиять на применяемый шаблон, изменив тему системы.  
  
<a name="routes"></a>   
## Маршруты для маршрутизируемых событий как «дерево»  
 Как уже отмечалось ранее, маршрут любого заданного перенаправленного события проходит по одному предопределенному пути дерева, представляющего собой гибрид представлений визуального и логического деревьев.  Маршрут события может проходить как по восходящей, так и по нисходящий в пределах дерева в зависимости от того, имеет ли перенаправленное событие нисходящую или восходящую маршрутизацию.  Концепция маршрута события не имеет непосредственного вспомогательного класса, который может быть использован для «прохода» маршрута события независимо от вызова фактически маршрутизируемого события.  Класс, представляющий маршрут, существует \(<xref:System.Windows.EventRoute>\), но методы этого класса, как правило, предназначены только для внутреннего использования.  
  
<a name="resourcesandtrees"></a>   
## Словари и деревья ресурсов  
 Поиск по словарю ресурсов для всех `Resources`, определенных на странице, обычно проходит по логическому дереву.  Объекты, которые не входят в логическое дерево, могут ссылаться на ресурсы с ключом, но последовательность поиска ресурса начинается с той точки, где объект подключен к логическому дереву.  В WPF только узлы логического дерева могут иметь свойство `Resources`, содержащее <xref:System.Windows.ResourceDictionary>. Таким образом, это означает отсутствие преимущества при обходе визуального дерева для поиска ресурсов с ключом из <xref:System.Windows.ResourceDictionary>.  
  
 В то же время поиск ресурсов также можно расширить за пределы логического дерева.  Для разметки приложения поиск ресурсов можно затем продолжить в словарях ресурсов на уровне приложений, поддержке тем и значениях системы, на которые ссылаются как на статические свойства или ключи.  Сами темы также могут ссылаться на системные значения вне логического дерева тем, если ссылки на ресурсы являются динамическими.  Дополнительные сведения о словарях ресурсов и логике поиска см. в разделе [Ресурсы XAML](../../../../docs/framework/wpf/advanced/xaml-resources.md).  
  
## См. также  
 [Общие сведения о входных данных](../../../../docs/framework/wpf/advanced/input-overview.md)   
 [Общие сведения об отрисовке графики в WPF](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)   
 [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md)   
 [Инициализация для элементов типа Object вне дерева объектов](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)   
 [Архитектура WPF](../../../../docs/framework/wpf/advanced/wpf-architecture.md)