---
title: "Общие сведения о вложенных событиях | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "вложенные события [WPF], определение"
  - "вложенные события [WPF], сценарии для"
  - "вложенные события и перенаправленные события [WPF]"
  - "резервирование вложенных событий с помощью перенаправленных событий [WPF]"
  - "определение вложенных событий как перенаправленные события [WPF]"
  - "обработка вложенных событий [WPF]"
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
caps.latest.revision: 11
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 10
---
# Общие сведения о вложенных событиях
[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] определяет компонент языка и тип события, называемый *вложенным событием*.  Концепция вложенных событий позволяет вам добавить обработчик для конкретного события к произвольному элементу, а не к элементу, который в настоящее время определяет или наследует событие.  В этом случае ни объект, потенциально вызывающий событие, ни экземпляр класса, обрабатывающий назначение, не определяет или как\-нибудь иначе не "владеет" событием.  
  
   
  
<a name="prerequisites"></a>   
## Предварительные требования  
 В этом разделе предполагается, что вы прочитали [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md) и [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="Syntax"></a>   
## Синтаксис вложенного события  
 Вложенные события имеют синтаксис [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и шаблон кодирования, который должен использоваться фоновым кодом, чтобы поддерживать использование вложенных событий.  
  
 В синтаксисе [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] вложенное событие определяется не только своим именем события, но и своим собственным типом и именем события, разделенными символом точки \(.\).  Так как имя события квалифицируется с именем его собственного типа, синтаксис вложенных событий позволяет любому присоединенному событию присоединиться к любому элементу, у которого может быть создан экземпляр.  
  
 Например, ниже приведен синтаксис [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] для присоединения обработчика для пользовательского вложенного события `NeedsCleaning`.  
  
 [!code-xml[WPFAquariumSln#AE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 Обратите внимание на префикс `aqua:`; префикс в этом случае необходим, поскольку вложенное событие является пользовательским событием, которое поступает из пользовательских сопоставленных xmlns.  
  
<a name="WPFImplements"></a>   
## Как WPF реализовывает вложенные события  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вложенные события содержатся в поле <xref:System.Windows.RoutedEvent> и направляются через дерево, после чего они вызываются.  Обычно источник вложенного события \(объект, который вызывает событие\) является системным или служебным источником, а объект, который запускает код, вызывающий событие, напрямую не является частью дерева элементов.  
  
<a name="Scenarios"></a>   
## Сценарии для вложенных событий  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вложенные события присутствуют в определенных функциональных областях, где присутствует уровневая абстракция служб, такая как для событий, включенных статическим классом <xref:System.Windows.Input.Mouse> или классом <xref:System.Windows.Controls.Validation>.  Классы, которые используют или взаимодействуют со службой, могут или использовать событие в синтаксисе вложенных событий, или они могут выбрать присоединение к событию в качестве события маршрутизации, которое является частью того, как класс объединяет возможности службы.  
  
 Хотя [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] определяет количество вложенных событий, скриптов, в которых вы будете либо использовать, либо непосредственно обрабатывать присоединенное событие, очень мало.  Как правило, вложенное событие служит архитектурной цели, но затем передается неприсоединенному \(прикреплен с "оболочкой" события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]\) событию маршрутизации.  
  
 Например, основное вложенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> может намного легче обрабатываться с заданным <xref:System.Windows.UIElement> с помощью <xref:System.Windows.UIElement.MouseDown> на <xref:System.Windows.UIElement> вместо работы с синтаксисом вложенных событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] или коде.  Вложенное событие выполняет свою цель в архитектуре, поскольку оно допускает будущее расширение устройств ввода.  Гипотетическим устройствам потребуется только вызвать <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName>, чтобы имитировать ввод данных с помощью мыши, и для этого не нужно будет получать данные из <xref:System.Windows.Input.Mouse>.  Однако этот скрипт включает код обработки событий и обработку [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] вложенного события, не относящегося к этому скрипту.  
  
<a name="Handling"></a>   
## Обработка вложенного события в WPF  
 Процесс для обработки вложенных событий и код обработчика, который вы будете писать, по существу такой же, как и для события маршрутизации.  
  
 В общем случае вложенное событие [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] не очень сильно отличается от события маршрутизации [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Различия в том, как событие привязывается и как оно представляется классом в качестве члена \(что также влияет на синтаксис обработчика [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]\).  
  
 Тем не менее, как было отмечено ранее, существующие вложенные события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] не предназначены непосредственно для обработки в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Более частой целью события является включение составного элемента, чтобы доложить о состоянии родительскому элементу в композиции, в случае которой событие обычно вызывается в коде и также основывается на обработке класса в соответствующем родительском классе.  Например, элементы в <xref:System.Windows.Controls.Primitives.Selector> ожидают вызов вложенного события <xref:System.Windows.Controls.Primitives.Selector.Selected>, которое затем обрабатывается классом с помощью класса <xref:System.Windows.Controls.Primitives.Selector> и затем, возможно, преобразовывается классом <xref:System.Windows.Controls.Primitives.Selector> в другое событие маршрутизации, <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>.  Дополнительные сведения о событиях маршрутизации и обработке классов содержатся в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
<a name="Custom"></a>   
## Определение собственных вложенных событий в качестве событий маршрутизации  
 Если вы сделаете производный от общих базовых классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], вы сможете реализовать собственные вложенные события, включив определенные методы шаблона в ваш класс и при помощи служебных методов, которые уже присутствуют в базовых классах.  
  
 Шаблон выглядит следующим образом.  
  
-   Метод `Add*Handler` с двумя параметрами.  Первый параметр должен определять событие, и у идентифицированного события должны совпадать имена со \* в имени метода.  Вторым параметром является обработчик для добавления.  Метод должен быть открытым и статическим, без возвращаемого значения.  
  
-   Метод `Remove*Handler` с двумя параметрами.  Первый параметр должен определять событие, и у идентифицированного события должны совпадать имена со \* в имени метода.  Вторым параметром является обработчик для удаления.  Метод должен быть открытым и статическим, без возвращаемого значения.  
  
 Метод доступа `Add*Handler` упрощает обработку [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], когда атрибуты вложенного обработчика событий объявлены в элементе.  Методы `Add*Handler` и `Remove*Handler` также разрешают доступ кода к хранилищу обработчика событий для вложенного события.  
  
 Этого общего шаблона еще не достаточно для практической реализации на платформе .NET Framework, так как любая данная реализация чтения [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] может иметь различные схемы для идентификации основных событий в поддерживаемом языке и архитектуре.  Это является одной из причин, по которой [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] реализует вложенные события в качестве перенаправленных событий; идентификатор, используемый для события \(<xref:System.Windows.RoutedEvent>\), уже определен системой событий [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  К тому же маршрутизация события является расширением естественной реализации в понятиях на уровне языка [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] вложенного события.  
  
 Реализация `Add*Handler` для вложенного события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] состоит из вызова <xref:System.Windows.UIElement.AddHandler%2A> с перенаправленным событием и обработчиком в качестве аргументов.  
  
 Эта стратегия реализации и системы событий маршрутизации в целом ограничивает обработку для вложенных событий либо производных классов <xref:System.Windows.UIElement>, либо производных классов <xref:System.Windows.ContentElement>, поскольку только эти классы имеют реализации <xref:System.Windows.UIElement.AddHandler%2A>.  
  
 Например, следующий код определяет вложенное событие `NeedsCleaning` в собственном классе `Aquarium`, используя стратегию присоединенных событий [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] объявления присоединенного события в качестве события с маршрутизацией.  
  
 [!code-csharp[WPFAquariumSln#AECode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 Обратите внимание, что метод, используемый для установления поля идентификатора вложенного события, <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>, является фактически тем же методом, используемым для регистрации неприсоединенного события маршрутизации.  Вложенные события и события маршрутизации регистрируются в централизованном внутреннем хранилище.  Эта реализация хранилища событий позволяет концептуальное рассмотрение "событий в качестве интерфейса", которое описывается в [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="Raising"></a>   
## Создание вложенного события WPF  
 Обычно вам необязательно вызывать существующие вложенные события, определенные [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], из своего кода.  Эти события следуют общей концептуальной модели "службы", и классы служб, такие как <xref:System.Windows.Input.InputManager>, ответственны за вызов событий.  
  
 Однако при определении пользовательского вложенного события на основе модели [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], основанной на вложенных событиях в <xref:System.Windows.RoutedEvent>, вы можете использовать <xref:System.Windows.UIElement.RaiseEvent%2A> для вызова присоединенного события из любого<xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.  Вызов перенаправленного события \(вложенного или нет\) требует объявления конкретного элемента в дереве элементов в качестве источника события; этот источник указывается в качестве вызывающего <xref:System.Windows.UIElement.RaiseEvent%2A>.  Определение, какой элемент описывается как источник в дереве, является обязанностью вашей службы  
  
## См. также  
 [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md)   
 [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)   
 [Код XAML и пользовательские классы для WPF](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)