---
title: "Общие сведения о языке XAML (WPF) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "синтаксис атрибутов [XAML]"
  - "базовые классы [XAML]"
  - "классы [XAML]"
  - "файлы с выделенным кодом [WPF], XAML"
  - "свойства коллекций [XAML]"
  - "модели содержимого [XAML]"
  - "события [XAML]"
  - "XAML - язык"
  - "property - элемент [XAML]"
  - "root - элемент [XAML]"
  - "перенаправляемые события"
  - "пользовательские интерфейсы [XAML]"
  - "XAML [WPF], сведения о XAML"
ms.assetid: a80db4cd-dd0f-479f-a45f-3740017c22e4
caps.latest.revision: 57
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 50
---
# Общие сведения о языке XAML (WPF)
В этом разделе описаны возможности языка XAML и показано, как можно использовать язык XAML для написания приложений [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].  В частности, в этом разделе описывается реализация XAML в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Сам язык XAML — это более широкое понятие языка, чем [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
   
  
<a name="what_is_xaml"></a>   
## Общие сведения о XAML  
 XAML — это декларативный язык разметки.  С точки зрения модели программирования [!INCLUDE[TLA2#tla_winfx](../../../../includes/tla2sharptla-winfx-md.md)] язык XAML упрощает создание [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] для приложения [!INCLUDE[TLA2#tla_winfx](../../../../includes/tla2sharptla-winfx-md.md)].  Можно создать видимые элементы [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] в декларативной разметке XAML, а затем отделить определение [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] от логики времени выполнения, используя файлы кода программной части, присоединенные к разметке с помощью определений разделяемых классов.  Язык XAML напрямую представляет создание экземпляров объектов в конкретном наборе резервных типов, определенных в сборках. В этом заключается его отличие от большинства других языков разметки, которые, как правило, представляют собой интерпретируемые языки без прямой связи с системой резервных типов.  Язык XAML обеспечивает рабочий процесс, позволяющий нескольким участникам разрабатывать [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] и логику приложения, используя потенциально различные средства.  
  
 При представлении в виде текста файлы XAML являются XML\-файлами, которые обычно имеют расширение `.xaml`.  Файлы можно сохранять в любой кодировке, поддерживаемой для XML, но обычно используется кодировка UTF\-8.  
  
 В следующем примере показано, как можно создать кнопку как часть [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].  Этот пример дает лишь общее представление о том, как в языке XAML представлены распространенные метафоры программирования для такого объекта как [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] \(это не полный пример\).  
  
 [!code-xml[XAMLOvwSupport#DirtSimple](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]  
  
<a name="xaml_syntax_in_brief"></a>   
## Краткое описание синтаксиса языка XAML  
 В следующих разделах приводится описание основных форм синтаксиса XAML и короткий пример разметки.  В этих разделах не приводится полная информация о каждой форме синтаксиса \(например, представление в системе резервных типов\).  Дополнительные сведения об особенностях синтаксиса XAML для каждой формы синтаксиса, представленной в этом разделе, см. в разделе [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
 Значительная часть материалов в следующих нескольких разделах будет уже знакома тем, кто имеет опыт работы с языком XML.  Это обусловлено базовыми принципами разработки языка XAML.  В языке XAML определяются собственные структуры, однако в них используются язык и форма разметки XML.  
  
### Объектные элементы XAML  
 Объектный элемент обычно объявляет экземпляр типа.  Этот тип определен в сборках, предоставляющих резервные типы для технологии, в которой XAML используется как язык.  
  
 Синтаксис объектного элемента всегда начинается с открывающейся угловой скобки \(\<\).  За ней следует имя типа, для которого требуется создать экземпляр.  \(Имя может содержать префикс. Описание этого понятия будет приведено далее.\) После этого при необходимости можно объявить атрибуты объектного элемента.  Для завершения тега объектного элемента введите закрывающую угловую скобку \(\>\).  Вместо этого можно использовать самозакрывающуюся форму, в которой отсутствует содержимое, установив в конце тега косую черту и закрывающую угловую скобку \(\/\>\).  Например, снова рассмотрим предыдущий фрагмент разметки.  
  
 [!code-xml[XAMLOvwSupport#DirtSimple](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#dirtsimple)]  
  
 В нем указано два объектных элемента: `<StackPanel>` \(с содержимым и последующим закрывающим тегом\) и `<Button .../>` \(самозакрывающаяся форма с несколькими атрибутами\).  Объектные элементы `StackPanel` и `Button` сопоставлены с именем класса, определенным [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и являющимся частью сборок [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  При задании тега объектного элемента создается инструкция обработки XAML для создания нового экземпляра.  Каждый экземпляр создается путем вызова конструктора базового типа или структуры по умолчанию при синтаксическом анализе и загрузке XAML\-кода.  
  
### Синтаксис атрибутов \(свойства\)  
 Свойства объекта часто можно выразить в виде атрибутов объектного элемента.  Синтаксис атрибутов называет свойство, задаваемое в синтаксисе атрибутов, после чего следует оператор назначения \(\=\).  Значение атрибута всегда задается как строка, заключенная в кавычки.  
  
 Синтаксис атрибутов — это наиболее простой синтаксис задания свойств, интуитивно понятный разработчикам, которые раньше использовали языки разметки.  Например, следующая разметка создает кнопку с красным текстом и синим фоном и отображает текст, заданный как `Content`.  
  
 [!code-xml[XAMLOvwSupport#BlueRedButton](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbutton)]  
  
### Синтаксис элемента свойства  
 Для некоторых свойств объектного элемента невозможен синтаксис атрибутов, так как объект или сведения, необходимые для задания значения свойства, не могут быть адекватно представлены в строке, указываемой в кавычках, с соблюдением ограничений синтаксиса атрибутов.  В этих случаях может использоваться другой синтаксис — синтаксис элементов свойств.  
  
 Для открывающего тега элемента свойства используется следующий синтаксис: `<`*имя\_типа*`.`*имя\_свойства*`>`.  В большинстве случаев содержимое тега является объектным элементом типа, к которому может принадлежать значение этого свойства.  Указав содержимое, необходимо завершить элемент свойства закрывающим тегом.  Для закрывающего тега используется синтаксис `</`*имя\_типа*`.`*имя\_свойства*`>`.  
  
 Если допустим синтаксис атрибутов, его использование, как правило, более удобно и приводит к созданию более компактной разметки, но часто выбор связан только со стилем, а не с техническими ограничениями.  В следующем примере те же свойства задаются так же, как в предыдущем примере синтаксиса атрибутов, но на этот раз с помощью синтаксиса элементов свойств для всех свойств `Button`.  
  
 [!code-xml[XAMLOvwSupport#BlueRedButtonPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#blueredbuttonpe)]  
  
### Синтаксис коллекции  
 Язык XAML включает некоторые оптимизации, делающие разметку удобнее для человеческого восприятия.  Одна из оптимизаций заключается в том, что если определенное свойство принимает тип коллекции, элементы, объявленные в разметке как дочерние в пределах значения этого свойства, становятся частью коллекции.  В этом случае коллекция дочерних объектных элементов является значением, которое задается для свойства коллекции.  
  
 В следующем примере показан синтаксис коллекции для задания значений свойства <xref:System.Windows.Media.GradientBrush.GradientStops%2A>.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <!-- no explicit new GradientStopCollection, parser knows how to find or create -->  
    <GradientStop Offset="0.0" Color="Red" />  
    <GradientStop Offset="1.0" Color="Blue" />  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
### Свойства содержимого XAML  
 XAML указывает функцию языка, за счет чего класс может назначить только одно из своих свойств как свойство содержимого XAML.  Дочерние элементы данного объектного элемента используются для задания значения этого свойства содержимого.  Другими словами, для свойства содержимого \(и только для него\) можно опустить элемент свойства, указав это свойство в XAML\-разметке, и тем самым создать более наглядную метафору родительского\/дочернего элементов в разметке.  
  
 Например, <xref:System.Windows.Controls.Border> указывает свойство содержимого <xref:System.Windows.Controls.Decorator.Child%2A>.  Следующие два элемента <xref:System.Windows.Controls.Border> обрабатываются одинаковым образом.  Первый элемент использует преимущества синтаксиса свойства содержимого и опускает элемент свойства `Border.Child`.  Второй элемент явно показывает `Border.Child`.  
  
```xaml  
<Border>  
  <TextBox Width="300"/>  
</Border>  
<!--explicit equivalent-->  
<Border>  
  <Border.Child>  
    <TextBox Width="300"/>  
  </Border.Child>  
</Border>  
```  
  
 Для языка XAML действует следующее правило: значение свойства содержимого XAML должно быть задано полностью либо до, либо после любых других элементов свойств данного объектного элемента.  Например, следующая разметка не компилируется:  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Дополнительные сведения об этом ограничении свойств содержимого XAML см. в подразделе "Свойства содержимого XAML" раздела [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
### Текстовое содержимое  
 Небольшое количество элементов XAML могут непосредственно обрабатывать текст как содержимое.  Это происходит в одной из следующих ситуаций.  
  
-   Класс должен объявить свойство содержимого, а это свойство содержимого должно принадлежать к типу, присваиваемому строке \(тип может быть <xref:System.Object>\).  Например, любой класс <xref:System.Windows.Controls.ContentControl> использует свойство <xref:System.Windows.Controls.ContentControl.Content%2A> как свойство содержимого, принадлежащее к типу <xref:System.Object>, и поддерживает следующее использование в практическом классе <xref:System.Windows.Controls.ContentControl>, например <xref:System.Windows.Controls.Button>: `<Button>Hello</Button>`.  
  
-   Тип должен объявлять преобразователь типов, при этом текстовое содержимое используется как текст инициализации для данного преобразователя типов.  Например, `<Brush>Blue</Brush>`.  Этот случай на практике встречается реже.  
  
-   Тип должен быть известным типом\-примитивом языка XAML.  
  
### Объединение свойств содержимого и синтаксиса коллекции  
 Рассмотрим следующий пример.  
  
```xaml  
<StackPanel>  
  <Button>First Button</Button>  
  <Button>Second Button</Button>  
</StackPanel>  
```  
  
 Здесь каждый <xref:System.Windows.Controls.Button> является дочерним элементом <xref:System.Windows.Controls.StackPanel>.  Это рациональная и интуитивно понятная разметка, в которой опущены два тега по двум разным причинам.  
  
-   **Опущен элемент свойства StackPanel.Children:** <xref:System.Windows.Controls.StackPanel> наследуется от <xref:System.Windows.Controls.Panel>.  <xref:System.Windows.Controls.Panel> определяет <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=fullName> как свойство содержимого XAML.  
  
-   **Опущен объектный элемент UIElementCollection:** свойство <xref:System.Windows.Controls.Panel.Children%2A?displayProperty=fullName> принимает тип <xref:System.Windows.Controls.UIElementCollection>, реализующий <xref:System.Collections.IList>.  Тег элемента коллекции можно опустить на основании правил XAML, касающихся обработки коллекций, например <xref:System.Collections.IList>.  \(В этом случае <xref:System.Windows.Controls.UIElementCollection> фактически не может быть создан, поскольку он не предоставляет конструктор по умолчанию, и поэтому объектный элемент <xref:System.Windows.Controls.UIElementCollection> показан закомментированным.\)  
  
```xaml  
<StackPanel>  
  <StackPanel.Children>  
    <!--<UIElementCollection>-->  
    <Button>First Button</Button>  
    <Button>Second Button</Button>  
    <!--</UIElementCollection>-->  
  </StackPanel.Children>  
</StackPanel>  
```  
  
### Синтаксис атрибутов \(события\)  
 Синтаксис атрибутов также можно использовать для элементов, которые являются событиями, а не свойствами.  В этом случае имя атрибута является именем события.  События для языка XAML реализованы в WPF таким образом, что значение атрибута является именем обработчика, реализующего делегат этого события.  Например, в следующей разметке назначается обработчик для события <xref:System.Windows.Controls.Primitives.ButtonBase.Click> класса <xref:System.Windows.Controls.Button>, созданного в разметке.  
  
 [!code-xml[XAMLOvwSupport#ButtonWithCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]  
  
 Помимо этого примера синтаксиса атрибутов имеется больше информации по событиям и XAML в WPF.  Например, может возникнуть вопрос, что представляет и как определяется указанный здесь атрибут `ClickHandler`.  Ответ на этот вопрос можно найти в следующем подразделе  данного раздела.  
  
<a name="case_and_whitespace_in_xaml"></a>   
## Чувствительность к регистру и пробелам в XAML  
 Вообще говоря, в языке XAML учитывается регистр символов.  При разрешении резервных типов в WPF XAML регистр учитывается по тем же правилам, что и для CLR.  Объектные элементы, элементы свойств и имена атрибутов должны быть указаны с учетом регистра символов при сравнении по имени с базовым типом в сборке или с элементом типа.  В ключевых словах и примитивах в языке XAML также учитывается регистр.  В значениях регистр учитывается не всегда.  Учет регистра для значений будет зависеть от типа преобразователя поведения, связанного со свойством, которое принимает значение, или с соответствующим типом значения свойства.  Например, свойства, принимающие тип <xref:System.Boolean>, могут принимать значения `true` и `True` как эквивалентные, но только потому, что синтаксический анализатор WPF XAML для преобразования из строкового формата в тип <xref:System.Boolean> уже рассматривает их как эквиваленты.  
  
 Обработчики и сериализаторы WPF XAML игнорируют или удаляют все незначимые пробелы и выполняют нормализацию всех значимых пробелов.  Эти принципы соответствуют стандартным рекомендациям по использованию пробелов, представленных в спецификации языка XAML.  Данное поведение типично только при задании строк в свойствах содержимого XAML.  Проще говоря, XAML преобразует пробелы, символы табуляции и перевода строки в пробелы, а затем сохраняет один пробел, если таковой найден с любого конца непрерывной строки.  Полное описание обработки пробелов в XAML в этом разделе не рассматривается.  Дополнительные сведения см. в разделе [Обработка пробелов в XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md).  
  
<a name="markup_extensions"></a>   
## Расширения разметки  
 Расширения разметки являются понятием языка XAML.  При использовании для предоставления значения синтаксиса атрибутов фигурные скобки \(`{` и `}`\) указывают на использование расширения разметки.  При обработке XAML расширения разметки обрабатываются иначе, чем значения атрибутов, обычно рассматриваемые как литеральная строка или как значение, которое может быть преобразовано в строку.  
  
 Наиболее распространенными расширениями разметки, используемыми при программировании приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], являются [Binding](../../../../docs/framework/wpf/advanced/binding-markup-extension.md), используемое для сохранения выражений привязки данных, и ссылки на ресурсы [StaticResource](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) и [DynamicResource](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md).  Используя расширения разметки можно использовать синтаксис атрибутов для указания значений свойств, которые в целом не поддерживают синтаксис атрибутов.  В расширениях разметки часто используются промежуточные типы выражений для включения функций, которые присутствуют только во время выполнения, например, откладывание значений или ссылка на другие объекты.  
  
 Например, в следующей разметке значение свойства <xref:System.Windows.FrameworkElement.Style%2A> задается с помощью синтаксиса атрибутов.  Свойство <xref:System.Windows.FrameworkElement.Style%2A> принимает экземпляр класса <xref:System.Windows.Style>, который невозможно создать по умолчанию с помощью строки синтаксиса атрибутов.  Но в этом случае атрибут ссылается на определенное расширение разметки, [StaticResource](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md).  Когда это расширение разметки обрабатывается, оно возвращает ссылку на стиль, экземпляр которого был ранее создан в качестве ключевого ресурса в словаре ресурсов.  
  
<!-- TODO: review snippet reference  [!CODE [FEResourceSH#XAMLOvwShortResources](FEResourceSH#XAMLOvwShortResources)]  -->  
<!-- TODO: review snippet reference [!CODE [FEResourceSH#XAMLOvwShortResources2](FEResourceSH#XAMLOvwShortResources2)]  -->  
<!-- TODO: review snippet reference [!CODE [FEResourceSH#XAMLOvwShortResources3](FEResourceSH#XAMLOvwShortResources3)]  -->  
  
 Список всех расширений разметки для XAML, реализованных в WPF, см. в разделе [Расширения XAML WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).  Список расширений разметки, определенных в сборке System.Xaml и более доступных для реализаций XAML платформы .NET Framework, см. в разделе [Возможности пространства имен языка XAML \(x:\)](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).  Дополнительные сведения о понятиях расширений разметки см. в разделе [Расширения разметки и XAML WPF](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).  
  
<a name="type_converters"></a>   
## Преобразователи типов  
 В разделе  было отмечено, что должна быть предоставлена возможность задать значение атрибута строкой.  Основная собственная обработка преобразования строк в другие типы объектов или простые значения основана на самом типе <xref:System.String>, помимо некоторой собственной обработки для определенных типов, например <xref:System.DateTime> или <xref:System.Uri>.  Но многие типы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] или элементы этих типов расширяют основное поведение обработки атрибутов строк таким образом, что экземпляры более сложных типов объектов могут быть заданы как строки и атрибуты.  
  
 Структура <xref:System.Windows.Thickness> является примером типа, для которого включено преобразование типа для использования XAML.  Класс <xref:System.Windows.Thickness> указывает измерения в рамках вложенного прямоугольника и используется как значение для свойств, таких как <xref:System.Windows.FrameworkElement.Margin%2A>.  Если поместить преобразователь типов в <xref:System.Windows.Thickness>, все свойства, использующие <xref:System.Windows.Thickness>, легче указать в XAML, поскольку их можно указать как атрибуты.  В следующем примере преобразование типов и синтаксис атрибутов используются для присвоения значения свойству <xref:System.Windows.FrameworkElement.Margin%2A>:  
  
 [!code-xml[XAMLOvwSupport#MarginTCE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#margintce)]  
  
 Предыдущий пример синтаксиса атрибутов эквивалентен следующему более подробному примеру синтаксиса, где свойство <xref:System.Windows.FrameworkElement.Margin%2A> задается с помощью синтаксиса элемента свойства, содержащего объектный элемент <xref:System.Windows.Thickness>.  Четыре ключевых свойства объекта <xref:System.Windows.Thickness> заданы как атрибуты нового экземпляра.  
  
 [!code-xml[XAMLOvwSupport#MarginVerbose](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#marginverbose)]  
  
> [!NOTE]
>  Кроме того, существует ограниченное количество объектов, для которых преобразование типов является единственным открытым способом присвоения свойству значения нужного типа без использования подкласса, так как у самого типа отсутствует конструктор по умолчанию.  Например, <xref:System.Windows.Input.Cursor>.  
  
 Дополнительные сведения о поддержке преобразователя типов для синтаксиса атрибутов см. в разделе [TypeConverters и XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).  
  
<a name="xaml_root_elements_and_xaml_namespaces"></a>   
## Корневые элементы XAML и пространства имен XAML  
 Файл XAML должен иметь только один корневой элемент, чтобы одновременно быть файлом [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] с правильным форматом и допустимым файлом XAML.  Обычно при работе с WPF используется корневой элемент, наиболее значимый в модели приложения WPF \(например, <xref:System.Windows.Window> или <xref:System.Windows.Controls.Page> для страницы, <xref:System.Windows.ResourceDictionary> для внешнего словаря или <xref:System.Windows.Application> для определения приложения\).  В следующем примере показан корневой элемент обычного файла XAML для страницы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] с корневым элементом <xref:System.Windows.Controls.Page>.  
  
 [!code-xml[XAMLOvwSupport#RootOnly](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly)]  
[!code-xml[XAMLOvwSupport#RootOnly2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page2.xaml#rootonly2)]  
  
 Корневой элемент также содержит атрибуты `xmlns` и `xmlns:x`.  Эти атрибуты указывают обработчику XAML, какие пространства имен XAML содержат определения типов для резервных типов, на которые будет ссылаться разметка в качестве элементов.  Атрибут `xmlns` специально указывает пространство имен XAML по умолчанию.  В пределах пространства имен XAML по умолчанию объектные элементы в разметке можно указывать без префикса.  Для большинства сценариев приложения [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и практически для всех примеров, приведенных в разделах [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], пространство имен XAML по умолчанию сопоставлено с пространством имен [!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Атрибут `xmlns:x` указывает дополнительное пространство имен XAML, которое сопоставлено пространству имен языка XAML [!INCLUDE[TLA#tla_xamlxmlnsv1](../../../../includes/tlasharptla-xamlxmlnsv1-md.md)].  
  
 Это использование атрибутов `xmlns` для определения области использования и сопоставления области видимости имен согласовано со спецификацией XML 1.0.  Области видимости имен XAML отличаются от областей видимости имен XML только тем, что область видимости имен XAML также подразумевает некоторую информацию о резервном копировании элементов области видимости имен по типам в случае разрешения типов и анализа XAML.  
  
 Обратите внимание, что атрибуты `xmlns` строго необходимы только для корневого элемента каждого XAML\-файла.  Определения `xmlns` будут применяться ко всем элементам\-потомкам корневого элемента \(такое поведение также соответствует спецификации XML 1.0 для `xmlns`\). Атрибуты `xmlns` также разрешены для других элементов ниже корня и будут применены ко всем элементам\-потомкам определяющего элемента.  Впрочем, частое определение или повторное определение пространств имен XAML может сделать стиль разметки XAML трудным для человеческого восприятия.  
  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] реализация обработчика XAML включает инфраструктуру, содержащую информацию о ключевых сборках WPF.  Ключевые сборки [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержат типы, поддерживающие сопоставления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] с пространством имен XAML по умолчанию.  Это осуществляется за счет конфигурации, являющейся частью файла построения проекта, построения WPF и систем проекта.  Таким образом, объявление пространства имен XAML как `xmlns` по умолчанию — это все, что нужно, чтобы ссылаться на элементы XAML, полученные из сборок [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
### Префикс "x:"  
 В предыдущем примере корневого элемента префикс `x:` использовался для сопоставления пространства имен XAML [!INCLUDE[TLA#tla_xamlxmlnsv1](../../../../includes/tlasharptla-xamlxmlnsv1-md.md)], которое является выделенным пространством имен XAML, поддерживающим конструкции языка XAML.  Префикс `x:` используется для сопоставления данного пространства имен XAML в шаблонах для проектов, в примерах и в документации по всему этому [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)].  Пространство имен XAML для языка XAML содержит несколько конструкций программирования, которые очень часто используются в XAML.  Ниже приведен список наиболее распространенных конструкций программирования с префиксом `x:`, которые могут вам потребоваться.  
  
-   [x:Key](../../../../docs/framework/xaml-services/x-key-directive.md). Задает уникальный ключ для каждого ресурса в словаре <xref:System.Windows.ResourceDictionary> \(или аналогичных словарях в других платформах\).  `x:Key` применяется примерно в 90% случаев использования сопоставления `x:` в разметке типичных приложений WPF.  
  
-   [x:Class](../../../../docs/framework/xaml-services/x-class-directive.md). Задает пространство имен [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] и имя класса, предоставляющего код программной части для страницы XAML.  Согласно модели программирования WPF, такой класс должен присутствовать для поддержки кода программной части, поэтому сопоставление `x:` присутствует почти всегда, даже если ресурсы отсутствуют.  
  
-   [x:Name](../../../../docs/framework/xaml-services/x-name-directive.md): задает имя объекта во время выполнения для экземпляра, который существует в коде во время выполнения после обработки объектного элемента.  Как правило, на практике часто используется свойство, определенное в WPF, эквивалентное [x:Name](../../../../docs/framework/xaml-services/x-name-directive.md).  Такие свойства сопоставляются непосредственно с резервным свойством CLR, а потому более удобны для программирования приложений, где код времени выполнения часто используется для поиска именованных элементов из инициализированного XAML\-кода.  Наиболее типичное из таких свойств — <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=fullName>.  [x:Name](../../../../docs/framework/xaml-services/x-name-directive.md) все же можно использовать, когда эквивалентное свойство <xref:System.Windows.FrameworkElement.Name%2A> [уровня среды WPF](GTMT) не поддерживается в определенном типе.  Это происходит в некоторых сценариях анимации.  
  
-   [x:Static](../../../../docs/framework/xaml-services/x-static-markup-extension.md). Позволяет использовать ссылку, возвращающую статическое значение, в остальном не являющееся свойством, совместимым с XAML.  
  
-   [x:Type](../../../../docs/framework/xaml-services/x-type-markup-extension.md): создает ссылку <xref:System.Type> на основе имени типа.  Это используется для задания атрибутов, которые принимают тип <xref:System.Type>, например <xref:System.Windows.Style.TargetType%2A?displayProperty=fullName>, хотя часто свойство имеет встроенное преобразование из строки в тип <xref:System.Type> и использование расширения разметки [x:Type](../../../../docs/framework/xaml-services/x-type-markup-extension.md) необязательно.  
  
 Существуют дополнительные конструкции программирования в пространстве имен XAML\/с префиксом `x:`, которые применяются не так часто.  Дополнительные сведения см. в разделе [Возможности пространства имен языка XAML \(x:\)](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).  
  
<a name="custom_prefixes_and_custom_types_in_xaml"></a>   
## Пользовательские префиксы и пользовательские типы в XAML  
 При использовании собственных пользовательских сборок или сборок за пределами заданных в ядре WPF сборок PresentationCore, PresentationFramework и WindowsBase можно указать сборку как часть пользовательского сопоставления `xmlns`.  Затем можно указывать в пользовательском XAML\-коде ссылки на типы из этой сборки, если в типе правильно реализована поддержка требуемых средств XAML.  
  
 Ниже приведен очень общий пример работы пользовательских префиксов в разметке XAML.  Префикс `custom` определен в теге корневого элемента и сопоставляется с конкретной сборкой, упакованной и доступной в приложении.  Эта сборка содержит тип `NumericUpDown`, который реализуется для поддержки общего использования XAML, а также использования наследования класса, которое можно вставить в данную конкретную точку модели содержимого XAML WPF.  Экземпляр этого элемента управления `NumericUpDown` объявлен как объектный элемент, префикс обеспечивает, что анализатор XAML "знает", какое пространство имен XAML содержит тип, и, следовательно, где находится резервная сборка, содержащая определение типа.  
  
```  
<Page  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"   
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"   
    xmlns:custom="clr-namespace:NumericUpDownCustomControl;assembly=CustomLibrary"  
    >  
  <StackPanel Name="LayoutRoot">  
    <custom:NumericUpDown Name="numericCtrl1" Width="100" Height="60"/>  
...  
  </StackPanel>  
</Page>  
```  
  
 Дополнительные сведения о пользовательских типах в языке XAML см. в разделе [Код XAML и пользовательские классы для WPF](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
 Дополнительные сведения об отношении пространств имен XML и пространств имен фонового кода в сборках см. в разделе [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="events_and_xaml_codebehind"></a>   
## События и код программной части XAML  
 В большинстве приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержится как разметка XAML, так и код программной части.  В проекте XAML\-код записывается как файл с расширением `.xaml`, а для записи файла с кодом программной части используется язык [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], например [!INCLUDE[TLA#tla_visualb](../../../../includes/tlasharptla-visualb-md.md)] или [!INCLUDE[TLA#tla_cshrp](../../../../includes/tlasharptla-cshrp-md.md)].  При компиляции разметки в файле XAML \(в составе модели приложений и программирования WPF\) расположение файла кода программной части для файла XAML определяется путем указания пространства имен и класса как атрибута `x:Class` корневого элемента XAML\-кода.  
  
 В приведенных примерах было использовано несколько кнопок, но ни с одной из этих кнопок не было ассоциировано логическое поведение.  Первичным механизмом добавления поведения для объектного элемента на уровне приложения является использование существующего события элементного класса и написание специального обработчика для этого события, которое вызывается при возникновении этого события во время выполнения.  Имя события и имя обработчика для использования указываются в разметке, тогда как код, который реализует обработчик, определен в фоновом коде.  
  
 [!code-xml[XAMLOvwSupport#ButtonWithCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml#buttonwithcodebehind)]  
  
 [!code-csharp[XAMLOvwSupport#ButtonWithCodeBehindHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page3.xaml.cs#buttonwithcodebehindhandler)]
 [!code-vb[XAMLOvwSupport#ButtonWithCodeBehindHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#buttonwithcodebehindhandler)]  
  
 Обратите внимание, что файл кода программной части использует пространство имен CLR `ExampleNamespace` и объявляет `ExamplePage` как частичный класс в этом пространстве имен.  Это аналогично значению атрибута `x:Class` `ExampleNamespace`.`ExamplePage`, предоставленному в корне разметки.  Компилятор разметки WPF автоматически создает разделяемый класс для любого скомпилированного файла XAML путем создания класса, унаследованного от типа корневого элемента.  При предоставлении фонового кода, который также определяет тот же частичный класс, результирующий код объединяется внутри того же пространства имен и класса скомпилированного приложения.  
  
 Дополнительные сведения о требованиях к созданию кода программной части в WPF см. в подразделе "Код программной части, обработчик событий и требования частичного класса" раздела [Код программной части и XAML в WPF](../../../../docs/framework/wpf/advanced/code-behind-and-xaml-in-wpf.md).  
  
 Если создание отдельного файла кода программной части нежелательно, то можно также встроить код в файл XAML.  Однако встроенный код является менее гибким методом, имеющим значительные ограничения.  Дополнительные сведения см. в разделе [Код программной части и XAML в WPF](../../../../docs/framework/wpf/advanced/code-behind-and-xaml-in-wpf.md).  
  
### Маршрутизируемые события  
 Одна из наиболее важных возможностей [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] — [перенаправленное событие](GTMT).  Перенаправленные события позволяют элементу обрабатывать событие, которое было вызвано другим элементом, пока они связаны через отношение дерева.  При задании обработки события атрибутом XAML перенаправленное событие может отслеживаться и обрабатываться любым элементом, включая те, для которых это событие не указано в таблице членов класса.  Это достигается путем уточнения атрибута имени события именем класса\-владельца.  Например, родительский `StackPanel` в текущем примере `StackPanel` \/ `Button` может зарегистрировать обработчик для события <xref:System.Windows.Controls.Primitives.ButtonBase.Click> кнопки дочернего элемента путем задания атрибута `Button.Click` для объектного элемента `StackPanel` именем обработчика в качестве значения атрибута.  Дополнительные сведения о принципах работы перенаправленных событий см. в разделе [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="x_name_and_xaml_named_elements"></a>   
## Именованные события XAML  
 По умолчанию экземпляр объекта, созданный в графе объекта путем обработки объектного элемента XAML, не имеет уникального идентификатора или ссылки на объект.  Тогда как если конструктор вызывается в коде, результат конструктора почти всегда используется для указания созданного экземпляра в качестве значения переменной, чтобы на него можно было ссылаться в дальнейшем коде.  Для предоставления стандартизованного доступа к объектам, созданным с помощью определения разметки, в языке XAML определяется [атрибут x:Name](../../../../docs/framework/xaml-services/x-name-directive.md).  Можно задать значение атрибута `x:Name` для любого объектного элемента.  В коде программной части выбранный идентификатор эквивалентен переменной экземпляра, которая ссылается на созданный экземпляр.  Именованные элементы во всех отношениях действуют так, как если бы они были экземплярами объекта \(имя только ссылается на этот экземпляр\), и в приложении код программной части может ссылаться на именованные элементы для обработки взаимодействий времени выполнения.  Эта связь между экземплярами и переменными обеспечивается компилятором разметки WPF XAML, и, в частности, использует такие функции как <xref:System.Windows.Markup.IComponentConnector.InitializeComponent%2A>, подробно не рассматриваемые в этом разделе.  
  
 Элементы XAML [уровня среды WPF](GTMT) наследуют свойство <xref:System.Windows.FrameworkElement.Name%2A>, являющееся эквивалентным определенному в XAML атрибуту `x:Name`.  Некоторые другие классы также предоставляют эквиваленты уровня свойств для `x:Name`, который также обычно определяется как свойство `Name`.  Вообще говоря, если не удается найти свойство `Name` в таблице членов для выбранного элемента\/типа, вместо него следует использовать атрибут `x:Name`.  Значения `x:Name` обеспечивают идентификатор элемента XAML, который может использоваться во время выполнения \(либо определенными подсистемами, либо вспомогательными методами, такими как <xref:System.Windows.FrameworkElement.FindName%2A>\).  
  
 В следующем примере задается <xref:System.Windows.FrameworkElement.Name%2A> для элемента <xref:System.Windows.Controls.StackPanel>.  Затем обработчик для <xref:System.Windows.Controls.Button> в <xref:System.Windows.Controls.StackPanel> ссылается на <xref:System.Windows.Controls.StackPanel> через его `buttonContainer` ссылок на экземпляры, как задано в <xref:System.Windows.FrameworkElement.Name%2A>.  
  
 [!code-xml[XAMLOvwSupport#NamedE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede)]  
[!code-xml[XAMLOvwSupport#NamedE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml#namede2)]  
  
 [!code-csharp[XAMLOvwSupport#NameCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page7.xaml.cs#namecode)]
 [!code-vb[XAMLOvwSupport#NameCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/XAMLOvwSupport/VisualBasic/Page1.xaml.vb#namecode)]  
  
 Как и в случае с переменными, имена экземпляров классов XAML регулируются понятием области, так что обеспечивается уникальность имен в пределах определенной области с известными границами.  Основная разметка, определяющая страницу, обозначает одну уникальную область видимости имен XAML с корневым элементом страницы в качестве границы.  Однако другие источники разметки могут взаимодействовать со страницей во время выполнения, например стили или шаблоны в стилях, и такие источники разметки часто имеют свои собственные области видимости имен XAML, не обязательно связанные с областью видимости имен XAML страницы.  Дополнительные сведения о `x:Name` и областях видимости имен XAML см. в разделе <xref:System.Windows.FrameworkElement.Name%2A>, [Директива x:Name](../../../../docs/framework/xaml-services/x-name-directive.md) или [Области видимости имен XAML в WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
<a name="attached_properties_and_attached_events"></a>   
## Вложенные свойства и события  
 Одна из возможностей языка XAML позволяет задавать для любого элемента определенные свойства или события, независимо от того, существует ли свойство или событие в таблице определений типа для этого элемента.  Версия свойств этой возможности называется [вложенное свойство](GTMT), версия событий называется [вложенное событие](GTMT).  Концептуально можно представить вложенные свойства и события как глобальные члены, которые могут быть заданы для любого элемента\/экземпляра объекта XAML.  Впрочем, этот элемент\/класс \(или более крупная инфраструктура\) должен поддерживать резервное хранилище свойств для вложенных значений.  
  
 Вложенные свойства в языке XAML обычно используются через синтаксис атрибутов.  В синтаксисе атрибутов можно указать вложенное свойство в виде *тип\_владельца*.*имя\_свойства*.  
  
 Внешне это напоминает использование элементов свойств, но в данном случае задаваемый тип *ownerType* всегда отличается от типа объектного элемента, для которого задается вложенное свойство.  *OwnerType* является типом, предоставляющим методы доступа, необходимые обработчику XAML для получения или установки значения вложенного свойства.  
  
 Наиболее распространенным скриптом для вложенных свойств является разрешение дочерним элементам предоставления значения свойства их родительскому элементу.  
  
 В следующем примере показано вложенное свойство <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>.  Класс <xref:System.Windows.Controls.DockPanel> определяет методы доступа для <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> и поэтому владеет вложенным свойством.  Класс <xref:System.Windows.Controls.DockPanel> также содержит логику, которая выполняет итерацию его дочерних элементов и специально проверяет каждый элемент на набор значений <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName>.  Если значение обнаруживается, это значение используется в процессе разметки для расположения дочерних элементов.  Использование вложенного свойства <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=fullName> и возможности размещения на самом деле является мотивирующим скриптом для класса <xref:System.Windows.Controls.DockPanel>.  
  
 [!code-xml[XAMLOvwSupport#DockAP](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#dockap)]  
  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] большинство вложенных свойств \(или все такие свойства\) также реализуются как [свойства зависимости](GTMT).  Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах зависимостей](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Вложенные события используют аналогичную форму *тип\_владельца*.*имя\_события* синтаксиса атрибутов.  Подобно невложенным событиям, значение атрибута для вложенного события в XAML задает имя метода обработчика, который вызывается, когда событие обрабатывается для элемента.  Использование вложенного события в XAML WPF менее распространено.  Дополнительные сведения см. в разделе [Общие сведения о вложенных событиях](../../../../docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="base_classes_and_xaml"></a>   
## Базовые типы и язык XAML  
 Базовая платформа XAML WPF и его пространство имен XAML представляют собой коллекцию типов, которые соответствуют объектам [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], а также элементы разметки для XAML.  Однако не все классы могут сопоставляться с элементами.  Абстрактные классы, например <xref:System.Windows.Controls.Primitives.ButtonBase>, и некоторые неабстрактные базовые классы используются для наследования в модели объектов [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  Базовые классы, включая абстрактные, по\-прежнему важны для разработки XAML, так как каждый из элементов XAML наследует члены некоторого базового класса в своей иерархии.  Часто эти члены включают в себя свойства, которые могут быть заданы как атрибуты элемента или как события, на которые можно реагировать.  <xref:System.Windows.FrameworkElement> — конкретный базовый класс компонента [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] на [уровне инфраструктуры WPF](GTMT).  При разработке [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] следует использовать различные классы фигур, панелей, декораторов или элементов управления, которые являются производными от <xref:System.Windows.FrameworkElement>.  Связанный базовый класс, <xref:System.Windows.FrameworkContentElement>, поддерживает элементы, ориентированные на документы, которые подходят для представления макета потока, используя [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], намеренно дублирующие [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] в <xref:System.Windows.FrameworkElement>.  Сочетание атрибутов на уровне элементов и объектной модели [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] обеспечивает набор общих свойств, которые можно задать для большинства конкретных элементов XAML, независимо от типа элемента XAML и его базового типа.  
  
<a name="xaml_security"></a>   
## Безопасность в XAML  
 XAML — это язык разметки, непосредственно представляющий создание и выполнение объекта.  Таким образом, элементы, созданные в XAML, имеют такие же возможности взаимодействия с системными ресурсами \(например, сетевой доступ и ввод\-вывод файловой системы\), как и эквивалентный порожденный код.  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] поддерживает [!INCLUDE[TLA#tla_cas](../../../../includes/tlasharptla-cas-md.md)] платформы безопасности [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].  Это означает, что содержимое [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], работающее в зоне "Интернет", сократило разрешения исполнения. "  Свободный XAML" \(страницы некомпилированного XAML, интерпретируемые во время загрузки средства просмотра XAML\) и [!INCLUDE[TLA#tla_xbap](../../../../includes/tlasharptla-xbap-md.md)] обычно выполняются в этой Интернет\-зоне и используют один набор разрешений.  Однако XAML, загруженный в полностью доверенное приложение, имеет такой же доступ к системным ресурсам, как и ведущее приложение.  Дополнительные сведения см. в разделе [Безопасность частичного доверия в WPF](../../../../docs/framework/wpf/wpf-partial-trust-security.md).  
  
<a name="loading_xaml_from_code"></a>   
## Загрузка XAML из кода  
 XAML можно использовать для определения всего пользовательского интерфейса, но иногда также уместно определение в XAML только его части.  Эта возможность может использоваться для включения частичной настройки, локального хранения данных, использования XAML для предоставления бизнес\-объекта или различных возможных сценариев.  Ключом для этих скриптов является класс <xref:System.Windows.Markup.XamlReader> и его метод <xref:System.Windows.Markup.XamlReader.Load%2A>.  Входные данные являются файлом XAML, а выходные данные — объектом, представляющим дерево объектов времени выполнения, созданных по разметке.  Можно затем вставить объект, который будет свойством другого объекта, уже существующего в приложении.  Пока свойство является допустимым свойством в модели содержимого, которая имеет возможности отображения и которая уведомляет ядро выполнения о добавлении в приложение нового содержимого, можно достаточно легко изменить содержимое работающего приложения путем загрузки XAML.  Обратите внимание, что эта возможность доступна только в приложениях с уровнем полного доверия из\-за очевидных с точки зрения безопасности последствий загрузки файлов в работающие приложения.  
  
<a name="whats_next"></a>   
## Что дальше?  
 Этот раздел содержит вводные сведения о терминологии и понятиях синтаксиса в XAML применительно к WPF.  Дополнительные сведения об используемых здесь терминах см. в разделе [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
 Выполните упражнения из раздела руководства [Пошаговое руководство. Начало работы с WPF](../../../../docs/framework/wpf/getting-started/walkthrough-my-first-wpf-desktop-application.md), если вы не сделали этого ранее.  При создании приложения, ориентированного на разметку и описанного в руководстве, упражнения помогут лучше осознать многие понятия, описанные в этом разделе.  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использует конкретную модель приложения, основанную на классе <xref:System.Windows.Application>.  Дополнительные сведения см. в разделе [Общие сведения об управлении приложением](../../../../docs/framework/wpf/app-development/application-management-overview.md).  
  
 В разделе [Построение приложения WPF](../../../../docs/framework/wpf/app-development/building-a-wpf-application-wpf.md) представлены дополнительные сведения о том, как построить включающие XAML приложения из командной строки и в [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)].  
  
 В [Общие сведения о свойствах зависимости](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md) представлены дополнительные сведения о разнообразии свойств в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и описано понятие [свойств зависимости](GTMT).  
  
## См. также  
 [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)   
 [Код XAML и пользовательские классы для WPF](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)   
 [Возможности пространства имен языка XAML \(x:\)](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)   
 [Расширения XAML WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)   
 [Общие сведения о базовых элементах](../../../../docs/framework/wpf/advanced/base-elements-overview.md)   
 [Деревья в WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)