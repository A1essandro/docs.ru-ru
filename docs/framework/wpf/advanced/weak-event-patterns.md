---
title: "Шаблоны слабых событий"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- weak event pattern implementation [WPF]
- event handlers [WPF], weak event pattern
- IWeakEventListener interface [WPF]
ms.assetid: e7c62920-4812-4811-94d8-050a65c856f6
caps.latest.revision: "18"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 21a36797f945f37a641e7002bbb9937a664650fd
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="weak-event-patterns"></a>Шаблоны слабых событий
В приложениях возможно, что обработчики, присоединенные к источнику событий не будут уничтожены в соответствии с объектом прослушивателя, который присоединил обработчик к источнику. Такая ситуация может привести к утечке памяти. [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]представляет шаблон, который может использоваться для устранения этой проблемы путем предоставления выделенного класса диспетчера для конкретных событий и реализации интерфейса прослушивателей для данного события. Этот шаблон разработки называется *шаблон слабых событий*.  
  
## <a name="why-implement-the-weak-event-pattern"></a>Почему следует реализовать шаблон слабых событий?  
 Прослушивание событий может привести к утечке памяти. Обычным методом для прослушивания событий является использование синтаксиса конкретного языка, который присоединяет обработчик событий в источнике. Например, в [!INCLUDE[TLA#tla_cshrp](../../../../includes/tlasharptla-cshrp-md.md)], что синтаксис является: `source.SomeEvent += new SomeEventHandler(MyEventHandler)`.  
  
 Этот метод создает строгую ссылку от источника события прослушиватель событий. Обычно присоединение обработчика событий для прослушивателя вызывает прослушиватель имеет время существования объекта, которое влияет время жизни объекта источника (если не будет явно удален обработчик событий). Однако в некоторых случаях может потребоваться время жизни объекта прослушивателя управляются другими факторами, например, принадлежит ли он в настоящее время к визуального дерева приложения, а не по времени существования источника. Каждый раз, когда время жизни объекта источника выходит за пределы времени существования объекта прослушивателя, обычный шаблон события приводит к утечке памяти: слушатель хранится дольше, чем ожидается.  
  
 Шаблон слабых событий предназначен для решения проблемы утечки памяти. Шаблон слабых событий можно использовать всякий раз, когда прослушивателю необходимо зарегистрироваться для получения события, но прослушиватель не знает, явно отмены регистрации. Шаблон слабых событий может также использоваться всякий раз, когда время жизни объекта источника превышает время существования полезных объект прослушивателя. (В этом случае *полезно* , определяется.) Шаблон слабых событий позволяет прослушивателю регистрировать и получать события, не затрагивая характеристики времени жизни объекта прослушивателя каким-либо образом. В результате неявная ссылка от источника не определить, является ли прослушиватель мусора. Ссылка является слабой ссылки, таким образом система именования шаблона слабых событий и связанных с [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]. Прослушиватель может быть собран как мусор или в противном случае удаляются, а источник может продолжить без сохранения только что уничтоженный обработчика ссылок на объект.  
  
## <a name="who-should-implement-the-weak-event-pattern"></a>Кто должен реализовывать шаблон слабых событий?  
 Реализация шаблона слабых событий представляет интерес главным образом для разработчиков элементов управления. Автор элемента управления являются значительной мере отвечаете за поведение и включения элемента управления и влияние на приложения, в которых он вставлен. Это входит и поведение времени жизни объекта элемента управления, в частности, обработка описанной проблемы утечки памяти.  
  
 Некоторые сценарии изначально подходят для применения шаблона слабых событий. Одним из таких сценариев является привязкой данных. При привязке данных часто исходный объект полностью независим от объекта прослушивателя, который является целевым объектом привязки. Многие аспекты [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] привязки данных уже имеют шаблон слабых событий, примененный в порядок реализации событий.  
  
## <a name="how-to-implement-the-weak-event-pattern"></a>Как реализовать шаблон слабых событий  
 Существует три способа реализации шаблона слабых событий. В следующей таблице перечислены три подхода и даются рекомендации по при их использованию.  
  
|Подход|Когда следует реализовать|  
|--------------|-----------------------|  
|Использовать существующий класс manager слабых событий|Если вы хотите подписаться на событие имеет соответствующий <xref:System.Windows.WeakEventManager>, диспетчер слабых событий. Список диспетчеров слабых событий, которые входят в состав WPF, см. в иерархии наследования <xref:System.Windows.WeakEventManager> класса. Обратите внимание, сравнительно мало диспетчеров слабых событий, включенных в WPF, поэтому, возможно, необходимо будет выбрать один из следующих подходов.|  
|Используйте класс manager универсального слабых событий|Использовать универсальный <xref:System.Windows.WeakEventManager%602> Если в имеющемся <xref:System.Windows.WeakEventManager> , недоступна, требуется простой способ реализации, и вы не занимается эффективность. Универсальный <xref:System.Windows.WeakEventManager%602> является менее эффективным, чем диспетчер существующих или пользовательских слабых событий. Например универсальный класс выполняет дополнительные отражения для получения событий, заданному имени события. Кроме того, код, чтобы зарегистрировать событие с помощью универсального <xref:System.Windows.WeakEventManager%602> является более подробным по сравнению с использованием существующих или пользовательских <xref:System.Windows.WeakEventManager>.|  
|Создание класса пользовательского слабых событий диспетчера|Создание пользовательского <xref:System.Windows.WeakEventManager> Если в имеющемся <xref:System.Windows.WeakEventManager> недоступен и нужно, повышения эффективности работы. С помощью настраиваемого <xref:System.Windows.WeakEventManager> подписаться на событие будет более эффективным, но при этом затраты на написание дополнительный код в начале.|  
  
 В следующих разделах описаны способы реализации шаблона слабых событий.  Для целей данного обсуждения подписаться на событие имеет следующие характеристики.  
  
-   Имя события `SomeEvent`.  
  
-   Вызывает событие `EventSource` класса.  
  
-   Обработчик событий имеет тип: `SomeEventEventHandler` (или `EventHandler<SomeEventEventArgs>`).  
  
-   Событие передает параметр типа `SomeEventEventArgs` обработчикам событий.  
  
### <a name="using-an-existing-weak-event-manager-class"></a>С помощью существующего класса слабого диспетчера событий  
  
1.  Найти существующий слабых событий диспетчера.  
  
     Список диспетчеров слабых событий, которые входят в состав WPF, см. в иерархии наследования <xref:System.Windows.WeakEventManager> класса.  
  
2.  Используйте новый диспетчер слабых событий вместо обычной привязке события.  
  
     Например, если ваш код использует следующий шаблон для подписки на событие:  
  
    ```  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично Если ваш код использует следующий шаблон для отмены подписки на событие:  
  
    ```  
    source.SomeEvent -= new SomeEventEventHandler(OnSome);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
### <a name="using-the-generic-weak-event-manager-class"></a>С помощью универсального класса слабого диспетчера событий  
  
1.  Использовать универсальный <xref:System.Windows.WeakEventManager%602> класса вместо обычной привязке события.  
  
     При использовании <xref:System.Windows.WeakEventManager%602> Чтобы зарегистрировать прослушивателей событий, необходимо указать источник события и <xref:System.EventArgs> типа, что и параметры типа класса и вызове <xref:System.Windows.WeakEventManager%602.AddHandler%2A> как показано в следующем коде:  
  
    ```  
    WeakEventManager<EventSource, SomeEventEventArgs>.AddHandler(source, "SomeEvent", source_SomeEvent);  
    ```  
  
### <a name="creating-a-custom-weak-event-manager-class"></a>Создание пользовательского класса слабого диспетчера событий  
  
1.  Скопируйте следующий шаблон класса в проект.  
  
     Этот класс наследует от <xref:System.Windows.WeakEventManager> класса.  
  
     [!code-csharp[WeakEvents#WeakEventManagerTemplate](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WeakEvents/CSharp/WeakEventManagerTemplate.cs#weakeventmanagertemplate)]  
  
2.  Замените `SomeEventWeakEventManager` с собственное имя.  
  
3.  Замените имена трех, описанные выше, с соответствующими именами для события. (`SomeEvent`, `EventSource`, и `SomeEventEventArgs`)  
  
4.  Видимость (открытый, внутренний, закрытый) класса диспетчера слабых событий для той же областью видимости, как событие, которыми он управляет.  
  
5.  Используйте новый диспетчер слабых событий вместо обычной привязке события.  
  
     Например, если ваш код использует следующий шаблон для подписки на событие:  
  
    ```  
    source.SomeEvent += new SomeEventEventHandler(OnSomeEvent);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.AddHandler(source, OnSomeEvent);  
    ```  
  
     Аналогично Если ваш код использует следующий шаблон для отмены подписки на событие:  
  
    ```  
    source.SomeEvent -= new SomeEventEventHandler(OnSome);  
    ```  
  
     Измените его на следующий шаблон:  
  
    ```  
    SomeEventWeakEventManager.RemoveHandler(source, OnSomeEvent);  
    ```  
  
## <a name="see-also"></a>См. также  
 <xref:System.Windows.WeakEventManager>  
 <xref:System.Windows.IWeakEventListener>  
 [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [Общие сведения о привязке данных](../../../../docs/framework/wpf/data/data-binding-overview.md)
