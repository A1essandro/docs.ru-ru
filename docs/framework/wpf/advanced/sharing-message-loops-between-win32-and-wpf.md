---
title: "Совместное использование циклов обработки сообщений между Win32 и WPF"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: d3122100f93d15c04c109564e1abd2dc13f37990
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="572bf-102">Совместное использование циклов обработки сообщений между Win32 и WPF</span><span class="sxs-lookup"><span data-stu-id="572bf-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="572bf-103">В этом разделе описывается реализация цикла обработки сообщений для взаимодействия с [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], при помощи существующего сообщения раскрытия цикла в <xref:System.Windows.Threading.Dispatcher> или путем создания отдельного цикла обработки сообщения на [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] параллельно кода взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="572bf-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="572bf-104">Диспетчер компонента и цикл обработки сообщений</span><span class="sxs-lookup"><span data-stu-id="572bf-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="572bf-105">Обычный сценарий для взаимодействия и поддержки события клавиатуры является реализация <xref:System.Windows.Interop.IKeyboardInputSink>, или подкласса из классов, которые уже реализуют <xref:System.Windows.Interop.IKeyboardInputSink>, такие как <xref:System.Windows.Interop.HwndSource> или <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="572bf-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="572bf-106">Поддержка приемник клавиатуры не учитывает все возможные циклам обработки сообщений при отправке и получении сообщений через ваши границы взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="572bf-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="572bf-107">Чтобы помочь формализовать архитектуру цикла обработки сообщений приложения, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] предоставляет <xref:System.Windows.Interop.ComponentDispatcher> класса, который определяет простой протокол для цикла обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="572bf-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="572bf-108"><xref:System.Windows.Interop.ComponentDispatcher>является статическим классом, предоставляющий несколько членов.</span><span class="sxs-lookup"><span data-stu-id="572bf-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="572bf-109">Область каждого метода неявно привязана в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="572bf-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="572bf-110">Цикл обработки сообщений должен вызывать некоторые из этих [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] в критические моменты времени (как определено в следующем разделе).</span><span class="sxs-lookup"><span data-stu-id="572bf-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="572bf-111"><xref:System.Windows.Interop.ComponentDispatcher>Предоставляет события, которые могут прослушивать другие компоненты (такие как приемник клавиатуры).</span><span class="sxs-lookup"><span data-stu-id="572bf-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="572bf-112"><xref:System.Windows.Threading.Dispatcher> Класса вызывает соответствующие <xref:System.Windows.Interop.ComponentDispatcher> методы в соответствующей последовательности.</span><span class="sxs-lookup"><span data-stu-id="572bf-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="572bf-113">При реализации собственного цикла обработки сообщений, код отвечает за вызов метода <xref:System.Windows.Interop.ComponentDispatcher> методы таким же образом.</span><span class="sxs-lookup"><span data-stu-id="572bf-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="572bf-114">Вызов <xref:System.Windows.Interop.ComponentDispatcher> методы в потоке только вызовет обработчики событий, которые были зарегистрированы в этом потоке.</span><span class="sxs-lookup"><span data-stu-id="572bf-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="572bf-115">Написание циклов обработки сообщений</span><span class="sxs-lookup"><span data-stu-id="572bf-115">Writing Message Loops</span></span>  
 <span data-ttu-id="572bf-116">Ниже приведен перечень <xref:System.Windows.Interop.ComponentDispatcher> члены, которые вы будете использовать при написании собственного цикла обработки сообщений:</span><span class="sxs-lookup"><span data-stu-id="572bf-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="572bf-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: ваш цикл обработки сообщений должен вызывать его, чтобы указать, что поток является модальным.</span><span class="sxs-lookup"><span data-stu-id="572bf-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="572bf-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: ваш цикл обработки сообщений должен вызывать его, чтобы указать, что поток вернулся немодальным.</span><span class="sxs-lookup"><span data-stu-id="572bf-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="572bf-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: ваш цикл обработки сообщений должен вызывать его, чтобы указать, что <xref:System.Windows.Interop.ComponentDispatcher> должен вызывать <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> событий.</span><span class="sxs-lookup"><span data-stu-id="572bf-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="572bf-120"><xref:System.Windows.Interop.ComponentDispatcher>не создает <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> Если <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> — `true`, но циклы обработки сообщений, можно вызвать <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> даже в том случае, если <xref:System.Windows.Interop.ComponentDispatcher> не может ответить на него в модальное состояние.</span><span class="sxs-lookup"><span data-stu-id="572bf-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="572bf-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: ваш цикл обработки сообщений должен вызывать его, чтобы указать, что доступно новое сообщение.</span><span class="sxs-lookup"><span data-stu-id="572bf-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="572bf-122">Возвращаемое значение указывает, является ли прослушиватель для <xref:System.Windows.Interop.ComponentDispatcher> сообщение обработано событие.</span><span class="sxs-lookup"><span data-stu-id="572bf-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="572bf-123">Если <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> возвращает `true` (обработано), диспетчер в дальнейшем ничего с сообщением.</span><span class="sxs-lookup"><span data-stu-id="572bf-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="572bf-124">Если возвращается значение `false`, диспетчер ожидает вызов [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] функция `TranslateMessage`, затем вызовите `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="572bf-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="572bf-125">Использование диспетчера компонента и обработки существующих сообщений</span><span class="sxs-lookup"><span data-stu-id="572bf-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="572bf-126">Ниже приведен перечень <xref:System.Windows.Interop.ComponentDispatcher> члены, которые будет использовать, если вы полагаетесь на встроенном [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="572bf-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="572bf-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: возвращает, стал ли приложение модальное (например, цикл модальное сообщение было помещено).</span><span class="sxs-lookup"><span data-stu-id="572bf-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="572bf-128"><xref:System.Windows.Interop.ComponentDispatcher>может отслеживать это состояние, так как класс содержит счетчик <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> и <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> вызовы от цикла обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="572bf-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="572bf-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>и <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> события соответствовать стандартным правилам для вызова делегата.</span><span class="sxs-lookup"><span data-stu-id="572bf-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="572bf-130">Делегаты вызываются в неопределенном порядке, и вызываются все делегаты, даже если первый из них помечает сообщение как обработанное.</span><span class="sxs-lookup"><span data-stu-id="572bf-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="572bf-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: указывает на соответствующий и эффективный время простоя обработки (нет других ожидающих сообщений для потока).</span><span class="sxs-lookup"><span data-stu-id="572bf-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="572bf-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>не будет вызываться, если поток является модальным.</span><span class="sxs-lookup"><span data-stu-id="572bf-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="572bf-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: вызывается для всех сообщений, обрабатываемых в генераторе сообщений.</span><span class="sxs-lookup"><span data-stu-id="572bf-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="572bf-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: вызывается для всех сообщений, которые не были обработаны во время <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="572bf-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="572bf-135">Сообщение считается обработанным, если после <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> событий или <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> событий, `handled` параметр, передаваемый по ссылке в данных события `true`.</span><span class="sxs-lookup"><span data-stu-id="572bf-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="572bf-136">Обработчики событий должны игнорировать сообщение, если `handled` — `true`, так как это означает, что другой обработчик обработал сообщение первым.</span><span class="sxs-lookup"><span data-stu-id="572bf-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="572bf-137">Обработчики событий для обоих событий могут изменить сообщение.</span><span class="sxs-lookup"><span data-stu-id="572bf-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="572bf-138">Диспетчер должен отправлять измененное сообщение, а не исходное сообщение без изменений.</span><span class="sxs-lookup"><span data-stu-id="572bf-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="572bf-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>доставляется всем слушателям, но архитектурно это только окна верхнего уровня, содержащий HWND, с которой сообщения должны вызвать код в ответ на сообщение.</span><span class="sxs-lookup"><span data-stu-id="572bf-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="572bf-140">Как HwndSource Рассматривает события диспетчера компонента</span><span class="sxs-lookup"><span data-stu-id="572bf-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="572bf-141">Если <xref:System.Windows.Interop.HwndSource> является окном верхнего уровня (нет родительского HWND), будет зарегистрирован <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="572bf-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="572bf-142">Если <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> возникает, если сообщение предназначено для <xref:System.Windows.Interop.HwndSource> или дочерних окон, <xref:System.Windows.Interop.HwndSource> вызовы его <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> последовательность приемника клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="572bf-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="572bf-143">Если <xref:System.Windows.Interop.HwndSource> не является окном верхнего уровня (имеет родителя HWND), обработано не будет.</span><span class="sxs-lookup"><span data-stu-id="572bf-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="572bf-144">Только окно верхнего уровня должен выполнять обработку и оно должно быть окном верхнего уровня с поддержкой приемника клавиатуры как часть любого скрипта взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="572bf-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="572bf-145">Если <xref:System.Windows.Interop.HwndHost.WndProc%2A> на <xref:System.Windows.Interop.HwndSource> вызывается без вызова метода приемника сочетания, ваше приложение получит более высокоуровневые события клавиатуры например <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="572bf-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="572bf-146">Тем не менее не методы приемника клавиатуры будет вызываться, которые нарушают возможности модели ввода клавиатуры, такие как поддержка клавиш доступа.</span><span class="sxs-lookup"><span data-stu-id="572bf-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="572bf-147">Это может происходить, когда цикл обработки сообщений не уведомил соответствующий поток на <xref:System.Windows.Interop.ComponentDispatcher>, или поскольку родительское HWND не вызвало соответствующие ответы приемника клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="572bf-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="572bf-148">Это сообщение в приемник клавиатуры может не должны отправляться HWND обработчики для этого сообщения, добавленные с помощью <xref:System.Windows.Interop.HwndSource.AddHook%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="572bf-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="572bf-149">Сообщение может быть обработано на уровне загрузки сообщений напрямую и не отправлено `DispatchMessage` функции.</span><span class="sxs-lookup"><span data-stu-id="572bf-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="572bf-150">См. также</span><span class="sxs-lookup"><span data-stu-id="572bf-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="572bf-151">Взаимодействие WPF и Win32</span><span class="sxs-lookup"><span data-stu-id="572bf-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="572bf-152">Потоковая модель</span><span class="sxs-lookup"><span data-stu-id="572bf-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="572bf-153">Общие сведения о входных данных</span><span class="sxs-lookup"><span data-stu-id="572bf-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
