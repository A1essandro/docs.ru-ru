---
title: "Подробное описание синтаксиса XAML"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
caps.latest.revision: "26"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 0aa85c9ec6e6b911444b07a4169dc769ac4df816
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="xaml-syntax-in-detail"></a>Подробное описание синтаксиса XAML
В этом разделе определяются термины, которые используются для описания элементов синтаксиса XAML. Эти термины часто используются в оставшейся части этой документации, в документации по WPF специально и для других платформ, использующих XAML или базовые понятия XAML, включаемые поддержки языка XAML на уровне System.Xaml. Этот раздел расширяет базовую терминологию, представленную в разделе [Обзор XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a>В спецификации языка XAML  
 Терминология синтаксиса XAML, заданным в этом окне также определяется или ссылаться в спецификации языка XAML. XAML — это язык на основе XML и следует или расширяет структурным правилам XML. Часть терминологии является общей или основан на терминологии, используемой при описании языка XML или модель объектов XML-документов.  
  
 Дополнительные сведения о спецификации языка XAML, загрузите [ \[MS-XAML\] ](http://go.microsoft.com/fwlink/?LinkId=114525) из центра загрузки Майкрософт.  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a>XAML и среда CLR  
 XAML — это язык разметки. [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], Как следует из названия, обеспечивает выполнение среды выполнения. XAML по себе не является одним из общих языков, который напрямую используется средой выполнения CLR. Вместо этого можно считать из XAML поддержки свою собственную систему типов. Особая система анализа XAML, который используется в WPF основана на среде CLR и системе типов среды CLR. Типы XAML сопоставляются с типами среды CLR для создания представления времени выполнения при синтаксическом анализе XAML для WPF. По этой причине оставшаяся часть обсуждения синтаксиса в этом документе будет содержать ссылки на системе типов среды CLR, несмотря на то, что такие же обсуждения синтаксиса в спецификации языка XAML не. (На уровне спецификации языка XAML, типы XAML могут быть сопоставлены для любой другой системой типов, которой не должен быть в среде CLR, но это потребует Создание и использование различных синтаксического анализа XAML.)  
  
#### <a name="members-of-types-and-class-inheritance"></a>Члены типов и наследование классов  
 Свойства и события, отображающиеся как XAML-члены из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , часто наследуются от базовых типов. Например, рассмотрим следующий пример: `<Button Background="Blue" .../>`. <xref:System.Windows.Controls.Control.Background%2A> Свойство не является непосредственно объявленным свойством в <xref:System.Windows.Controls.Button> класса, если вы посмотрите на определение класса, результаты отражения или документации. Вместо этого <xref:System.Windows.Controls.Control.Background%2A> наследуются от базового <xref:System.Windows.Controls.Control> класса.  
  
 Поведение наследования классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] элементы XAML, это значительно отличается от схемы принудительно интерпретации разметки XML. Наследование классов может стать сложной задачей, особенно в том случае, если промежуточные базовые классы являются абстрактными, или при использовании интерфейсов. Это одна из причин, набор элементов XAML и их допустимых атрибутов очень сложно представляют точно и полностью с помощью типов схемы, которые обычно используются для [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] программирования, таких как формат DTD или XSD. Другой причиной является расширяемости и сопоставления типов возможности языка XAML препятствуют полноте представления допустимых типов и членов.  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a>Синтаксис объектных элементов  
 *Синтаксис элемента объекта* является синтаксиса разметки XAML, который создает экземпляры CLR-класса или структуры путем объявления XML-элемента. Этот синтаксис похож на синтаксис элемента других языков разметки, таких как HTML. Синтаксис элемента объекта начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, создание экземпляров. Ноль или более пробелов можно использовать имя типа и ноль или более атрибутов также может быть объявлен с одним или несколькими пробелами, отделяя каждое имя атрибута в элементе объекта = пару «значение». Наконец должна быть одна из следующих true:  
  
-   Элемент и тег должны быть закрыты косой черты (/), за которым следует по правой угловой скобки (>).  
  
-   Открывающий тег должен выполнять правой угловой скобки (>). Другие элементы объектов, свойств элементов или внутренний текст, можно выполнить открывающего тега. Точно содержимого могут содержаться здесь обычно ограничивается объектной модели элемента. Эквивалентный закрывающий тег для элемента объекта необходимо также существует в правильной вложенности и балансировать с других открывающий и закрывающий тег пары.  
  
 В языке XAML, реализованном в .NET имеет набор правил, которые сопоставляют элементы объекта с типами, атрибуты в свойства или события и пространства имен языка XAML для среды CLR и сборки. WPF и .NET Framework, элементы объекта XAML сопоставляются с [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] типов, как определено в ссылочных сборках, а атрибуты сопоставляются с членами этих типов. При ссылке на тип CLR, в XAML имеется доступ к унаследованным членам этого типа также.  
  
 Например, ниже приведен синтаксис элемента объекта, который создает новый экземпляр <xref:System.Windows.Controls.Button> класса, а также задает <xref:System.Windows.FrameworkElement.Name%2A> атрибут и значение этого атрибута:  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 Ниже приведен синтаксис элемента объекта, который также включает синтаксис свойства содержимого XAML. Внутренний текст, содержащийся в будет использоваться для задания <xref:System.Windows.Controls.TextBox> свойством содержимого XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a>Модели содержимого  
 Класс может поддерживать использование в качестве элемента объекта XAML в рамках синтаксиса, но этот элемент будет работать должным образом в приложении или на странице только помещенный в ожидаемое положение в целом содержимого модели или в дереве элементов. Например <xref:System.Windows.Controls.MenuItem> следует обычно размещаться только как дочерний <xref:System.Windows.Controls.Primitives.MenuBase> производного класса, такие как <xref:System.Windows.Controls.Menu>. Содержимое модели для определенных элементов описаны как часть примечаний на страницах класса для элементов управления и других [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классы, которые можно использовать в качестве элементов XAML.  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a>Свойства элементов объекта  
 Свойства в XAML задаются набором возможных синтаксисов. Какой синтаксис может использоваться для конкретного свойства будет зависеть от базовых характеристик системы тип свойства, которое вы настраиваете.  
  
 Задавая значения свойств, добавьте функции и характеристики объектов согласно они существуют в графике объектов времени выполнения. Начальное состояние объекта, созданного из элемента объекта основан на поведение конструктора по умолчанию. Как правило приложение будет использовать нечто, отличное от экземпляр по умолчанию полностью любого объекта.  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a>Синтаксис атрибутов (свойства)  
 Синтаксис атрибутов является синтаксисом разметки XAML, который задает значение свойства посредством объявления атрибута в элементе существующего объекта. Имя атрибута должно соответствовать имени члена CLR свойства класса, который поддерживает соответствующий элемент объекта. Имя атрибута находится перед оператором присвоения (=). Значение атрибута должно быть строкой, заключенной в кавычки.  
  
> [!NOTE]
>  Разные кавычки можно использовать для размещения литеральные кавычки в пределах атрибут. Для экземпляра можно использовать одинарные кавычки, служащими для объявления строка, содержащая символ двойной кавычки в ней. Можно использовать одинарные или двойные кавычки, следует ли использовать пары для открытия и закрытия строки значения атрибута. Доступны также escape-последовательности и другие методы для обойти ограничения, накладываемые особенностями синтаксиса XAML. В разделе [сущностей символов XML и XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).  
  
 Чтобы задать с помощью синтаксиса атрибута, свойства должен быть открытым и доступным для записи. Значение свойства в системе резервных типов должно быть типом значения или должен быть ссылочного типа, который может создать экземпляр или ссылается обработчик XAML, обратившись к соответствующему резервного типа.  
  
 Для событий WPF XAML события, которое указано как имя атрибута должны быть открытыми и иметь открытый делегат.  
  
 Свойство или событие должно быть членом класса или структуры, экземпляр которого создается, содержащий его элемент объекта.  
  
### <a name="processing-of-attribute-values"></a>Обработка значений атрибутов  
 Строковое значение, содержащееся в открывающих и закрывающих кавычек обрабатывается обработчиком XAML. Для свойств режим обработки по умолчанию определяется типом базового свойства среды CLR.  
  
 Значение атрибута заполняется одним из следующих значений, используя этот порядок обработки:  
  
1.  Если обработчик XAML обнаруживает фигурную скобку или элемент объекта, производного от <xref:System.Windows.Markup.MarkupExtension>, то расширение разметки, на которую указывает ссылка, вычисляется раньше, чем происходит обработка значения как строки и используется в качестве объекта, возвращаемого расширения разметки значение. Во многих случаях объект, возвращаемый расширением разметки будет ссылку на существующий объект или выражение, вычисление которого откладывается до времени выполнения, а не вновь созданный экземпляр объекта.  
  
2.  Если свойство объявлено с атрибутами <xref:System.ComponentModel.TypeConverter>, или тип значения этого свойства, объявленные с атрибутом <xref:System.ComponentModel.TypeConverter>, строковое значение атрибута отправляется в преобразователь типа в качестве входных данных преобразования, и преобразователь вернет новый экземпляр объекта.  
  
3.  При наличии не <xref:System.ComponentModel.TypeConverter>, выполняется попытка прямого преобразования в тип свойства. Этот конечный уровень является прямым преобразованием с собственного средства синтаксического анализа значения между типы-примитивы языка XAML, или проверка имен именованных констант в перечислении (средство синтаксического анализа. затем обращается к совпадающие значения).  
  
#### <a name="enumeration-attribute-values"></a>Значения атрибутов перечисления  
 Перечисления в XAML обрабатываются само по себе средства синтаксического анализа XAML, а члены перечисления должны быть заданы путем указания имени строки в одной из именованных констант перечисления.  
  
 Для значений перечисления nonflag собственное поведение — обработать строки значения атрибута и разрешении его в одно из значений перечисления. Перечисление не указан в формате *перечисления*. *Значение*, как и в коде. Вместо этого укажите только *значение*, и *перечисления* определяется по типу свойства. При указании атрибута в *перечисления*. *Значение* формы, он не будут разрешаться правильно.  
  
 Для флагового перечисления на основе поведения <xref:System.Enum.Parse%2A?displayProperty=nameWithType> метод. Можно указать несколько значений для флагового перечисления, отделяя каждое значение запятой. Однако нельзя объединять значения перечисления, которые не являются flagwise. Например, нельзя использовать синтаксис с запятой попытаться создать <xref:System.Windows.Trigger> , воздействующей на несколько условий перечисления nonflag:  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 В WPF редки флагового перечисления, которые поддерживают атрибуты, которые можно задать в XAML. Тем не менее одного перечисления является <xref:System.Windows.Media.StyleSimulations>. Для экземпляра используйте синтаксис с разделителями запятыми флагового атрибутов для изменения примера, приведенного в комментарии для <xref:System.Windows.Documents.Glyphs> класса; `StyleSimulations = "BoldSimulation"` может стать `StyleSimulations = "BoldSimulation,ItalicSimulation"`. <xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>является другим свойством, где можно указать несколько значений перечисления. Тем не менее, это свойство может быть является особым случаем, поскольку <xref:System.Windows.Input.ModifierKeys> перечисление поддерживает свой собственный преобразователь типов. Преобразователь типов для модификаторов использует знак плюс (+) в качестве разделителя вместо запятой (,). Это преобразование поддерживает традиционный синтаксис обозначения сочетаний клавиш в Microsoft Windows программирования, такие как «Ctrl + Alt».  
  
### <a name="properties-and-event-member-name-references"></a>Свойства и события ссылки на имя члена  
 При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве члена типа среды CLR, который создан для содержащего элемента объекта.  
  
 Или можно ссылаться на вложенное свойство или событие, независимо от содержащего элемента объекта. (Вложенные свойства обсуждаются в следующем разделе).  
  
 Также можно задать имя любого события из любого объекта, доступного через пространство имен по умолчанию с помощью *typeName*. *событие* частично проверенное имя; этот синтаксис поддерживает присоединение обработчиков для перенаправленных событий, где обработчик предназначен для обработки перенаправления событий из дочерних элементов, но родительский элемент не имеет это событие в своей таблице элементов. Этот синтаксис напоминает синтаксис вложенного события, но события не является true вложенное событие. Вместо этого осуществляется ссылка на событие с полным именем. Дополнительные сведения см. в разделе [направлено Общие сведения о событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
 В некоторых случаях имена свойств иногда предоставляются в качестве значения атрибута, а не имя атрибута. Такое имя свойства также может содержать квалификаторы, например свойство, указанное в виде *ownerType*. *dependencyPropertyName*. Этот сценарий характерен при написании стили и шаблоны в XAML. Правила обработки имен свойств, предоставленных в качестве значения атрибута различаются, а также определены типом свойства, задаваемого или поведения конкретной подсистемы WPF. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](../../../../docs/framework/wpf/controls/styling-and-templating.md).  
  
 Другой вариант использования в именах свойств — Если значение атрибута описывает свойство свойств связи. Эта функция используется для привязки данных и раскадровки целей и обеспечивается <xref:System.Windows.PropertyPath> класс и его преобразователя типов. Более полное описание семантики поиска см. в разделе [XAML синтаксическая конструкция PropertyPath](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a>Синтаксис элемента свойства  
 *Синтаксис элемента свойства* является синтаксисом, который отличается от правил для элементов в базовом синтаксисе XML. В XML значение атрибута является строкой, фактически, с единственным возможным вариантом используется формат кодировки строки. В XAML можно назначить другие элементы объекта в качестве значения свойства. Эта возможность включена по синтаксис элемента свойства. Вместо свойства, указанного как атрибут в теге элемента, свойство задается с помощью элемента открывающий тег в *сочетание elementTypeName*. *propertyName* формы, значение свойства, указанного в, а затем закрывается элемент свойства.  
  
 В частности, этот синтаксис начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, в котором синтаксис элемента свойства. Это следуют сразу следует точка (.), затем имя свойства, затем правой угловой скобкой (>). Как и в случае с синтаксисом атрибута, это свойство должно существовать в объявленный открытые члены указанного типа. Значение, присваиваемое свойству содержится в элементе свойства. Как правило значение задается в виде одной или нескольких элементов объекта, поскольку указание объектов как значений является скриптом этот синтаксис элемента свойства предназначен для адреса. Наконец, эквивалентный закрывающий тег, указание же *сочетание elementTypeName*. *propertyName* сочетание должно быть указано в правильном вложении и балансе с другими тегами элемента.  
  
 Например, ниже приведен синтаксис элемента свойства для <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство <xref:System.Windows.Controls.Button>.  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 Значение внутри элемента свойства также может быть задано как внутренний текст, в случаях, когда тип свойства указывается как примитивный тип значения, такие как <xref:System.String>, или где указывается имя перечисления. Эти два варианта использования довольно редки, так как каждый из этих случаев могут использоваться более простой синтаксис атрибута. Один сценарий для заполнения элемента свойства строкой предназначен для свойств, которые не являются свойством содержимого XAML, но по-прежнему используются для представления текста пользовательского интерфейса и отдельных элементов пробелов как символ перевода строки, необходимых в тексте пользовательского интерфейса. Синтаксис атрибута не может сохранять символы переноса строк, но синтаксис элемента свойства может, до тех пор, пока активен сохранение значимых пробелов (Дополнительные сведения см. в разделе [Обработка пробелов в XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)). Другой сценарий, чтобы [x: Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) может применяться к элементу свойства, отметив таким образом значение как значение, которое должно быть локализовано в WPF выходной BAML или с помощью других методов.  
  
 Элемент свойства не представлен в логическом дереве WPF. Элемент свойства является лишь отдельный синтаксис для установки свойства, а не элемент, который имеет экземпляр или резервный объект. (Дополнительные сведения о логическом дереве см. в разделе [деревьев в WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)  
  
 Для свойств, поддерживающих синтаксис атрибутов и свойств элемента два синтаксиса обычно имеют один и тот же результат, несмотря на то, что тонкостей, такие как обработка пробелов может слегка различаться для разных вариантов синтаксиса.  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a>Синтаксис коллекции  
 В спецификации XAML требует реализаций обработчиков XAML для идентификации свойств, где тип значения — это коллекция. Реализация общего обработчика XAML в .NET основана на управляемом коде и средой CLR, и он определяет типы коллекций с помощью одного из следующих:  
  
-   Тип реализует <xref:System.Collections.IList>.  
  
-   Тип реализует <xref:System.Collections.IDictionary>.  
  
-   Тип является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x: Array](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)  
  
 Если тип свойства является коллекцией, тип выводимых коллекции не требуется указывать в разметке в качестве элемента объекта. Вместо этого элементы, которые должны стать элементами в коллекции, указываются как дочерние элементы элемента свойства. Каждый такой элемент вычисляется для объекта во время загрузки и добавить в коллекцию, вызвав метод `Add` метод неявной коллекции. Например <xref:System.Windows.Style.Triggers%2A> свойство <xref:System.Windows.Style> принимает специализированный тип коллекции <xref:System.Windows.TriggerCollection>, который реализует <xref:System.Collections.IList>. Это не обязательно создавать <xref:System.Windows.TriggerCollection> элемент объекта в разметке. Вместо этого укажите один или несколько <xref:System.Windows.Trigger> элементы как элементы в `Style.Triggers` элемент property, где <xref:System.Windows.Trigger> (или производный класс) является ожидаемым типом элемента для строго типизированных и неявные <xref:System.Windows.TriggerCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 Свойство может быть типом коллекции и свойством содержимого XAML для этого типа и производных типов, который рассматривается в следующем разделе этой статьи.  
  
 Элемент неявной коллекции создает элемент в представлении логического дерева, даже если он не отображается в разметке как элемент. Обычно конструктор родительского типа выполняет создание экземпляра коллекции, являющейся одним из его свойств и изначально пустая коллекция становится частью дерева объектов.  
  
> [!NOTE]
>  Универсальные интерфейсы списка и словаря (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются при обнаружении коллекций. Тем не менее, можно использовать <xref:System.Collections.Generic.List%601> классом в качестве базового класса, так как он реализует <xref:System.Collections.IList> напрямую, или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.  
  
 В ссылочных страницах .NET для типов коллекций этот синтаксис с намеренным упущение элемента объекта для коллекции иногда отмечен в разделах синтаксиса XAML как синтаксис неявных коллекций.  
  
 За исключением корневого элемента, каждый элемент объекта в файле XAML, вложенный как дочерний элемент другого элемента, фактически является элемент, который является одно или оба из следующих случаев: член неявного свойства коллекции своего родительского элемента , или элемент, указывающий значение свойства содержимого XAML для родительского элемента (XAML-содержимого, свойств будут рассмотрены в следующем разделе). Иными словами отношений родительских и дочерних элементов в разметке страницы действительно представляет собой один объект в корне, и каждый объектный элемент ниже корня является одним экземпляром, предоставляющим значение свойства родительского объекта, или один из элементов в пределах col lection, который также является значение свойства типа коллекции родительского объекта. Этот принцип единого корня являются общими с XML и часто закрепляется в поведении API-интерфейсы, такие как загрузки XAML <xref:System.Windows.Markup.XamlReader.Load%2A>.  
  
 Ниже приведен синтаксис с элементом объекта для коллекции (<xref:System.Windows.Media.GradientStopCollection>) задан явным образом.  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 Обратите внимание, что не всегда возможно явно объявить коллекции. Например, пытается объявить <xref:System.Windows.TriggerCollection> явным образом в ранее показанном <xref:System.Windows.Style.Triggers%2A> примере произойдет сбой. Явного объявления коллекции необходимо, чтобы класс коллекции поддерживал конструктор по умолчанию и <xref:System.Windows.TriggerCollection> не имеет конструктора по умолчанию.  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a>Свойства содержимого XAML  
 Синтаксис содержимого XAML является синтаксисом, который выполняется только на классы, которые задают <xref:System.Windows.Markup.ContentPropertyAttribute> как часть объявления их класса. <xref:System.Windows.Markup.ContentPropertyAttribute> Ссылается на имя свойства, которое является свойством содержимого для этого типа элементов (включая производные классы). При обработке обработчиком XAML все дочерние элементы или внутренний текст, найденные между открывающим и закрывающим тегами элемента объекта будет назначен в качестве значения свойства содержимого XAML для этого объекта. Вы можете задать явные элементы свойства для свойства содержимого, но это использования обычно не показано в разделах о синтаксисе XAML в справочнике по .NET. Явные/verbose метод имеет случайное значение для ясности разметку или указать ее стиль, но обычно целью свойства содержимого является упрощение разметки, чтобы можно было непосредственно вложить элементы, интуитивно связанные отношением подчинения. Теги элементов свойства для других свойств в элементе не заданы как «содержимое» в strict определение языка XAML; они обрабатываются в порядке обработки синтаксического анализа XAML и не считаются «содержимое».  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a>Значения свойств содержимого XAML должны быть непрерывными  
 Значение свойства содержимого XAML должно быть задано полностью до или после любых других элементов свойств данного элемента объекта. Это верно, является ли значение свойства содержимого XAML указан как строка или как один или несколько объектов. Например следующая разметка не анализируется:  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 Это неверно, поскольку если этот синтаксис не было внесено явной, используя синтаксис элемента свойства для свойства содержимого, то свойство содержимого будет задано дважды:  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 Аналогично неверным примером является, если свойство содержимого представляет собой коллекцию, и дочерние элементы перемежаемых свойств элементов:  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a>Объединение свойства содержимого и синтаксиса коллекции  
 Чтобы принимать несколько элементов объекта в качестве содержимого, тип свойства содержимого обязательно должен быть типом коллекции. Аналогично в синтаксис элемента свойства для типов коллекций, обработчик XAML должен идентифицировать типы, которые являются типами коллекций. Если элемент имеет свойство содержимого XAML и тип свойства содержимого XAML — это коллекция, неявный тип коллекции не требуется указывать в разметке в качестве элемента объекта и свойством содержимого XAML необходимо указать как el свойство ement. Поэтому видимая модель содержимого в разметке теперь может иметь более одного дочернего элемента, назначенных в качестве содержимого. Ниже приведен синтаксис содержимого <xref:System.Windows.Controls.Panel> производного класса. Все <xref:System.Windows.Controls.Panel> свойством содержимого XAML, необходимо установить производные классы <xref:System.Windows.Controls.Panel.Children%2A>, что требует значение типа <xref:System.Windows.Controls.UIElementCollection>.  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 Обратите внимание, что ни элемент свойства для <xref:System.Windows.Controls.Panel.Children%2A> ни элемент для <xref:System.Windows.Controls.UIElementCollection> является обязательным в разметку. Это средство разработки XAML, чтобы рекурсивно содержащиеся элементы, которые определяют [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] были более понятно представлены в виде дерева вложенных элементов с немедленного родительско дочерних отношений элемент, не содержит промежуточных тегов элементов свойства или Коллекция объектов. На самом деле <xref:System.Windows.Controls.UIElementCollection> не может быть явно указан в разметке как элемент объекта намеренно. Так как является предназначен для использования только в качестве неявной коллекции, <xref:System.Windows.Controls.UIElementCollection> не предоставляет открытый конструктор по умолчанию и таким образом, не может быть создан в качестве элемента объекта.  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a>Смешивание элементов свойств и элементов объектов в объекте со свойством содержимого  
 В спецификации XAML объявляет, что обработчик XAML может требовать элементы объектов, которые используются для заполнения свойства содержимого XAML в элементе объекта должны быть непрерывными, которое не должно смешиваться. Это ограничение, запрещающее смешивание элементов свойств и содержимого обеспечивается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обработчики XAML.  
  
 Дочерний элемент объекта может иметь как первый немедленно разметка внутри элемента объекта. Затем можно вводить элементы свойств. Или можно указать один или несколько элементов свойства, затем содержимое, а затем дополнительные элементы свойств. Но после элемента свойства следует за содержимым, нельзя добавлять последующее содержимое, можно добавлять только элементы свойств.  
  
 Это содержимое и свойства элемента заказа требование не относится к внутреннему тексту, используемому в качестве содержимого. Однако она по-прежнему хорошего стиля разметки для сохранения внутренний текст смежными, так как значащие пробелы будет сложно обнаружить визуально в разметке, если элементы свойств смешиваются с внутренним текстом.  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a>Пространства имен языка XAML  
 Ни один из предыдущих примеров синтаксиса указано пространство имен XAML, отличное от пространства имен XAML по умолчанию. В обычных [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложений, пространства имен XAML по умолчанию указывается как [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] пространства имен. Можно указать пространство имен XAML, отличное от пространства имен XAML по умолчанию и по-прежнему использовать аналогичный синтаксис. Но затем, в любом где именуется класс, который недоступен в пространстве имен XAML по умолчанию, имя этого класса должно начинаться с префикса пространства имен XAML как сопоставлен с соответствующим пространством имен CLR. Например `<custom:Example/>` является синтаксис элемента объекта для создания экземпляра `Example` класса, где пространство имен CLR, содержащее этот класс (и, возможно, сведения о внешней сборке, содержащей резервные типы) было предварительно сопоставлено `custom` префикс.  
  
 Дополнительные сведения о пространствах имен XAML см. в разделе [пространства имен XAML и сопоставление пространства имен WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a>Расширения разметки  
 Код XAML определяет программную сущность, которая позволяет выйти за рамки обычной обработки процессором XAML строковых атрибутов или элементов объектов и переложить обработку на вспомогательный класс расширения разметки. Символ, который определяет расширения разметки для обработчика XAML при использовании синтаксис атрибутов, открывающая фигурная скобка ({}), следуют любой символ, отличный от закрывающей фигурной скобки (}). Первая строка, следующая открывающая фигурная скобка должна ссылаться на класс, предоставляющий определенное расширение поведения, где этой ссылке можно пропустить подстроку «Extension», если эта подстрока является частью истинного имени класса. После этого может использоваться один пробел, и затем каждый последующий знак используется в качестве входных данных реализации расширения, вплоть до появления закрывающую фигурную скобку.  
  
 Реализация .NET XAML использует <xref:System.Windows.Markup.MarkupExtension> абстрактного класса в качестве основы для всех расширений разметки, поддерживаемых [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , а также другие платформы или технологии. Расширения разметки, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] часто реализует специально предназначены для создания ссылок на другие существующие объекты или для предоставления отложенных ссылок на объекты, которые будут вычисляться во время выполнения. Например, простая привязка данных WPF выполняется путем указания `{Binding}` расширения разметки вместо значения, которое обычно принимает определенное свойство. Большинство расширений разметки WPF включает синтаксис атрибута для свойств, где синтаксис атрибутов в противном случае нельзя сделать. Например <xref:System.Windows.Style> объект имеет сложный тип, содержащий серию вложенных объектов и свойств. Стили в WPF обычно определяются как ресурс в <xref:System.Windows.ResourceDictionary>, а затем указываются с помощью одного из двух расширений разметки WPF, запрашивающих ресурс. Расширение разметки откладывает вычисление значения свойства до выполнения поиска ресурса и включает предоставление значение <xref:System.Windows.FrameworkElement.Style%2A> свойства, принимающего объект типа <xref:System.Windows.Style>в атрибут синтаксис, как показано в следующем примере:  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 Здесь `StaticResource` идентифицирует <xref:System.Windows.StaticResourceExtension> класс, предоставляющий реализации расширения разметки. Следующая строка `MyStyle` используется в качестве входных данных для нестандартных <xref:System.Windows.StaticResourceExtension> конструктор, где параметр, принимаемый из строки расширения, объявляет запрашиваемый <xref:System.Windows.ResourceKey>. `MyStyle`должно быть [x: Key](../../../../docs/framework/xaml-services/x-key-directive.md) значение <xref:System.Windows.Style> определяются как ресурсы. [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) использование запрашивает использование ресурсов для предоставления <xref:System.Windows.Style> значение свойства через логику поиска статических ресурсов во время загрузки.  
  
 Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md). Справочную информацию о расширениях разметки и других программирования функции, доступные в общей реализации .NET XAML XAML, см. в разделе [пространства имен XAML (x:) Возможности языка](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md). WPF-расширениях разметки см [расширения XAML WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a>Вложенные свойства  
 Вложенные свойства являются понятием программирования, представленным в XAML, благодаря которым владеет и определяется определенного типа, свойства но устанавливаться как атрибуты или элементы свойства для любого элемента. Основным сценарием, предназначены вложенные свойства, является включение дочерних элементов в структуре разметки для передачи сведений родительскому элементу без осуществления сложного распределения объектной модели для всех элементов. И наоборот вложенные свойства можно использовать с родительскими элементами для передачи сведений дочерних элементов. Дополнительные сведения о назначении вложенных свойств и создании собственных присоединенных свойств см. в разделе [зависимостей](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Вложенные свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в котором также указывается *typeName*. *propertyName* комбинации. Однако имеется два важных отличия.  
  
-   Можно использовать *typeName*. *propertyName* комбинации даже при задании вложенного свойства с помощью синтаксиса атрибутов. Вложенные свойства — это единственный случай, если уточнение имени свойства является обязательным в синтаксисе атрибута.  
  
-   Можно также использовать синтаксис элемента свойства для вложенных свойств. Однако для обычного синтаксиса элемента свойства *typeName* указать, является элементом объекта, содержащим элемент свойства. Если вы ссылаетесь на вложенное свойство, то *typeName* является классом, который определяет присоединенное свойство, не содержащий его элемент объекта.  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a>Вложенные события  
 Вложенные события — это другое понятие программирования, представленное в XAML, где события могут быть определены с помощью определенных типов, но могут быть присоединены обработчики для любого элемента объекта. В реализации WOF часто тип, определяющий вложенное событие является статический тип, который определяет службу, и иногда эти присоединенные события предоставляются с помощью псевдонимов перенаправленных событий в типах, которые предоставляют службу. Обработчики присоединенных событий указываются с помощью синтаксиса атрибутов. Как с вложенными событиями, синтаксис атрибута расширен для присоединенных событий, чтобы разрешить *typeName*. *eventName* использования, где *typeName* является классом, предоставляющим `Add` и `Remove` методы доступа обработчика событий для инфраструктуры присоединенных событий и *eventName* является именем события.  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a>Составляющие корневого элемента XAML  
 В следующей таблице показаны типичные корневой элемент XAML разбивкой, отображающее определенные атрибуты корневого элемента:  
  
|||  
|-|-|  
|`<Page`|Открытие объектного элемента корневого элемента|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|Значение по умолчанию ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) пространства имен XAML|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|Пространства имен XAML языка XAML|  
|`x:Class="ExampleNamespace.ExampleCode"`|Объявление разделяемого класса, связывающее разметку для любого кода, определенные для разделяемого класса|  
|`>`|Конец для корневого элемента объекта. Объект еще не закрыт, поскольку элемент содержит дочерние элементы|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a>Использование необязательное и не рекомендуемое XAML  
 В следующих разделах описаны использований XAML с технической точки зрения, которые поддерживаются обработчики XAML, однако создают детализации или другие внешнего вида проблемы, мешающие XAML-файлов, оставшихся в удобное для восприятия, когда к разработке приложений, содержащих источникам XAML .  
  
### <a name="optional-property-element-usages"></a>Необязательное использование элемента свойства  
 Необязательное использование элемента свойства относится явное объявление свойств содержимого элементов обработчик XAML рассматривает как неявные. Например, при объявлении содержимого <xref:System.Windows.Controls.Menu>, можно явно объявить <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекцию <xref:System.Windows.Controls.Menu> как `<Menu.Items>` тега элемента свойства и поместить каждый <xref:System.Windows.Controls.MenuItem> в `<Menu.Items>`, а чем использование неявное поведение обработчика XAML, все дочерние элементы элемента <xref:System.Windows.Controls.Menu> должно быть <xref:System.Windows.Controls.MenuItem> и помещаются в <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекции. Иногда необязательное использование помогает визуально уточнить структуры объектов, представленных в разметке. Или иногда использование явного свойства элемента можно избежать разметку, технически функциональной, но визуально непонятной, таких как вложенные расширения разметки в значении атрибута.  
  
### <a name="full-typenamemembername-qualified-attributes"></a>Полный typeName.memberName имен атрибутов  
 *TypeName*. *имя пользователя* форму для атрибута фактически работает более универсально, чем только вариант перенаправленного события. В остальных случаях эта форма является избыточной, но следует избегать его, если только по причинам, стиля и удобочитаемости разметки. В следующем примере каждая из трех ссылок на <xref:System.Windows.Controls.Control.Background%2A> атрибута полностью эквивалентны:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 `Button.Background`работает, поскольку полный поиск этого свойства в <xref:System.Windows.Controls.Button> успешно (<xref:System.Windows.Controls.Control.Background%2A> унаследованного от элемента управления) и <xref:System.Windows.Controls.Button> классом элемента объекта или базового класса. `Control.Background`работает, поскольку <xref:System.Windows.Controls.Control> класс фактически определяет <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control> — <xref:System.Windows.Controls.Button> базового класса.  
  
 Тем не менее следующие *typeName*. *имя пользователя* пример элемента form не работает и таким образом маркерами комментария:  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <xref:System.Windows.Controls.Label>является другой класс, производный от <xref:System.Windows.Controls.Control>, и если вы задали `Label.Background` в <xref:System.Windows.Controls.Label> элемент объекта это использование могло бы работать. Тем не менее поскольку <xref:System.Windows.Controls.Label> не является классом или базовым классом для <xref:System.Windows.Controls.Button>, заданное поведение обработчика XAML является последующее `Label.Background` как вложенное свойство. `Label.Background`не является доступным вложенным свойством, и такое использование не удается.  
  
### <a name="basetypenamemembername-property-elements"></a>baseTypeName.memberName свойств элементов  
 В виде аналогом как *typeName*. *имя пользователя* форма работает для синтаксиса атрибутов *Имя_базового_типа*. *имя пользователя* работает для синтаксиса элемента свойства. Например следующий синтаксис работает:  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 Здесь элемент свойства задан как `Control.Background` несмотря на то, что элемент свойства содержались в `Button`.  
  
 Но так же, как *typeName*. *имя пользователя* форму для атрибутов, *Имя_базового_типа*. *имя пользователя* является неудовлетворительным стилем в разметке, и ее следует избегать.  
  
## <a name="see-also"></a>См. также  
 [Общие сведения о языке XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [Возможности пространства имен языка XAML (x:)](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [Расширения XAML WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [Общие сведения о свойствах зависимости](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [TypeConverters и XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)  
 [Код XAML и пользовательские классы для WPF](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
