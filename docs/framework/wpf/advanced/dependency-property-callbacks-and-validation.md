---
title: "Проверка и обратные вызовы свойства зависимостей | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "обратные вызовы, проверка"
  - "обратные вызовы с привязкой к значению"
  - "свойства зависимостей, обратные вызовы"
  - "свойства зависимостей, проверка"
  - "проверка свойств зависимостей"
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
caps.latest.revision: 17
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 16
---
# Проверка и обратные вызовы свойства зависимостей
В этом разделе описывается создание свойства зависимости с помощью альтернативных пользовательских реализаций для функций, связанных со свойствами \(например, для определения проверки\), обратных вызовов, которые вызываются при каждом изменении эффективного значения свойства, и переопределения возможных внешних влияний на определение значения.  В этом разделе также обсуждается сценарии, в которых возможно расширение стандартного поведения системы свойств с помощью этих методов.  
  
   
  
<a name="prerequisites"></a>   
## Предварительные требования  
 Этот раздел предполагает понимание основных скриптов реализации свойства зависимостей и применения метаданных к пользовательскому свойству зависимостей.  Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) и [Метаданные свойства зависимости](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).  
  
<a name="Validation_Callbacks"></a>   
## Обратные вызовы проверки  
 Обратные вызовы проверки могут быть присвоены свойству зависимости при первой регистрации.  Обратный вызов проверки не является частью метаданных свойства; это прямой ввод метода <xref:System.Windows.DependencyProperty.Register%2A>.  Таким образом, как только обратный вызов проверки создан для свойства проверки, он не может быть переопределен новой реализацией..  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 Обратные вызовы реализованы в том виде, в котором они предоставляются значением объекта.  Они возвращают `true`, если предоставленное значение является допустимым для свойства; в противном случае возвращается `false`.  Предполагается, что свойство является допустимым типом согласно типу, зарегистрированному системой свойства, поэтому проверка типов в обратных вызовах обычно не выполняется.  Обратные вызовы используются системой свойства во многих различных операциях.  В их число входят инициализация начального типа значением по умолчанию, программное изменение путем вызова <xref:System.Windows.DependencyObject.SetValue%2A>, а также попытки переопределить метаданные новым предоставленным значением по умолчанию.  Если обратный вызов проверки был вызван любой из этих операций и возвратил `false`, то будет вызвано исключение.  Программисты должны быть готовы обрабатывать эти исключения.  Обычно обратные вызовы проверки используются для проверки числовых значений, ограниченных целых или действительных значений при установке значения свойства в ноль и выше.  
  
 Обратные вызовы проверки предназначены для проверки класса, а не экземпляра данного класса.  Параметры обратного вызова не устанавливают связь с нужным <xref:System.Windows.DependencyObject>, на котором устанавливаются свойства для проверки.  Таким образом, обратные вызовы проверки бесполезны для реализации возможных «зависимостей», способных влиять на значение свойства, в котором относящееся к экземпляру значение свойства не зависит от таких факторов, как значения других свойств, относящиеся к экземпляру класса, или состояние выполнения.  
  
 Ниже приведен пример кода для простого скрипта обратного вызова проверки: проверка того, что введенное как простой тип <xref:System.Double> свойство не является <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity>.  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>   
## Приведенные обратные вызовы значений и события изменения свойств  
 Приведенные обратные вызовы значений передают определенный экземпляр <xref:System.Windows.DependencyObject> для свойств. Это же справедливо для реализаций <xref:System.Windows.PropertyChangedCallback>, вызываемых системой свойств всякий раз, когда меняется значение свойства зависимостей.  Использование сочетания этих обратных вызовов позволяет создать ряд свойств для элементов, в которых изменения в одном свойстве будет принудительно вызывать приведение или переоценку другого свойства.  
  
 Обычным скриптом для использования компоновки свойств зависимостей является следующий: существует управляемое свойство пользовательского интерфейса, где элемент содержит по одному свойству для минимального и максимального значения и третье свойство для фактического или текущего значения.  В этом случае, если максимальное значение была изменено таким образом, что текущее значение превысило новое максимальное, необходимо привести текущее значение к значению, не превышающему новое максимальное, и выполнить аналогичные действия для приведения минимального к текущему.  
  
 Ниже приведен пример очень краткого кода только для одного из трех свойств зависимостей, которые иллюстрируют это отношение.  В примере показана регистрация свойства `CurrentReading` из набора Min\/Max\/Current связанных свойств \*Reading.  Пример использует проверку, рассмотренную в предыдущем разделе.  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 Ответный вызов для Current, измененный свойством, используется для пересылки изменений в другие зависимые свойства путем явного обратного вызова приведенного значения, которое зарегистрировано для других свойств:  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 Приведенный обратный вызов значения проверяет значения свойств, от которых потенциально зависит текущее свойство, и при необходимости осуществляет приведение текущего значения:  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
>  Значения свойств по умолчанию не приводятся.  Значение свойства, равное значению по умолчанию, может использоваться, если оно по\-прежнему имеет свое начальное значение или путем очистки других значений с помощью <xref:System.Windows.DependencyObject.ClearValue%2A>.  
  
 Приведенное значение и обратный вызов, измененный свойством, являются частью метаданных свойства.  Это позволяет изменить обратные вызовы для конкретного свойства зависимостей путем переопределения метаданных для свойства в типе, так как оно существует в типе, который является производным типом из типа, содержащего свойство зависимости.  
  
<a name="Advanced"></a>   
## Дополнительные сценарии приведения и обратного вызова  
  
### Ограничения и требуемые значения  
 Обратные вызовы <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> будут использоваться системой свойства для присвоения значения в соответствии с объявленной разработчиком логикой, но приведенное значение локально заданного свойства будет по\-прежнему внутренне сохранять «требуемое значение».  Если ограничения основаны на других значениях свойств, которые могут динамически измениться в течение времени жизни приложения, то приведенные ограничения также изменяются динамически, а ограниченное свойство может изменить свое значение, чтобы получить значение, более близкое к требуемому с учетом новых ограничений.  Значение станет требуемым, если все ограничения сняты.  Потенциально можно ввести некоторые довольно сложные сценарии зависимостей при наличии нескольких свойств, которые циклически зависят друг от друга.  Например, в сценарии Min\/Max\/Current можно предоставить пользователю установку минимального и максимального значения.  В этом случае может потребоваться установить условие, чтобы максимальное значение всегда было больше минимального и наоборот.  Но если приведение активно, и максимальное значение приводится к минимальному, оно оставляет текущее в неопределенном состоянии, так как зависит от них обоих и ограничено диапазоном между значениями, который равен нулю.  Затем, если максимальное или минимальное значение настраиваются, будет казаться, что текущее значение будет «следовать» за одним из значений, поскольку требуемое текущее значение по\-прежнему хранится и пытается достичь требуемого по мере ослабления ограничений.  
  
 В сложных зависимостях нет ничего технически неправильного, но они могут привести к падению производительности, если потребуют большого количества переустановок, а также могут ввести в заблуждение пользователей, если напрямую влияют на пользовательский интерфейс.  Будьте внимательны с обратными вызовами измененных свойств и приведенных значений и убедитесь в том, что попытка приведения не может быть рассмотрена двусмысленно и не вызовет «сверхограничений».  
  
### Использование CoerceValue для отмены изменений значения  
 Система свойств будет рассматривать любой <xref:System.Windows.CoerceValueCallback>, который возвращает значение <xref:System.Windows.DependencyProperty.UnsetValue>, как особый случай.  Рассмотрение в качестве особого случая означает то, что изменение свойства, отразившееся в вызове <xref:System.Windows.CoerceValueCallback>, должно быть отклонено системой свойств, а также то, что система свойства вместо этого может сообщить предыдущее значение свойства.  Этот механизм может быть полезен для проверки того, что асинхронно инициированные изменения свойства все еще является допустимым для текущего состояния объекта и запрещения изменений в противном случае.  Другим возможным скриптом является скрипт, в котором разработчик может выборочно запретить значение в зависимости от того, какой компонент определения значения свойства отвечает за отправленное значение.  Для этого следует использовать <xref:System.Windows.DependencyProperty>, переданное в обратном вызове, и идентификатор свойства в качестве входных данных для <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, а затем обработать <xref:System.Windows.ValueSource>.  
  
## См. также  
 [Общие сведения о свойствах зависимости](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   
 [Метаданные свойства зависимости](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md)   
 [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)