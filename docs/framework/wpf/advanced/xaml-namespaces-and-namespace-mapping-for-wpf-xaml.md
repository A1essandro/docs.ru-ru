---
title: "Пространства имен XAML и сопоставление пространств имен для WPF XAML | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "сборки, отображение пространств имен на"
  - "классы, отображение пространств имен на"
  - "пользовательские классы, отображение пространств имен на"
  - "отображение пространств имен"
  - "отображение пространств имен"
  - "пространства имен"
  - "XAML, отображение пространств имен"
  - "XAML, пространства имен"
ms.assetid: 5c0854e3-7470-435d-9fe2-93eec9d3634e
caps.latest.revision: 23
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 22
---
# Пространства имен XAML и сопоставление пространств имен для WPF XAML
В этом разделе обосновывается наличие и рассматриваются цели сопоставления двух пространств имен XAML, обычно содержащихся в корневом теге файлов WPF XAML.  Также дается описание способов создания аналогичных сопоставлений для использования элементов, заданных в коде и\/или в отдельных сборках.  
  
   
  
## Общие сведения о пространстве имен XAML  
 Пространство имен XAML — это расширенная версия пространства имен XML.  При указании пространства имен XAML используется синтаксис пространства имен XML: соблюдается принцип использования URI\-адресов в качестве идентификаторов пространств имен, использование префиксов, позволяющих указать несколько пространств имен с общим исходным кодом разметки и т. п.  Основное нововведение в определении пространства имен XML, используемом в XAML, заключается в том, что пространство имен XAML неявно задает область уникальности используемой разметки и при этом влияет на возможное дополнение сущностей разметки определенными пространствами имен CLR и указанными в них сборками.  Последний фактор обусловлен в том числе природой контекста схемы XAML.  Впрочем, в отношении взаимодействия WPF с пространствами имен XAML можно рассматривать пространства имен XAML с учетом пространства имен XAML по умолчанию, пространства имен языка XAML и любых других пространств имен XAML, напрямую сопоставленных в разметке XAML с дополняющими их пространствами имен CLR и указанными в них сборками.  
  
<a name="The_WPF_and_XAML_Namespace_Declarations"></a>   
## WPF и объявления пространства имен XAML  
 В объявлении пространства имен в корневом теге многих XAML\-файлов, как правило, содержатся два объявления пространства имен XML.  Первое объявление задает сопоставление для общего пространства имен клиента WPF\/платформы XAML как для пространства имен по умолчанию:  
  
 `xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`  
  
 Второе объявление сопоставляет отдельное пространство имен XAML, сопоставляя его \(обычно\) с префиксом `x:`.  
  
 `xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`  
  
 Связь между этими объявлениями состоит в том, что сопоставление префикса `x:` поддерживает встроенные функции, которые являются частью определения языка XAML, и [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является реализацией, которая использует XAML в качестве языка и определяет словарь объектов для XAML.  Так как использование словаря WPF более распространено, чем использование встроенных функций XAML, словарь WPF сопоставляется по умолчанию.  
  
 Поддержка соглашения префикса `x:` для сопоставления встроенных функций языка XAML также используется в шаблонах проектов, образцах кода и документации по возможностям языка в этом [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)].  Пространство имен XAML определяет многие часто используемые функциональные возможности, которые необходимы даже для основных приложений WPF.  Например, чтобы присоединить какой\-либо код к XAML\-файлу через разделяемый класс, необходимо именовать класс как атрибут `x:Class` в корневом элементе соответствующего XAML\-файла.  Или же любой элемент, определенный на XAML\-странице, к которой необходимо получить доступ в качестве ключевого ресурса, должен иметь набор атрибутов `x:Key` элемента в вопросе.  Дополнительные сведения об этих и других аспектах XAML см. в разделах [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md) и [Подробное описание синтаксиса XAML](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).  
  
<a name="Mapping_To_Custom_Classes_and_Assemblies"></a>   
## Сопоставление пользовательских классов и сборок  
 Можно сопоставить пространства имен XML со сборками, используя серии токенов в объявлениях префиксов `xmlns`, аналогично тому, как стандартные пространства имен WPF и встроенных функций XAML сопоставляются с префиксами.  
  
 Синтаксис допускает следующие возможные именованные маркеры и следующие значения:  
  
 `clr-namespace:` Пространство имен CLR объявлено внутри сборки, которая содержит открытые типы, предоставленные как элементы.  
  
 `assembly=` Сборка, которая содержит некоторые или все указанные пространства имен [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  Это значение обычно содержит имя файла сборки, а не пути, и не включает расширение имени файла \(например, EXE или DLL\).  Путь к этой сборке должен быть установлен в качестве ссылки проекта в файле проекта, который содержит XAML, который следует сопоставить.  Чтобы включить отслеживание версий и подписи строгого имени, значение `assembly` может быть строкой, которая определяется классом <xref:System.Reflection.AssemblyName>, а не простым именем строки.  
  
 Обратите внимание, что маркер `clr-namespace`  отделяется от его значения двоеточием \(:\), тогда как маркер `assembly` отделяется от значения знаком равенства \(\=\).  Эти два маркера разделяются точкой с запятой.  Также не включайте пробел где\-либо в объявлении.  
  
### Простой пример пользовательского сопоставления  
 В следующем примере кода определяется пользовательский класс:  
  
```csharp  
namespace SDKSample {  
    public class ExampleClass : ContentControl {  
        public ExampleClass() {  
        ...  
        }  
    }  
}  
```  
  
```vb  
Namespace SDKSample  
    Public Class ExampleClass  
        Inherits ContentControl  
         ...  
        Public Sub New()  
        End Sub  
    End Class  
End Namespace  
```  
  
 Затем пользовательский класс компилируется в библиотеку, которая согласно параметрам проекта \(не показано\) имеет имя `SDKSampleLibrary`.  
  
 Для ссылки на этот пользовательский класс также следует включить его в качестве ссылки на текущий проект, что обычно делается с помощью интерфейса пользователя обозревателя решений в Visual Studio.  
  
 Теперь есть библиотека с классом и ссылка на него в параметрах проектах и можно добавить следующее сопоставление префикса как часть корневого элемента в XAML:  
  
 `xmlns:custom="clr-namespace:SDKSample;assembly=SDKSampleLibrary"`  
  
 Чтобы собрать это все вместе, используется следующий XAML, в который включено пользовательское сопоставление с обычным сопоставлением и сопоставлением x: в корневом теге. Затем используется ссылка на префикс для создания экземпляра `ExampleClass` в этом интерфейсе пользователя:  
  
```xaml  
<Page x:Class="WPFApplication1.MainPage"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"   
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    xmlns:custom="clr-namespace:SDKSample;assembly=SDKSampleLibrary">  
  ...  
  <custom:ExampleClass/>  
...  
</Page>  
```  
  
### Сопоставление с текущими сборками  
 Можно опустить `assembly`, если указанное пространство имен `clr-namespace`, определенное в этой сборке в качестве кода приложения, ссылается на пользовательские классы.  Или аналогичный способ для этого случая ― указание `assembly=` с нестроковым маркером после знака равенства.  
  
 Пользовательские классы нельзя использовать в качестве корневого элемента страницы, если они определены в той же сборке.  Разделяемые классы не требуют сопоставления; должны быть сопоставлены только классы, которые не являются разделяемыми классами страницы в приложении, если планируется ссылка на них как на элементы в XAML.  
  
<a name="Mapping_CLR_Namespaces_to_XML_Namespaces_in_an"></a>   
## Сопоставление пространств имен CLR с пространствами имен XML в сборке  
 WPF определяет атрибут CLR, который обрабатывается процессорами XAML по порядку для сопоставления нескольких пространств имен CLR с одним пространством имен XAML.  Этот атрибут <xref:System.Windows.Markup.XmlnsDefinitionAttribute> помещается на уровне сборки в исходном коде, который создает сборку.  Исходный код сборки использует этот атрибут для сопоставления различных общих пространств имен, например <xref:System.Windows> и <xref:System.Windows.Controls>, с пространством имен [!INCLUDE[TLA#tla_wpfxmlnsv1](../../../../includes/tlasharptla-wpfxmlnsv1-md.md)].  
  
 Атрибут <xref:System.Windows.Markup.XmlnsDefinitionAttribute> принимает два параметра: имя пространства имен XML\/XAML и CLR.  Может существовать несколько <xref:System.Windows.Markup.XmlnsDefinitionAttribute> для сопоставления нескольких пространств имен CLR с тем же пространством имен XML.  После сопоставления на члены этих пространств имен при желании можно ссылаться без указания полного имени, предоставляя соответствующую инструкцию `using` на странице программного кода разделяемого класса.  Дополнительные сведения см. в разделе <xref:System.Windows.Markup.XmlnsDefinitionAttribute>.  
  
## Пространство имен разработчика и другие префиксы из шаблонов XAML  
 При работе в средах разработки или со средствами разработки для WPF XAML можно заметить, что в элементах разметки XAML определены и другие пространства имен\/префиксы XAML.  
  
 В [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] используется пространство имен разработчика, обычно сопоставляемое с префиксом `d:`.  В новейших шаблонах проектов для WPF это пространство имен XAML иногда заранее сопоставляется так, чтобы обеспечить поддержку переноса XAML\-кода между [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] и другими средами разработки.  Это пространство имен разработчика XAML используется для сохранения состояния среды разработки при переносе пользовательского интерфейса, созданного на основе XAML, из одного средства разработки в другое.  Оно также используется в таких функциях как `d:IsDataSource`, позволяющих использовать источники данных среды выполнения в средстве разработки.  
  
 Среди сопоставленных префиксов также встречается `mc:`.  Префикс `mc:` используется для обеспечения совместимости разметки. С его помощью можно обеспечить шаблон совместимости не только для языка XAML.  Функции обеспечения совместимости разметки в некоторой степени можно использовать для обмена XAML\-кодом между различными платформами, взаимодействия между различными схемами XAML, обеспечения совместимости для ограниченных режимов в средствах разработки и т. п.  Дополнительные сведения о принципах обеспечения совместимости разметки и их применении к WPF см. в разделе [Совместимость разметки \(mc:\) языковые компоненты](../../../../docs/framework/wpf/advanced/markup-compatibility-mc-language-features.md).  
  
## WPF и загрузка сборок  
 Контекст схемы XAML для WPF тесно связан с моделью приложения WPF, которая, в свою очередь, использует определенное в среде CLR понятие <xref:System.AppDomain>.  В следующей последовательности показано, как контекст схемы XAML интерпретирует либо порядок загрузки сборок, либо поиска типов во время выполнения или во время разработки, основываясь на использовании <xref:System.AppDomain> в WPF и других факторах.  
  
1.  Здесь выполняется перебор объектов <xref:System.AppDomain> с целью поиска уже загруженной сборки, соответствующей всем аспектам имени, начиная с последней загруженной сборки.  
  
2.  Если определено полное имя, вызовите метод <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName> для полного имени.  
  
3.  Если сборке, из которой была загружена разметка, соответствует сочетание "короткое имя \+ токен открытого ключа полного имени", возвратите эту сборку.  
  
4.  Используйте сочетание "короткое имя \+ токен открытого ключа" для вызова метода <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=fullName>.  
  
5.  Если определено неполное имя, вызовите метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=fullName>.  
  
 Свободный XAML не использует шаг 3, поскольку здесь нет сборки, из которой выполнялась загрузка.  
  
 Скомпилированный XAML для WPF \(сформированный с помощью XamlBuildTask\) не использует уже загруженные сборки из <xref:System.AppDomain> \(шаг 1\).  Кроме того, имя из выходных данных XamlBuildTask не должно быть неполным, поэтому шаг 5 не применяется.  
  
 Скомпилированный BAML \(сформированный с помощью PresentationBuildTask\) использует все шаги, хотя BAML также не должен содержать неполные имена сборок.  
  
## См. также  
 [Understanding XML Namespaces](http://go.microsoft.com/fwlink/?LinkId=98069)   
 [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)