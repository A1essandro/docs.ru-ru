---
title: "Свойства зависимости &quot;только для чтения&quot; | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "свойства зависимостей, только для чтения"
  - "свойства зависимостей "только для чтения""
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
caps.latest.revision: 8
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 7
---
# Свойства зависимости &quot;только для чтения&quot;
В этом разделе описаны свойства зависимости «только для чтения», включая существующие свойства зависимости «только для чтения», сценарии и методики создания пользовательского свойства зависимости только для чтения.  
  
   
  
<a name="prerequisites"></a>   
## Предварительные требования  
 Этот раздел предполагает понимание основных скриптов реализации свойства зависимостей и применения метаданных к пользовательскому свойству зависимостей.  Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) и [Метаданные свойства зависимости](../../../../docs/framework/wpf/advanced/dependency-property-metadata.md).  
  
<a name="existing"></a>   
## Существующие свойства зависимости только для чтения  
 Некоторые свойства зависимостей, определенные в оболочке [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], доступны только для чтения.  Типичной причиной для указания свойства зависимости только для чтения является то, что эти свойства следует использовать для определения состояния там, где на это состояние влияет множество факторов и установление свойства в это состояние не желательно с точки зрения разработки интерфейса пользователя.  Например, свойство <xref:System.Windows.UIElement.IsMouseOver%2A> действительно только отображает состояние, определенное вводом с помощью мыши.  Любая попытка задать это значение программным путем в обход истинного значения входных данных с мыши будет непредсказуема и может привести к несогласованности.  
  
 На основании того, что оно является неустанавливаемым, свойство зависимость только для чтения не подходит для множества скриптов, для которых свойства зависимости обычно предлагают решение \(а именно: привязка данных, непосредственное изменение стиля значения, проверка, анимация, наследование\).  Несмотря на то, что оно является неустанавливаемым, свойства зависимости только для чтения все еще имеют некоторые дополнительные возможности, поддерживаемые свойствами зависимости в системе свойств.  Наиболее важной оставшейся возможностью является то, что свойство зависимости только для чтения может по\-прежнему использоваться как триггер свойства в стиле.  Вас не удастся включить триггеры со обычным свойством [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]; оно должно быть свойством зависимости.  Вышеупомянутое свойство <xref:System.Windows.UIElement.IsMouseOver%2A> является отличным примером скрипта, в котором может оказаться весьма полезными определение стиля элемента управления, где некоторые отображаемые свойство, такие как фоновый рисунок, основной цвет или похожие свойства сложных элементов в элементе управления будут изменяться при перемещении пользователем мыши в некоторую определенную область элемента управления.  Изменения в свойстве зависимости только для чтения также могут быть обнаружены и извещены в процессе проверки системы свойств, и фактически поддерживает внутри себя триггеры свойств  
  
<a name="new"></a>   
## Создание пользовательского свойства зависимостей только для чтения  
 Убедитесь, что вы ознакомлены с разделом выше, касающимся того, почему свойства зависимости только для чтения свойства не работают для многих типичных скриптов свойств зависимости.  Но если имеется соответствующий скрипт, может потребоваться создание собственного свойства зависимости только для чтения.  
  
 Большая часть процесса создания свойства зависимости только для чтения похожа совпадает с тем, что описывается в разделах [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) и [Реализация свойства зависимостей](../../../../docs/framework/wpf/advanced/how-to-implement-a-dependency-property.md).  Существуют три важных отличия:  
  
-   При регистрации свойства следует вызвать метод <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> вместо обычного метода <xref:System.Windows.DependencyProperty.Register%2A> для регистрации свойства.  
  
-   При реализации свойства «оболочки» [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], убедитесь, что оболочка не имеет реализации набора, таким образом, отсутствует несогласованность в состоянии только для чтения предоставляемой открытой оболочки.  
  
-   Объект, возвращаемый при регистрации только для чтения, является <xref:System.Windows.DependencyPropertyKey>, а не <xref:System.Windows.DependencyProperty>.  Вам все еще следует хранить это поле в качестве члена, но обычно его не следует делать открытым членом типа.  
  
 Любое закрытое поле или значение, куда было осуществлено резервирование свойства зависимости только для чтения, разумеется, может быть полностью записываемым с помощью любой логики.  Однако, наиболее простым способом задать свойство изначально или как часть логики выполнения является использование [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] системы свойств, вместо обхода системы свойств и непосредственной настройки закрытого резервного поля.  В частности, имеется подпись <xref:System.Windows.DependencyObject.SetValue%2A>, которая принимает параметр из типа <xref:System.Windows.DependencyPropertyKey>.  Как и где значение этого параметра будет установлено программным способом в логике приложения, повлияет на то, как можно установить доступ к <xref:System.Windows.DependencyPropertyKey>, созданному при первой регистрации свойства зависимости.  Если эта логики обработана внутри класса, ее можно сделать закрытой, или, если требуется ее установка из других частей сборки, это следует задать вручную.  Одним из подходов является вызов <xref:System.Windows.DependencyObject.SetValue%2A> внутри обработчика событий класса соответствующего события, сообщающего экземпляру класса, что требуется изменение значения хранимого свойства.  Другой подход заключается в связывании свойств зависимости с помощью парных обратных вызовов <xref:System.Windows.PropertyChangedCallback> и <xref:System.Windows.CoerceValueCallback>, как часть свойств метаданные во время регистрации.  
  
 Поскольку <xref:System.Windows.DependencyPropertyKey> является закрытым и не распространяется системой свойств вне вашего кода, свойству зависимости только для чтения лучше иметь безопасность настроек, чем свойство зависимости для чтения и записи.  Для свойства зависимости для чтения и записи идентифицирующее поле является явно или неявно открытым и, таким образом, свойство является широко устанавливаемым.  Дополнительные особенности см. в разделе [Безопасность свойства зависимости](../../../../docs/framework/wpf/advanced/dependency-property-security.md).  
  
## См. также  
 [Общие сведения о свойствах зависимости](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   
 [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)   
 [Стилизация и использование шаблонов](../../../../docs/framework/wpf/controls/styling-and-templating.md)