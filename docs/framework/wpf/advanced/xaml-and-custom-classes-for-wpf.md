---
title: "Код XAML и пользовательские классы для WPF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "классы, пользовательские классы в XAML"
  - "пользовательские классы в XAML"
  - "XAML, пользовательские классы"
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
caps.latest.revision: 22
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 21
---
# Код XAML и пользовательские классы для WPF
В соответствии с реализацией в языке XAML [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] границы поддерживают возможность указывать пользовательские класс или структуру в любых  [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] язык, а затем получить доступ к такой класс с помощью разметки XAML.  В одном файле разметки можно использовать сочетание заданных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML.  В этом разделе обсуждаются требования, пользовательский класс должен удовлетворять как использовать как элемент XAML.  
  
   
  
<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## Пользовательские классы в приложениях или сборках  
 Пользовательские классы, которые используются в языке XAML можно указать в определенных случаях: 2 в пределах фонового кода или другого кода, который создает первичное [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] приложение или как класс в отдельной сборке, что и исполняемый файл или библиотеку DLL, используемые как библиотека классов.  Каждый из этих подходов имеет определенные преимущества и недостатки.  
  
-   Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями.  Отдельные библиотеки также делает проблемы управления версиями приложений более простым наблюдение и упрощает создание класса, в котором заданное потребление класса в качестве корневого элемента на странице язык XAML.  
  
-   Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.  
  
-   Требуется, задано ли в том же или другой сборке, пользовательские классы быть сопоставленным между пространством имен среды CLR и пространство имен XML для использования в языке XAML как элементы.  См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## Требования к пользовательскому классу как элементу XAML  
 Чтобы обеспечить себе возможность создания в качестве объектного элемента, класс должен удовлетворять следующим требованиям:  
  
-   Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию \(без параметров\).  \(Примечания о структурах см. в следующем разделе.\)  
  
-   Пользовательский класс не должен быть вложенным классом.  Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтует с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как подключенные свойства.  
  
 В дополнение к разрешению синтаксиса элемента объекта, определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения.  Это происходит потому, что объект теперь может быть создан в качестве элемента объекта и может заполнить значение элемента такого свойства.  
  
### Структуры  
 Структуры, определенные как пользовательские типы может всегда быть построения в языке XAML in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] . Это происходит потому, что  [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] компиляторы неявно создают конструктор по умолчанию для структуры, инициализирует все значения свойства с их значениями по умолчанию.  В некоторых случаях поведение конструктора по умолчанию или использование элементов объекта для структуры является нежелательным.  Это возможно в тех случаях, когда структура используется в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение.  Примером такой структуры в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является <xref:System.Windows.GridLength>.  Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры.  Структура также должна реализовывать аналогичное поведение для конструкции кода с помощью конструктора, не являющегося конструктором по умолчанию.  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## Требования к свойствам пользовательского класса как атрибутам XAML  
 Свойства должны ссылаться на тип, передаваемый по значению \(такой как примитив\), или использовать класс для типа, имеющего конструктор по умолчанию или преобразователь выделенного типа, к которому может получить доступ процессор XAML.  В реализации XAML среды CLR процессоры XAML находят такие преобразователи с помощью собственной поддержки примитивов языка либо с помощью приложения <xref:System.ComponentModel.TypeConverterAttribute> к типу или элементу в определениях резервных типов  
  
 Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс.  Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые производятся от абстрактного класса.  
  
 Свойства могут быть объявлены в абстрактном классе, но могут быть установлены только в практических классах, производных от абстрактных классов.  Это объясняется тем, что для создания элемента объекта для класса в целом требуется открытый конструктор по умолчанию в классе.  
  
### Синтаксис включенного атрибута TypeConverter  
 Если поддерживается выделенный атрибутивный преобразователь типов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа.  Преобразователь типа не включает использование элемента объекта типа — только наличие конструктора по умолчанию для данного типа развешает использование элемента объекта.  Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис элемента объекта.  Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку.  На самом деле, такое использование эквивалентно использованию синтаксиса атрибута, и оно не часто применяется, если нет необходимости в более надежной обработке пробелов в значении атрибута.  Например, ниже приведено использование элемента свойства, который принимает строку, а использование атрибута эквивалентно:  
  
 [!code-xml[XamlOvwSupport#GoofyTCPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xml[XamlOvwSupport#GoofyTCPE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 Примеры свойств, где синтаксис атрибута разрешен только синтаксиса элемента свойства, содержащий элемент объекта запрещены по XAML различные свойства, принимающие <xref:System.Windows.Input.Cursor> этот тип.  Класс <xref:System.Windows.Input.Cursor> имеет выделенный преобразователь типа <xref:System.Windows.Input.CursorConverter>, но не предоставляет конструктор по умолчанию, поэтому свойство <xref:System.Windows.FrameworkElement.Cursor%2A> может быть установлено только через синтаксис атрибута, даже если фактический тип <xref:System.Windows.Input.Cursor> является ссылочным типом.  
  
### Преобразователь типа каждого свойства  
 В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств.  Это допускает "мини\-язык", который создает объекты типа встроенного свойства путем обработки входящих строковых значений атрибута в качестве входных данных для операции <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>, основанной на соответствующем типе.  Обычно это делается, чтобы обеспечить метод доступа удобства, а не как единственное означает включать задания свойства в XAML.  Кроме того, можно также использовать преобразователь типов для атрибутов, если необходимо использовать существующие типы [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которые не предоставляют конструктор по умолчанию или преобразователь типов атрибутов.  Примеры из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API некоторые свойства, которые принимают  <xref:System.Globalization.CultureInfo> этот тип.  В этом случае [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использовал существовать [!INCLUDE[TLA#tla_winfx](../../../../includes/tlasharptla-winfx-md.md)] <xref:System.Globalization.CultureInfo> введите для улучшения сценарии совместимости и миграции адреса, которые использовались в более ранних версиях платформы, но  <xref:System.Globalization.CultureInfo> тип не поддерживает необходимые конструкторы или преобразование типов тип\-уровня будет использовать в качестве значения свойства XAML напрямую.  
  
 При каждом предоставлении свойства, использующего XAML \(особенно в том случае, если вы являетесь автором элемента управления\), следует принять во внимание необходимость резервного копирования этого свойства с помощью свойства зависимостей.  Это особенно верно при использовании существовать [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] реализация процессора XAML, поскольку можно повысить производительность с помощью  <xref:System.Windows.DependencyProperty> поддержка.  Свойство зависимостей предоставит возможности системы свойств для данного свойства, так что пользователям будет поставлено доступное свойство XAML.  В это число входят такие возможности как анимация, привязка данных и поддержка стилей.  Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).  
  
### Написание и установка атрибутов преобразователя типов  
 Иногда бывает необходимо написать пользовательский производный класс <xref:System.ComponentModel.TypeConverter>, чтобы предоставить преобразование для типа свойства.  Информация о производных классах и способе создания преобразователя типов, поддерживающего использование XAML, и о способах применения объекта <xref:System.ComponentModel.TypeConverterAttribute> см. в разделе [TypeConverters и XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса  
 Чтобы использоваться в качестве события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], событие должно быть предоставлено в качестве открытого события класса, поддерживающего конструктор по умолчанию, или абстрактного класса, где событие может быть доступно из производных классов.  Чтобы событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] могло использоваться как [перенаправленное событие](GTMT), оно должно явным образом реализовывать методы `add` и `remove`, которые добавляют и удаляют обработчики для подписи события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] и направляют эти обработчики в методы <xref:System.Windows.UIElement.AddHandler%2A> и <xref:System.Windows.UIElement.RemoveHandler%2A>.  Эти методы добавляют или удалят обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.  
  
> [!NOTE]
>  Возможно регистрировать обработчики непосредственно для маршрутизируемых событий с помощью <xref:System.Windows.UIElement.AddHandler%2A>, и намеренно не определять событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которое предоставляет [перенаправленное событие](GTMT).  Обычно это не рекомендуется, поскольку событие не включает синтаксис атрибута XAML для вложить обработчики, и результирующий класс предложит меньше прозрачного представления XAML возможностей этого типа.  
  
<a name="Collection_Properties"></a>   
## Написание свойств коллекции  
 Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию.  Этот синтаксис имеет две важные функции.  
  
-   Объект, являющийся объектом коллекции, необязательно определять в синтаксисе элемента объекта.  Присутствие этого типа коллекции подразумевается всякий раз, когда указывается свойство в XAML, принимающее тип коллекции.  
  
-   Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы стать элементами коллекции.  Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор.  Но синтаксис языка XAML не поддерживает методы или индексаторы \(исключение: Язык XAML 2009 может поддерживать методы, но использование XAML 2009 ограничивает возможные использования WPF; см. [Возможности языка XAML 2009](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)\).  Очевидно, коллекции являются очень общим требованием для построения дерева элементов, поэтому требуется какой\-нибудь способ заполнения этих коллекций в декларативном XAML.  Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.  
  
 Реализация служб XAML платформы .NET Framework и, таким образом, процессор XAML WPF использует следующее определение того, что составляет свойство коллекции.  Тип свойства должен реализовывать одно из нижеперечисленного:  
  
-   Реализовывать объект <xref:System.Collections.IList>.  
  
-   Реализовывать <xref:System.Collections.IDictionary> или универсальный эквивалент \(<xref:System.Collections.Generic.IDictionary%602>\).  
  
-   Является производным <xref:System.Array> \(дополнительные сведения о массивах в XAML приводится здесь:  [Расширение разметки x:Array](../../../../docs/framework/xaml-services/x-array-markup-extension.md).\)  
  
-   Реализовывать <xref:System.Windows.Markup.IAddChild> \(интерфейс определяется [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]\).  
  
 Каждый из этих типов имеет среды CLR `Add` метод, который используется процессором XAML для добавления элементов в базовой коллекции создать граф объекта.  
  
> [!NOTE]
>  Универсальный шаблон `List` и  `Dictionary` интерфейсы \(<xref:System.Collections.Generic.IList%601> и  <xref:System.Collections.Generic.IDictionary%602>\) не поддерживается для обнаружения коллекции  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Процессор XAML.  Тем не менее можно использовать класс <xref:System.Collections.Generic.List%601> как базовый класс, так как он непосредственно реализует <xref:System.Collections.IList> или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, потому что он непосредственно реализует <xref:System.Collections.IDictionary>.  
  
 При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа.  Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции.  Если свойство является свойством зависимости, то может потребоваться инициалиализация свойства коллекции как части конструктора типа по умолчанию.  Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией.  Экземпляр коллекции должен быть для каждого экземпляра, содержащего тип.  Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Можно реализовать пользовательский тип коллекции для свойства коллекции.  Из\-за неявной обработки свойства коллекции пользовательскому типу коллекции не требуется предоставлять конструктор по умолчанию для неявного использования в XAML.  Однако, при необходимости можно предоставить конструктор по умолчанию для типа коллекции.  Это может быть общемировая практика.  Если не предоставить конструктор по умолчанию, невозможно будет явно объявить коллекцию в качестве элемента объекта.  Некоторые авторы разметок могут предпочесть просмотр явной коллекции в качестве стиля разметки.  Кроме того, конструктор по умолчанию может уменьшить требования к инициализации при создании новых объектов, использующих тип коллекций в качестве значения свойства.  
  
<a name="XAMLCONtent"></a>   
## Объявление свойств содержимого XAML  
 Язык XAML определяет понятие a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] свойство содержимого.  Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML.  Чтобы объявить свойство в качестве свойства содержимого XAML для данного класса, следует применить объект <xref:System.Windows.Markup.ContentPropertyAttribute> как часть определения класса.  Укажите имя предполагаемого свойства содержимого XAML как свойства <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> в атрибуте.  Свойство определяется как строка, а не как конструкция отражения имени как<xref:System.Reflection.PropertyInfo>.  
  
 Можно задать свойство коллекции как свойство содержимого XAML.  Это отражается на использовании этого свойства, так как элемент объекта может иметь один или несколько дочерних элементов без промежуточных элементов объектов коллекции или тегов элементов свойства.  Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к экземпляру коллекции резервного копирования.  
  
 Некоторые существующие свойства содержимого XAML используется тип свойства `Object`.  Это допускает использование свойства содержимого XAML, которое может принимать как простые значения \(например, объект <xref:System.String>\), так и значение объекта с отдельной ссылкой.  Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов.  Типичной причиной построения типа содержимого <xref:System.Object> является поддержка как простых средств добавления содержимого объекта в виде строки \(которая получает обработку представления по умолчанию\), так и улучшенных средств для добавления содержимого объекта, который задает нестандартное представление или дополнительные данные.  
  
<a name="Serializing"></a>   
## Сериализация XAML  
 Для некоторых сценариях, например при создании, то элемента управления, может также потребоваться обеспечить, что любое представление объекта, которое может быть создан в языке XAML можно сериализовать в эквивалентные разметки XAML.  Требования сериализации не описаны в этом разделе.  См. разделы [Общие сведения о разработке управления](../../../../docs/framework/wpf/controls/control-authoring-overview.md) и [Дерево элементов и сериализация](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).  
  
## См. также  
 [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)   
 [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)   
 [Общие сведения о разработке управления](../../../../docs/framework/wpf/controls/control-authoring-overview.md)   
 [Общие сведения о базовых элементах](../../../../docs/framework/wpf/advanced/base-elements-overview.md)   
 [Загрузка кода XAML и свойства зависимостей](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)