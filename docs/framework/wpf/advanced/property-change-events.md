---
title: "События изменения свойств | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "события изменения [WPF], свойство"
  - "создание триггеров свойств [WPF]"
  - "свойства зависимостей [WPF], события изменения"
  - "события [WPF], изменение значений свойств"
  - "определение измененных событий свойств [WPF]"
  - "события изменения свойства [WPF]"
  - "события изменения свойства [WPF], типы"
  - "триггеры свойств [WPF]"
  - "триггеры свойств [WPF], определение"
  - "изменения значений свойств [WPF]"
ms.assetid: 0a7989df-9674-4cc1-bc50-5d8ef5d9c055
caps.latest.revision: 10
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 9
---
# События изменения свойств
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] определяет несколько событий, которые вызываются в ответ на изменение значения свойства.  Часто свойством является [свойство зависимостей](GTMT).  Самим событием иногда является [маршрутизированное событие](GTMT) и иногда — стандартное событие [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)].  Определение события зависит от скрипта, так как некоторые изменения свойств маршрутизируются через дерево элементов, тогда как другие, как правило, влияют только на объект, в котором это свойство изменено.  
  
## Определение события изменения свойства  
 Не все события, сообщающие об изменении свойства явным образом, определяются как событие изменения свойства на основании подписи или именования шаблона.  Как правило, в описании события в документации [!INCLUDE[TLA#tla_sdk](../../../../includes/tlasharptla-sdk-md.md)] указывается, связано ли событие непосредственно с изменением значения свойства и обеспечивает ли оно перекрестные ссылки между свойством и событием.  
  
### События RoutedPropertyChanged  
 Некоторые события используют тип данных события и делегат, который явно используется для событий изменения свойств.  Типом данных события является <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, а делегатом — <xref:System.Windows.RoutedPropertyChangedEventHandler%601>.  Данные события и делегат имеют параметр универсального типа, который используется для указания фактического типа изменения свойства при определении обработчика.  Данные события содержат два свойства — <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> и <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>, которые затем передаются как тип аргумента в данных события.  
  
 "Маршрутизированная" часть имени указывает, что измененное событие свойства зарегистрировано как перенаправленное событие.  Преимуществом маршрутизированного события изменения свойства является то, что верхний уровень элемента управления может получать события изменения свойств, если свойства дочерних элементов \(составные части элемента управления\) изменяют значения.  Например, можно создать элемент управления, который включает элемент управления <xref:System.Windows.Controls.Primitives.RangeBase>, такой как <xref:System.Windows.Controls.Slider>.  Если значение свойства <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> изменяет часть ползунка, может потребоваться обработать эти изменения на родительском элементе управления, а не на этой части.  
  
 Поскольку имеется старое и новое значение, может казаться заманчивым использовать этот обработчик событий в качестве средства проверки значения свойства.  Однако это не является необходимым в большинстве событий изменения свойств.  Как правило, значения предоставляются таким образом, что можно воздействовать на них в других логических областях кода, но в действительности, изменение значений из обработчика событий не рекомендуется, потому что это может привести к непреднамеренной рекурсии, в зависимости от реализации обработчика.  
  
 Если свойством является пользовательское свойство зависимостей или если работа выполняется с производным классом, где определен код экземпляра, то нет лучше механизма для отслеживания изменений свойства, чем система свойств, встроенная в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], которая выполняет обратный вызов <xref:System.Windows.CoerceValueCallback> и <xref:System.Windows.PropertyChangedCallback>.  Дополнительные сведения о том, как можно использовать систему свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] для проверки и приведения, см. в разделах [Проверка и обратные вызовы свойства зависимостей](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md) и [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
### События DependencyPropertyChanged  
 Другая пара типов, которые являются частью скрипта события изменения свойства, это <xref:System.Windows.DependencyPropertyChangedEventArgs> и <xref:System.Windows.DependencyPropertyChangedEventHandler>.  События для этих изменений свойств не маршрутизируются, они являются стандартными событиями [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  Объект <xref:System.Windows.DependencyPropertyChangedEventArgs> является нестандартным типом отчета о данных события, так как он не унаследован от объекта <xref:System.EventArgs>; <xref:System.Windows.DependencyPropertyChangedEventArgs> представляет собой структуру, а не класс.  
  
 События, которые используют <xref:System.Windows.DependencyPropertyChangedEventArgs> и <xref:System.Windows.DependencyPropertyChangedEventHandler>, являются более общими, чем события `RoutedPropertyChanged`.  Примером события, которое использует эти типы, является <xref:System.Windows.UIElement.IsMouseCapturedChanged>.  
  
 Подобно <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, <xref:System.Windows.DependencyPropertyChangedEventArgs> также предоставляет старые и новые значения свойства.  То же относится к применению значений; обычно не рекомендуется пытаться изменить значения снова в отправителе в ответ на событие.  
  
## Триггеры свойств  
 Триггер свойства является концепцией, тесно связанной с событием изменения свойства.  Триггер свойства создается внутри стиля или шаблона и позволяет создавать условное поведение, в зависимости от значения свойства там, где назначается триггер свойства.  
  
 Свойством для триггера свойства должно быть свойство зависимости.  Оно может быть \(и часто является\) свойством зависимости только для чтения.  Хороший показатель, когда свойство зависимости, предоставляемое элементом управления, хотя бы частично предназначено для того, чтобы быть триггером свойства, если имя свойства начинается с «Is».  Свойства, имеющие это именование, являются часто логическими свойствами зависимости только для чтения, где основным скриптом для свойства является отчет о состоянии элемента управления, которое может повлиять на пользовательский интерфейс в режиме реального времени и, следовательно, на кандидат триггера свойства.  
  
 Некоторые из этих свойств также имеют выделенное событие изменения свойства.  Например, свойство <xref:System.Windows.UIElement.IsMouseCaptured%2A> имеет значение <xref:System.Windows.UIElement.IsMouseCapturedChanged> события изменения свойства.  Само свойство является свойством только для чтения со значением, скорректированным системой ввода, которая вызывает событие <xref:System.Windows.UIElement.IsMouseCapturedChanged> при каждом изменении в режиме реального времени.  
  
 По сравнению с действительным событием изменения свойства, которое использует триггер свойства для изменения свойства, оно имеет некоторые ограничения.  
  
 Триггеры свойств работают через логику точного соответствия.  Необходимо указать свойство и значение, определяющее конкретное значение, для которого будет действовать триггер.  Например: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`.  Из\-за этого ограничения, триггер свойства, в основном, будет использоваться для логических свойств или свойств, которые принимают значение перечисления, где задается достаточный диапазон возможных значений, чтобы определить триггер для каждого случая.  Или триггеры свойств могут существовать только для специальных значений, например, когда подсчет элементов достигает нуля и не существует триггер, который выполняет вычисление для случаев, когда значение свойства изменяется снова обратно от нуля \(вместо триггеров для всех случаев может потребоваться в коде обработчик событий или поведение по умолчанию, которое сбрасывает состояние триггера, когда значение не равно нулю\).  
  
 Синтаксис триггера свойства является аналогом инструкции if в программировании.  Если условием триггера является true, тогда «тело» триггера свойства «выполняется».  «Тело» триггера свойства не является кодом, это разметка.  Эта разметка ограничена использованием одного или нескольких элементов <xref:System.Windows.Setter> для задания других свойств объекта, где применяется стиль или шаблон.  
  
 Чтобы сместить условие «if» триггера свойства, которое имеет широкий выбор возможных значений, обычно рекомендуется установить это же значение свойства по умолчанию при помощи <xref:System.Windows.Setter>.  Таким образом, объект <xref:System.Windows.Trigger>, содержащий метод записи свойств, будет иметь приоритет, если условие триггера выполнено, и объект <xref:System.Windows.Setter>, который находится вне <xref:System.Windows.Trigger>, будет иметь приоритет всякий раз, когда условие триггера не выполняется.  
  
 Обычно триггеры свойств подходят для скриптов, где одно или несколько свойств внешнего вида следует изменить, в зависимости от состояния другого свойства в том же элементе.  
  
 Чтобы получить более подробные сведения о триггерах свойств, см. раздел [Стилизация и использование шаблонов](../../../../docs/framework/wpf/controls/styling-and-templating.md).  
  
## См. также  
 [Общие сведения о перенаправленных событиях](../../../../docs/framework/wpf/advanced/routed-events-overview.md)   
 [Общие сведения о свойствах зависимости](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)