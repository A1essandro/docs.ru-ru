---
title: Общие сведения о перенаправленных событиях
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-wpf
ms.tgt_pltfrm: ''
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
caps.latest.revision: 29
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 896f3b852c00b9c7cd031710dbdaa00974428344
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/26/2018
---
# <a name="routed-events-overview"></a>Общие сведения о перенаправленных событиях
В этом разделе описывается понятие перенаправленных событий в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]. Здесь определяется терминология перенаправленных событий, описывается, как перенаправленные события маршрутизируются через дерево элементов, кратко описываются способы обработки перенаправленных событий, а также способы создания пользовательских перенаправленных событий.
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Предварительные требования  
 Этот раздел предполагает наличие базовых знаний о [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] и объектно-ориентированном программировании,а также представление о связях между элементами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в виде дерева. Чтобы выполнить примеры в этом разделе, следует также понимать [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и знать, как писать простые приложения или страницы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Дополнительные сведения см. в разделе [Пошаговое руководство: My первого классического приложения WPF](../../../../docs/framework/wpf/getting-started/walkthrough-my-first-wpf-desktop-application.md) и [Обзор XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="routing"></a>   
## <a name="what-is-a-routed-event"></a>Что такое перенаправленное событие?  
 Перенаправленные события можно рассматривать с точки зрения функциональности или реализации. Здесь приводятся оба определения, чтобы пользователи могли выбрать наиболее подходящее для себя.  
  
 Функциональное определение. Перенаправленное событие — это тип события, которое может вызывать обработчики нескольких слушателей в дереве элементов, а не только объекта, вызвавшего событие.  
  
 Определение реализации: перенаправленное событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событий, поддерживаемый экземпляром <xref:System.Windows.RoutedEvent> класса и обрабатывается [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] системы событий.  
  
 Обычно в приложении [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержится много элементов. В зависимости от того, созданы элементы в коде или объявлены в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], они связаны в дереве элементов друг с другом. Маршрут события может проходить в одном из двух направлений в зависимости от определения события, но обычно маршрут проходит от исходного элемента и затем "всплывает" вверх по дереву элементов до тех пор, пока не достигнет корневого элемента дерева (как правило, страница или окно). Концепция всплывания может быть знакома, если имеется опыт работы с моделью DHTML-объектов.  
  
 Рассмотрим следующее простое дерево элементов.  
  
 [!code-xaml[EventOvwSupport#GroupButton](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 Это дерево элементов выглядит примерно следующим образом.  
  
 ![Кнопки "Да", "Нет" и "Отмена"](../../../../docs/framework/wpf/advanced/media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")  
  
 В этом упрощенном дереве элементов, источник <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие является одним из <xref:System.Windows.Controls.Button> элементов и какое значение <xref:System.Windows.Controls.Button> была нажата кнопка является первым элементом, имеющим возможность для обработки события. Но если обработчик не подключена к <xref:System.Windows.Controls.Button> действует в событии, а затем событие всплывает элементу <xref:System.Windows.Controls.Button> родительский элемент в дерево элементов, который является <xref:System.Windows.Controls.StackPanel>. Возможно, событие может передаваться к <xref:System.Windows.Controls.Border>, а затем за пределы границы к корневой странице дерева элементов (не показано).  
  
 Другими словами, маршрут для данного события <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие:  
  
 Button-->StackPanel-->Border-->...  
  
### <a name="top-level-scenarios-for-routed-events"></a>Сценарии верхнего уровня для перенаправленных событий  
 Ниже приведен краткий обзор сценариев, определяющих концепцию перенаправления событий и то, почему обычного события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] не было достаточно для осуществления этих сценариев.  
  
 **Композиция элементов управления и инкапсуляция.** Различные элементы управления в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют расширенную модель содержимого. Например, можно поместить изображение внутри <xref:System.Windows.Controls.Button>, что эффективно расширит визуальное дерево кнопки. Тем не менее, добавленное изображение не должно отключать проверку попадания поведение, которое позволяет реагировать на кнопке <xref:System.Windows.Controls.Primitives.ButtonBase.Click> ее содержимого, даже в том случае, если пользователь нажимает на точках, которые технически являются частью изображения.  
  
 **Точки присоединения одного обработчика.** В [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] придется присоединить один обработчик несколько раз для обработки событий, которые могут возникнуть из нескольких элементов. Перенаправленные события позволяют присоединить обработчик только один раз, как было показано в предыдущем примере, и при необходимости использовать логику обработки для определения места возникновения события. Например, это может быть обработчиком для ранее показанного [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].  
  
 [!code-csharp[EventOvwSupport#GroupButtonCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
 [!code-vb[EventOvwSupport#GroupButtonCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]  
  
 **Обработка класса.** Перенаправленные события разрешают использовать статический обработчик, определяемый классом. Этот обработчик классов может обрабатывать событие раньше любого вложенного обработчика экземпляров.  
  
 **Ссылка на событие без отражения.** Для определенных методов кода и исправлений требуется идентификация определенного события. Перенаправленное событие создает <xref:System.Windows.RoutedEvent> как идентификатора, который обеспечивает надежный метод идентификации события, не требующий отражения статического или во время выполнения.  
  
### <a name="how-routed-events-are-implemented"></a>Реализация перенаправленных событий  
 Перенаправленное событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событий, поддерживаемый экземпляром <xref:System.Windows.RoutedEvent> класса и зарегистрирована [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] системы событий. <xref:System.Windows.RoutedEvent> Экземпляр, полученный из регистрации, как правило, сохраняется как `public` `static` `readonly` поле член класса, который регистрирует и таким образом «владеет» перенаправленного события. Соединение с событием [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] с таким же именем (которое иногда называется событием программы-оболочки) выполняется путем переопределения реализаций `add` и `remove` для события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]. Как правило, `add` и `remove` остаются неявными по умолчанию и используют соответствующий синтаксис события определенного языка для добавления и удаления обработчиков события. Механизм подключения и резервирования перенаправленного события аналогичен как свойство зависимостей является [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] свойства, поддерживаемый <xref:System.Windows.DependencyProperty> класса и зарегистрирована [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] системы свойств.  
  
 В следующем примере показано объявление пользовательского `Tap` маршрутизируемого события, включая регистрацию и использование <xref:System.Windows.RoutedEvent> поле идентификатора и `add` и `remove` реализации для `Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событий.  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
### <a name="routed-event-handlers-and-xaml"></a>Обработчики перенаправленных событий и XAML  
 Чтобы добавить обработчик для события с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], следует объявить имя события как атрибут для элемента, который является прослушивателем событий. Значением атрибута является имя метода реализуемого обработчика, который должен существовать в разделяемом классе файла кода программной части.  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 Синтаксис языка [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] для добавления стандартных обработчиков событий [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] одинаков для добавления обработчиков перенаправленных событий, так как на самом деле обработчики добавляются к программе-оболочке события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которая содержит реализацию перенаправленного события. Дополнительные сведения о добавлении обработчиков событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Общие сведения о языке XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="routing_strategies"></a>   
## <a name="routing-strategies"></a>Стратегии маршрутизации  
 Перенаправленные события используют одну из трех стратегий маршрутизации.  
  
-   **Восходящая маршрутизация событий.** Обработчики событий вызываются в источнике событий. Перенаправленное событие затем следует к родительским элементам до достижения корневого элемента дерева. Большинство перенаправленных событий используют стратегию восходящей маршрутизации. События восходящей маршрутизации обычно используются для получения отчета об изменении входных данных или состояния от различных элементов управления или других элементов пользовательского интерфейса.  
  
-   **Прямая маршрутизация.** Только элемент-источник события имеет возможность вызывать обработчики событий. Это является аналогом "маршрутизации", которая используется [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] для события. Тем не менее, в отличие от стандартной [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событий, прямые перенаправленные события поддерживают обработку классов (обработка классов объясняется в следующем разделе) и может использоваться с <xref:System.Windows.EventSetter> и <xref:System.Windows.EventTrigger>.  
  
-   **Нисходящая маршрутизация.** Обработчики событий изначально вызываются в корневом элементе дерева. Перенаправленное событие затем передается по маршруту через последовательные дочерние элементы к узловому элементу, который является источником перенаправленного события (элементом, вызвавшим перенаправленное событие). Нисходящая маршрутизация событий часто используется или обрабатывается как часть композиции для элемента управления таким образом, что события из составных частей композиции могут намеренно подавляться или заменяться событиями, которые определены для полного контроля. Входные события, которые содержатся в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], часто реализуются в виде пары нисходящей и восходящей маршрутизации. События нисходящей маршрутизации также иногда называют событиями предварительного просмотра по причине используемого для пар соглашения об именах.  
  
<a name="why_use"></a>   
## <a name="why-use-routed-events"></a>Зачем использовать перенаправленные события?  
 Разработчикам приложений не всегда необходимо знать, реализуется ли обрабатываемое событие как перенаправленное. Перенаправленные события имеют особое поведение, но такое событие остается невидимым, если обрабатывается в элементе, где оно возникает.  
  
 Перенаправленные события являются мощным инструментом при использовании их в одном из предлагаемых сценариев: при определении общих обработчиков для общего корня, при композиции собственного элемента управления или при определении собственного класса пользовательского элемента управления.  
  
 Прослушиватели перенаправленных событий и источники перенаправленных событий не требуются для совместного использования общего события в их иерархии. Любой <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement> может быть прослушивателя событий для любого перенаправленного события. Таким образом, можно использовать полный набор перенаправленных событий, доступных во всем рабочем [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] как концептуальный "интерфейс", посредством чего разнородные элементы в приложении могут обмениваться данными о событиях. Эта концепция "интерфейса" для перенаправленных событий особенно применима для событий ввода.  
  
 Перенаправленные события могут также использоваться для связи элементов дерева, так как данные событий сохраняются для каждого элемента в маршруте. Один элемент может изменить что-либо в данных события, и это изменение будет доступно для следующего элемента в маршруте.  
  
 Помимо маршрутизации, существуют еще две причины реализации события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в качестве перенаправленного события вместо стандартного события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]. При реализации собственных событий рекомендуется учитывать приведенные далее принципы.  
  
-   Некоторые [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Стилизация и использование шаблонов функции, такие как <xref:System.Windows.EventSetter> и <xref:System.Windows.EventTrigger> требуется указанное событие было перенаправленным. Это сценарий идентификатора события, упомянутого выше.  
  
-   Перенаправленные события поддерживают механизм обработки классов, в силу чего класс может указывать статические методы, имеющие возможность обрабатывать перенаправленные события до того, как любой зарегистрированный обработчик экземпляров сможет получить к ним доступ. Это очень полезно при разработке элемента управления, поскольку класс может управляться с помощью событий, что не может быть случайно подавлено обработкой события в экземпляре.  
  
 Каждое из описанных выше рассуждений рассматривается в отдельной части этого раздела.  
  
<a name="event_handing"></a>   
## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a>Добавление и реализация обработчика событий для перенаправленного события  
 Чтобы добавить обработчик событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], просто добавьте имя события в элемент как атрибут и установите значение атрибута в качестве имени обработчика событий, который реализует соответствующий делегат, как показано в следующем примере.  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 `b1SetColor` имя реализуемого обработчика, который содержит код, который обрабатывает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий. `b1SetColor` должен иметь такой же сигнатурой, что <xref:System.Windows.RoutedEventHandler> делегат, который является делегата обработчика событий для <xref:System.Windows.Controls.Primitives.ButtonBase.Click> события. Первый параметр всех делегатов обработчиков перенаправленных событий указывает элемент, к которому добавляется обработчик событий, а второй параметр указывает данные для события.  
  
[!code-csharp[EventOvwSupport#SimpleHandlerA](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]  
  
 <xref:System.Windows.RoutedEventHandler> является делегатом обработчика основные перенаправленного события. Для перенаправленных событий, которые являются специализированными для определенных элементов управления или скриптов, делегаты, которые используются для обработчиков перенаправленных событий, также могут быть более специализированными, чтобы они могли передавать определенные данные события. Например, в общем сценарии ввода можно обработать <xref:System.Windows.UIElement.DragEnter> перенаправленного события. Обработчик должен реализовывать <xref:System.Windows.DragEventHandler> делегата. С помощью наиболее конкретного делегата, можно обработать <xref:System.Windows.DragEventArgs> в обработчике событий и прочитать <xref:System.Windows.DragEventArgs.Data%2A> свойство, которое содержит полезные данные буфера обмена операции перетаскивания.  
  
 Полный пример добавления обработчика событий к элементу с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Обработка перенаправленных событий](../../../../docs/framework/wpf/advanced/how-to-handle-a-routed-event.md).  
  
 Добавить обработчик для перенаправленного события в приложении, созданном в коде, достаточно просто. Обработчиков перенаправленных событий всегда можно добавлять с помощью вспомогательного метода <xref:System.Windows.UIElement.AddHandler%2A> (это тот же метод требует резервной копией `add`.) Однако существующие перенаправленные события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обычно имеют резервную реализацию `add` и логику `remove`, позволяющую добавлять обработчики перенаправленных событий с помощью синтаксиса событий для определенного языка, являющегося более понятным, чем вспомогательный метод. Ниже приведен пример использования вспомогательного метода.  
  
 [!code-csharp[EventOvwSupport#AddHandlerCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
 [!code-vb[EventOvwSupport#AddHandlerCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]  
  
 Следующий пример показывает C# синтаксис оператора (Visual Basic имеет немного другой синтаксис оператора из-за обработки разыменовывания):  
  
 [!code-csharp[EventOvwSupport#AddHandlerPlusEquals](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
 [!code-vb[EventOvwSupport#AddHandlerPlusEquals](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]  
  
 Пример добавления обработчика событий в коде см. в разделе [Добавление обработчика событий с помощью кода](../../../../docs/framework/wpf/advanced/how-to-add-an-event-handler-using-code.md).  
  
 Если вы используете Visual Basic, можно использовать `Handles` ключевое слово для добавления обработчиков как часть объявления обработчиков. Дополнительные сведения см. в разделе [Обработка событий в Visual Basic и WPF](../../../../docs/framework/wpf/advanced/visual-basic-and-wpf-event-handling.md).  
  
<a name="concept_handled"></a>   
### <a name="the-concept-of-handled"></a>Концепция обработанных событий  
 Все перенаправленные события совместно используют общий базовый класс данных события, <xref:System.Windows.RoutedEventArgs>. <xref:System.Windows.RoutedEventArgs> Определяет <xref:System.Windows.RoutedEventArgs.Handled%2A> свойства, которое принимает логическое значение. Назначение <xref:System.Windows.RoutedEventArgs.Handled%2A> свойство — возможность любого обработчика событий в маршруте пометить перенаправленное событие как *обрабатываются*, его значение <xref:System.Windows.RoutedEventArgs.Handled%2A> для `true`. После обработки обработчиком в одном элементе в маршруте совместно используемые данные события снова предоставляются каждому прослушивателю в маршруте.  
  
 Значение <xref:System.Windows.RoutedEventArgs.Handled%2A> влияет на перенаправленное событие сообщил или обработки при перемещении его прохождении по маршруту. Если <xref:System.Windows.RoutedEventArgs.Handled%2A> — `true` событий данные для перенаправленного события, то обработчики, которые прослушивают перенаправляемые события на элементах, обычно больше не вызываются для этого конкретного экземпляра события. Это справедливо как для обработчиков, присоединенных к [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], так и для обработчиков, добавленных с помощью синтаксиса присоединения обработчика событий конкретного языка, например `+=` или `Handles`. Для наиболее общих сценариев обработки отметка события как обработанное, задав <xref:System.Windows.RoutedEventArgs.Handled%2A> для `true` будет «остановить» нисходящую или восходящую маршрутизацию, а также для любого события, которое обрабатывается в точке маршрута обработчиком классов маршрутизацию.  
  
 Тем не менее, есть механизм «handledEventsToo», при котором прослушиватели могут работать обработчики в ответ на перенаправленные события где <xref:System.Windows.RoutedEventArgs.Handled%2A> — `true` в данных события. Другими словами, маршрут события в действительности не останавливается при пометке события в данных события как обработанного. Механизм handledEventsToo можно использовать только в коде или в <xref:System.Windows.EventSetter>:  
  
-   В коде, вместо того чтобы использовать синтаксис событий определенного языка, который работает общего [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] события, вызывать [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] метод <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> для добавления обработчика. Задайте для `handledEventsToo` значение `true`.  
  
-   В <xref:System.Windows.EventSetter>, задайте <xref:System.Windows.EventSetter.HandledEventsToo%2A> атрибут, который будет `true`.  
  
 Помимо поведения, <xref:System.Windows.RoutedEventArgs.Handled%2A> состояния выводятся в перенаправленных событиях концепция <xref:System.Windows.RoutedEventArgs.Handled%2A> может повлиять на способ следует разработать приложение и написать код обработчика событий. Можно представить <xref:System.Windows.RoutedEventArgs.Handled%2A> как простой протокол, предоставляемый перенаправленными событиями. Существуют различные способы использования этого протокола является, однако концептуальное проектирование как значение <xref:System.Windows.RoutedEventArgs.Handled%2A> предназначен для использования выглядит следующим образом:  
  
-   Если перенаправленное событие помечено как обработанное, то затем его не требуется снова обрабатывать другими элементами в маршруте.  
  
-   Если перенаправленное событие не помечено как обработанное, то либо не зарегистрировать обработчик, или обработчиков, которые были зарегистрированных выбрал использовать данные события и установили отказались другие прослушиватели, которые были ранее на маршруте <xref:System.Windows.RoutedEventArgs.Handled%2A> для `true`. (Или, возможно, текущий прослушиватель является первой точкой в маршруте.) Обработчики на текущем прослушивателе имеют три возможных варианта действий.  
  
    -   Не выполнять никаких действий. Событие остается необработанным и переходит к следующему прослушивателю.  
  
    -   Выполнить код в ответ на событие, при этом убедиться, что выполненное действие не было достаточно существенным, чтобы пометить событие как обработанное. Событие перенаправляется к следующему прослушивателю.  
  
    -   Выполнить кода в ответ на событие. Пометить событие как обработанное в данных события, передаваемых обработчику, потому что предпринятое действие считается достаточно существенным, чтобы пометить событие как обработанное. По-прежнему переходит к следующему прослушивателю, но с <xref:System.Windows.RoutedEventArgs.Handled%2A> = `true` в его данных события, поэтому только `handledEventsToo` прослушиватели могут вызвать следующие обработчики.  
  
 Этот концептуальный проект подкреплен описанным ранее поведением при маршрутизации: более сложным (хотя и возможным для кода и стилей) является присоединение обработчиков для перенаправленных событий, которые вызываются, даже если предыдущий обработчик маршрута уже установил <xref:System.Windows.RoutedEventArgs.Handled%2A>для `true`.  
  
 Дополнительные сведения о <xref:System.Windows.RoutedEventArgs.Handled%2A>, обработка перенаправленных событий, и рекомендации о том, когда это необходимо пометить перенаправленное событие как <xref:System.Windows.RoutedEventArgs.Handled%2A>, в разделе [как Handled и обработка класса](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 В приложениях весьма распространена обработка только перенаправляемого по восходящей события в объекте, который вызывал его, независимо от характеристик маршрутизации события. Однако все же рекомендуется помечать перенаправленное событие как обработанное в данных события, чтобы избежать непредвиденных побочных эффектов на случай, если элемент, который далее следует в дереве элементов, имеет вложенный обработчик для этого же перенаправленного события.  
  
<a name="class_handlers"></a>   
## <a name="class-handlers"></a>Обработчики классов  
 При определении класса, производного иным образом из <xref:System.Windows.DependencyObject>, можно определить и присоединить обработчик класса для перенаправленного события, который является элементом объявленным или унаследованным события этого класса. Обработчики классов вызываются ранее любого обработчика прослушивателей экземпляров, присоединенного к экземпляру этого класса, всякий раз, когда перенаправленное событие встречает экземпляр элемента в своем маршруте.  
  
 Некоторые элементы управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют внутреннюю обработку классов для некоторых перенаправленных событий. Может показаться, что перенаправленное событие не возникает никогда, но на самом деле оно обрабатывается классом и перенаправленное событие по-прежнему может потенциально обрабатываться с помощью обработчиков экземпляров при использовании определенных методов. Кроме того, многие базовые классы и элементы управления предоставляют виртуальные методы, которые могут быть использованы для переопределения поведения при обработке классов. Дополнительные сведения о том, как обрабатывать нежелательные классы и как определить обработку собственного класса в пользовательском классе, см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
<a name="attached_events"></a>   
## <a name="attached-events-in-wpf"></a>Вложенные события в WPF  
 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] также определяет специальный тип события, называемого *вложенным событием*. Вложенное событие позволяет добавлять обработчик для конкретного события в произвольный элемент. Элементу, обрабатывающему событие, не требуется определять или наследовать вложенное событие, и ни объект, который потенциально может вызвать событие, ни экземпляр обработки места назначения не должны определять или каким-либо иным способом владеть этим событием в качестве элемента класса.  
  
 Система ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] широко использует вложенные события. Однако практически все эти вложенные события перенаправляются через базовые элементы. События ввода затем отображаются как эквивалент невложенных перенаправленных событий, которые являются членами класса базового элемента. Для экземпляра, основное вложенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> можно намного легче обрабатываться с заданным <xref:System.Windows.UIElement> с помощью <xref:System.Windows.UIElement.MouseDown> , <xref:System.Windows.UIElement> вместо работы с синтаксисом вложенных событий, либо в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] или код.  
  
 Дополнительные сведения о вложенных событиях в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] см. в разделе [Общие сведения о вложенных событиях](../../../../docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>   
## <a name="qualified-event-names-in-xaml"></a>Полные имена событий в XAML  
 Другой синтаксис напоминает синаксис *typename*. *EventName* вложенного события, но он не является синтаксисом вложенного события при присоединении обработчиков для перенаправленных событий, вызываемых дочерними элементами. Обработчики присоединяются в общем родительском элементе, чтобы воспользоваться преимуществами маршрутизации событий, несмотря на то что общий родительский элемент может не иметь соответствующего перенаправленного события в качестве члена. Рассмотрим этот пример еще раз.  
  
 [!code-xaml[EventOvwSupport#GroupButton](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 Здесь является прослушивателем родительского элемента, где добавляется обработчик <xref:System.Windows.Controls.StackPanel>. Тем не менее, она добавляет обработчик перенаправленного события, который был объявлен и будет вызываться <xref:System.Windows.Controls.Button> класса (<xref:System.Windows.Controls.Primitives.ButtonBase> на самом деле, но доступен для <xref:System.Windows.Controls.Button> через наследование). <xref:System.Windows.Controls.Button> «владеет» событием, но позволяет обработчикам системы перенаправленного события для перенаправленного события, для подключения к любой <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement> прослушиватель экземпляра, в противном случае может присоединить прослушиватели для [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] события. Пространством имен xmlns по умолчанию для этих полных имен атрибутов событий обычно является пространство имен xmlns [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] по умолчанию, но можно также указать префиксные пространства имен для пользовательских перенаправленных событий. Дополнительные сведения о xmlns см. в разделе [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="how_event_processing_works"></a>   
## <a name="wpf-input-events"></a>События ввода WPF  
 Перенаправленные события в платформе [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] часто применяются для событий ввода. В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имена перенаправляемых по нисходящей событий по соглашению указываются с префиксом Preview. События ввода часто возникают попарно, одно маршрутизируется по восходящей, другое — по нисходящей. Например <xref:System.Windows.ContentElement.KeyDown> событий и <xref:System.Windows.ContentElement.PreviewKeyDown> события имеют одинаковую сигнатуру, при этом первое является восходящей события ввода и второе — по нисходящей входных событий. Иногда события ввода имеют только восходящую или, возможно, только прямую маршрутизацию. В документации в разделах, посвященных перенаправленным событиям, содержатся перекрестные ссылки на аналогичные перенаправленные события с альтернативной стратегией маршрутизации, если такие перенаправленные события существуют, и ссылки на разделы документации для уточнения стратегии маршрутизации каждого перенаправленного события.  
  
 События ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], возникающие попарно, реализуются таким образом, что одно действие пользователя из входных данных, такое как нажатие кнопки мыши, последовательно вызовет оба перенаправленные события пары. Сначала вызывается событие, которое маршрутизируется по нисходящей. Затем вызывается событие, которое маршрутизируется по восходящей. Два события буквально совместно используют тот же экземпляр данных события, так как <xref:System.Windows.UIElement.RaiseEvent%2A> вызова метода в реализующем классе, создает событие восходящую прослушивает данных событий из события туннелирования и использует его повторно в новой вызванного события. Прослушиватели с обработчиками для события, маршрутизирующегося по нисходящей, могут первыми пометить перенаправленное событие как обработанное (сначала обработчики классов, затем обработчики экземпляров). Если элемент при нисходящей маршрутизации отметил перенаправленное событие как обработанное, уже обработанные данные события отправляются для события, маршрутизирующегося по восходящей, и типичные обработчики, вложенные для эквивалентных маршрутизируемых по восходящей событий, не будут вызываться. Внешне это будет выглядеть так, как будто обработанное маршрутизируемое по восходящей событие и не вызывалось. Поведение при обработке полезно использовать при композиции элементов управления, где требуется, чтобы конечный элемент управления (а не его составные части) создавал отчеты о событиях проверки нажатия при вводе или событиях ввода на основе фокуса. Конечный элемент управления находится ближе к корневому элементу в композиции и поэтому имеет возможность обработать событие, передаваемое по нисходящей, первым и, возможно, "заменить" это перенаправленное событие более подходящим для данного элемента управления как часть кода, которая резервирует класс элемента управления.  
  
 В качестве иллюстрации того, как обрабатываются события ввода, рассмотрим следующий пример. На следующем рисунке дерева `leaf element #2` является источником событий `PreviewMouseDown` и `MouseDown`.  
  
 ![Схема маршрутизации события](../../../../docs/framework/wpf/advanced/media/wcsdkcoreinputevents.png "wcsdkCoreInputEvents")  
Восходящая и нисходящая маршрутизация событий ввода  
  
 Порядок обработки событий выглядит следующим образом.  
  
1.  `PreviewMouseDown` (нисходящее) на корневом элементе.  
  
2.  `PreviewMouseDown` (нисходящее) на промежуточном элементе № 1.  
  
3.  `PreviewMouseDown` (нисходящее) на исходном элементе № 2.  
  
4.  `MouseDown` (всплывающее) на исходном элементе № 2.  
  
5.  `MouseDown` (всплывающее) на промежуточном элементе № 1.  
  
6.  `MouseDown` (всплывающее) на корневом элементе.  
  
 Делегат обработчика перенаправленных событий содержит ссылки на два объекта: объект, который вызвал событие, и объект, в котором был вызван обработчик. Объект, в котором был вызван обработчик, указывается с помощью параметра `sender`. Объект, где сначала было вызвано событие выдается <xref:System.Windows.RoutedEventArgs.Source%2A> свойство в данных события. Перенаправленное событие может по-прежнему возникает и обрабатывается один и тот же объект, в этом случае `sender` и <xref:System.Windows.RoutedEventArgs.Source%2A> являются идентичными (это относится к шаги 3 и 4 событий обработки пример списка).  
  
 Из-за нисходящей и восходящей маршрутизации, родительские элементы получают события ввода где <xref:System.Windows.RoutedEventArgs.Source%2A> является одним из их дочерних элементов. При очень важно знать, какова исходного элемента, можно определить исходный элемент, обратившись к <xref:System.Windows.RoutedEventArgs.Source%2A> свойство.  
  
 Как правило отмеченное входного события <xref:System.Windows.RoutedEventArgs.Handled%2A>, дополнительные обработчики не вызываются. Обычно события ввода помечаются как обработанные сразу же после вызова обработчика, который при обработке события ввода опирается на логику приложения.  
  
 Исключением из общего правила о <xref:System.Windows.RoutedEventArgs.Handled%2A> обработчики событий, которые регистрируются для намеренного игнорирования ввода находится в состоянии <xref:System.Windows.RoutedEventArgs.Handled%2A> состояние данных событий будет по-прежнему вызываться в маршруте. Дополнительные сведения см. в разделах [События предварительного просмотра](../../../../docs/framework/wpf/advanced/preview-events.md) или [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Модель общего использования данных события при нисходящей и восходящей маршрутизации и последовательный вызов сначала нисходящих, а потом всплывающих событий не обязательно выполняются для всех перенаправленных событий. Такое поведение реализуется в зависимости от того, как устройства ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывают или соединяют пары событий ввода. Дополнительным сценарием является реализация собственных событий ввода, но эту модель также можно реализовывать для собственных событий ввода.  
  
 В определенных классах обработка классов используется для определенных событий ввода, как правило, с целью переопределения значения событий ввода, вызываемых пользователем, и вызова новых событий. Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Дополнительные сведения о вводе данных и о том, как ввод данных и события взаимодействуют в обычных сценариях приложения, см. в разделе [Общие сведения о входных данных](../../../../docs/framework/wpf/advanced/input-overview.md).  
  
<a name="events_styles"></a>   
## <a name="eventsetters-and-eventtriggers"></a>EventSetters и EventTriggers  
 В стилях, можно включить какой-либо предопределенный [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] обработки с помощью синтаксиса в разметке событий <xref:System.Windows.EventSetter>. При применении стиля указанный обработчик добавляется в экземпляр стиля. Можно объявить <xref:System.Windows.EventSetter> только для перенаправленного события. Пример. Обратите внимание, что указанный метод `b1SetColor` находится в файле кода программной части.  
  
 [!code-xaml[EventOvwSupport#XAML2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 Преимущество является стиль может содержать большое количество другие сведения, которые могут применяться к любой кнопке в приложении, и с <xref:System.Windows.EventSetter> входить в состав этого стиля способствует повторному использованию кода даже на уровне разметки. Кроме того <xref:System.Windows.EventSetter> абстрагирует имена методов для обработчиков один шаг дальше от Общие приложения и страницы разметки.  
  
 Другой специальный синтаксис, который объединяет перенаправленных событий и анимации свойства [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] — <xref:System.Windows.EventTrigger>. Как и в <xref:System.Windows.EventSetter>, только перенаправленные события могут использоваться для <xref:System.Windows.EventTrigger>. Как правило <xref:System.Windows.EventTrigger> объявляется как часть стиля, но <xref:System.Windows.EventTrigger> также могут быть объявлены на уровне элементов страницы как часть <xref:System.Windows.FrameworkElement.Triggers%2A> коллекции, или в <xref:System.Windows.Controls.ControlTemplate>. <xref:System.Windows.EventTrigger> Дает возможность указать <xref:System.Windows.Media.Animation.Storyboard> , выполняется каждый раз, когда перенаправленное событие достигает на своем маршруте элемент, который объявляет <xref:System.Windows.EventTrigger> для данного события. Преимущество <xref:System.Windows.EventTrigger> через только что обработки событий и приводит его для запуска существующей раскадровки является, <xref:System.Windows.EventTrigger> обеспечивает лучший контроль над раскадровкой и его поведение во время выполнения. Дополнительные сведения см. в разделе [Использование триггеров событий для управления раскадровкой после ее запуска](../../../../docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).  
  
<a name="more_about"></a>   
## <a name="more-about-routed-events"></a>Дополнительные сведения о перенаправленных событиях  
 В этом разделе перенаправленные события рассматриваются, главным образом, с точки зрения описания основных понятий. Также приводится руководство по тому, как и когда следует отвечать на перенаправляемые события, которые уже существуют в различных базовых элементах и элементах управления. Однако можно создать собственное перенаправленное событие на пользовательском классе вместе со всей необходимой поддержкой, такой как особые для этого события классы данных и делегаты. Владельцем перенаправленного события может быть любой класс, но перенаправленные события должны вызываться и может быть обработано <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement> производных классов для практического. Дополнительные сведения о пользовательских событиях см. в разделе [Создание пользовательских событий маршрутизации](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
## <a name="see-also"></a>См. также  
 <xref:System.Windows.EventManager>  
 <xref:System.Windows.RoutedEvent>  
 <xref:System.Windows.RoutedEventArgs>  
 [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)  
 [Общие сведения о входных данных](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [Общие сведения о системе команд](../../../../docs/framework/wpf/advanced/commanding-overview.md)  
 [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [Деревья в WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)  
 [Шаблоны слабых событий](../../../../docs/framework/wpf/advanced/weak-event-patterns.md)
