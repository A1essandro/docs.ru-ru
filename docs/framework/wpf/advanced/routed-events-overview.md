---
title: "Общие сведения о перенаправленных событиях | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "вложенные события"
  - "восходящая маршрутизация событий"
  - "набор кнопок, сгруппированный"
  - "события, присоединенные"
  - "события, перенаправленные"
  - "набор кнопок - сгруппированный"
  - "перенаправляемые события"
  - "события - стратегии маршрутизации"
  - "нисходящая маршрутизация"
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
caps.latest.revision: 29
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 28
---
# Общие сведения о перенаправленных событиях
В этом разделе описывается понятие перенаправленных событий в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].  В этом разделе определяется терминология перенаправленных событий, описывается, как перенаправленные события маршрутизируются через дерево элементов, кратко описываются способы обработки перенаправленных событий, а также способы создания пользовательских перенаправленных событий.  
  
 [!INCLUDE[autoOutline](../Token/autoOutline_md.md)]  
  
<a name="prerequisites"></a>   
## Предварительные требования  
 В этом разделе предоставляется набор базовых знаний о [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] и объектно\-ориентированном программировании, а также понятие представления связей между элементами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в виде дерева.  Чтобы понять примеры в этом разделе, следует также понимать [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и знать, как писать простые приложения или страницы [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Дополнительные сведения см. в разделах [Пошаговое руководство. Начало работы с WPF](../../../../docs/framework/wpf/getting-started/walkthrough-my-first-wpf-desktop-application.md) и [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="routing"></a>   
## Что такое перенаправленное событие?  
 Можно рассматривать перенаправленные события с точки зрения функциональности или реализации.  Здесь приводятся оба определения, чтобы пользователи могли выбрать наиболее подходящее для себя определение.  
  
 Функциональное определение. Перенаправленное событие — это тип события, который может вызывать обработчики для нескольких прослушивателей в элементе дерева, а не только для объекта, вызвавшего событие.  
  
 Определение с точки зрения реализации. [Перенаправленное событие](GTMT) — это событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которое резервируется экземпляром класса <xref:System.Windows.RoutedEvent> и обрабатывается в системе событий [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].  
  
 Обычно в приложении [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержится много элементов.  В зависимости от того, созданы элементы в коде или объявлены в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], они связаны в дереве элементов друг с другом.  Маршрут события может проходить в одном из двух направлений в зависимости от определения события, но обычно маршрут проходит от исходного элемента и затем "всплывает" вверх по дереву элементов до тех пор, пока не достигнет корневого элемента дерева \(как правило, страница или окно\).  Концепция всплывания может быть знакома, если имеется опыт работы с моделью DHTML\-объектов.  
  
 Рассмотрим следующее простое дерево элементов.  
  
 [!code-xml[EventOvwSupport#GroupButton](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 Это дерево элементов выглядит примерно следующим образом:  
  
 ![Кнопки “Да”, “Нет” и “Отменить”](../../../../docs/framework/wpf/advanced/media/routedevent-ovw-1.png "RoutedEvent\_ovw\_1")  
  
 В этом упрощенном дереве элементов источником события <xref:System.Windows.Controls.Primitives.ButtonBase.Click> является один из элементов <xref:System.Windows.Controls.Button>, и любая нажатая <xref:System.Windows.Controls.Button> будет являться первым элементом, который имеет возможность обработать событие.  При отсутствии обработчика, вложенного в <xref:System.Windows.Controls.Button> и выполняющегося при возникновении события, событие будет передано родительскому элементу <xref:System.Windows.Controls.Button> в дереве элементов, которым является <xref:System.Windows.Controls.StackPanel>.  Потенциально событие может передаваться к <xref:System.Windows.Controls.Border>, а затем за пределы границы к корневой странице дерева элементов \(не показано\).  
  
 Другими словами, маршрутом события для данного события <xref:System.Windows.Controls.Primitives.ButtonBase.Click> является:  
  
 Button\-\-\>StackPanel\-\-\>Border\-\-\>...  
  
### Сценарии верхнего уровня для перенаправленных событий  
 Ниже приведено краткое описание скриптов, определяющих концепцию перенаправления событий, и почему обычного события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] не было достаточно для осуществления этих скриптов:  
  
 **Композиция элементов управления и инкапсуляция.** Различные элементы управления в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют расширенную модель содержимого.  Например, можно поместить изображение внутри <xref:System.Windows.Controls.Button>, что эффективно расширит визуальное дерево кнопки.  Тем не менее, добавленное изображение не должно отключать проверку нажатия, которая позволяет кнопке откликаться на <xref:System.Windows.Controls.Primitives.ButtonBase.Click> ее содержимого, даже если пользователь выполняет нажатие на пикселях, которые технически являются частью изображения.  
  
 **Точки присоединения одного обработчика:** В [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] придется присоединить один обработчик несколько раз для обработки событий, которые могут возникнуть из нескольких элементов.  Перенаправленные события позволяют присоединить обработчик только один раз, как было показано в предыдущем примере, и при необходимости использовать логику обработки для определения места возникновения события.  Например, это может быть обработчиком для ранее показанного [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]:  
  
 [!code-csharp[EventOvwSupport#GroupButtonCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
 [!code-vb[EventOvwSupport#GroupButtonCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]  
  
 **Обработка класса:** Перенаправленные события разрешают использовать статический обработчик, определяемый классом.  Этот обработчик классов имеет возможность обрабатывать событие раньше любого вложенного обработчика экземпляров.  
  
 **Ссылка на событие без отражения:** для определенных методов кода и исправлений требуется идентификация определенного события.  Перенаправленное событие создает поле <xref:System.Windows.RoutedEvent> в качестве идентификатора, который обеспечивает надежный метод идентификации события, который не требует статического отражения или отражения во время выполнения.  
  
### Реализация перенаправленных событий  
 [Перенаправленное событие](GTMT) — это событие [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которое резервируется экземпляром класса <xref:System.Windows.RoutedEvent> и регистрируется в системе событий [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Экземпляр <xref:System.Windows.RoutedEvent>, полученный из регистрации, обычно сохраняется в качестве поля `public` `static` `readonly` класса, который регистрирует и таким образом "владеет" перенаправленным событием.  Соединение с событием [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] с таким же именем \(которое иногда называется событием программы\-оболочки\) выполняется путем переопределения реализаций `add` и `remove` для события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  Как правило, `add` и `remove` остаются неявными по умолчанию и используют соответствующий синтаксис события определенного языка для добавления и удаления обработчиков события.  Концептуально механизм подключения и резервирования перенаправленного события похож на то, как [свойство зависимостей](GTMT) является свойством [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которое резервно копируется классом <xref:System.Windows.DependencyProperty> и регистрируется в системе свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 В следующем примере показано объявление пользовательского перенаправленного события `Tap`, включая регистрацию и использование поля идентификатора <xref:System.Windows.RoutedEvent> и реализаций `add` и `remove` для события `Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
### Обработчики перенаправленных событий и язык XAML  
 Чтобы добавить обработчик для события с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], следует объявить имя события как атрибут для элемента, который является прослушивателем событий.  Значением атрибута является имя метода реализуемого обработчика, который должен существовать в разделяемом классе файла кода программной части.  
  
 [!code-xml[EventOvwSupport#SimplestSyntax](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 Синтаксис [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] для добавления стандартных обработчиков событий [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] одинаков для добавления обработчиков перенаправленных событий, так как на самом деле обработчики добавляются к программе\-оболочке события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которая содержит реализацию перенаправленного события.  Дополнительные сведения о добавлении обработчиков событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Общие сведения о языке XAML \(WPF\)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).  
  
<a name="routing_strategies"></a>   
## Стратегии маршрутизации  
 Перенаправленные события используют одну из трех стратегий маршрутизации:  
  
-   **Восходящая маршрутизация событий:** обработчики событий вызываются на источнике события.  Перенаправляемые события затем следуют к родительским элементам до достижения корневого элемента дерева.  Большинство перенаправленных событий используют стратегию восходящей маршрутизации.  Передача вверх перенаправляемых событий обычно используются для получения отчета об изменении входных данных или состояния от различных элементов управления или других элементов пользовательского интерфейса.  
  
-   **Прямая маршрутизация:** только элемент\-источник события имеет возможность вызывать обработчики событий.  Это является аналогом "маршрутизации", которая используется [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] для событий.  Однако в отличие от стандартных событий [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] прямые перенаправленные события поддерживают обработку классов \(обработка классов объясняется в одном из следующих разделов\) и может использоваться объектами <xref:System.Windows.EventSetter> и <xref:System.Windows.EventTrigger>.  
  
-   **Нисходящая маршрутизация событий:** обработчики событий изначально вызываются в корневом элементе дерева.  Перенаправленное событие затем передается по маршруту через последовательные дочерние элементы к узловому элементу, который является источником перенаправленного события \(элементом, вызвавшим перенаправленное событие\).  Нисходящая маршрутизация событий часто используется или обрабатывается как часть композиции для элемента управления таким образом, что события из составных частей композиции могут быть намеренно подавляться или заменяться событиями, которые определены для полного контроля.  События ввода, которые содержатся в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], часто реализуются в виде пары нисходящей\/восходящей маршрутизации.  Нисходящую маршрутизацию событий также иногда называют событием предварительного просмотра по причине используемого для пар соглашения об именах.  
  
<a name="why_use"></a>   
## Зачем использовать перенаправленные события?  
 Разработчикам приложения не всегда необходимо знать, реализуется ли обрабатываемое событие как перенаправленное.  Перенаправленные события имеют особое поведение, но оно остается невидимым, если событие обрабатывается на элементе, где оно возникает.  
  
 Перенаправленные события являются мощным инструментом при использовании их в одном из предлагаемых скриптов: при определении общих обработчиков для общего корня, при композиции собственного элемента управления или при определении собственного класса пользовательского элемента управления.  
  
 Прослушиватели перенаправленных событий и источники перенаправленных событий не требуются для совместного использования общего события в их иерархии.  Любой <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement> может являться прослушивателем перенаправленных событий.  Таким образом, можно использовать полный набор перенаправленных событий, доступных во всем рабочем наборе [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] как концептуальный "интерфейс", посредством чего разнородные элементы в приложении могут обмениваться данными о событиях.  Эта концепция "интерфейс" для перенаправленных событий особенно применима для событий ввода.  
  
 Перенаправленные события могут также использоваться для связи элементов дерева, так как данные событий сохраняются для каждого элемента в маршруте.  Один элемент может изменить что\-либо в данных события и это изменение будет доступно для следующего элемента в маршруте.  
  
 Помимо маршрутизации существуют еще две причины реализации события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] в качестве перенаправленного события вместо стандартного события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  При реализации собственных событий рекомендуется учитывать эти принципы:  
  
-   Для некоторых функций стилей и шаблонов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], например <xref:System.Windows.EventSetter> и <xref:System.Windows.EventTrigger>, требуется, чтобы указанное событие было перенаправленным.  Это скрипт идентификатора события, упомянутого выше.  
  
-   Перенаправленные события поддерживают механизм обработки классов, в силу чего класс может указывать статические методы, имеющие возможность обрабатывать перенаправленные события до того, как любой зарегистрированный обработчик экземпляров сможет сделать это.  Это очень полезно при разработке элемента управления, поскольку класс может управляться с помощью событий, что не может быть случайно подавлено обработкой события в экземпляре.  
  
 Каждое из описанных выше рассуждений рассматривается в отдельной части этого раздела.  
  
<a name="event_handing"></a>   
## Добавление и реализация обработчика событий для перенаправленного события  
 Чтобы добавить обработчик событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], просто добавьте имя события в элемент как атрибут и установите значение атрибута в качестве имени обработчика событий, который реализует соответствующий делегат, как показано в следующем примере.  
  
 [!code-xml[EventOvwSupport#SimplestSyntax](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 `b1SetColor` — имя реализуемого обработчика, содержащего код, обрабатывающий событие <xref:System.Windows.Controls.Primitives.ButtonBase.Click>.  `b1SetColor` должен иметь такую же сигнатуру как делегат <xref:System.Windows.RoutedEventHandler>, который является делегатом обработчика событий для события <xref:System.Windows.Controls.Primitives.ButtonBase.Click>.  Первый параметр всех делегатов обработчиков перенаправленных событий указывает элемент, к которому добавляется обработчик событий, а второй параметр указывает данные для события.  
  
 [!code-csharp[EventOvwSupport#SimpleHandlerA](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
 [!code-vb[EventOvwSupport#SimpleHandlerA](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]  
[!code-csharp[EventOvwSupport#SimpleHandlerB](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlerb)]
[!code-vb[EventOvwSupport#SimpleHandlerB](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlerb)]  
  
 <xref:System.Windows.RoutedEventHandler> является основным делегатом обработчика перенаправленных событий.  Для перенаправленных событий, которые являются специализированными для определенных элементов управления или скриптов, делегаты, которые используются для обработчиков перенаправленных событий, также могут быть более специализированными, чтобы они могли передавать определенные данные события.  Например, в общем сценарии ввода можно обработать перенаправленное событие <xref:System.Windows.UIElement.DragEnter>.  Обработчик должен реализовывать делегат <xref:System.Windows.DragEventHandler>.  С помощью наиболее конкретного делегата можно обработать <xref:System.Windows.DragEventArgs> в обработчике событий и прочитать свойство <xref:System.Windows.DragEventArgs.Data%2A>, содержащее полезную нагрузку буфера обмена от операцией перетаскивания.  
  
 Полный пример для добавления обработчика событий к элементу с помощью [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] см. в разделе [Обработка перенаправленных событий](../../../../docs/framework/wpf/advanced/how-to-handle-a-routed-event.md).  
  
 Добавить обработчик для перенаправленного события в приложении, созданном в коде, достаточно просто.  Обработчики перенаправленных событий всегда можно добавлять с помощью вспомогательного метода <xref:System.Windows.UIElement.AddHandler%2A> \(который является тем же методом, который вызывается резервной копией для `add`.\) Однако, существующие перенаправленные события [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] обычно имеют резервную реализацию `add` и логику `remove`, позволяющую добавлять обработчики перенаправленных событий с помощью синтаксис событий определенного языка, являющегося более понятным, чем вспомогательный метод.  Ниже приведен пример использования вспомогательного метода.  
  
 [!code-csharp[EventOvwSupport#AddHandlerCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
 [!code-vb[EventOvwSupport#AddHandlerCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]  
  
 В следующем примере показан синтаксис оператора [!INCLUDE[TLA#tla_cshrp](../../../../includes/tlasharptla-cshrp-md.md)] \([!INCLUDE[TLA2#tla_visualb](../../../../includes/tla2sharptla-visualb-md.md)] имеет немного другой синтаксис оператора из\-за обработки разыменовывания\):  
  
 [!code-csharp[EventOvwSupport#AddHandlerPlusEquals](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
 [!code-vb[EventOvwSupport#AddHandlerPlusEquals](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]  
  
 Пример добавления обработчика событий в коде см. в разделе [Добавление обработчика событий с помощью кода](../../../../docs/framework/wpf/advanced/how-to-add-an-event-handler-using-code.md).  
  
 При использовании [!INCLUDE[TLA2#tla_visualb](../../../../includes/tla2sharptla-visualb-md.md)] можно также использовать ключевое слово `Handles`, чтобы добавить обработчик как часть объявлений обработчика.  Дополнительные сведения см. в разделе [Обработка событий в Visual Basic и WPF](../../../../docs/framework/wpf/advanced/visual-basic-and-wpf-event-handling.md).  
  
<a name="concept_handled"></a>   
### Концепция "обработанных событий"  
 Все перенаправленные события совместно используют общий базовый класс данных события <xref:System.Windows.RoutedEventArgs>.  <xref:System.Windows.RoutedEventArgs> определяет свойство <xref:System.Windows.RoutedEventArgs.Handled%2A>, которое принимает логическое значение.  Свойство <xref:System.Windows.RoutedEventArgs.Handled%2A> предназначено для того, чтобы любой обработчик событий в маршруте мог отметить перенаправленное событие как *обработанное* с помощью задания для <xref:System.Windows.RoutedEventArgs.Handled%2A> значения `true`.  После обработки обработчиком на одном элементе в маршруте совместно используемые данные события снова предоставляются каждому прослушивателю в маршруте.  
  
 Значение <xref:System.Windows.RoutedEventArgs.Handled%2A> влияет на то, как создается отчет о перенаправленном событии и как оно обрабатывается, во время передачи вдоль маршрута.  Если <xref:System.Windows.RoutedEventArgs.Handled%2A> является `true` в данных события для перенаправленного события, то обработчики, которые прослушивают перенаправляемые события на элементах, обычно больше не вызываются для этого конкретного экземпляра события.  Это справедливо как для обработчиков, присоединенных в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], так и для обработчиков, добавленных с помощью синтаксиса присоединения обработчика событий конкретного языка, например `+=` или `Handles`.  Для наиболее общих сценариев обработки отметка события как обработанного путем присвоения свойству <xref:System.Windows.RoutedEventArgs.Handled%2A> значения `true` будет останавливать нисходящую или восходящую маршрутизацию событий, а также маршрутизацию любого события, которое обрабатывается в точке маршрута обработчиком классов.  
  
 Однако существует механизм "handledEventsToo", с помощью которого прослушиватели могут по\-прежнему запускать обработчики в ответ на перенаправляемые события, для которых <xref:System.Windows.RoutedEventArgs.Handled%2A> установлено в значение `true` в данных события.  Другими словами, маршрут события в действительности не останавливается при пометке события в данных события как обработанного.  Механизм "HandledEventsToo" можно использовать только в коде или в <xref:System.Windows.EventSetter>:  
  
-   Вместо использования в коде синтаксиса события конкретного языка, подходящего для общих событий [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], вызовите метод [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> для добавления обработчика.  Установите для `handledEventsToo` значение `true`.  
  
-   В <xref:System.Windows.EventSetter> задайте для атрибута <xref:System.Windows.EventSetter.HandledEventsToo%2A> значение `true`.  
  
 В дополнение к поведению состояния <xref:System.Windows.RoutedEventArgs.Handled%2A> в перенаправленных событиях концепция <xref:System.Windows.RoutedEventArgs.Handled%2A> должна учитываться при определении того, как должно разрабатываться приложение и писаться код обработчика событий.  Можно концептуализировать <xref:System.Windows.RoutedEventArgs.Handled%2A> как простой протокол, предоставляемый перенаправленными событиями.  Существуют различные способы использования этого протокола, однако концептуальное проектирование того, как используется значение <xref:System.Windows.RoutedEventArgs.Handled%2A>, выглядит следующим образом:  
  
-   Если перенаправленное событие помечено как обработанное, то затем его не требуется снова обрабатывать другими элементами в маршруте.  
  
-   Если перенаправленное событие не помечено как обработанное, то либо другой прослушиватель, более ранний в маршруте, не регистрировал обработчик, или зарегистрированные обработчики отказались использовать данные события и установили для <xref:System.Windows.RoutedEventArgs.Handled%2A> значение `true`.  \(Или текущий прослушиватель является первой — первая точка в маршруте\). Обработчики на текущем прослушивателе имеют три возможных варианта действий:  
  
    -   не выполнять никаких действий; событие остается необработанным и переходит к следующему прослушивателю.  
  
    -   выполнить код в ответ на событие, при этом убедиться, что выполненное действие не было достаточно существенным, чтобы пометить событие как обработанное.  событие перенаправляется к следующему прослушивателю.  
  
    -   выполнить код в ответ на событие.  пометить событие как обработанное в данных события, передаваемых обработчику, потому что предпринятое действие считается достаточно существенным, чтобы пометить событие как обработанное.  Событие так же перенаправляется к следующему прослушивателю, но с <xref:System.Windows.RoutedEventArgs.Handled%2A>\=`true` в его данных, поэтому только прослушиватели `handledEventsToo` имеют возможность вызвать следующие обработчики.  
  
 Этот концептуальный проект подкреплен описанным ранее поведением при маршрутизации: Более сложным \(хотя и возможным для кода и стилей\) является присоединение обработчиков для перенаправленных событий, которые вызываются, даже если предыдущий обработчик маршрута уже установил для <xref:System.Windows.RoutedEventArgs.Handled%2A> значение `true`.  
  
 Дополнительные сведения о <xref:System.Windows.RoutedEventArgs.Handled%2A>, обработке классов перенаправленных событий, и рекомендации о том, когда необходимо пометить перенаправленное событие как <xref:System.Windows.RoutedEventArgs.Handled%2A> см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 В приложениях весьма распространена обработка только перенаправляемого по восходящей события на объекте, который вызывал его, независимо от характеристик маршрутизации события.  Однако, все же рекомендуется помечать перенаправленное событие как обработанное в данных события, чтобы избежать непредвиденных побочных эффектов, на случай если элемент, который далее следует в дереве элементов, имеет вложенный обработчик для этого же перенаправленного события.  
  
<a name="class_handlers"></a>   
## Обработчики классов  
 При определении класса, производного от <xref:System.Windows.DependencyObject>, можно также определить и присоединить обработчик класса для перенаправленного события, который является объявленным или унаследованным элементом события класса.  Обработчики классов вызываются ранее любого обработчика прослушивателей экземпляров, присоединенного к экземпляру этого класса, всякий раз, когда перенаправленное событие встречает экземпляр элемента в своем маршруте.  
  
 Некоторые элементы управления [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имеют внутреннюю обработку классов для некоторых перенаправленных событий.  Может показаться, что перенаправленное событие не возникает никогда, но на самом деле оно обрабатывается классом, и перенаправленное событие по\-прежнему может потенциально обрабатываться с помощью обработчиков экземпляров при использовании определенных методов.  Кроме того многие базовые классы и элементы управления предоставляют виртуальные методы, которые могут быть использованы для переопределения поведения при обработке классов.  Дополнительную информацию о том, как обрабатывать нежелательные классы и как определить обработку собственного класса в пользовательском классе, см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
<a name="attached_events"></a>   
## Вложенные события в WPF  
 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] также определяет специальный тип события, называемого *вложенным событием*.  Вложенное событие позволяет добавлять обработчик для конкретного события в произвольный элемент.  Элементу, обрабатывающему событие, не требуется определять или наследовать вложенное событие, и ни объект, который потенциально может вызвать событие, ни экземпляр обработки места назначения не должны определять или каким\-либо иным способом владеть этим событием в качестве элемента класса.  
  
 Система ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] широко использует вложенные события.  Однако практически все эти вложенные события перенаправляются через базовые элементы.  События ввода затем отображаются как эквивалент невложенных перенаправленных событий, которые являются членами базового элемента класса.  Например, основное вложенное событие <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=fullName> может намного легче обрабатываться с заданным <xref:System.Windows.UIElement> с помощью <xref:System.Windows.UIElement.MouseDown> на <xref:System.Windows.UIElement> вместо работы с синтаксисом вложенных событий в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] или коде.  
  
 Дополнительные сведения о вложенных событиях в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] см. в разделе [Общие сведения о вложенных событиях](../../../../docs/framework/wpf/advanced/attached-events-overview.md).  
  
<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>   
## Полные имена событий в языке XAML  
 Другой синтаксис напоминает синтаксис *typename*. *eventname* вложенного события, но он не является синтаксисом вложенного события при присоединении обработчиков для перенаправленных событий, вызываемых дочерними элементами.  Обработчики присоединяются в общем родительском элементе, чтобы воспользоваться преимуществами маршрутизации событий, несмотря на то, что общий родительский элемент может не иметь соответствующего перенаправленного события в качестве члена.  Рассмотрим этот пример еще раз.  
  
 [!code-xml[EventOvwSupport#GroupButton](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 Прослушивателем родительского элемента, в котором добавляется обработчик, является <xref:System.Windows.Controls.StackPanel>.  Однако обработчик добавляется для перенаправленного события, который был объявлен и будет вызван классом <xref:System.Windows.Controls.Button> \(<xref:System.Windows.Controls.Primitives.ButtonBase> на самом деле, но доступен для <xref:System.Windows.Controls.Button> через наследование\).  <xref:System.Windows.Controls.Button> "владеет" событием, но система обработки перенаправленных событий позволяет обработчикам любого перенаправленного события, быть присоединенными к любому прослушивателю экземпляров <xref:System.Windows.UIElement> или<xref:System.Windows.ContentElement>, который в противном случае может присоединить прослушиватели для события [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)].  Пространством имен xmlns по умолчанию для этих полных имен атрибутов событий обычно является пространство имен xmlns [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] по умолчанию, но можно также указать префиксные пространства имен для пользовательских перенаправленных событий.  Дополнительные сведения о xmlns см. в разделе [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
<a name="how_event_processing_works"></a>   
## События ввода WPF  
 Перенаправленные события в платформе [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] часто применяются для событий ввода. В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] имена перенаправляемых по нисходящей событий по соглашению указываются с префиксом "Preview".  События ввода часто возникают попарно, одно — маршрутизируется по восходящей, другое — по нисходящей.  Например, события <xref:System.Windows.ContentElement.KeyDown> и <xref:System.Windows.ContentElement.PreviewKeyDown> имеют одинаковую подпись, при этом первое является событием, маршрутизируемым по восходящей, а второе — по нисходящей.  Иногда события ввода имеют только восходящую или, возможно, только прямую маршрутизацию.  В документации в разделах, посвященных перенаправленным событиям, содержатся перекрестные ссылки на аналогичные перенаправленные события с альтернативной стратегией маршрутизации, если такие перенаправленные события существуют, и ссылки на разделы документации для уточнения стратегии маршрутизации каждого перенаправленного события.  
  
 События ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], возникающие попарно, реализуются таким образом, что одно действие пользователя из входных данных, такое как нажатие кнопки мыши, последовательно вызовет оба перенаправленные события пары.  Сначала вызывается событие, которое маршрутизируется по нисходящей.  Затем вызывается событие, которое маршрутизируется по восходящей.  Два события буквально совместно используют один и тот же экземпляр данных события, поскольку вызов метода <xref:System.Windows.UIElement.RaiseEvent%2A> в реализации класса, вызвавшего маршрутизирующееся по восходящей событие, приводит к прослушиванию данных события, маршрутизирующегося по восходящей, и повторному использованию его для новых вызываемых событий.  Прослушиватели с обработчиками для события, маршрутизирующегося по нисходящей, могут первыми пометить перенаправленное событие как обработанное \(сначала обработчики классов, затем обработчики экземпляров\).  Если элемент при нисходящей маршрутизации отметил перенаправленное событие как обработанное, уже обработанные данные события отправляются для события, маршрутизирующегося по восходящей, и типичные обработчики, вложенные для эквивалентных маршрутизируемых по восходящей событий, не будут вызываться.  Внешне это будет выглядеть так, как будто обработанное маршрутизируемое по восходящей событие и не вызывалось.  Поведение при обработке полезно использовать при композиции элементов управления, где требуется, чтобы конечный элемент управления \(а не его составные части\) создавал отчеты о событиях проверки нажатия при вводе или событиях ввода на основе фокуса.  Конечный элемент управления находится ближе к корневому элементу в композиции и поэтому имеет возможность обработать событие, передаваемое по нисходящей, первым и, возможно, "заменить" это перенаправленное событие более подходящим для данного элемента управления как часть кода, которая резервирует класс элемента управления.  
  
 В качестве иллюстрации того, как выполняются события ввода, рассмотрим следующий пример.  На следующем рисунке дерева `leaf element #2` является источником события `PreviewMouseDown` и `MouseDown`.  
  
 ![Схема маршрутизации события](../../../../docs/framework/wpf/advanced/media/wcsdkcoreinputevents.png "wcsdkCoreInputEvents")  
Восходящая и нисходящая маршрутизация событий ввода  
  
 Порядок обработки событий выглядит следующим образом:  
  
1.  `PreviewMouseDown` \(нисходящее\) на корневом элементе.  
  
2.  `PreviewMouseDown` \(нисходящее\) на промежуточном элементе №1.  
  
3.  `PreviewMouseDown` \(нисходящее\) на исходном элементе №2.  
  
4.  `MouseDown` \(всплывающее\) на исходном элементе №2.  
  
5.  `MouseDown` \(всплывающее\) на промежуточном элементе №1.  
  
6.  `MouseDown` \(всплывающее\) на корневом элементе.  
  
 Делегат обработчика перенаправленных событий содержит ссылки на два объекта: объект, который вызвал событие, и объект, на котором был вызван обработчик.  Объект, на котором был вызван обработчик, указывается с помощью параметра `sender`.  Объект, в котором было вызвано событие, указывается с помощью свойства <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события.  Перенаправленное событие может так же вызываться и обрабатываться из одного и того же объекта. В этом случае `sender` и <xref:System.Windows.RoutedEventArgs.Source%2A> идентичны \(как показано на этапах 3 и 4 в примере обработки событий\).  
  
 Из\-за нисходящей и восходящей маршрутизации родительские элементы получают события ввода, в которых <xref:System.Windows.RoutedEventArgs.Source%2A> является одним из их дочерних элементов.  Если необходимо знать, что является исходным элементом, можно определить его путем обращения к свойству <xref:System.Windows.RoutedEventArgs.Source%2A>.  
  
 Как правило, после того, как событие ввода помечено как <xref:System.Windows.RoutedEventArgs.Handled%2A>, дополнительные обработчики не вызываются.  Обычно события ввода помечаются как обработанные сразу же после вызова обработчика, который при обработке события ввода опирается на логику приложения.  
  
 Исключением из общего правила о состоянии <xref:System.Windows.RoutedEventArgs.Handled%2A> являются обработчики событий ввода, зарегестрированные для намеренного игнорирования состояния <xref:System.Windows.RoutedEventArgs.Handled%2A> события данных, которые будут по\-прежнему вызываться в маршруте.  Дополнительные сведения см. в разделе [События предварительного просмотра](../../../../docs/framework/wpf/advanced/preview-events.md) или [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Модель общего использования данных события при нисходящей и восходящей маршрутизации и последовательный вызов сначала нисходящих, а потом всплывающих событий не обязательно выполняются для всех перенаправленных событий.  Такое поведение реализуется в зависимости от того, как устройства ввода [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызывают или соединяют пары событий ввода.  Дополнительным скриптом является реализация собственных событий ввода, но эту модель также реализовывать для собственных событий ввода.  
  
 В определенных классах обработка классов используется для определенных событий ввода, как правило, с целью переопределения значения событий ввода, вызываемых пользователем, и вызова новых событий.  Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Дополнительные сведения о вводе данных и о том, как ввод данных и события взаимодействуют в обычных скриптах приложения, см. в разделе [Общие сведения о входных данных](../../../../docs/framework/wpf/advanced/input-overview.md).  
  
<a name="events_styles"></a>   
## EventSetters и EventTriggers  
 В стилях можно включить какой\-либо предопределенный синтаксис [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] обработки события в разметку с помощью <xref:System.Windows.EventSetter>.  При применении стиля указанный обработчик добавляется в экземпляр стиля.  Можно объявить <xref:System.Windows.EventSetter> только для перенаправленного события.  Пример.  Обратите внимание, что указанный метод `b1SetColor` находится в файле кода программной части.  
  
 [!code-xml[EventOvwSupport#XAML2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 Преимущество от этого состоит в том, что стиль, вероятно, будет содержать много другой информации, которая могла бы применяться к любой кнопке в приложении, а наличие <xref:System.Windows.EventSetter>в качестве части стиля способствует повторному использованию кода даже на уровне разметки.  Кроме того <xref:System.Windows.EventSetter> отделяет имена методов для обработчиков от общих имен приложения и страницы разметки.  
  
 Другим особым синтаксисом, объединяющим функции перенаправленных событий и анимации [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], является <xref:System.Windows.EventTrigger>.  Как и в случае с <xref:System.Windows.EventSetter>, только перенаправленные события могут использоваться для <xref:System.Windows.EventTrigger>. Как правило, <xref:System.Windows.EventTrigger> объявляется как часть стиля, но <xref:System.Windows.EventTrigger> может также быть объявлен на уровне элементов страницы как часть коллекции <xref:System.Windows.FrameworkElement.Triggers%2A> или в <xref:System.Windows.Controls.ControlTemplate>. <xref:System.Windows.EventTrigger> позволяет указать объект <xref:System.Windows.Media.Animation.Storyboard>, который выполняется всякий раз, когда перенаправленное событие встречает в своем маршруте элемент, объявляющий <xref:System.Windows.EventTrigger> для этого события.  Преимущество объекта <xref:System.Windows.EventTrigger> перед обычной обработкой события и использованием этого события для запуска существующей раскадровки состоит в том, что <xref:System.Windows.EventTrigger> предоставляет лучший контроль над раскадровкой и ее поведением во время выполнения. Дополнительные сведения см. в разделе [Использование триггеров событий для управления раскадровкой после ее запуска](../../../../docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).  
  
<a name="more_about"></a>   
## Дополнительные сведения о перенаправленных событиях  
 В этом разделе перенаправленные события рассматриваются, главным образом, с точки зрения описания основных понятий. Также приводится руководство по тому, как и когда следует отвечать на перенаправляемые события, которые уже существуют в различных базовых элементах и элементах управления.  Однако, можно создать собственное перенаправленное событие на пользовательском классе вместе со всей необходимой поддержкой, такой как особые для этого события классы данных и делегаты.  Владельцем перенаправленного события может быть любой класс, но перенаправленные события должны вызываться и обрабатываться с помощью производных классов <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.  Дополнительные сведения о пользовательских событиях см. в разделе [Создание пользовательских перенаправленных событий](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
## См. также  
 <xref:System.Windows.EventManager>   
 <xref:System.Windows.RoutedEvent>   
 <xref:System.Windows.RoutedEventArgs>   
 [Маркировка перенаправленных событий как обработанных и обработка классов](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)   
 [Общие сведения о входных данных](../../../../docs/framework/wpf/advanced/input-overview.md)   
 [Общие сведения о системе команд](../../../../docs/framework/wpf/advanced/commanding-overview.md)   
 [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)   
 [Деревья в WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)   
 [Шаблоны слабых событий](../../../../docs/framework/wpf/advanced/weak-event-patterns.md)