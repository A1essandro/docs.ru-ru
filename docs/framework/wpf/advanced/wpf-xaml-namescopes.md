---
title: "Области видимости имен XAML в WPF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "API - интерфейсы, связанные с именами"
  - "классы, FrameworkContentElement"
  - "классы, FrameworkElement"
  - "классы, RegisterName"
  - "FrameworkContentElement - класс"
  - "FrameworkElement - класс"
  - "интерфейсы API, связанные с именами"
  - "области видимости имен"
  - "RegisterName - класс"
  - "стили, области видимости имен в"
  - "шаблоны, области видимости имен в"
  - "XAML, области видимости имен"
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
caps.latest.revision: 19
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 18
---
# Области видимости имен XAML в WPF
Области видимости имен XAML — это понятие, которое идентифицирует объекты, определенные в XAML.  Имена из области видимости имен XAML можно использовать для установления связей между именами объектов, определенными в XAML, и эквивалентными им экземплярами из дерева объектов.  Области видимости имен XAML в управляемом коде [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], как правило, создаются при загрузке отдельных корневых страниц XAML для приложения XAML.  Области видимости имен XAML как программируемые объекты определяются интерфейсом <xref:System.Windows.Markup.INameScope> и реализуются также посредством практического класса <xref:System.Windows.NameScope>.  
  
 [!INCLUDE[autoOutline](../Token/autoOutline_md.md)]  
  
<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## Области видимости имен в загруженных приложениях XAML  
 В более широком контексте программирования или вычислительной техники в концепции программирования включается принцип уникального идентификатора или имени, которое можно использовать для доступа к объекту.  В системах, где используются идентификаторы или имена, область видимости имен определяет границы, в пределах которых процесс или технология ищет объект с запрошенным именем, или границы, в пределах которых применяются уникальные имена.  Эти общие принципы действительны и для областей видимости имен XAML.  В WPF области видимости имен XAML создаются в корневом элементе страницы XAML при загрузке страницы.  Каждое имя, указанное внутри XAML\-страницы, начиная с корневой страницы, добавляется в соответствующую область видимости имен XAML.  
  
 В языке XAML системы WPF элементы, являющиеся общими корневыми элементами \(например, <xref:System.Windows.Controls.Page> и <xref:System.Windows.Window>\), всегда управляют областью видимости имен XAML.  Если такой элемент, как <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, является корневым элементом страницы в разметке, то обработчик [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] неявно добавляет корень <xref:System.Windows.Controls.Page>, чтобы элемент управления <xref:System.Windows.Controls.Page> мог предоставить рабочую область видимости имен XAML.  
  
> [!NOTE]
>  Область видимости имен XAML создается для производственного приложения XAML при выполнении действий построения WPF, даже если атрибуты `Name` и `x:Name` не определены в элементах разметки [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].  
  
 При попытке использования одинакового имени дважды в любой области видимости имен XAML будет вызвано исключение.  Для кода XAML системы WPF, которые содержит код программной части и является компонентом скомпилированного приложения, во время первоначальной компиляции разметки при создании сформированного класса для страницы вызывается исключение при выполнении действий построения WPF.  Для кода XAML, разметка которого не скомпилирована действием построения, исключения, связанные с проблемами области видимости имен XAML, могут вызываться при загрузке кода XAML.  Разработчики XAML должны также учитывать возможность возникновения проблем области видимости имен XAML во время разработки.  
  
### Добавление в дерево объектов среды выполнения  
 Область видимости имен XAML системы WPF создается и определяется в момент синтаксического анализа кода XAML.  Если объект добавляется в дерево объектов уже после того, как выполнен синтаксический анализ кода XAML, сформировавшего это дерево, значение `Name` или `x:Name` нового объекта не приводит к автоматическому обновлению сведений из области видимости имен XAML.  Чтобы добавить имя объекта в область видимости имен XAML системы WPF после загрузки кода XAML, необходимо вызвать соответствующую реализацию метода <xref:System.Windows.Markup.INameScope.RegisterName%2A> для объекта, который определяет область видимости имен XAML \(как правило, для корневой страницы XAML\).  Если имя не зарегистрировано, на добавленный объект нельзя ссылаться по имени с помощью таких методов, как <xref:System.Windows.FrameworkElement.FindName%2A>. Кроме того, такое имя нельзя использовать при подготовке для анимации.  
  
 Наиболее распространенным сценарием для разработчиков приложений является использование метода <xref:System.Windows.FrameworkElement.RegisterName%2A> для регистрации имен в области видимости XAML в текущем корне страницы.  Метод <xref:System.Windows.FrameworkElement.RegisterName%2A> является частью важного сценария для раскадровок, которые подготавливают объекты для анимаций.  Дополнительные сведения см. в разделе [Общие сведения о Storyboard](../../../../docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 При вызове метода <xref:System.Windows.FrameworkElement.RegisterName%2A> для объекта, отличного от объекта, который определяет область видимости имен XAML, имя по\-прежнему будет зарегистрировано в области видимости имен XAML, содержащей вызывающий объект, как если бы метод <xref:System.Windows.FrameworkElement.RegisterName%2A> вызывался для объекта, определяющего эту область видимости имен XAML.  
  
### Области видимости имен XAML в коде  
 Можно создавать и использовать области видимости имен XAML в коде.  Интерфейсы API и понятия, участвующие в создании областей видимости XAML, совпадают с применяемыми в чистом коде, поскольку обработчик XAML для [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использует эти API и понятия при обработке самого кода XAML.  Они существуют в основном для поиска объектов по имени в дереве объектов, которое, как правило, частично или полностью задано в XAML.  
  
 Для приложений, создаваемых программным путем, а не из загруженного кода XAML, объект, определяющий область видимости имен XAML, должен реализовывать интерфейс <xref:System.Windows.Markup.INameScope> или быть классом, производным от класса <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, чтобы поддерживать создание области видимости имен XAML в своих экземплярах.  
  
 Также для любого элемента, не загруженного и не обработанного обработчиком XAML, область видимости имен XAML для объекта не создается и не инициализируется по умолчанию.  Необходимо явным образом создать новую область видимости имен XAML для любого объекта, в котором впоследствии требуется зарегистрировать имена.  Чтобы создать область видимости имен XAML для элемента, вызовите статический метод <xref:System.Windows.NameScope.SetNameScope%2A>.  Укажите объект, являющийся его владельцем, в качестве параметра `dependencyObject` и новый конструктор <xref:System.Windows.NameScope.%23ctor%2A> в качестве параметра `value`.  
  
 Если объект, предоставленный как `dependencyObject` для метода <xref:System.Windows.NameScope.SetNameScope%2A>, не является реализацией <xref:System.Windows.Markup.INameScope> либо классом <xref:System.Windows.FrameworkElement> или <xref:System.Windows.FrameworkContentElement>, то вызов метода <xref:System.Windows.FrameworkElement.RegisterName%2A> для любых дочерних элементов не приведет ни к какому результату.  Если при создании новой области видимости имен XAML произойдет сбой, то вызовы метода <xref:System.Windows.FrameworkElement.RegisterName%2A> вызовут исключение.  
  
 Пример использования интерфейсов API для области видимости имен XAML в коде см. в разделе [Определение пространства имен](../../../../docs/framework/wpf/graphics-multimedia/how-to-define-a-name-scope.md).  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## Области видимости имен XAML в стилях и шаблонах  
 Стили и шаблоны [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] позволяют повторно использовать и применять содержимое простым и понятным способом.  Однако стили и шаблоны могут также включать элементы с именами XAML, определенными на уровне шаблона.  Затем один и тот же шаблон может использоваться несколько раз на странице.  По этой причине стили и шаблоны определяют свои собственные области видимости имен XAML, независимо от расположения в дереве объектов, где применяется стиль или шаблон.  
  
 Рассмотрим следующий пример:  
  
 [!code-xml[XamlOvwSupport#NameScopeTemplates](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 Здесь один тот же шаблон применяется к двум разным кнопкам.  Если у шаблонов не было дискретных областей видимости имен XAML, имя `TheBorder`, используемое в шаблоне, вызовет конфликт имен в области видимости имен XAML.  Каждый экземпляр шаблона имеет свою собственную область видимости имен XAML, поэтому в данном примере каждая область видимости имен экземпляра шаблона будет содержать ровно одно имя.  
  
 Стили также определяют собственные области видимости имен XAML, в основном поэтому части раскадровок могут иметь присвоенные индивидуальные имена.  Эти имена включают конкретные поведения элемента управления, которые будут целевыми элементами с таким именем, даже если шаблон был переопределен как часть настройки элемента управления.  
  
 Из\-за независимых областей видимости имен XAML поиск именованных элементов в шаблоне является более затратной задачей, чем поиск нешаблонного именованного элемента на странице.  Сначала необходимо определить применяемый шаблон, путем получения значения свойства <xref:System.Windows.Controls.Control.Template%2A> элемента управления, в котором шаблон применяется.  Затем вызывается версия шаблона <xref:System.Windows.FrameworkTemplate.FindName%2A>, передающая элемент управления, в котором шаблон применяется в качестве второго параметра.  
  
 Если вы являетесь автором элементом управления и создаете соглашение, в котором конкретный именованный элемент в примененном шаблоне является целью для поведения, заданного самим элементом управления, то вы можете использовать метод <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> из кода реализации элемента управления.  Метод <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> является защищенным, поэтому только автор элемента управления имеет доступ к нему.  
  
 Если при работе в шаблоне требуется получить область видимости имен XAML, в которой применяется шаблон, получите значение свойства <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, а затем вызовите метод <xref:System.Windows.FrameworkElement.FindName%2A>.  В качестве примера работы в шаблоне можно привести ситуацию, когда пишется реализация обработчика событий, в котором событие будет вызвано из элемента в примененном шаблоне.  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## Области видимости имен XAML и интерфейсы API, связанные с именами  
 <xref:System.Windows.FrameworkElement> имеет методы <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> и <xref:System.Windows.FrameworkElement.UnregisterName%2A>.  Если объект, вызываемый этими методами, имеет собственную область видимости имен XAML, то методы элемента вызываются в методах соответствующей области видимости XAML.  В противном случае проверяется, владеет ли родительский элемент собственной областью видимости имен XAML, и этот процесс продолжается рекурсивно до тех пор, пока область видимости имен не будет найдена \(из\-за того, что поведение обработчика XAML гарантирует наличие области видимости имен XAML в корне\).  У <xref:System.Windows.FrameworkContentElement> аналогичное поведение, за тем исключением, что у <xref:System.Windows.FrameworkContentElement> никогда не будет собственной области видимости имен XAML.  Методы существуют в <xref:System.Windows.FrameworkContentElement>, так что вызовы могут быть в конечном счете переданы родительскому элементу <xref:System.Windows.FrameworkElement>.  
  
 <xref:System.Windows.NameScope.SetNameScope%2A> используется для сопоставления новой области видимости имен XAML с существующим объектом.  Можно вызывать метод <xref:System.Windows.NameScope.SetNameScope%2A> несколько раз, чтобы сбросить или очистить область видимости имен XAML, но он предназначен не для этого.  Кроме того, <xref:System.Windows.NameScope.GetNameScope%2A> обычно не используется из кода.  
  
### Реализации области видимости имен XAML  
 Следующие классы реализуют <xref:System.Windows.Markup.INameScope> непосредственно:  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <xref:System.Windows.ResourceDictionary> не использует области видимости имен XAML. Вместо этого он использует ключи, так как это является реализацией словаря.  Единственная причина, по которой <xref:System.Windows.ResourceDictionary> реализует <xref:System.Windows.Markup.INameScope>, является то, что он может вызывать исключения в пользовательском коде, которые помогают уточнить различие между верными областями видимости имен XAML и тем, как <xref:System.Windows.ResourceDictionary> обрабатывает ключи, а также чтобы убедиться, что области видимости в отдельности не применяются к <xref:System.Windows.ResourceDictionary> при помощи родительских элементов.  
  
 <xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style> реализуют <xref:System.Windows.Markup.INameScope> через явные определения интерфейса.  Явные реализации позволяют этим областям видимости имен XAML вести себя условно, когда они доступны через интерфейс <xref:System.Windows.Markup.INameScope>, который определяет, как области видимости имен XAML передаются внутренними процессами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Но явные определения интерфейса не являются частью обычной области API объектов <xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style>, поскольку редко бывает нужно вызывать методы <xref:System.Windows.Markup.INameScope> непосредственно в <xref:System.Windows.FrameworkTemplate> и <xref:System.Windows.Style>, а вместо этого используется другой интерфейс API, такой как <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.  
  
 Следующие классы определяют свои собственные области видимости имен XAML, используя вспомогательный класс <xref:System.Windows.NameScope?displayProperty=fullName> и подключая к его реализации области видимости имен через вложенное свойство <xref:System.Windows.NameScope.NameScope%2A?displayProperty=fullName>:  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## См. также  
 [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)   
 [Директива x:Name](../../../../docs/framework/xaml-services/x-name-directive.md)