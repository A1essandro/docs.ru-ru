---
title: "Архитектура WPF | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework-4.6"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "сходство потоков"
  - "архитектура"
  - "вложенные свойства"
  - "классы, System.Object"
  - "классы, System.Threading.DispatcherObject"
  - "классы, System.Windows.Controls.Control"
  - "классы, System.Windows.DependencyObject"
  - "классы, System.Windows.FrameworkElement"
  - "классы, System.Windows.Media.Visual"
  - "классы, System.Windows.UIElement"
  - "CommandBinding"
  - "компоненты, unmanaged"
  - "Control - класс"
  - "данные - шаблоны"
  - "DependencyObject - класс"
  - "DispatcherObject - класс"
  - "FrameworkElement - класс"
  - "INotifyPropertyChange - интерфейс"
  - "интерфейсы, INotifyPropertyChange"
  - "milcore"
  - "алгоритм рисования"
  - "свойства, присоединенные"
  - "Раскадровки"
  - "System.Object - класс"
  - "System.Threading.DispatcherObject - класс"
  - "System.Windows.Controls.Control - класс"
  - "System.Windows.DependencyObject - класс"
  - "System.Windows.FrameworkElement - класс"
  - "System.Windows.Media.Visual - класс"
  - "System.Windows.UIElement - класс"
  - "thread, сходство"
  - "UIElement - класс"
  - "неуправляемые компоненты"
  - "Visual - класс"
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
caps.latest.revision: 17
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 16
---
# Архитектура WPF
В этом разделе предлагается ознакомительная демонстрация иерархии классов [!INCLUDE[TLA#tla_wpf](../../../../includes/tlasharptla-wpf-md.md)].  Она охватывает большую часть подсистем [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] и описывает их взаимодействие.  Здесь также подробно рассматриваются некоторые архитектурные решения [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  
  
   
  
<a name="System_Object"></a>   
## System.Object  
 Основная модель программирования [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] доступна через управляемый код.  Ранее, на этапе проектирования [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], несколько раз обсуждалось, где следует провести черту между управляемыми и неуправляемыми компонентами системы.  [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] предоставляет ряд возможностей, которые делают разработку более продуктивной и надежной \(включая управление памятью, обработку ошибок, систему общих типов и т. д.\), но требуют некоторых затрат.  
  
 Основные компоненты [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] показаны на расположенном ниже рисунке.  Красные разделы диаграммы \(PresentationFramework, PresentationCore и milcore\) представляют собой основные части кода [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  Только один из этих компонентов является неуправляемым — milcore.  Компонент milcore написан в неуправляемом коде, чтобы обеспечить тесную интеграцию с [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)].  Все отрисовки в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] выполнены с помощью подсистемы [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)], позволяющей эффективно использовать оборудование и программное обеспечение для отрисовки.  Для [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] также необходим тонкий контроль над памятью и выполнением.  Механизм композиции в milcore крайне чувствителен к производительности и требует отказа от многих преимуществ [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] в пользу производительности.  
  
 ![Размещение WPF в платформе .NET Framework.](../../../../docs/framework/wpf/advanced/media/wpf-architect1.png "wpf\_architect1")  
  
 Связь между управляемыми и неуправляемыми частями [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] обсуждается далее в этом разделе.  Остальная часть управляемой модели программирования описана ниже.  
  
<a name="System_Threading_DispatcherObject"></a>   
## System.Threading.DispatcherObject  
 Большинство объектов в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] произошли от <xref:System.Windows.Threading.DispatcherObject>, который предоставляет базовые конструкции для работы с параллелизмом и потоковостью.  [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] базируется на системе обмена сообщениями, реализуемой диспетчером.  Его работа очень похожа на обычную загрузку сообщений в [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]; в действительности диспетчер [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] использует сообщения User32 для выполнения перекрестных вызовов потоков.  
  
 Существует два основных понятия при обсуждении параллельной работы в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] — диспетчер и сходство потоков.  
  
 На этапе проектирования [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] основной целью был переход к одному потоку выполнения при непотоковой модели "со сходством".  Сходство потоков случается, когда компонент использует идентификацию выполняемого потока для сохранения некоторых типов состояния.  Наиболее распространенной формой этого является использование локальной памяти потока \(TLS\) для сохранения состояния.  Сходство потоков требует, чтобы каждый логический поток выполнения принадлежал только одному физическому потоку в операционной системе, что создает большую нагрузку на память.  В итоге сохранилась синхронизация потоковой модели WPF с существующей потоковой моделью User32 однопотокового выполнения со сходством потоков.  Основной причиной этого явилась функциональная совместимость — для всех систем, таких как [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], буфер обмена и Internet Explorer, требуется выполнение в одном сходном потоке \(STA\).  
  
 Пусть имеются объекты с организацией потоковой обработки STA и необходим способ связи между потоками и проверка нахождения в правильном потоке.  В этом заключается роль диспетчера.  Диспетчер — это основная диспетчерская система управления сообщениями, включающая несколько очередей с назначенными приоритетами.  Примеры сообщений включают необработанные входящие уведомления \(перемещение мыши\), функции Framework \(макет\) или пользовательские команды \(выполнение этого метода\).  Благодаря наследованию из <xref:System.Windows.Threading.DispatcherObject> создается объект [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], который обладает функциями STA и получает во время создания указатель на диспетчер.  
  
<a name="System_Windows_DependencyObject"></a>   
## System.Windows.DependencyObject  
 Одним из основных архитектурных принципов, используемых в построении [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], является предпочтение свойств методам или событиям.  Свойства являются декларативными и с их помощью проще указать цель, а не действие.  Поддерживается также система для отображения содержимого пользовательского интерфейса на основе моделей \(или данных\).  Такой подход оказал влияние на создание дополнительных свойств, к которым можно осуществить привязку в целях лучшего управления поведением приложения.  
  
 Чтобы иметь больше свойств управления системой, требовалась более полная система свойств, чем предоставляемая [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)].  Простым примером такой полноты являются уведомления об изменении.  Для включения двусторонней привязки необходимо, чтобы обе стороны привязки поддерживали уведомления об изменениях.  Чтобы поведение зависело от значений свойств, необходимо получать уведомление в случае изменения значения свойства.  В [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] существует интерфейс **INotifyPropertyChange**, который позволяет объекту публиковать уведомления об изменениях \(однако это необязательно\).  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] предоставляет обширную систему свойств, полученную из <xref:System.Windows.DependencyObject>.  Система свойств действительно является системой свойств "зависимостей" в том смысле, что она отслеживает зависимости между выражениями свойств и автоматически проверяет значения свойства при изменении зависимости.  Например, если имеется наследующее свойство \(например <xref:System.Windows.Controls.Control.FontSize%2A>\), то система автоматически обновляется при изменении свойства в родительском объекте элемента, наследующего значение.  
  
 Основой системы свойств [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] является понятие "выражение свойства".  В этом первом выпуске [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] система выражений свойств закрыта, и все выражения предоставлены как часть Framework.  Выражения объясняют, почему система свойств не поддерживает привязку к данным, создание стилей или жестко запрограммированное наследование, но вместо этого представлена макетами более поздних версий в Framework.  
  
 Система свойств также предоставляет способ разреженного хранения значений свойств.  Поскольку объекты могут иметь десятки \(если не сотни\) свойств, и большинство значений находятся в состоянии по умолчанию \(унаследованы, задаются стилем и т. д.\), не каждый экземпляр объекта должен иметь все определенные в нем свойства в полном объеме.  
  
 Наконец последняя новая особенность системы свойств — это понятие [вложенных свойств](GTMT).  Элементы [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] базируются на принципе повторного использования композиции и компонентов.  Часто бывает так, что некоторому содержащему элементу \(например элементу макета <xref:System.Windows.Controls.Grid>\) требуются дополнительные данные о дочерних элементах для управления их поведением \(например сведения о строках и столбцах\).  Вместо того чтобы сопоставлять все эти свойства с каждым элементом, любой объект может предоставить определения свойств для любого другого объекта.  Это похоже на возможности "expando" JavaScript.  
  
<a name="System_Windows_Media_Visual"></a>   
## System.Windows.Media.Visual  
 После определения системы следующим шагом является рисование пикселей на экране.  Класс <xref:System.Windows.Media.Visual> предоставляет средства для построения дерева визуальных объектов, которые дополнительно включают инструкции по рисованию и метаданные о способе визуализации этих инструкций \(обрезка, преобразование и другие\).  Класс <xref:System.Windows.Media.Visual> разработан максимально облегченным и гибким, так что большинство компонентов скрыто от общего доступа [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] и сильно зависит от защищенных функций обратного вызова.  
  
 Класс <xref:System.Windows.Media.Visual> является реальной точкой входа в систему композиции [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  Класс <xref:System.Windows.Media.Visual> является точкой соединения между двумя подсистемами, управляемым [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] и неуправляемым компонентом milcore.  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] отображает данные, проходя по неуправляемым структурам данных под управлением milcore.  Эти структуры, называемые узлами композиции, представляют собой иерархическое дерево отрисовки с инструкциями по отрисовке в каждом узле.  Это дерево, показанное в правой части расположенного ниже рисунка, доступно только через протокол обмена сообщениями.  
  
 При программировании [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] создаются элементы <xref:System.Windows.Media.Visual> и производные типы, которые осуществляют внутреннее взаимодействие с деревом композиции через этот протокол обмена сообщениями.  Каждый элемент <xref:System.Windows.Media.Visual> в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] может создать один, ни одного или несколько узлов композиции.  
  
 ![Windows Presentation Foundation в визуальном дереве.](../../../../docs/framework/wpf/advanced/media/wpf-architecture2.png "wpf\_architecture2")  
  
 Здесь имеется один очень важный архитектурный момент — все дерево визуальных объектов и инструкций по рисованию кэшируется.  С графической точки зрения [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] использует систему сохраненной отрисовки.  Это позволяет системе осуществлять перерисовку с высокой частотой без блокирования системы композиции при обратных вызовах, обращенных к коду пользователя.  Это помогает предотвратить признаки неотвечающего приложения.  
  
 Другим важным моментом, который не заметен на диаграмме, является то, как система в действительности выполняет композицию.  
  
 В User32 и [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] система работает в немедленном режиме системы обрезки.  Когда требуется визуализация компонента, система устанавливает границы обрезки, вне которых компонент не может изменять пиксели, а затем компонент запрашивает рисование пикселей в этой области.  Эта система работает очень хорошо в системах с ограниченной памятью, поскольку в случае каких\-либо изменений приходится иметь дело только с измененным компонентом — два компонента никогда не воздействуют на цвет одного пикселя.  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] использует "алгоритм художника" для модели рисования.  Это означает, что вместо обрезки каждого компонента каждый компонент запрашивается для отрисовки, начиная с заднего плана и до переднего плана отображения.  Это позволяет рисовать каждый компонент поверх отображения предыдущего компонента.  Преимуществом этой модели является то, что можно создавать сложные, полупрозрачные фигуры.  В сочетании с современным графическим оборудованием эта модель является относительно быстрой \(чего нельзя было сказать о создании User32\/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)]\).  
  
 Как упоминалось ранее, основным принципом [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] является переход к более декларативной, "сфокусированной на свойствах" модели программирования.  В визуальной системе это проявляется в паре любопытных моментов.  
  
 Во\-первых, если говорить о сохраненном режиме графической системы, он действительно отражает переход от обязательной модели DrawLine\/DrawLine к модели, ориентированной на данные — new Line \(\)\/new Line\(\).  Этот переход к управляемой данными отрисовке позволяет выполнять сложные операции в инструкциях по рисованию, выражаемых с помощью свойств.  Типы, получаемые из <xref:System.Windows.Media.Drawing>, являются эффективной объектной моделью для отрисовки.  
  
 Во\-вторых, оценивая систему анимации, можно увидеть, что она является практически полностью декларативной.  Вместо обязательного вычисления разработчиком следующего положения или цвета можно выразить анимации как набор свойств для объекта анимации.  Эти анимации могут выражать замыслы разработчика или проектировщика \(переместить эту кнопку отсюда туда в течение 5 секунд\), и система может определить наиболее эффективный способ для их выполнения.  
  
<a name="System_Windows_UIElement"></a>   
## System.Windows.UIElement  
 <xref:System.Windows.UIElement> определяет основные подсистемы, включая "Макет", "Ввод данных" и "События".  
  
 Макет представляет собой основное понятие в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  Во многих системах либо присутствует фиксированный набор моделей для макетов \(HTML поддерживает три модели для макетов: поток, абсолютное значение и таблицы\), либо вообще нет модели для макета \(User32 в действительности поддерживает только абсолютное размещение\).  Предпосылкой для создания [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] стало желание разработчиков и конструкторов иметь гибкую, расширяемую модель макета, которая управлялась бы значениями свойств, а не императивной логикой.  На уровне <xref:System.Windows.UIElement> вводится основное соглашение для макета — двухэтапная модель с передачей <xref:System.Windows.UIElement.Measure%2A> и <xref:System.Windows.UIElement.Arrange%2A>.  
  
 <xref:System.Windows.UIElement.Measure%2A> позволяет компоненту определить требуемый размер.  Этот этап является отдельным от <xref:System.Windows.UIElement.Arrange%2A>, поскольку существует множество ситуаций, когда родительский элемент запрашивает несколько раз измерение дочернего элемента для определения его оптимального положения и размера.  Тот факт, что родительские элементы запрашивают измерение дочерних, демонстрирует еще один ключевой принцип [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] — размер по содержимому.  Все элементы управления в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] поддерживает возможность изменения размера по размеру их содержимого.  Это значительно упрощает локализацию и позволяет осуществлять динамическую разметку элементов в соответствии с изменением размеров.  На этапе <xref:System.Windows.UIElement.Arrange%2A> родительский элемент может расположить каждый дочерний элемент и определить его конечный размер.  
  
 Много времени часто затрачивается на обсуждение внешней стороны [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] — <xref:System.Windows.Media.Visual> и связанных объектов.  Однако существует также множество новшеств со стороны ввода данных.  Вероятно, наиболее фундаментальным изменением в модели ввода для [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] является согласованная модель, согласно которой события ввода направляются через систему.  
  
 Ввод возникает как сигнал драйверу устройства режима ядра и направляется в нужный процесс и поток через сложный процесс, в котором участвуют ядро Windows и User32.  После того как сообщение User32, соответствующее входным данным, направлено в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], оно преобразуется в сообщение базового ввода для [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] и отправляется к диспетчеру.  [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] позволяет преобразовать события базового ввода в несколько фактических событий, запуская реализацию таких компонентов, как "MouseEnter", на низких уровнях системы с гарантированной доставкой.  
  
 Каждое событие ввода преобразуется, по крайней мере, в два события — событие "предварительного просмотра" и фактическое событие.  Все события в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] имеют представление о маршрутизации через дерево элементов.  События называются "всплывающими", если они перемещаются от конечной точки вверх по дереву к корню, и "нисходящими", если они начинаются от корня дерева и перемещаются вниз к конечной точке.  События предварительного просмотра ввода перемещаются по нисходящей, позволяя любому элементу в дереве фильтровать или обрабатывать событие.  Обычные события \(не предварительного просмотра\) перемещаются по восходящей от конечной точки вверх к корню.  
  
 Это разделение между нисходящим и всплывающим этапами делает возможным согласованную реализацию таких возможностей, как сочетания клавиш.  В User32 сочетания клавиш реализуются посредством одной глобальной таблицы, содержащей все необходимые сочетания клавиш \(Ctrl \+ N сопоставляется с командой "Создать"\).  В диспетчере приложения вызывается метод **TranslateAccelerator**, который будет анализировать входящие сообщения в User32 и определять их соответствие зарегистрированному сочетанию клавиш.  В [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] это не работает, поскольку система полностью "компонуема" — любой элемент может обрабатывать и использовать любые сочетания клавиш.  Наличие этой двухэтапной модели для ввода позволяет компонентам реализовать собственные методы TranslateAccelerator.  
  
 Забегая на шаг вперед, в <xref:System.Windows.UIElement> вводится также понятие CommandBindings.  Система команд [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] позволяет разработчикам определять функциональность в терминах конечной точки команды — нечто, что реализует <xref:System.Windows.Input.ICommand>.  Команды привязки включают элемент для определения соответствия между действием ввода \(CTRL \+ N\) и командой \("Создать"\).  И действия ввода, и определения команд являются расширяемыми и могут быть связаны вместе во время использования.  Это делается, например, для того чтобы разрешить конечному пользователю настраивать привязки клавиш, которые ему необходимо использовать в приложении.  
  
 До этого момента в разделе рассматривались "основные" возможности [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] — возможности, реализованные в сборке PresentationCore.  При построении [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] предполагалось четкое разделение между фундаментальными частями \(такими как соглашение для макета с использованием **Measure** и **Arrange**\) и частями Framework \(такими как реализация определенного макета, например <xref:System.Windows.Controls.Grid>\).  Целью являлось предоставление точки расширения внизу стека, что позволило бы внешним разработчикам при необходимости создавать свои собственные структуры.  
  
<a name="System_Windows_FrameworkElement"></a>   
## System.Windows.FrameworkElement  
 Элемент <xref:System.Windows.FrameworkElement> можно рассматривать с двух разных сторон.  Он представляет набор политик и настроек подсистем, введенных на нижнем уровне [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  В нем также вводится набор новых подсистем.  
  
 Основная политика, представленная классом <xref:System.Windows.FrameworkElement>, затрагивает макет приложения.  Класс <xref:System.Windows.FrameworkElement> строится на основе базового контракта макета, представленного <xref:System.Windows.UIElement>, и добавляет понятие "ячейки" макета, что упрощает для авторов макета создание согласованного набора управляемых свойствами семантик макета.  Свойства, такие как <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.Margin%2A> \(для нескольких именований\), обеспечивают всем компонентам, производным от <xref:System.Windows.FrameworkElement>, согласованное поведение внутри контейнеров макета.  
  
 <xref:System.Windows.FrameworkElement> упрощает также доступ к [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] для множества функций на уровне ядра [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].  Например, класс <xref:System.Windows.FrameworkElement> предоставляет прямой доступ к анимации с помощью метода <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>.  Объект <xref:System.Windows.Media.Animation.Storyboard> предоставляет способ создания скриптов нескольких анимаций вместо набора свойств.  
  
 Две наиболее важные вещи, представленные в <xref:System.Windows.FrameworkElement> — это привязка данных и стили.  
  
 Подсистема привязки данных в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] должна быть относительно знакома каждому, кто использовал [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] или [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], чтобы создать [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] приложения.  В каждой из этих систем есть простой способ выразить, что для данного элемента необходимо привязать одно или более свойств к части данных.  [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] обладает полным набором возможностей для привязки свойств, преобразования и привязки списка.  
  
 Одной из наиболее интересных возможностей привязки данных в [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] является введение шаблонов данных.  Шаблоны данных позволяют декларативно указать способ визуализации фрагмента данных.  Вместо создания настраиваемого пользовательского интерфейса, который может быть привязан к данным, можно обойти проблему и позволить данным определять отображение, которое будет создано.  
  
 Создание стилей — это облегченная форма привязки данных.  Посредством создания стилей можно привязать набор свойств из общего определения к одному или нескольким экземплярам элемента.  Стили применяются к элементу посредством либо явной ссылки \(путем задания свойства <xref:System.Windows.FrameworkElement.Style%2A>\), либо неявного связывания стиля с типом [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] элемента.  
  
<a name="System_Windows_Controls_Control"></a>   
## System.Windows.Controls.Control  
 Наиболее значимая возможность для элемента управления — это использование шаблонов.  Если представлять себе систему композиции WPF как систему отрисовки сохраненного режима, то шаблоны позволяют элементу управления описывать свою отрисовку в параметризированной, декларативной форме.  <xref:System.Windows.Controls.ControlTemplate> в действительности не более чем скрипт для создания набора дочерних элементов с привязками к свойствам, предлагаемым элементом управления.  
  
 <xref:System.Windows.Controls.Control> предоставляет набор стандартных свойств <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A> и т. д., которые авторы шаблона могут затем использовать для настройки отображения элемента управления.  Реализация элемента управления обеспечивает модель данных и модель взаимодействия.  Модель взаимодействия определяет набор команд \(таких как "Закрыть" для окна\) и привязки к действиям ввода \(таким как нажатие красного символа X в верхнем углу окна\).  Модель данных предоставляет набор свойств либо для настройки модели взаимодействия, либо для настройки отображения \(определяется шаблоном\).  
  
 Это разделение между моделью данных \(свойства\), моделью взаимодействия \(команды и события\) и моделью отображения \(шаблоны\) позволяет полностью настроить внешний вид и поведение элемента управления.  
  
 Типичным аспектом модели данных элементов управления является модель содержимого.  Если представить себе элемент управления, например <xref:System.Windows.Controls.Button>, то можно увидеть, что он имеет свойство с именем "Content" типа <xref:System.Object>.  В [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] и [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] это свойство было бы строкой, но это ограничивает тип содержимого, который можно поместить на кнопку.  Содержимое для кнопки может представлять собой простую строку, сложный объект данных или все дерево элементов.  В случае объекта данных используется шаблон данных для создания отображения.  
  
<a name="Summary"></a>   
## Сводка  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] предназначается для создания динамических, управляемых данными систем представления данных.  Каждая часть системы предназначена для создания объектов с помощью наборов свойств, которые определяют их поведение.  Привязка данных является основополагающей частью системы и интегрирована на каждом уровне.  
  
 Традиционные приложения создают отображение, а затем привязывают его к некоторым данным.  В [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] все, что касается элемента управления, каждый аспект отображения, создается посредством некоторого типа привязки данных.  Текст внутри кнопки отображается путем создания составного элемента управления внутри кнопки и путем привязки его отображения к свойству содержимого кнопки.  
  
 В начале разработки приложений на основе [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] все должно быть знакомо.  Можно задавать свойства, использовать объекты и привязывать данные практически так же, как с помощью [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] или [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)].  При углублении в архитектуру [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] вы обнаружите, что можно создавать значительно более сложные приложения, которые фундаментально обрабатывают данные, как драйвер ядра приложения.  
  
## См. также  
 <xref:System.Windows.Media.Visual>   
 <xref:System.Windows.UIElement>   
 <xref:System.Windows.Input.ICommand>   
 <xref:System.Windows.FrameworkElement>   
 <xref:System.Windows.Threading.DispatcherObject>   
 <xref:System.Windows.Input.CommandBinding>   
 <xref:System.Windows.Controls.Control>   
 [Общие сведения о связывании данных](../../../../docs/framework/wpf/data/data-binding-overview.md)   
 [Макет](../../../../docs/framework/wpf/advanced/layout.md)   
 [Общие сведения об эффектах анимации](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)