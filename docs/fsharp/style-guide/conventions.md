---
title: 'Соглашения о написании кода на языке F #'
description: 'Дополнительные сведения, общие рекомендации и идиом при написании кода F #.'
ms.date: 05/14/2018
ms.openlocfilehash: f3d16f735ddc1901aeaa5ebb39e2fa2b70a3d836
ms.sourcegitcommit: 43924acbdbb3981d103e11049bbe460457d42073
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/23/2018
---
# <a name="f-coding-conventions"></a>Соглашения о написании кода на языке F #

Из опыта работы с большой F # формулируются следующим соглашениям базы кода. [Пять принципов хороший код F #](index.md#five-principles-of-good-f-code) являются основой каждой рекомендации. Они связаны с [рекомендации по проектированию компонент F #](component-design-guidelines.md), но подходят для любого кода F #, не только компонентов, таких как библиотеки.

## <a name="organizing-code"></a>Организация кода

Возможности два основных способа организации кода F #: модули и пространства имен. Они похожи, но имеют следующие отличия:

* Пространства имен, компилируются как пространства имен .NET. Модули компилируются как статические классы.
* Пространства имен всегда являются верхнего уровня. Модули могут быть верхнего уровня и вложенными в других модулях.
* Пространства имен могут охватывать несколько файлов. Модули не могут.
* Можно снабдить модули `[<RequireQualifiedAccess>]` и `[<AutoOpen>]`.

Следующие рекомендации помогут использовать их для организации кода.

### <a name="prefer-namespaces-at-the-top-level"></a>Предпочтение пространства имен на верхнем уровне

Для любого общедоступной кода пространства имен являются предпочтительным модули верхнего уровня. Так, как они компилируются как пространства имен .NET, они могут использоваться из C# с не возникает проблем.

```fsharp
// Good!
namespace MyCode

type MyClass() =
    ...
```

С помощью модуля верхнего уровня не могут отображаться различные при вызове только из F #, но для C# потребителей, вызывающие объекты могут удивить необходимости квалификации `MyClass` с `MyCode` модуля.

```fsharp
// Bad!
module MyCode

type MyClass() =
    ...
```

### <a name="carefully-apply-autoopen"></a>Тщательно применить `[<AutoOpen>]`

`[<AutoOpen>]` Конструкция можно повредить области Доступные вызывающим объектам и ответ на что-то откуда «magic». Это обычно не хорошо. Исключением из этого правила является основной библиотеки F #, сам (хотя этот факт также немного противоречивым).

Однако это удобный метод при наличии модуля поддержки для открытого API-интерфейса, которую нужно организовать отдельно от, открытый API.

```fsharp
module MyAPI =
    [<AutoOpen>]
    module private Helpers =
        let helper1 x y z =
            ...


    let myFunction1 x =
        let y = ...
        let z = ...

        helper1 x y z
```

Это позволяет вам четко отдельные реализации из открытого API-интерфейса функции без необходимости каждый раз при вызове его полного определения вспомогательного класса.

Кроме того, предоставление доступа к методам расширения и построители выражений на уровне пространства имен могут аккуратно выражаться с помощью `[<AutoOpen>]`.

### <a name="use-requirequalifiedaccess-whenever-names-could-conflict-or-you-feel-it-helps-with-readability"></a>Используйте `[<RequireQualifiedAccess>]` каждый раз, когда это может вызвать конфликт имен, или вы считаете, что оно помогает обеспечивать читаемость

Добавление `[<RequireQualifiedAccess>]` атрибут для модуля указывает, что модуль не может быть открыт, и необходимость явной ссылки на элементы модуля полное доступ. Например `Microsoft.FSharp.Collections.List` модуль имеет этот атрибут.

Это полезно в том случае, когда функции и значения в модуле имеют имена, которые могут вступать в конфликт с именами в других модулях. Требование полного доступа может значительно повысить удобство поддержки долгосрочной и evolvability библиотеки.

```fsharp
[<RequireQualifiedAccess>]
module StringTokenization =
    let parse s = ...

...

let s = getAString()
let parsed = StringTokenization.parse s // Must qualify to use 'parse'
```

### <a name="sort-open-statements-topologically"></a>Сортировка `open` инструкции топологически

В языке F # порядок объявления имеет значение, в том числе с `open` инструкции. В отличие от C#, где эффект `using` и `using static` не зависит от порядка этих инструкций в файле.

В F # открывается в область видимости элементов можно скрывать другие уже присутствует. Это означает, что переупорядочение `open` инструкций может изменить значение кода. Таким образом, любые произвольные сортировки всех `open` инструкций (например, алфавитно-цифровом порядке) обычно не рекомендуется, иначе создать другое поведение, которое могут рассчитывать.

Вместо этого рекомендуется их сортировки [топологически](https://en.wikipedia.org/wiki/Topological_sorting); то есть порядок вашей `open` операторов в порядке, в котором _слои_ определенные системой. Это буквенно-цифровой сортировки в разных слоев топологические может также считаться.

Например вот топологические сортировки для языка F # компилятора открытый API файла службы.

```fsharp
namespace Microsoft.FSharp.Compiler.SourceCodeServices

open System
open System.Collections.Generic
open System.Collections.Concurrent
open System.Diagnostics
open System.IO
open System.Reflection
open System.Text

open Microsoft.FSharp.Compiler
open Microsoft.FSharp.Compiler.AbstractIL
open Microsoft.FSharp.Compiler.AbstractIL.Diagnostics
open Microsoft.FSharp.Compiler.AbstractIL.IL
open Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader
open Microsoft.FSharp.Compiler.AbstractIL.Internal
open Microsoft.FSharp.Compiler.AbstractIL.Internal.Library

open Microsoft.FSharp.Compiler.AccessibilityLogic
open Microsoft.FSharp.Compiler.Ast
open Microsoft.FSharp.Compiler.CompileOps
open Microsoft.FSharp.Compiler.CompileOptions
open Microsoft.FSharp.Compiler.Driver
open Microsoft.FSharp.Compiler.ErrorLogger
open Microsoft.FSharp.Compiler.Infos
open Microsoft.FSharp.Compiler.InfoReader
open Microsoft.FSharp.Compiler.Lexhelp
open Microsoft.FSharp.Compiler.Layout
open Microsoft.FSharp.Compiler.Lib
open Microsoft.FSharp.Compiler.NameResolution
open Microsoft.FSharp.Compiler.PrettyNaming
open Microsoft.FSharp.Compiler.Parser
open Microsoft.FSharp.Compiler.Range
open Microsoft.FSharp.Compiler.Tast
open Microsoft.FSharp.Compiler.Tastops
open Microsoft.FSharp.Compiler.TcGlobals
open Microsoft.FSharp.Compiler.TypeChecker
open Microsoft.FSharp.Compiler.SourceCodeServices.SymbolHelpers

open Internal.Utilities
open Internal.Utilities.Collections
```

Обратите внимание, что разрыв строки отделяет топологические слои с каждым слоем сортируемых алфавитно-цифровом порядке после. Это верно организует кода без случайно затенение значения.

## <a name="use-classes-to-contain-values-that-have-side-effects"></a>Использование классов для содержат значения, которые имеют побочные эффекты

Существует много раз, при инициализации значение может иметь побочные эффекты, например при создании экземпляра контекста базы данных или другого удаленного ресурса. Это заманчивой для инициализации таких сведений в модуль и использовать его в последующих функций:

```fsharp
// This is bad!
module MyApi =
    let dep1 = File.ReadAllText "/Users/{your name}/connectionstring.txt"
    let dep2 = Environment.GetEnvironmentVariable "DEP_2"

    let private r = Random()
    let dep3() = r.Next() // Problematic if multiple threads use this

    let function1 arg = doStuffWith dep1 dep2 dep3 arg
    let function2 arg = doSutffWith dep1 dep2 dep3 arg
```

Это часто не рекомендуются по нескольким причинам:

Во-первых, конфигурацию приложения помещается в базу кода с `dep1` и `dep2`. Это довольно трудно поддерживать в больших баз кода.

Второй, статически инициализированные данных не должно содержать значения, которые не являются потокобезопасными, если компонент себя с помощью нескольких потоков. Четко нарушено `dep3`.

Наконец инициализации модуля компилирует в статический конструктор для всего блока компиляции. Если возникают ошибки при инициализации значение привязки let в этом модуле, он объявляется в качестве `TypeInitializationException` , сохраняется в кэше в течение всего времени существования приложения. Это может быть трудно диагностировать. Обычно имеется внутреннее исключение, которое можно попытаться обсуждения, но если нет, то есть не о том, что корневой причиной является.

Вместо этого используйте только простым классом для хранения зависимости:

```fsharp
type MyParametricApi(dep1, dep2, dep3) =
    member __.Function1 arg1 = doStuffWith dep1 dep2 dep3 arg1
    member __.Function2 arg2 = doStuffWith dep1 dep2 dep3 arg2
```

Это позволяет следующее:

1. Помещает все зависимые состояния за пределами самого API.
2. Настройка теперь может выполняться вне API.
3. Ошибки во время инициализации для зависимых значений не предполагается ведут как `TypeInitializationException`.
4. API-Интерфейс теперь стало проще тестирования.

## <a name="error-management"></a>Управление обработкой ошибок

Управление обработкой ошибок в больших системах является сложной и огромным процесс и существует не silver маркеры в обеспечении системы отказоустойчивые и хорошо работают. Следующие рекомендации должны обеспечивать рекомендации при навигации это сложно пространство.

### <a name="represent-error-cases-and-illegal-state-in-types-intrinsic-to-your-domain"></a>Представления ошибки и недопустимые состояния в типах, встроенными в домене

С [размеченные объединения](../language-reference/discriminated-unions.md), F # дает возможность представлять состояние неисправный программы в системе типов. Пример:

```fsharp
type MoneyWithdrawalResult =
    | Success of amount:decimal
    | InsufficientFunds of balance:decimal
    | CardExpired of DateTime
    | UndisclosedFailure
```

В этом случае тремя способами известных которых может произойти сбой снятия денег со банковского счета. Каждый случай ошибки представить в типе и может поэтому обрабатываться безопасно в программе.

```fsharp
let handleWithdrawal amount =
    let w = withdrawMoney amount
    match w with
    | Success am -> printfn "Successfully withdrew %f" am
    | InsufficientFunds balance -> printfn "Failed: balance is %f" balance
    | CardExpired expiredDate -> printfn "Failed: card expired on %O" expiredDate
    | UndisclosedFailure -> printfn "Failed: unknown"
```

Как правило, если можно моделировать различные способы что-то может **ошибкой** данного домена, затем код обработки ошибок больше не рассматривается как что-нибудь должны предусматривать помимо обычных программного потока. Он является просто частью нормального выполнения программы и не считается **исключительные**. Существует два основных преимущества этого:

1. Проще поддерживать при изменении домена.
2. Ошибка случаев легче модульного теста.

### <a name="use-exceptions-when-errors-cannot-be-represented-with-types"></a>Используйте исключения, если ошибки не могут быть представлены с типами

Не все ошибки могут быть представлены в домене проблему. Эти типы ошибок является *исключительные* по своей природе, поэтому возможность вызывать и перехватывать исключения в языке F #.

Во-первых, рекомендуется ознакомиться с [правила разработки исключений](../../standard/design-guidelines/exceptions.md). Это также применимо к F #.

Основными компонентами, доступные в языке F # в целях возникновения исключений должно рассматриваться в следующем порядке приоритета.

| Функция | Синтаксис | Цель |
|----------|--------|---------|
| `nullArg` | `nullArg "argumentName"` | Вызывает `System.ArgumentNullException` с заданным именем аргумента. |
| `invalidArg` | `invalidArg "argumentName" "message"` | Вызывает `System.ArgumentException` с заданным именем аргумента и сообщений. |
| `invalidOp` | `invalidOp "message"` | Вызывает `System.InvalidOperationException` с указанным сообщением. |
|`raise`| `raise (ExceptionType("message"))` | Универсальный механизм вызова исключений. |
| `failwith` | `failwith "message"` | Вызывает `System.Exception` с указанным сообщением. |
| `failwithf` | `failwithf "format string" argForFormatString` | Вызывает `System.Exception` сообщением определяется строка формата и ее входными данными. |

Используйте `nullArg`, `invalidArg` и `invalidOp` в качестве механизма для вызова `ArgumentNullException`, `ArgumentException` и `InvalidOperationException` при необходимости.

`failwith` И `failwithf` функции обычно следует избегать, так как они вызывают базовый `Exception` тип, не определенное исключение. Согласно [правила разработки исключений](../../standard/design-guidelines/exceptions.md), нужно создать более конкретные исключения, если вы можете.

### <a name="using-exception-handling-syntax"></a>Используя синтаксис обработки исключений

F # поддерживает шаблоны исключение через `try...with` синтаксис:

```fsharp
try
    tryGetFileContents()
with
| :? System.IO.FileNotFoundException as e -> // Do something with it here
| :? System.Security.SecurityException as e -> // Do something with it here
```

Согласование функциональные возможности для выполнения при возникновении исключения с сопоставлением шаблонов может быть немного сложнее, если вы хотите хранить код очистки. Один для обработки этого таким способом является использование [активные шаблоны](../language-reference/active-patterns.md) позволяет вокруг ветвь ошибка с исключением самого функциональность группы. Например может использовать API-Интерфейсы, когда он создает исключение, ограничивающий ценную информацию в метаданные исключения. Развертывание полезные значение в теле записанного исключения внутри активного шаблона и возвращая значение может быть полезным в некоторых ситуациях.

### <a name="do-not-use-monadic-error-handling-to-replace-exceptions"></a>Не используйте результата вычисления обработку ошибок, чтобы заменить исключения

Исключения представляются немного запретным в функциональном программировании. На самом деле исключения нарушает чистоты, поэтому можно безопасно рассматривать их работы не совсем. Однако это не обрабатывает реальность, где необходимо запустить код, и эту среду выполнения, которые могут возникнуть ошибки. В общем случае следует писать код на предположении, что для большинства задач не являются чисто и общее, чтобы свести к минимуму непредсказуемых ситуаций.

Очень важно учесть следующие основные преимущества/аспекты исключений по отношению к их релевантность и целесообразность в среду выполнения .NET и экосистема версий на разных языках в целом:

1. Они содержат подробные диагностические сведения, что очень удобно при отладке проблемы.
2. Это хорошо понятны средой выполнения и других языков .NET.
3. Позволяют уменьшить значительные стандартного по сравнению с кодом, который выходит за пределы пути *избежать* исключения путем реализации некоторого подмножества их семантика на основе ad-hoc.

Это третья точка важен. Для нетривиальных сложные операции не сможет использовать исключений может привести работа со структурами следующим образом:

```fsharp
Result<Result<MyType, string>, string list>
```

Который может легко привести к уязвимости кода как «stringly типизированные» ошибки сопоставления шаблонов:

```fsharp
let result = doStuff()
match result with
| Ok r -> ...
| Error e ->
    if e.Contains "Error string 1" then ...
    elif e.Contains "Error string 2" then ...
    else ... // Who knows?
```

Кроме того может быть заманчивой слишком сложно любое исключение в желания для функции «простой», которая возвращает тип «лучше»:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with _ -> None
```

К сожалению `tryReadAllText` могут создавать многочисленные исключения с учетом множество вещей, которые могут произойти в файловой системе, и этот код немедленно удаляет любые сведения о том, что может фактически пошло не так в вашей среде. Если необходимо заменить этот код с типом результатов, вы будете обратно в «stringly типизированные» ошибка при синтаксическом анализе сообщения:

```fsharp
// This is bad!
let tryReadAllText (path : string) =
    try System.IO.File.ReadAllText path |> Ok
    with e -> Error e.Message

let r = tryReadAllText "path-to-file"
match r with
| Ok text -> ...
| Error e ->
    if e.Contains "uh oh, here we go again..." then ...
    else ...
```

А сам объект исключения в `Error` конструктор просто вызывает должным образом работать с тип исключения во время вызова, а не в функции. Это фактически создает checked исключений, которые заведомо unfun обрабатывать как вызывающий объект API-интерфейса.

— Это хорошая альтернатива для приведенных выше примерах для перехвата *конкретных* исключения и возвращаемое значение может применяться в контексте этого исключения. При изменении `tryReadAllText` следующим образом, функция `None` имеет дополнительные значения:

```fsharp
let tryReadAllTextIfPresent (path : string) =
    try System.IO.File.ReadAllText path |> Some
    with :? FileNotFoundException -> None
```

Вместо функции универсальным, эта функция теперь правильную обработку случае если файл не найден и назначьте этого значения возврата. Это возвращаемое значение можно сопоставить в этом случае ошибка, не отменяя все контекстные сведения или принудительное вызывающим объектам работать со случаем, который может быть не актуальной на данный момент в коде.

Типы, такие как `Result<'Success, 'Error>` подходят для основных операций, где они не являются вложенными и дополнительные типы F # удобны для представления, когда что-то может либо возвращают *что-нибудь* или *ничего*. Они не замены для исключений, хотя и не должны использоваться с целью для замены исключения. Вместо этого они должны применяться осмотрительно для определенных аспектов адрес исключения и ошибки политики управления целевых способами.

## <a name="partial-application-and-point-free-programming"></a>Частичное применение и освободить точки программирование

F # поддерживает частичное применение и, следовательно, различные способы программы в стиле освободить точки. Это может быть использовано для повторного использования кода в модуль или что-то реализации, но обычно это не что-нибудь для предоставления публично. В общем случае точки освободить программирования не является тем, сама по себе и можно добавить когнитивных перешагнуть барьер для тех, кто не занимается стиль.

### <a name="do-not-use-partial-application-and-currying-in-public-apis"></a>Не используйте частичное применение и каррирования в открытых интерфейсах API

За исключением мало использование частичное применение в открытых интерфейсах API могут показаться сложными для потребителей. Как правило `let`-связанных значений в коде F #, **значения**, а не **значений функций**. Смешивание вместе значений и значений функций может привести к сохранение небольшое количество строк кода за счет бит когнитивных издержек, особенно в том случае, если вместе с операторами, такие как `>>` для создания функции.

### <a name="consider-the-tooling-implications-for-point-free-programming"></a>Следует учитывать влияние инструментарий для освобождения точки программирования

Каррированные функции метки не для их аргументов. Это имеет последствия для работы с проектами. Рассмотрим следующие две функции:

```fsharp
let func name age =
    printfn "My name is %s and I am %d years old!" name age

let funcWithApplication =
    printfn "My name is %s and I am %d years old!"
```

Оба являются допустимым функции, но `funcWithApplication` является каррированные функции. При наведении указателя мыши на их типы в редакторе можно увидеть:

```fsharp
val func : name:string -> age:int -> unit

val funcWithApplication : (string -> int -> unit)
```

В источнике вызова с указанием подсказки в инструментарий, такой как Visual Studio не даст значимую информацию о том, что `string` и `int` фактически представляют типа входных данных.

При возникновении освободить точки кода, подобного `funcWithApplication` , является общедоступной, рекомендуется сделать полную η-расширения, чтобы средства можно обратить ваше внимание на значимые имена для аргументов.

Кроме того отладка освободить точки кода может оказаться сложной задачей, если вообще. Средства отладки зависит от значений, привязанный к именам (например, `let` привязок), чтобы можно было проверить середине промежуточных значений выполнения. Если код не имеет значений для проверки, нет ничего для отладки. В будущем, средства отладки может развиваться синтезировать эти значения в зависимости от ранее выполненного пути, но не рекомендуется hedge вашей подходящих на *потенциальных* функциональные возможности отладки.

### <a name="consider-partial-application-as-a-technique-to-reduce-internal-boilerplate"></a>Рассмотрим частичное применение как способ для уменьшения внутреннего стандартного

В отличие от предыдущей точке частичное применение — это здорово средство для снижения стандартного внутри приложения или более глубокого внутренних API-интерфейса. Может быть полезным для модульного тестирования реализации более сложной API, в которых стандартного является неудобной для работы с. Например в следующем коде показано, как это можно сделать какие инфраструктур наиболее макетирования позволяют без учета внешней зависимости такую платформу и изучая связана bespoke API.

Например рассмотрим следующие решения топографии:

```
MySolution.sln
|_/ImplementationLogic.fsproj
|_/ImplementationLogic.Tests.fsproj
|_/API.fsproj
```

`ImplementationLogic.fsproj` Например, может предоставлять код:

```fsharp
module Transactions =
    let doTransaction txnContext txnType balance =
        ...

type Transactor(ctx, currentBalance) =
    member __.ExecuteTransaction(txnType) =
        Transactions.doTransaction ctx txtType currentBalance
        ...
```

Модульное тестирование `Transactions.doTransaction` в `ImplementationLogic.Tests.fspoj` прост:

```fsharp
namespace TransactionsTestingUtil

open Transactions

module TransactionsTestable =
    let getTestableTransactionRoutine mockContext = Transactions.doTransaction mockContext
```

Частично применение `doTransaction` имитации контекстом объекта можно вызывать функции во всех модульных тестов без необходимости создания макеты контекста каждый раз:

```fsharp
namespace TransactionTests

open Xunit
open TransactionTypes
open TransactionsTestingUtil
open TransactionsTestingUtil.TransactionsTestable

let testableContext =
    { new ITransactionContext with
        member __.TheFirstMember() = ...
        member __.TheSecondMember() = ... }

let transactionRoutine = getTestableTransactionRoutine testableContext

[<Fact>]
let ``Test withdrawal transaction with 0.0 for balance``() =
    let expected = ...
    let actual = transactionRoutine TransactionType.Withdraw 0.0
    Assert.Equal(expected, actual)
```

Этот способ не следует применять ко всем компонентам на всей базе кода, но это хороший способ уменьшить стандартный для сложных внутренних компонентов и модульного тестирования эти внутренние компоненты.

## <a name="access-control"></a>Управление доступом

F # имеет несколько возможностей для [управления доступом к](../language-reference/access-control.md), унаследованное от того, что доступно в среде выполнения .NET. Это не просто можно использовать для типов — их можно использовать для функций, слишком.

* Предпочтение не`public` типов и членов, пока вы они нужны в виде общедоступной. Это сводит к минимуму какие несколько потребителей для
* Стремятся сохранить все функциональные возможности поддержки `private`.
* Рассмотрите возможность использования `[<AutoOpen>]` на закрытого модуля вспомогательных функций, если они станут многочисленные.

## <a name="type-inference-and-generics"></a>Определение типа и универсальные шаблоны

Вывод типа, которые можно сохранить большой объем стандартного ввода. И Автоматическое обобщение в компиляторе F # может помочь написать более общий код с практически никаких дополнительных действий со стороны пользователя. Однако эти компоненты не всегда хорошо.

* Рассмотрим маркировкой явные типы в открытых интерфейсах API: имена аргументов и не следует полагаться на определение типа для этого.

    Это обусловлено тем, **вы** должно быть в элементе управления фигуры API, не компилятора. Несмотря на то, что компилятор может сделать нормально задание на вывод типов автоматически, существует возможность иметь форму изменения в API, если внутренние компоненты, которые он основывается на были изменены типы. Это может быть неподходящей, но это почти наверняка приведет к критическим изменением API, потребителей потока данных будет иметь дело с. Вместо этого если явным образом управления фигуры открытые API, можно управлять эти критические изменения. В терминах ддд это может рассматриваться как уровень защиты от повреждения.

* Следует давать понятное имя для универсальных аргументов.

    Если вы пишете действительно универсального кода, который не относится к определенному домену, понятное имя может помочь другим программистам основные сведения о домене, при работе в. Например, параметр типа с именем `'Document` в контексте взаимодействия с документом базы данных упрощает яснее, типы универсального документа может быть принят функции или элемента, вы работаете с.

* Рекомендуется называть PascalCase в параметрах универсального типа.

    Это общий способ для выполнения различных операций в .NET, поэтому рекомендуется использовать PascalCase вместо snake_case или camelCase.

Наконец Автоматическое обобщение не всегда является весьма полезным для пользователей, незнакомых с F # или большой базе кода. Требуется когнитивных с помощью компонентов, которые являются универсальными. Кроме того Если автоматически обобщенной функции не используются для различных типов входных данных (только в том случае, если они предназначены для использования таким образом не говоря), то не имеет смысла реальные им быть универсальным на момент времени. Всегда учитывается, если код, который вы пишете фактически выиграет от быть универсальным.

## <a name="performance"></a>Производительность

F # значения являются неизменяемыми, по умолчанию, что позволяет избежать определенные классы ошибок (особенно эти связанные с параллелизмом и параллелизма). Однако в некоторых случаях для достижения оптимальной (или даже приемлемого) эффективность времени выполнения или выделения памяти диапазон работы может лучше всего реализовать с помощью изменение состояния на месте. Это можно сделать в согласие на основе, то есть с помощью F # с `mutable` ключевое слово.

Однако использование `mutable` в языке F # могут счесть соответствует функциональной чистоты. Это нормально, если настроить ожиданиям из чистоты для [ссылочной прозрачности](https://en.wikipedia.org/wiki/Referential_transparency). Ссылочная прозрачность - не чистоты - — конечная цель при написании функции F #. Это позволяет писать функциональной интерфейс через реализацию на основе изменений для критического кода производительности.

### <a name="wrap-mutable-code-in-immutable-interfaces"></a>Поместите код, изменяемые в неизменяемый интерфейсов

С ссылочной прозрачности как целевой крайне важно написать код, который не предоставляет изменяемый underbelly функций, критический с точки зрения производительности. Например, следующий код реализует `Array.contains` функции в основной библиотеке F #:

```fsharp
[<CompiledName("Contains")>]
let inline contains value (array:'T[]) =
    checkNonNull "array" array
    let mutable state = false
    let mutable i = 0
    while not state && i < array.Length do
        state <- value = array.[i]
        i <- i + 1
    state
```

Несколько раз при вызове этой функции не изменяет базовый массив и не требуется поддерживать любое изменяемое состояние, в его использования. Он прозрачно со ссылочным, несмотря на то, что изменение использует практически в каждой строке кода внутри него.

### <a name="consider-encapsulating-mutable-data-in-classes"></a>Рассмотрим, инкапсулируя изменяемых данных в классах

Предыдущий пример использовать одной функции для инкапсуляции операций с использованием изменяемых данных. Это не всегда достаточно для более сложных наборов данных. Рассмотрим следующий набор функций:

```fsharp
open System.Collections.Generic

let addToClosureTable (key, value) (t: Dictionary<_,_>) =
    if not (t.ContainsKey(key)) then
        t.Add(key, value)
    else
        t.[key] <- value

let closureTableCount (t: Dictionary<_,_>) = t.Count

let closureTableContains (key, value) (t: Dictionary<_, HashSet<_>>) =
    match t.TryGetValue(key) with
    | (true, v) -> v.Equals(value)
    | (false, _) -> false
```

Данный пример кода является высокопроизводительных, но предоставляет структуру данных на основе изменений, что вызывающие объекты отвечают за обеспечение. Это может быть перенесено внутри класса без базовых членов, которые можно изменить:

```fsharp
open System.Collections.Generic

/// The results of computing the LALR(1) closure of an LR(0) kernel
type Closure1Table() =
    let t = Dictionary<Item0, HashSet<TerminalIndex>>()

    member __.Add(key, value) =
        if not (t.ContainsKey(key)) then
            t.Add(key, value)
        else
            t.[key] <- value

    member __.Count = t.Count

    member __.Contains(key, value) =
        match t.TryGetValue(key) with
        | (true, v) -> v.Equals(value)
        | (false, _) -> false
```

`Closure1Table` Инкапсулирует базовой структуры данных на основе изменений, тем самым не выполняется принудительно вызывающих объектов для сохранения структуры данных. Классы являются мощным средством для инкапсуляции данных и подпрограммы, которые основаны на изменение без предоставления сведений вызывающим объектам.

### <a name="prefer-let-mutable-to-reference-cells"></a>Предпочтение `let mutable` для ссылочные ячейки

Ссылочные ячейки являются способ представления ссылку на значение, а не само значение. Несмотря на то, что они могут использоваться для важных для производительности кода, они обычно не рекомендуются. Рассмотрим следующий пример.

```fsharp
let kernels =
    let acc = ref Set.empty

    processWorkList startKernels (fun kernel ->
        if not ((!acc).Contains(kernel)) then
            acc := (!acc).Add(kernel)
        ...)

    !acc |> Seq.toList
```

Использовать ссылочную ячейку теперь «засоряет» все последующие кода с входящим разыменования и повторно ссылки на базовые данные. Вместо этого рассмотрите возможность `let mutable`:

```fsharp
let kernels =
    let mutable acc = Set.empty

    processWorkList startKernels (fun kernel ->
        if not (acc.Contains(kernel)) then
            acc <- acc.Add(kernel)
        ...)

    acc |> Seq.toList
```

Помимо единой точки изменений в середине лямбда-выражения, все остальные кода, касается `acc` можно сделать, таким образом, чтобы не отличается с использованием обычной `let`-привязан постоянное значение. Это поможет упростить его изменение во времени.

## <a name="object-programming"></a>Программирование объектов

F # имеет полную поддержку для объектов и объектно ориентированные концепции (ОО). Хотя многие понятия OO мощным и удобным, не все из них идеально подходят для использования. Перечисленные ниже представлено руководство по категориям OO функций высокого уровня.

**Рассмотрите возможность использования этих функций во многих ситуациях:**

* Нотация с точками (`x.Length`)
* Члены экземпляров
* Неявные конструкторы
* Статические члены
* Обозначения индексатора (`arr.[x]`)
* Именованные и необязательные аргументы
* Интерфейсы и реализации интерфейса

**Не достигнет первым для этих возможностей, но осмотрительно их применяют, когда они удобны для решения проблемы:**

* Перегрузка методов
* Инкапсулированный изменяемых данных.
* Операторы типов
* Свойства Auto
* Реализация `IDisposable` и `IEnumerable`
* Расширения типов
* События
* Структуры
* Делегаты
* перечислениям;

**Если требуется использовать их Избегайте эти функции:**

* Иерархии типа на основе наследования и наследование реализации
* Значения NULL и `Unchecked.defaultof<_>`

### <a name="prefer-composition-over-inheritance"></a>Предпочтение компоновки наследования

[Композиция через наследование](https://en.wikipedia.org/wiki/Composition_over_inheritance) широко устойчивую, может следовать хороший код F #. Основной задачей является следует предоставить базовый класс и не принудительно наследовать от этого базового класса, чтобы функции от вызывающих объектов.

### <a name="use-object-expressions-to-implement-interfaces-if-you-dont-need-a-class"></a>Выражения объекта используются для реализации интерфейсов, если вам не нужен класс

[Выражения объектов](../language-reference/object-expressions.md) позволяют реализовать интерфейсы на ходу, привязывая реализованный интерфейс к значению без необходимости делать это в теле класса. Это удобно, особенно в том случае, если вы _только_ необходимо реализовать интерфейс и не требуются для полного класса.

Например, ниже приведен код, выполняемый в [Ionide](http://ionide.io/) для обеспечения действие исправления кода, если вы добавили символ, не нужно `open` инструкции для:

```fsharp
    let private createProvider () =
        { new CodeActionProvider with
            member this.provideCodeActions(doc, range, context, ct) =
                let diagnostics = context.diagnostics
                let diagnostic = diagnostics |> Seq.tryFind (fun d -> d.message.Contains "Unused open statement")
                let res =
                    match diagnostic with
                    | None -> [||]
                    | Some d ->
                        let line = doc.lineAt d.range.start.line
                        let cmd = createEmpty<Command>
                        cmd.title <- "Remove unused open"
                        cmd.command <- "fsharp.unusedOpenFix"
                        cmd.arguments <- Some ([| doc |> unbox; line.range |> unbox; |] |> ResizeArray)
                        [|cmd |]
                res
                |> ResizeArray
                |> U2.Case1
        }
```

Поскольку нет необходимости для класса при взаимодействии с API кода Visual Studio, выражения объекта являются идеальным средством для этого. Их также можно использовать для модульного тестирования, чтобы заглушки для интерфейса с помощью процедуры тестирования в нерегламентированной форме.

## <a name="type-abbreviations"></a>Сокращенные обозначения типов

[Аббревиатуры типов](../language-reference/type-abbreviations.md) — это удобный способ назначить метку другого типа, например сигнатуру функции или более сложного типа. Например, следующий псевдоним присваивается метка что требуется для определения вычислений с [CNTK](https://www.microsoft.com/cognitive-toolkit/), глубокая обучения библиотеки:

```fsharp
open CNTK

// DeviceDescriptor, Variable, and Function all come from CNTK
type Computation = DeviceDescriptor -> Variable -> Function
```

`Computation` Имя является удобным способом для обозначения любая функция, которая совпадает с подписью, это задание псевдонимов. С помощью сокращенные обозначения типов следующим образом является удобным и позволяет более лаконичный код.

### <a name="avoid-using-type-abbreviations-to-represent-your-domain"></a>Старайтесь не использовать для представления домена сокращенные обозначения типов

Несмотря на то, что сокращенные обозначения типов удобны для присвоения имени сигнатур функций, они могут ввести в заблуждение при сокращение параметра других типов. Рассмотрим это сокращенная форма:

```fsharp
// Does not actually abstract integers.
type BufferSize = int
```

Это может вызывать путаницу несколькими способами:

* `BufferSize` не является абстракцией; Это просто другое название для целого числа.
* Если `BufferSize` предоставляется в открытый интерфейс API, его можно легко пониматься больше, чем просто означает `int`. Как правило, имеет несколько атрибутов, к ним типов домена и не являются простыми типами, например `int`. Это сокращение нарушает этого предположения.
* Регистр `BufferSize` (PascalCase) означает, что этот тип содержит дополнительные данные.
* Этот псевдоним не обеспечивает четкое по сравнению с предоставлением именованный аргумент функции.
* Сокращение не будут проявляться в скомпилированных IL; он представляет собой целое, и этот псевдоним — это конструкция, во время компиляции.

```fsharp
module Networking =
    ...
    let send data (bufferSize: int) =
        ...
```

Таким образом, ловушек с сокращенные обозначения типов для этого используется **не** абстракции по типам, они сокращение параметра. В предыдущем примере `BufferSize` только `int` на самом деле с без дополнительных данных, а также все преимущества из системы типов, что помимо `int` уже есть.
