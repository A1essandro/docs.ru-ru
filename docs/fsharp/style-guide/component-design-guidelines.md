---
title: 'Рекомендации по проектированию компонент F #'
description: 'Дополнительные рекомендации по написанию компонентов F #, предназначен для использования в других вызывающих объектов.'
ms.date: 05/14/2018
ms.openlocfilehash: 7e71710b1bc2fe3e8d7a5a091513a1432650dc04
ms.sourcegitcommit: 43924acbdbb3981d103e11049bbe460457d42073
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/23/2018
---
# <a name="f-component-design-guidelines"></a>Рекомендации по проектированию компонент F #

Этот документ представляет собой набор компонентов правилам разработки для языка F # программирования, в зависимости от F # компонент рекомендации по разработке, v14, Microsoft Research и [другая версия](https://fsharp.org/specs/component-design-guidelines/) изначально курируемый и обслуживается Software Foundation F #.

В этом документе предполагается, что вы знакомы с программированием на языке F #. Выражаем благодарность сообщества F # для их вклад и полезные отзывы в разных версиях данного руководства.

## <a name="overview"></a>Обзор

В этом документе рассматриваются некоторые вопросы, связанные с F # компонент проектирование и кодирование. Компонент может иметь одно из следующих:

* Слой в проекте F #, имеющий внешних потребителей в рамках проекта.
* Библиотека предназначена для использования в коде F # за пределами сборки.
* Библиотека, предназначен для использования в любом языке .NET за пределами сборки.
* Библиотека, предназначенных для распространения через репозитория пакетов, таких как [NuGet](https://nuget.org).

Выполните указания, приведенные в этой статье [пять принципов хороший код F #](index.md#five-principles-of-good-f-code)и таким образом использовать оба функционального и объекта программирования соответствующим образом.

Независимо от того, методику конструктор компонентов и библиотека сталкивается с различными практичный и прозаическом проблемы при попытке создать интерфейс API, проще всего использовать разработчиками. Применение conscientious [правилам разработки библиотеки .NET](../../standard/design-guidelines/index.md) будет управлять процессом по созданию согласованного набора интерфейсов API, удобную для использования.

## <a name="general-guidelines"></a>Общие рекомендации

Существует несколько универсальных правил, применимых к библиотеки F #, независимо от того, целевая аудитория для библиотеки.

### <a name="learn-the-net-library-design-guidelines"></a>Дополнительные сведения согласно правилам разработки библиотеки .NET

Независимо от типа F # кодирования, вы выполняете, важно иметь опыт работы с [правилам разработки библиотеки .NET](../../standard/design-guidelines/index.md). Большинство других F # и .NET программистам будет иметь навыки работы с помощью этих рекомендаций; ожидается код .NET, чтобы соответствовать им.

Согласно правилам разработки библиотеки .NET обеспечивает общие рекомендации относительно именования, конструирование классов и интерфейсов, член конструктора (свойства, методы, события, т. д.) и более и полезные первой точки ссылки для разнообразных руководство по проектированию.

### <a name="add-xml-documentation-comments-to-your-code"></a>Добавьте в код комментарии XML-документации

XML-документации на общедоступных API убедитесь, что пользователи могут получить значительные Intellisense и краткие сведения с помощью этих типов и членов и включить создание документации файлов для библиотеки. В разделе [XML-документации](../language-reference/xml-documentation.md) о различных XML-теги, которые могут использоваться для дополнительных разметка в рамках xmldoc комментарии.

```fsharp
/// A class for representing (x,y) coordinates
type Point =

    /// Computes the distance between this point and another
    member DistanceTo : otherPoint:Point -> float
```

Можно использовать комментарии XML краткая форма (`/// comment`), или стандартные XML-комментарии (`///<summary>comment</summary>`).

### <a name="consider-using-explicit-signature-files-fsi-for-stable-library-and-component-apis"></a>Рассмотрите возможность использования явное подписи файлов (.fsi) для stable библиотеки и API-интерфейсы компонента

С помощью явных подписи файлов в библиотеке F # Сводка сжатой открытый API, для которых позволяет гарантировать, что вы знаете полного открытого рабочей области библиотеки, а также обеспечивает четкое разделение между документации открытых и внутренних сведения о реализации. Обратите внимание, что файлы сигнатур добавить трения изменение открытого API-интерфейса, при необходимости вносить изменения в реализации и подписи файлов. В результате файлы сигнатур должен обычно только быть привело к появлению API становятся упрочило и больше не может значительно измениться.

### <a name="always-follow-best-practices-for-using-strings-in-net"></a>Всегда Следуйте советам и рекомендациям по использованию строк в .NET

Выполните [советы и рекомендации по использованию строк в .NET](../../standard/base-types/best-practices-strings.md) рекомендации. В частности, всегда явно указывать *региональные намерение* преобразования и сравнение строк (где применимо).

## <a name="guidelines-for-f-facing-libraries"></a>Рекомендации для языка F # — с выходом библиотеки

В этом разделе даются рекомендации по разработке открытый F # — с выходом библиотеки; то есть, библиотек, предоставление открытые API, которые предназначены для использования разработчиками F #. Специально для языка F # применяются различные рекомендации по проектированию библиотеки. В случае отсутствия конкретные рекомендации, которые выполните согласно правилам разработки библиотеки .NET — это резервная рекомендации.

### <a name="naming-conventions"></a>Соглашения об именах

#### <a name="use-net-naming-and-capitalization-conventions"></a>Используйте соглашения об именовании и регистр букв .NET

Соглашения об именовании и регистр букв .NET учтена в следующей таблице. Существуют небольшие дополнения для включения конструкции в F #.

| Конструкция | Case | Отделение | Примеры | Примечания |
|-----------|------|------|----------|-------|
| Конкретные типы | PascalCase | Существительное / прилагательных | Список, Double, сложный | Конкретные типы являются структуры, классы, перечисления, делегаты, записей и объединений. Хотя в большинстве случаев нижнего регистра в OCaml имена типов F # приняла схему именования .NET для типов.
| библиотеки DLL           | PascalCase |                 | Fabrikam.Core.dll |  |
| Объединить теги     | PascalCase | существительное | Некоторые из них, добавлять, успех | Не используйте префикс в открытых интерфейсах API. При необходимости использовать префикс, когда внутреннее, такие как "" тип команды = TAlpha | TBeta | TDelta.'' " |
| событие          | PascalCase | Команда | ValueChanged / ValueChanging |  |
| Исключения     | PascalCase |      | WebException | Имя должно заканчиваться «Исключение». |
| Поле          | PascalCase | существительное | CurrentName  | |
| Типы интерфейса |  PascalCase | Существительное / прилагательных | IDisposable | Имя должно начинаться с «I». |
| Метод |  PascalCase |  Команда | ToString | |
| Пространство имен | PascalCase | | Microsoft.FSharp.Core | Как правило, использовать `<Organization>.<Technology>[.<Subnamespace>]`, но удалить организации, если технология не зависит от организации. |
| Параметры | camelCase | существительное |  Имя типа, преобразование, диапазон | |
| Разрешить значения (внутренний) | camelCase или PascalCase | Существительное-команда |  getValue myTable |
| Разрешить значения (внешний) | camelCase или PascalCase | Существительное команда  | List.map Dates.Today | привязки let значения часто являются открытыми, при попытке шаблоны традиционных функциональной разработки. Однако обычно используется PascalCase, если идентификатор может использоваться в других языках .NET. |
| Свойство.  | PascalCase  | Существительное / прилагательных  | IsEndOfFile BackColor  | Логические свойства обычно использование является и могут и должны быть голосами как IsEndOfFile не IsNotEndOfFile.

#### <a name="avoid-abbreviations"></a>Избегать сокращений

Рекомендации по .NET отказа от использования сокращений (например, «использовать `OnButtonClick` вместо `OnBtnClick`»). Сокращений, таких как `Async` для «Асинхронной», которая допустима. Иногда это правило игнорируется для функционального программирования; например `List.iter` использует это сокращение для «итерация». По этой причине использования сокращений, как правило, допустимое в большей степени в языке F #-к-программирование на F #, но по-прежнему обычно следует избегать в проектирования общих компонентов.

#### <a name="avoid-casing-name-collisions"></a>Избежать конфликтов имен регистр

Рекомендации по .NET говорят, что регистр отдельно не может использоваться для устранения неоднозначности конфликтов имен, так как некоторые языки клиента (например, Visual Basic), без учета регистра.

#### <a name="use-acronyms-where-appropriate"></a>Используйте акронимы, если это уместно

Акронимы, таких как XML не сокращений и широко используются в библиотеках .NET в параметр формы (Xml). Только хорошо известными, широко известных сокращений.

#### <a name="use-pascalcase-for-generic-parameter-names"></a>Используйте PascalCase для имен универсального параметра

Используйте PascalCase для универсального параметра имен в открытых интерфейсах API, в том числе для языка F # — с выходом библиотеки. В частности, используйте имена, такие как `T`, `U`, `T1`, `T2` для произвольных универсальных параметров и имен имеет смысл, затем F # — с выходом библиотеки используют имена, такие как `Key`, `Value`, `Arg`(но не к примеру, `TKey`).

#### <a name="use-either-pascalcase-or-camelcase-for-public-functions-and-values-in-f-modules"></a>Используйте PascalCase или camelCase для значений в F # модули и открытые функции

camelCase используется для общих функций, которые предназначены для использования неполное (например, `invalidArg`) и для «функции стандартной коллекции» (например, List.map). В обоих этих случаях имена функций действуют во многом аналогично ключевых слов языка.

### <a name="object-type-and-module-design"></a>Объект, тип и модуль разработки

#### <a name="use-namespaces-or-modules-to-contain-your-types-and-modules"></a>Использовать пространства имен или модули для хранения типов и модулей

Каждый файл F # в компоненте должно начинаться с объявления пространства имен либо объявление модуля.

```fsharp
namespace Fabrikam.BasicOperationsAndTypes

type ObjectType1() =
    ...

type ObjectType2() =
     ...

module CommonOperations =
    ...
```

или

```fsharp
module Fabrikam.BasicOperationsAndTypes

type ObjectType1() =
    ...

type ObjectType2() =
    ...

module CommonOperations =
    ...
```

Ниже приведены различия между использованием модулей и пространств имен для организации кода на верхнем уровне.

* Пространства имен могут охватывать несколько файлов
* Пространства имен не может содержать функции F #, если они включены в модуль, внутренний
* Код для любого заданного модуля должны находиться в пределах одного файла
* Модули верхнего уровня может содержать функции F # без необходимости внутренним

Выбор между верхнего уровня пространства имен или модуля влияет на форме скомпилированного кода и таким образом повлияет на представлении из других языков .NET API в конечном итоге следует заполнить вне кода F #.

#### <a name="use-methods-and-properties-for-operations-intrinsic-to-object-types"></a>Использовать методы и свойства для операций встроенные типы объектов

При работе с объектами, рекомендуется убедиться, что использовать функциональные возможности реализуется в виде методам и свойствам этого типа.

```fsharp
type HardwareDevice() =

    member this.ID = ...

    member this.SupportedProtocols = ...

type HashTable<'Key,'Value>(comparer: IEqualityComparer<'Key>) =

    member this.Add(key, value) = ...

    member this.ContainsKey(key) = ...

    member this.ContainsValue(value) = ...
```

Основная часть функции для данного элемента должны обязательно нельзя реализовать этот элемент, но следует использовать часть этой функциональности.

#### <a name="use-classes-to-encapsulate-mutable-state"></a>Использование классов, инкапсулирующих изменяемое состояние

В языке F # это действие необходимо выполнить где, состояние не уже инкапсулируется другой языковой конструкции, например, закрытия, выражение последовательности или асинхронное вычисление.

```fsharp
type Counter() =
    // let-bound values are private in classes.
    let mutable count = 0

    member this.Next() =
        count <- count + 1
        count
```

#### <a name="use-interfaces-to-group-related-operations"></a>Использовать интерфейсы для группировки связанных операций

Типы интерфейсов используются для представления ряда операций. Этот метод является предпочтительным для другие параметры, например кортежей, функций или записей функций.

```fsharp
type Serializer =
    abstract Serialize<'T> : preserveRefEq: bool -> value: 'T -> string
    abstract Deserialize<'T> : preserveRefEq: bool -> pickle: string -> 'T
```

В ссылке к:

```fsharp
type Serializer<'T> = {
    Serialize : bool -> 'T -> string
    Deserialize : bool -> string -> 'T
}
```

Интерфейсы являются понятия первого класса .NET, который можно использовать для достижения что Функторы обычно отображаются. Кроме того они могут использоваться для кодирования типов, существующий в программу, которое не может быть записей функций.

#### <a name="use-a-module-to-group-functions-which-act-on-collections"></a>Использовать модуль для групповых функций, которые работают с коллекциями

При определении типа коллекции, подберите стандартный набор операций, например `CollectionType.map` и `CollectionType.iter`) для новых типов коллекций.

```fsharp
module CollectionType =
    let map f c =
        ...
    let iter f c =
        ...
```

Если включить такой модуль, выполните стандартным соглашениям об именовании для функций, содержащихся в FSharp.Core.

#### <a name="use-a-module-to-group-functions-for-common-canonical-functions-especially-in-math-and-dsl-libraries"></a>Используйте модуль с функциями группу для распространенных канонические функции, особенно в math и библиотеки DSL

Например `Microsoft.FSharp.Core.Operators` является коллекцией автоматически открытых функций верхнего уровня (как `abs` и `sin`), предоставляемые FSharp.Core.dll.

Аналогичным образом, библиотека статистики может включать модуль с функциями `erf` и `erfc`, для которой предназначен этот модуль должен быть открыт автоматически.

#### <a name="consider-using-requirequalifiedaccess-and-carefully-apply-autoopen-attributes"></a>Рассмотрите возможность использования RequireQualifiedAccess и тщательно применить атрибуты AutoOpen

Добавление `[<RequireQualifiedAccess>]` атрибут для модуля указывает, что модуль не может быть открыт, и необходимость явной ссылки на элементы модуля полное доступ. Например `Microsoft.FSharp.Collections.List` модуль имеет этот атрибут.

Это полезно в том случае, когда функции и значения в модуле имеют имена, которые могут вступать в конфликт с именами в других модулях. Требование полного доступа может значительно повысить удобство поддержки долгосрочной и evolvability библиотеки.

Добавление `[<AutoOpen>]` атрибут к модулю означает модуль будет открываться при открытии содержащего пространства имен. `[<AutoOpen>]` Атрибут также может применяться к сборке, чтобы указать модуль, который автоматически открывается при ссылке на сборку.

Например, Статистика библиотеки **MathsHeaven.Statistics** может содержать `module MathsHeaven.Statistics.Operators` содержащие функции `erf` и `erfc`. Это целесообразно пометить этот модуль как `[<AutoOpen>]`. Это означает `open MathsHeaven.Statistics` также откроет этот модуль и перевести имена `erf` и `erfc` в область действия. Использование другого хорошо `[<AutoOpen>]` для модулей, содержащих методы расширения.

Для связи с чрезмерным использованием `[<AutoOpen>]` приводит к его засорения пространств имен и атрибут должен использоваться с осторожностью. Для определенных библиотек в отдельные домены, разумно использовать `[<AutoOpen>]` может привести к более удобной.

#### <a name="consider-defining-operator-members-on-classes-where-using-well-known-operators-is-appropriate"></a>Рекомендуется определять оператор членов в классах, когда с помощью хорошо известных операторов не соответствует

Иногда классы используются для моделирования математических конструкций, таких как векторов. Если моделируемый домен содержит хорошо известных операторов, определяя их как члены, встроенная в класс полезен.

```fsharp
type Vector(x:float) =

    member v.X = x

    static member (*) (vector:Vector, scalar:float) = Vector(vector.X * scalar)

    static member (+) (vector1:Vector, vector2:Vector) = Vector(vector1.X + vector2.X)

let v = Vector(5.0)

let u = v * 10.0
```

В этом руководстве соответствует Общие рекомендации .NET для этих типов. Тем не менее может быть дополнительно важную роль в F # кодирования, как это позволяет этих типов, которые должны использоваться в методах с ограничениями членов, например List.sumBy и вместе с функциями F #.

#### <a name="consider-using-compiledname-to-provide-a-net-friendly-name-for-other-net-language-consumers"></a>Рассмотрите возможность использования CompiledName для предоставления. NET-понятное имя для других потребителей языков .NET

Иногда может потребоваться назвать в один стиль для потребителей F # (такие как статический член в нижнем регистре, чтобы он располагался как если бы функция привязкой модуля), но имеют другой стиль для имени, если он компилируется в сборку. Можно использовать `[<CompiledName>]` атрибут для предоставления другой стиль для кода не F #, использование сборки.

```fsharp
type Vector(x:float, y:float) =

    member v.X = x
    member v.Y = y

    [<CompiledName("Create")>]
    static member create x y = Vector (x, y)

let v = Vector.create 5.0 3.0
```

С помощью `[<CompiledName>]`, соглашения об именовании .NET можно использовать для пользователей без F # сборки.

#### <a name="use-method-overloading-for-member-functions-if-doing-so-provides-a-simpler-api"></a>Используйте перегрузки метода для функций-членов, если это позволяет достичь более простой API

Перегрузка метода является мощным средством для упрощения API, который может потребоваться выполнить аналогичные функциональные возможности, но различные параметры и аргументы.

```fsharp
type Logger() =

    member this.Log(message) =
        ...
    member this.Log(message, retryPolicy) =
        ...
```

В языке F # чаще для перегрузки на количество аргументов, а не типы аргументов.

#### <a name="hide-the-representations-of-record-and-union-types-if-the-design-of-these-types-is-likely-to-evolve"></a>Скрыть представления типы объединений и записи, если вероятно эволюционирование разработки этих типов

Избегайте раскрытия конкретного представления объектов. Например, конкретная представление <xref:System.DateTime> значения не показывается внешних, открытый API для разработки библиотеки .NET. Во время выполнения общеязыковая среда выполнения знает зафиксированных реализацию, которая будет использоваться на протяжении выполнения. Тем не менее скомпилированный код не сам получают зависимостей от конкретного представления.

#### <a name="avoid-the-use-of-implementation-inheritance-for-extensibility"></a>Избегайте использования наследование реализации для расширяемости

В языке F # наследование реализации используется редко. Кроме того часто иерархий наследования являются сложными и сложным для изменения при поступлении новых требований. Реализация наследования по-прежнему существует в языке F # для совместимости и в редких случаях это лучшее решение проблемы, однако альтернативные методы, необходимо обратиться в программах F #, при разработке для полиморфизма, например реализацию интерфейса.

### <a name="function-and-member-signatures"></a>Функции и член подписи

#### <a name="use-tuples-for-return-values-when-returning-a-small-number-of-multiple-unrelated-values"></a>Используйте кортежей для возвращаемых значений, если возвращается небольшое количество несколько несвязанных значений

Вот хороший пример использования кортеж в тип возвращаемого значения:

```fsharp
val divrem : BigInteger -> BigInteger -> BigInteger * BigInteger
```

Для возврата типов, содержащих множество компонентов или где компоненты относятся к одной сущности характера, рассмотрите возможность использования именованного типа вместо кортеж.

#### <a name="use-asynct-for-async-programming-at-f-api-boundaries"></a>Используйте `Async<T>` для асинхронного программирования на границах API F #

Если имеется соответствующий синхронную операцию с именем `Operation` , возвращающий `T`, то должен быть назван асинхронной операции `AsyncOperation` если он возвращает `Async<T>` или `OperationAsync` если он возвращает `Task<T>`. Для часто используемых типов .NET, предоставляющих методов Begin и End, рассмотрите возможность использования `Async.FromBeginEnd` для записи методы расширения в качестве оболочки для предоставления F # асинхронную модель программирования этих интерфейсов API .NET.

```fsharp
type SomeType =
    member this.Compute(x:int) : int =
        ...
    member this.AsyncCompute(x:int) : Async<int> =
        ...

type System.ServiceModel.Channels.IInputChannel with
    member this.AsyncReceive() =
        ...
```

### <a name="exceptions"></a>Исключения

Исключениями являются исключительные в .NET; то есть они не должно происходить часто во время выполнения. После этого полезные сведения, содержащиеся в них. Исключения — это основное понятие первого класса .NET; поэтому ИТ следующим образом, соответствующие приложения исключений следует использовать как часть конструктора интерфейса компонента.

#### <a name="follow-the-net-guidelines-for-exceptions"></a>Следуйте инструкциям для исключений .NET

[Правилам разработки библиотеки .NET](../../standard/design-guidelines/exceptions.md) предоставить отличные советы по использованию исключения в контексте всех программирования .NET. Из этих инструкций входят следующие:

* Не используйте исключения для обычного потока управления. Несмотря на то, что этот метод часто используется в таких языках, как OCaml, он часто встречаются ошибки и может быть неэффективным на платформе .NET. Вместо этого рассмотрите возможность возврата `None` параметра значение, указывающее на сбой, — это общие или ожидаемых дело.

* Документ исключений для компонентов, если функция используется неправильно.

* Если это возможно, использовать существующие исключения из пространства имен System. Избегайте <xref:System.ApplicationException>, хотя.

* Не вызывайте <xref:System.Exception> при escape для пользовательского кода. Сюда входят избегать использования `failwith`, `failwithf`, которая — это удобные функции для использования при создании сценариев и для разрабатываемого кода, но должны быть удалены из кода библиотеки F # пользу генерации более конкретный тип исключения.

* Используйте `nullArg`, `invalidArg`, и `invalidOp` в качестве механизма для вызова <xref:System.ArgumentNullException>, <xref:System.ArgumentException>, и <xref:System.InvalidOperationException> при необходимости.

#### <a name="consider-using-option-values-for-return-types-when-failure-is-not-an-exceptional-scenario"></a>Рассмотрите возможность использования значения параметров для возвращаемых типов, когда сбой не является исключительной ситуации.

Является подход с использованием .NET для исключения, они должны быть «исключительные»; то есть их следует выполнять относительно редко. Однако некоторые операции (например, поиск таблицы) может не часто. Значения параметров в F # являются отличным способом представляют типы возвращаемого значения этих операций. Эти операции обычно начинаются с префикса имени «try»:

```fsharp
// bad: throws exception if no element meets criteria
member this.FindFirstIndex(pred : 'T -> bool) : int =
    ...

// bad: returns -1 if no element meets criteria
member this.FindFirstIndex(pred : 'T -> bool) : int =
    ...

// good: returns None if no element meets criteria
member this.TryFindFirstIndex(pred : 'T -> bool) : int option =
    ...
```

### <a name="extension-members"></a>Члены расширений

#### <a name="carefully-apply-f-extension-members-in-f-to-f-components"></a>Тщательно применить члены расширений F # в F #-к-компоненты F #

Члены расширений F #, обычно только используется в для операций, находящиеся в замыкании внутренних операций, связанных с типом, в большинстве режимов его использования. Как правило — обеспечить API, которые являются более устойчивым к F # для различных типов .NET.

```fsharp
type System.ServiceModel.Channels.IInputChannel with
    member this.AsyncReceive() =
        Async.FromBeginEnd(this.BeginReceive, this.EndReceive)

type System.Collections.Generic.IDictionary<'Key,'Value> with
    member this.TryGet key =
        let ok, v = this.TryGetValue key
        if ok then Some v else None
```

### <a name="union-types"></a>Типы объединения

#### <a name="use-discriminated-unions-instead-of-class-hierarchies-for-tree-structured-data"></a>Вместо иерархии классов древовидной структурой данных следует использовать размеченные объединения

Древовидной структуры являются рекурсивно определяемые. Это неудобно с наследованием, но элегантное с размеченного объединения.

```fsharp
type BST<'T> =
    | Empty
    | Node of 'T * BST<'T> * BST<'T>
```

Представления данных древовидной с размеченные объединения также позволяет использовать преимущества exhaustiveness в сопоставлениях с шаблоном.

#### <a name="use-requirequalifiedaccess-on-union-types-whose-case-names-are-not-sufficiently-unique"></a>Используйте `[<RequireQualifiedAccess>]` на регистра, имена которых не являются достаточно уникальными типы объединения

Тратится время в домене, где то же имя — это наиболее имя для выполнения различных задач, таких как случаи размеченного объединения. Можно использовать `[<RequireQualifiedAccess>]` для однозначного определения вариантов имена во избежание запуска путаницу ошибок из-за затенения зависит от порядка `open` инструкций

#### <a name="hide-the-representations-of-discriminated-unions-for-binary-compatible-apis-if-the-design-of-these-types-is-likely-to-evolve"></a>Скрыть представления размеченные объединения для двоичного совместимые интерфейсы API, если вероятно эволюционирование разработки этих типов

Типы объединений полагаться на F # подборе шаблонов форм для краткости модели программирования. Как упоминалось ранее, следует избегать раскрытия представления конкретных данных, если может развиваться разработки этих типов.

Например, представление размеченного объединения могут быть скрыты с помощью объявление закрытого или внутреннего или с помощью файла подписи.

```fsharp
type Union =
    private
    | CaseA of int
    | CaseB of string
```

При выводе размеченные объединения беспорядочно, может оказаться неудобным для версии библиотеки без нарушения кода пользователя. Вместо этого рассмотрите возможность предоставления одного или нескольких активных шаблонов, позволяющая сопоставления над значениями типа шаблона.

Активные шаблоны предоставляют альтернативный способ предоставления потребители F # с помощью шаблона при этом избежать предоставления непосредственно типы объединения F #.

### <a name="inline-functions-and-member-constraints"></a>Встроенные функции и ограничения элементов

#### <a name="define-generic-numeric-algorithms-using-inline-functions-with-implied-member-constraints-and-statically-resolved-generic-types"></a>Определение универсального числовые алгоритмы, с помощью встроенных функций с ограничениями подразумеваемых членов и статически разрешаемые универсальных типов

Арифметические член ограничения и ограничения сравнения F # — это стандарт для программирование на F #. Рассмотрим следующий пример кода:

```fsharp
let inline highestCommonFactor a b =
    let rec loop a b =
        if a = LanguagePrimitives.GenericZero<_> then b
        elif a < b then loop a (b - a)
        else loop (a - b) b
    loop a b
```

Тип функции выглядит следующим образом:

```fsharp
val inline highestCommonFactor : ^T -> ^T -> ^T
                when ^T : (static member Zero : ^T)
                and ^T : (static member ( - ) : ^T * ^T -> ^T)
                and ^T : equality
                and ^T : comparison
```

Это подходящая функция для открытого API в математическую библиотеку.

#### <a name="avoid-using-member-constraints-to-simulate-type-classes-and-duck-typing"></a>Старайтесь не использовать ограничения элементов для моделирования классов типа и типизация

Можно имитировать «типизация» с помощью ограничения элементов F #. Однако члены, которые делают с помощью данного объекта не поддерживается в общие используется в F #-к-проекты библиотеки F #. Это происходит потому библиотеки макетов на основе неявных ограничений незнакомых или стандартным приводят к появлению код пользователя, становятся неудобными и привязан к шаблону одной конкретной платформы.

Кроме того является вполне вероятно, что активно использовать ограничения элементов таким образом может привести к компиляции очень много времени.

### <a name="operator-definitions"></a>Определения операторов

#### <a name="avoid-defining-custom-symbolic-operators"></a>Не рекомендуется определять пользовательские операторы, символьные

Пользовательские операторы необходимы в некоторых ситуациях и очень полезных обозначениям устройства в пределах большая часть кода реализации. Для новых пользователей библиотеки именованных функций зачастую проще использовать. Кроме того пользовательские символьных операторы могут быть трудными для документа, и пользователи находят более сложным для поиска справки по операторам, из-за существующих ограничений обработчиков интегрированной среды разработки и поиска.

Поэтому рекомендуется для публикации в виде именованных функций и членов и дополнительно предоставляют операторы для этой функции только в том случае, если значимых преимуществ перевешивают документации и когнитивных затраты на их наличие.

### <a name="units-of-measure"></a>Единицы измерения

#### <a name="carefully-use-units-of-measure-for-added-type-safety-in-f-code"></a>Тщательно единицы измерения используются в целях безопасности добавлен тип в коде F #

Дополнительные сведения о типизации для единицы измерения удаляется при просмотре в других языках .NET. Помните, что компоненты .NET, инструменты и отражения будет видна типы сетей SAN единицы. Например, C# пользователи увидят `float` вместо `float<kg>`.

### <a name="type-abbreviations"></a>Сокращенные обозначения типов

#### <a name="carefully-use-type-abbreviations-to-simplify-f-code"></a>Внимательно используйте сокращенные обозначения типов для упрощения кода F #

Сокращенные имена типов не будут видеть отражения, средства и компоненты .NET. Значительный объем сокращенные обозначения типов также можно сделать домена отображаются сложнее, чем фактически является, которой может запутать потребителей.

#### <a name="avoid-type-abbreviations-for-public-types-whose-members-and-properties-should-be-intrinsically-different-to-those-available-on-the-type-being-abbreviated"></a>Избегайте сокращенные обозначения типов для открытых типов, членов и свойства должны различаться по своей природе с доступными в сокращаемом

В этом случае сокращаемом раскроется много о представление, определенное фактический тип. Вместо этого рассмотрите возможность упаковки сокращение в тип класса или одиночным размеченного объединения (или когда важна производительность, рассмотрите возможность использования типа struct сокращенное название программы-оболочки).

Например — заманчивой определить несколькими карты как особый случай F # карты, например:

```fsharp
type MultiMap<'Key,'Value> = Map<'Key,'Value list>
```

Тем не менее операции логического обозначении для данного типа не совпадают, как операции на карте — например, это целесообразно, чтобы оператор lookup сопоставлены. [ключа] возвращают пустой список, если ключа нет в словаре, а не вызывая исключение.

## <a name="guidelines-for-libraries-for-use-from-other-net-languages"></a>Рекомендации для библиотек для использования из других языков .NET

При разработке библиотеки для использования из других языков .NET, очень важно следовать [правилам разработки библиотеки .NET](../../standard/design-guidelines/index.md). В этом документе, эти библиотеки помечены как соответствующего ванили библиотеки .NET, в отличие от F # — с выходом библиотек, которые используются в языке F # создает без ограничений. Проектирование соответствующего ванили библиотек .NET означает предоставление знакомых и идиоматическое API, согласованное с оставшейся частью .NET Framework, сводя к минимуму использование F #-конкретных конструкций в открытом API. В следующих разделах описываются правила.

### <a name="namespace-and-type-design-for-libraries-for-use-from-other-net-languages"></a>Пространство имен и тип конструктора (для библиотек для использования из других языков .NET)

#### <a name="apply-the-net-naming-conventions-to-the-public-api-of-your-components"></a>Соблюдать правила именования .NET для открытого API-интерфейса компонентов

Обратите внимание на использование сокращенного названия и правила использования прописных букв .NET.

```fsharp
type pCoord = ...
    member this.theta = ...

type PolarCoordinate = ...
    member this.Theta = ...
```

#### <a name="use-namespaces-types-and-members-as-the-primary-organizational-structure-for-your-components"></a>Использовать пространства имен, типов и членов в качестве основной организационной структурой для компонентов

Все файлы, содержащие открытые функциональные возможности должна начинаться с `namespace` объявления только общедоступные сущности в пространствах имен следует и типы. Не используйте модули F #.

Используйте неоткрытые модули для размещения код реализации, служебные типы и служебных функций.

Статические типы имеют преимущество перед модули, поскольку они позволяют будущих развитие API-интерфейса для использования перегрузки и другие концепции проектирования .NET API, которые не могут быть использованы в модулях F #.

Например, вместо открытый API:

```fsharp
module Fabrikam

module Utilities =
    let Name = "Bob"
    let Add2 x y = x + y
    let Add3 x y z = x + y + z
```

Рекомендуется вместо:

```fsharp
namespace Fabrikam

[<AbstractClass; Sealed>]
type Utilities =
    static member Name = "Bob"
    static member Add(x,y) = x + y
    static member Add(x,y,z) = x + y + z
```

#### <a name="use-f-record-types-in-vanilla-net-apis-if-the-design-of-the-types-wont-evolve"></a>Используйте типы записи F # в ванильные API-интерфейсы .NET, если не будет развиваться конструктора типов

Типы записей F #, компилируются в простой класс .NET. Это подходит для некоторых типов простой и стабильность в API-интерфейсы. Следует рассмотреть возможность использования `[<NoEquality>]` и `[<NoComparison>]` атрибуты, чтобы отключить автоматическое создание интерфейсов. Также Избегайте поля изменяемых записей в ванильные API-интерфейсы .NET как эти предоставляет доступ к открытым полем. Всегда учитывайте, будет ли класс предоставляют более гибкий вариант будущих развитие API-интерфейса.

Например следующий код F # предоставляет открытый API для потребителя, C#:

F #:

```fsharp
[<NoEquality; NoComparison>]
type MyRecord =
    { FirstThing : int
        SecondThing : string }
```

C#:

```csharp
public sealed class MyRecord
{
    public MyRecord(int firstThing, string secondThing);
    public int FirstThing { get; }
    public string SecondThing { get; }
}
```

#### <a name="hide-the-representation-of-f-union-types-in-vanilla-net-apis"></a>Скрыть представление типов F # объединения в ванильные API-интерфейсы .NET

Типы объединения F # обычно не используется за границы компонентов даже для F #-к-F # кодирования. Это устройство отлично реализации при использовании внутри в компоненты и библиотеки.

При разработке ванильные .NET API, можно спрятать представление типа объединения с помощью объявления private или файл сигнатур.

```fsharp
type PropLogic =
    private
    | And of PropLogic * PropLogic
    | Not of PropLogic
    | True
```

Вы также может быть расширено типов, которые внутренне используют объединения представление с элементами для обеспечения требуемой. С выходом NET API.

```fsharp
type PropLogic =
    private
    | And of PropLogic * PropLogic
    | Not of PropLogic
    | True

    /// A public member for use from C#
    member x.Evaluate =
        match x with
        | And(a,b) -> a.Evaluate && b.Evaluate
        | Not a -> not a.Evaluate
        | True -> true

    /// A public member for use from C#
    static member CreateAnd(a,b) = And(a,b)
```

#### <a name="design-gui-and-other-components-using-the-design-patterns-of-the-framework"></a>Проектирование графического пользовательского интерфейса и другими компонентами с помощью шаблонов проектирования платформы

Существует множество различных платформ в .NET, таких как ASP.NET, WPF и WinForms. Соглашения об именовании и проектирования для каждого следует использовать при разработке компонентов, используемых в этих платформ. Например для программирования WPF, применяйте предусмотренные WPF принципы разработки классов, которые вы разрабатываете. Для моделей в программирование пользовательского интерфейса используйте шаблоны проектирования, таких как события и коллекций, основанных на уведомления, например в <xref:System.Collections.ObjectModel>.

### <a name="object-and-member-design-for-libraries-for-use-from-other-net-languages"></a>Объекты и элементы проектирования (для библиотек для использования из других языков .NET)

#### <a name="use-the-clievent-attribute-to-expose-net-events"></a>Используется для предоставления событий .NET CLIEvent-атрибут

Создать `DelegateEvent` с определенной версии .NET типа, которая принимает объект делегата и `EventArgs` (вместо `Event`, с использованием `FSharpHandler` типа по умолчанию), чтобы события, опубликованные в знакомой для других языков .NET.

```fsharp
type MyBadType() =
    let myEv = new Event<int>()

    [<CLIEvent>]
    member this.MyEvent = myEv.Publish

type MyEventArgs(x:int) =
    inherit System.EventArgs()
    member this.X = x

    /// A type in a component designed for use from other .NET languages
type MyGoodType() =
    let myEv = new DelegateEvent<EventHandler<MyEventArgs>>()

    [<CLIEvent>]
    member this.MyEvent = myEv.Publish
```

#### <a name="expose-asynchronous-operations-as-methods-which-return-net-tasks"></a>Предоставлять асинхронные операции как методы, которые возвращают задач .NET

Задачи используются в .NET для представления активных асинхронных вычислений. Задачи — в целом менее композиционная, чем F # `Async<T>` объектов, так как они представляют задачи «уже выполняется» и не может состоять вместе способами, параллельные построения или которой скрыть распространение сигналы отмены и другие контекстные параметры.

Тем не менее несмотря на это, методы, которые возвращают задачи — это стандартное представление об асинхронном программировании на платформе .NET.

```fsharp
/// A type in a component designed for use from other .NET languages
type MyType() =

    let compute (x: int) : Async<int> = async { ... }

    member this.ComputeAsync(x) = compute x |> Async.StartAsTask
```

Вы будете часто Обраб явного токена отмены:

```fsharp
/// A type in a component designed for use from other .NET languages
type MyType() =
    let compute(x:int) : Async<int> = async { ... }
    member this.ComputeAsTask(x, cancellationToken) = Async.StartAsTask(compute x, cancellationToken)
```

#### <a name="use-net-delegate-types-instead-of-f-function-types"></a>Использовать типы делегатов .NET вместо функции типов F #

Здесь «типы функции F #» означает «стрелка» типов, таких как `int -> int`.

Вместо этого:

```fsharp
member this.Transform(f:int->int) =
    ...
```

Выполните следующее.

```fsharp
member this.Transform(f:Func<int,int>) =
    ...
```

Тип функции F # отображается в виде `class FSharpFunc<T,U>` с другими языками .NET и менее подходящим для языковые возможности и средства, которые понимать типы делегата. При создании метода более высокого порядка, предназначенных для .NET Framework 3.5 или более поздней версии, `System.Func` и `System.Action` делегаты являются вправо API-интерфейсы для публикации позволяет разработчикам .NET использовать эти API-интерфейсы в виде трения низкий. (При разработке для .NET Framework 2.0, типы делегатов системные более ограничены; следует использовать предопределенный делегат типы, такие как `System.Converter<T,U>` или определение определенному типу делегата.)

С другой стороны, делегаты .NET не являются естественным для языка F #-с выходом библиотеки (см. следующий раздел на F #-с выходом библиотек). В результате общие стратегии реализации при разработке более высокого порядка методы для соответствующего ванили библиотек .NET является создание всех реализации, с помощью функции типы F #, а затем создать открытый интерфейс API, с помощью делегатов как тонкой оболочкой поверх фактическое F # Реализация.

#### <a name="use-the-trygetvalue-pattern-instead-of-returning-f-option-values-and-prefer-method-overloading-to-taking-f-option-values-as-arguments"></a>Использовать шаблон TryGetValue вместо возвращения значения параметров F # и выбрать предпочтительные перегрузки метода принимать значения параметров F # в качестве аргументов

Общие шаблоны использования для типа параметра F # в API-интерфейсы предпочтительнее реализации в ванильные методы разработки с помощью стандартных .NET API-интерфейсы .NET. Вместо возвращения значения параметра F #, рассмотрите возможность использования возвращаемый тип bool, а также как шаблон «TryGetValue» выходной параметр. И, а F # значения параметра в качестве параметров, рассмотрите возможность использования перегрузки метода или необязательные аргументы.

```fsharp
member this.ReturnOption() = Some 3

member this.ReturnBoolAndOut(outVal : byref<int>) =
    outVal <- 3
    true

member this.ParamOption(x : int, y : int option) =
    match y with
    | Some y2 -> x + y2
    | None -> x

member this.ParamOverload(x : int) = x

member this.ParamOverload(x : int, y : int) = x + y
```

#### <a name="use-the-net-collection-interface-types-ienumerablet-and-idictionarykeyvalue-for-parameters-and-return-values"></a>Используйте интерфейс коллекции .NET типы IEnumerable\<T\> и IDictionary\<ключ, значение\> для параметров и возвращаемых значений

Избегайте использования конкретных типах коллекций например массивов .NET `T[]`, типы F # `list<T>`, `Map<Key,Value>` и `Set<T>`, и .NET конкретные типы коллекций, такие как `Dictionary<Key,Value>`. Согласно правилам разработки библиотеки .NET имеют хороший совет о необходимости использования различных типов коллекций, такие как `IEnumerable<T>`. Некоторые использование массивов (`T[]`) допустима в некоторых случаях на территории производительности. Обратите внимание, особенно, `seq<T>` является просто F # псевдоним для `IEnumerable<T>`, и, следовательно seq часто соответствующего типа нужна .NET API.

Вместо F # списки:

```fsharp
member this.PrintNames(names : string list) =
    ...
```

Использование последовательностей F #:

```fsharp
member this.PrintNames(names : seq<string>) =
    ...
```

#### <a name="use-the-unit-type-as-the-only-input-type-of-a-method-to-define-a-zero-argument-method-or-as-the-only-return-type-to-define-a-void-returning-method"></a>Используйте тип единицы измерения как единственный входной тип метода в определении нулевой аргумент метода или как единственный возвращаемый тип для определения метода, возвращающего void

Избегайте другим пользователям типа единицы. Это хорошо.

```fsharp
✔ member this.NoArguments() = 3

✔ member this.ReturnVoid(x : int) = ()
```

Это неправильный:

```fsharp
member this.WrongUnit( x:unit, z:int) = ((), ())
```

#### <a name="check-for-null-values-on-vanilla-net-api-boundaries"></a>Проверку наличия значений null в пределах границ соответствующего ванили .NET API

Реализация кода F #, как правило, имеют меньшее количество значений null, из-за шаблоны неизменяемый проектирования и ограничения на использование литералов null для типов F #. Других языков .NET часто используют значение null гораздо более часто. По этой причине кода F #, точкой ванильные .NET API необходимо проверить параметры со значением NULL на границе API и запретить поступающих глубже в код F #, реализация этих значений. `isNull` Функции или сопоставления шаблонов `null` шаблон может использоваться.

```fsharp
let checkNonNull argName (arg: obj) =
    match arg with
    | null -> nullArg argName
    | _ -> ()

let checkNonNull` argName (arg: obj) =
    if isNull arg then nullArg argName
    else ()
```

#### <a name="avoid-using-tuples-as-return-values"></a>Избегайте использования кортежи в качестве возвращаемых значений

Вместо этого предпочтительно, возвращая именованный тип хранения статистических данных или использование выходных параметров, чтобы возвращать несколько значений. Хотя кортежи и кортежи, структуры в .NET (в том числе поддержка языков C# для кортежей структуры), они чаще всего не даст идеальный и ожидаемый интерфейс API для разработчиков .NET.

#### <a name="avoid-the-use-of-currying-of-parameters"></a>Избегайте использования каррирования параметров

Используйте соглашения о вызовах .NET ``Method(arg1,arg2,…,argN)``.

```fsharp
member this.TupledArguments(str, num) = String.replicate num str
```

Совет: Если вы разрабатываете библиотеки для использования в любом языке .NET, то нет возможно только при этом некоторые экспериментальный C# и Visual Basic программирования для убедитесь, что библиотеки «вид справа» из этих языков. Также можно использовать средства, такие как .NET Reflector и обозреватель объектов Visual Studio для того, библиотеки и соответствующей документации отображалось должным образом для разработчиков.

## <a name="appendix"></a>Приложение

### <a name="end-to-end-example-of-designing-f-code-for-use-by-other-net-languages"></a>Законченный пример создания кода F # для использования с другими языками .NET

Рассмотрим следующий класс:

```fsharp
open System

type Point1(angle,radius) =
    new() = Point1(angle=0.0, radius=0.0)
    member x.Angle = angle
    member x.Radius = radius
    member x.Stretch(l) = Point1(angle=x.Angle, radius=x.Radius * l)
    member x.Warp(f) = Point1(angle=f(x.Angle), radius=x.Radius)
    static member Circle(n) =
        [ for i in 1..n -> Point1(angle=2.0*Math.PI/float(n), radius=1.0) ]
```

Выведенный тип F # этого класса выглядит следующим образом:

```fsharp
type Point1 =
    new : unit -> Point1
    new : angle:double * radius:double -> Point1
    static member Circle : n:int -> Point1 list
    member Stretch : l:double -> Point1
    member Warp : f:(double -> double) -> Point1
    member Angle : double
    member Radius : double
```

Давайте рассмотрим, как этот тип F # вид программисту, используя другой язык .NET. Например приблизительное C# «подпись» выглядит следующим образом:

```csharp
// C# signature for the unadjusted Point1 class
public class Point1
{
    public Point1();

    public Point1(double angle, double radius);

    public static Microsoft.FSharp.Collections.List<Point1> Circle(int count);

    public Point1 Stretch(double factor);

    public Point1 Warp(Microsoft.FSharp.Core.FastFunc<double,double> transform);

    public double Angle { get; }

    public double Radius { get; }
}
```

Существуют некоторые важные особенности как F # представляет конструкции здесь. Пример:

* Метаданные, такие как имена аргументов был сохранен.

* Методы F #, которые принимают два аргумента становятся методы C#, которые принимают два аргумента.

* Функции и списки становятся ссылки на соответствующие типы в библиотеке F #.

Ниже показано, как настроить этот код необходимо учитывать следующее.

```fsharp
namespace SuperDuperFSharpLibrary.Types

type RadialPoint(angle:double, radius:double) =

    /// Return a point at the origin
    new() = RadialPoint(angle=0.0, radius=0.0)

    /// The angle to the point, from the x-axis
    member x.Angle = angle

    /// The distance to the point, from the origin
    member x.Radius = radius

    /// Return a new point, with radius multiplied by the given factor
    member x.Stretch(factor) =
        RadialPoint(angle=angle, radius=radius * factor)

    /// Return a new point, with angle transformed by the function
    member x.Warp(transform:Func<_,_>) =
        RadialPoint(angle=transform.Invoke angle, radius=radius)

    /// Return a sequence of points describing an approximate circle using
    /// the given count of points
    static member Circle(count) =
        seq { for i in 1..count ->
                RadialPoint(angle=2.0*Math.PI/float(count), radius=1.0) }
```

Выведенный тип F # код выглядит следующим образом:

```fsharp
type RadialPoint =
    new : unit -> RadialPoint
    new : angle:double * radius:double -> RadialPoint
    static member Circle : count:int -> seq<RadialPoint>
    member Stretch : factor:double -> RadialPoint
    member Warp : transform:System.Func<double,double> -> RadialPoint
    member Angle : double
    member Radius : double
```

Подпись C# — теперь следующим образом:

```csharp
public class RadialPoint
{
    public RadialPoint();

    public RadialPoint(double angle, double radius);

    public static System.Collections.Generic.IEnumerable<RadialPoint> Circle(int count);

    public RadialPoint Stretch(double factor);

    public RadialPoint Warp(System.Func<double,double> transform);

    public double Angle { get; }

    public double Radius { get; }
}
```

Чтобы подготовить к использованию этого типа, как часть соответствующего ванили библиотеки .NET, как показано ниже внесены исправления:

* Изменены имена нескольких: `Point1`, `n`, `l`, и `f` стала `RadialPoint`, `count`, `factor`, и `transform`соответственно.

* Используемый тип возвращаемого значения `seq<RadialPoint>` вместо `RadialPoint list` , изменив создания списка с помощью `[ ... ]` построения последовательности с помощью `IEnumerable<RadialPoint>`.

* Используемый тип делегата .NET `System.Func` вместо типа функции F #.

Это позволяет гораздо лучше использовать в коде C#.
