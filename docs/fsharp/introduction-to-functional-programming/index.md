---
title: Введение в функциональное программирование на F#
description: Изучение основ функционального программирования в F#.
ms.date: 10/29/2018
ms.openlocfilehash: d4a9bb0cd826b41aca96e12e2bcb5aab80c18eb4
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "25724481"
---
# <a name="introduction-to-functional-programming-in-f"></a>Введение в функциональное программирование на F# #

Функциональное программирование является стилем, который делается упор на использование функций и постоянные данные. Типизированный функциональное программирование является функционального программирования в сочетании с статические типы, такие как с F#. Как правило в функциональном программировании выделены следующие понятия:

* Функции как основными конструкциями, которые можно использовать
* Выражения вместо инструкций
* Постоянные значения, переменные
* Декларативную модель программирования через императивного программирования

В этой серии, на них рассматриваются концепции и шаблоны в функционального программирования, используя F#. Кроме того, вы узнаете о некоторых F# слишком.

## <a name="terminology"></a>Терминология

Функциональное программирование, как и других парадигм программирования, в состав словаря, который со временем необходимо будет узнать. Ниже приведены некоторые распространенные термины, вы увидите все время.

* **Функция** -функция представляет собой конструкцию, будет преобразовано в выходное при заданном входном. Более формально, его _сопоставляет_ набор из одного элемента к другому набору. Этот формализм она поднимается в конкретных во многих отношениях, особенно при использовании функции, которые работают с коллекциями данных. Это наиболее основных (и важный) концепции функционального программирования. 
* **Выражение** -выражение — это конструкция, в коде, который создает значение. В F#, это значение должно быть привязаны или явным образом игнорировать. Выражения могут быть просто заменены вызов функции.
* **Чистота** -чистоты является свойством функции, таким образом, что его возвращаемое значение всегда является одинаковым для те же аргументы, и что его вычисление не имеет побочных эффектов. Чистая функция полностью зависит от своих аргументов.
* **Ссылочной прозрачности** -ссылочной прозрачности является свойством выражений таким образом, что они могут быть заменены свои выходные данные без влияния на поведение программы.
* **Неизменность** -постоянство означает, что значение не может быть изменен на месте. Это отличает их от переменных, которые можно изменить на месте.

## <a name="examples"></a>Примеры

В следующих примерах демонстрируется следующих базовых понятиях.

### <a name="functions"></a>Функции

Наиболее распространенные и основные конструкции функционального программирования является функция. Ниже приведен простой функции, которая добавляет 1 к целое число.

```fsharp
let addOne x = x + 1
```

Сигнатура типа выглядит следующим образом:

```fsharp
val addOne: x:int -> int
```

Подпись может быть прочитан как, «`addOne` принимает `int` с именем `x` и создаст `int`«. Более формально `addOne` — _сопоставление_ значение из набора целых чисел в набор целых чисел. `->` Токен указывает на это сопоставление. В F#, обычно можно посмотреть на сигнатуру функции, чтобы понять, что она делает.

Таким образом, почему важен подпись? В типизированных функционального программирования, реализации функции меньше часто важным, чем фактический тип подписи! Тот факт, `addOne` добавляет значение в целое число 1 интересен во время выполнения, но при создании программы, тот факт, что он принимает и возвращает `int` является что информирует о том, как его можно использовать эту функцию. Кроме того, как только эта функция правильно (по отношению к его сигнатура типа), диагностики проблем можно сделать только в теле `addOne` функции. Это движущая сила типизированный функционального программирования.

### <a name="expressions"></a>Выражения

Выражения — это конструкции, которые возвращают значения. В отличие от инструкции, которые выполняют действия, выражения можно рассматривать выполняет действие, которое возвращает значение. Выражения используются почти всегда пользу инструкций в функциональном программировании.

Рассмотрим функцию предыдущих `addOne`. Тело `addOne` — это выражение:

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

Она является результатом этого выражения, который определяет тип результата `addOne` функции. Например, выражение, которое представляет эта функция может измениться на быть другого типа, например `string`:

```fsharp
let addOne x = x.ToString() + "1"
```

Подпись функции теперь является:

```fsharp
val addOne: x:'a -> string
```

С момента любого типа в F# может иметь `ToString()` для нее тип `x` стала универсального (вызывается [Автоматическое обобщение](../language-reference/generics/automatic-generalization.md)), и результирующим типом является `string`.

Выражения не только тела функции. Может иметь выражений, возвращающих значение, которое можно использовать в другом месте. Он общий `if`:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if` Выражение создает значение с именем `result`. Обратите внимание, что можно опустить `result` полностью, что делает `if` выражение текст из `addOneIfOdd` функции. Следует помнить о выражениях ключевой момент заключается в том, что они создают значение.

Есть особый тип `unit`, используемый при нет ничего для возврата. Например рассмотрим Эта простая функция:

```fsharp
let printString (str: string) =
    printfn "String is: %s" s
```

Подпись выглядит следующим образом:

```fsharp
val printString: str:string -> unit
```

`unit` Тип указывает, что фактическое значение не возвращается. Это полезно при наличии подпрограмму, которая должна «рабочая», несмотря на наличие значения, которое можно вернуть в результате этой работы.

Это существенно отличаются от императивного программирования, где эквивалент `if` конструкция является оператором, и создание значения часто выполняется с помощью изменения переменных. Например, в C#, код может быть написан следующим образом:

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

Следует отметить, что C# и других языков в стиле C поддерживают [троичное выражение](../../csharp/language-reference/operators/conditional-operator.md), что позволяет условного программирование на основе выражения.

В функциональном программировании очень редко изменяемая значений с помощью инструкций. Несмотря на то, что некоторые функциональные языки поддерживают операторы и изменений, обычно не использовать эти концепции в функциональном программировании.

### <a name="pure-functions"></a>Чистые функции

Как упоминалось ранее, чистые функции являются функции, которые:

* Всегда возвращают значение то же значение для того же входа.
* Не имеют побочных эффектов.

Это можно представить математические функции в этом контексте. В математике функции зависят только от их аргументов и не оказывает никакого влияния. Математические функции `f(x) = x + 1`, значение `f(x)` зависит только от значение `x`. Чистые функции в функциональном программировании являются одинаково.

При написании чистой функции, функция должна зависеть только от своих аргументов и не выполнять никаких действий, которые приводят к побочный эффект.

Вот пример функция, изменяющая, так как он зависит от состояния глобального, изменяемый:

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

`addOneToValue` Функция четко "нечистыми", так как `value` могут быть изменены в любое время, чтобы иметь разное значение 1. Этот шаблон в зависимости от глобальное значение — избегать в функциональном программировании.

Вот еще один пример функции, не являющийся чистым, так как он выполняет побочный эффект:

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

Несмотря на то, что эта функция не зависит от глобальное значение, он записывает значение `x` в выходные данные программы. Несмотря на то, что нет ничего плохого таким образом, это означает, что функция не является чисто.

Удаление `printfn` инструкции наконец делает функцию чисто:

```fsharp
let addOneToValue x = x + 1
```

Несмотря на то, что данная функция не является по своей природе _лучше_ прежней версией с `printfn` инструкции, это гарантирует, что все этой функции будет возвращать значение. При вызове этой функции функцию один раз или 1 миллиарда раз будет по-прежнему результат, в то же самое: просто результатом является значение. Эта предсказуемость полезно в функциональное программирование, так как это означает, что любой чистой функции со ссылочным прозрачен.

### <a name="referential-transparency"></a>Ссылочной прозрачности

Ссылочной прозрачности является свойством выражения и функции. Для выражения со ссылочным прозрачным должен иметь возможность заменить его результирующее значение без изменения ее поведения. Все чистые функции являются со ссылочным прозрачными.

Как и в чистые функции может быть полезным подумать об ссылочной прозрачности с точки зрения математические. В математическое выражение `y = f(x)`, `f(x)` могут быть заменены результат функции и по-прежнему будет равно `y`. Это относится и к ссылочной прозрачности в функциональном программировании.

Рассмотрите возможность вызова ранее определенный `addOneIfOdd` функцию дважды:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result

let res1 = addOneIffOdd 1 // Produces 2
let res2 = addOneIffOdd 2 // Produces 2
```

Можно заменить каждого вызова функции в теле функции, заменив аргумент `input` с каждым из значений:

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result

let res1 =
    let result =
        if isOdd 1 then
            1 + 1
        else
            1

    result
let res2 =
    let result =
        if isOdd 2 then
            2 + 1
        else
            2

    result
```

Оба `res1` и `res2` имеют одинаковое значение, как если бы вызывалась функция, означает, что `addOneIfOdd` со ссылочным прозрачно!

Кроме того функции не нужно быть чистым, также были со ссылочным прозрачными. Рассмотрите предыдущее определение `addOneTovalue`:

```fsharp
let addOneToValue x = 
    printfn "x is %d" x
    x + 1
```

Каждый вызов этой функции можно заменить его телом и того, что будет происходить каждый раз:

* Значение, перед добавлением к, выводится в выходные данные
* Значение имеет 1 добавляется при

При программировании в F#, часто бывает ссылочной прозрачности, цель, а не чистоты. Тем не менее рекомендуется по-прежнему записываемый чистых функций, когда это возможно.

### <a name="immutability"></a>Неизменность

Наконец одним из фундаментальных понятий типизированный функционального программирования является неизменяемости. В F#, все значения являются неизменяемыми по умолчанию. Это означает, что они не могут быть изменяемые локально, если только вы явным образом пометить их как изменяемые.

На практике работы с неизменяемыми значениями означает, что изменить ваш подход к программированию из «Необходимо изменить что-то», чтобы «мне нужно создать новое значение».

Например добавление 1 значение означает, что результатом является новый значение, не изменения существующего:

```fsharp
let value = 1
let secondValue = value + 1
```

В F#, показано в следующем коде **не** изменяет `value` функции; вместо этого он выполняет проверку равенства:

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

Некоторые языки функционального программирования вообще не поддерживают изменения. В F#, он поддерживается, но не значения по умолчанию.

Эта концепция расширяет еще дальше структур данных. В функциональном программировании неизменяемых структур данных такие как наборы (и многих других) имеют другую реализацию, чем изначально может ожидать. По сути, что-то, как добавить элемент в набор не приводит к изменению набора, он создает _новый_ набор с выгод. На самом деле это часто выполняется с другой структурой данных, позволяющий для эффективного отслеживания значение таким образом, чтобы в результате можно предоставить подходящее представление данных.

Этот стиль работы со значениями и структур данных крайне важен, как приходится обрабатывать любая операция, изменяющая что-то, как если бы он создает новую версию от этого. Это позволяет выполнять такие проверки на равенство и сравнимость согласованности в программах.

## <a name="next-steps"></a>Следующие шаги

Следующий раздел тщательно будут рассмотрены функции, исследует различные способы, их можно использовать в функциональном программировании.

[Функций первого класса](first-class-functions.md) рассматриваются функции глубоко, показывающий, как их можно использовать в различных контекстах.

## <a name="further-reading"></a>Дополнительные сведения

[Мышления функционально](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/) series – это еще один интересный ресурс, чтобы узнать о функциональное программирование на F#. Он охватывает основы функционального программирования в смысле практичные и простые для чтения, с помощью F# функции, чтобы продемонстрировать основные понятия.