---
title: Функции как значения первого класса (F#)
description: 'Узнайте, как функции повышаются до состояния первого класса в языке F #.'
ms.date: 05/16/2016
ms.openlocfilehash: cccff5fcf9de150da26422f80cae032ddf21014c
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566669"
---
# <a name="functions-as-first-class-values"></a>Функции как значения первого класса

Определяющей характеристикой функциональных языков программирования является повышение функций до состояния первого класса. Можно сделать с помощью функции, все, что можно сделать со значениями других встроенных типов и иметь возможность сделать это с сопоставимым трудозатрат.

Ниже приведены типичные вопросы для состояния первого класса:

- Можно ли привязать к идентификаторам функций? То есть можно предоставить имена?

- Для хранения функций в структурах данных, например, в списке.

- Можно передать функции в качестве аргумента в вызове функции?

- Можно вернуть функцию из вызова функции?

Последние две меры определяют, что известно как *операции высшего порядка* или *функции высшего порядка*. Функции высшего порядка принимают функции в качестве аргументов и возвращают функции в качестве значений из вызовов функций. Эти операции поддерживают такие основы функционального программирования как функции сопоставления и объединение функций.


## <a name="give-the-value-a-name"></a>Присвойте имя значения

Если функция является значением первого класса, необходимо присвоить ей имя так же, как целые числа, строки и другие встроенные типы данных. Это упоминается в литературе о функциональном программировании привязкой значение идентификатора. F # использует [ `let` привязки](../language-reference/functions/let-bindings.md) для привязки к значениям имена: `let <identifier> = <value>`. Ниже представлены два примера.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet20.fs)]

Функция так же, как легко можно задать имя. В следующем примере определяется функция с именем `squareIt` путем связывания идентификатора `squareIt` для [лямбда-выражение](../language-reference/functions/lambda-expressions-the-fun-keyword.md) `fun n -> n * n`. Функция `squareIt` имеет один параметр `n`, и она возвращает квадрат этого параметра.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet21.fs)]

F # предоставляет следующий более сокращенный синтаксис для достижения такого же результата с меньше ввода кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet22.fs)]

В примерах, приведенных в основном используется первый стиль `let <function-name> = <lambda-expression>`, чтобы подчеркнуть сходства объявления функций и объявления других типов значений. Тем не менее именованных функций могут быть написаны с сокращенный синтаксис. Некоторые примеры записываются в обоих направлениях.


## <a name="store-the-value-in-a-data-structure"></a>Сохранение значения в структуре данных

Значение первого класса может храниться в структуре данных. В следующем коде показано примеры, демонстрирующие хранение значений в списках и в кортеже.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet23.fs)]

Чтобы убедиться, что имя функции, хранимое в кортеже фактически выполняет вычисление функции, в следующем примере используется `fst` и `snd` операторов для извлечения первого и второго элемента из кортежа `funAndArgTuple`. Первый элемент в кортеже — `squareIt` и второй элемент — `num`. Идентификатор `num` привязана в предыдущем примере целое число 10, которое является допустимым аргументом для `squareIt` функции. Второе выражение применяется первый элемент в кортеже, второй элемент в кортеже: `squareIt num`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet24.fs)]

Аналогичным образом, так как идентификатор `num` и может принимать целое число 10 взаимозаменяемы, поэтому можно идентификатор `squareIt` и лямбда-выражение `fun n -> n * n`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet25.fs)]
    
## <a name="pass-the-value-as-an-argument"></a>Передайте значение в качестве аргумента

Если значение имеет состояние первого класса на языке, можно передать в качестве аргумента в функцию. Например общие для передачи целых чисел и строк в качестве аргументов. В следующем коде показано целые числа и строки, передаваемые в качестве аргументов в языке F #.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet26.fs)]

Если функции имеют состояние первого, необходимо передать в качестве аргументов таким же образом. Помните, что это первая характеристика функции высшего порядка.

В следующем примере функция `applyIt` имеет два параметра `op` и `arg`. При отправке в функцию, которая имеет один параметр для `op` и соответствующий аргумент для функции `arg`, функция возвращает результат применения `op` для `arg`. В следующем примере аргумент функции и целочисленный аргумент отправляются таким же образом, с помощью их имен.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet27.fs)]

Возможность отправки функции в качестве аргумента другой функции лежит в основе типичных абстракций функциональных языков программирования, таких как операции сопоставления или фильтрации. Операция сопоставления, например, является функция высшего порядка, захватывающей общее вычисление функции, которые перехода по списку, каким-либо образом каждый элемент и затем возвращают список результатов. Можно увеличить значение каждого элемента в список целых чисел, или квадрат каждого элемента или перевести каждый элемент в списке строк в верхний регистр. Ошибкам часть вычисления является рекурсивным процессом, который проходит по списку и выполняет построение списка возвращаемых результатов. Эта часть захватывается функцией сопоставления. Все же придется создавать для конкретного приложения — функция, которая будет применяться к каждому элементу списка по отдельности (Добавление, возведение в квадрат, изменение регистра). Эта функция отправляется в качестве аргумента в функцию сопоставления как `squareIt` отправляется `applyIt` в предыдущем примере.

F # предоставляет методы сопоставления для большинства типов коллекций, включая [перечислены](../language-reference/lists.md), [массивы](../language-reference/arrays.md), и [последовательности](../language-reference/sequences.md). В следующих примерах используются списки. Синтаксис `List.map <the function> <the list>`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet28.fs)]

Дополнительные сведения см. в разделе [перечислены](../language-reference/lists.md).

## <a name="return-the-value-from-a-function-call"></a>Возвращаемое значение из вызова функции

Наконец Если функция имеет состояние первого класса на языке, необходимо вернуть в качестве значения вызова функции, так же, как возвращаются другие типы, такие как Integer и String.

Следующие вызовы функции возвращают целые числа и отобразить их.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet29.fs)]

Следующий вызов функции возвращает строку.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet30.fs)]

Следующий вызов функции, объявленный внутри нее, возвращает значение типа Boolean. Отображается значение `True`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet31.fs)]

Возможность возвращать функцию в качестве значения вызова функции является второй характеристикой функции высшего порядка. В следующем примере `checkFor` определяется как функция, которая принимает один аргумент `item`и возвращает новую функцию в качестве его значения. Возвращаемая функция принимает список в качестве аргумента, `lst`и выполняется поиск `item` в `lst`. Если `item` присутствует, то функция возвращает `true`. Если `item` не указан, функция возвращает `false`. Как показано в предыдущем разделе, в следующем коде используется функция списка, [List.exists](https://msdn.microsoft.com/library/15a3ebd5-98f0-44c0-8220-7dedec3e68a8), для поиска в списке.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet32.fs)]

В следующем коде используется `checkFor` для создания новой функции, которая принимает один аргумент, списки и ищет 7 в списке.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet33.fs)]

В следующем примере состояние первого класса функций в языке F # для объявления функции, `compose`, которая возвращает композицию двух аргументов функции.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet34.fs)]
    
>[!NOTE]
Для более краткую версию в следующем разделе, «Функции Curried».


Следующий код отправляет две функции в качестве аргументов `compose`, оба из которых принимает один аргумент того же типа. Возвращаемое значение имеет новую функцию, которая представляет собой сочетание двух аргументов функции.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet35.fs)]
    
>[!NOTE] 
F # предоставляет два оператора `<<` и `>>`, которая объединяет функции. Например `let squareAndDouble2 = doubleIt << squareIt` эквивалентно `let squareAndDouble = compose doubleIt squareIt` в предыдущем примере.

В следующем примере возврата функции в качестве значения вызова функции создается простая игра по угадыванию. Чтобы создать игру, вызовите `makeGame` со значением должен угадать, отправленным для `target`. Возвращаемое значение функции `makeGame` — функция, которая принимает один аргумент (предположение) и сообщает, является ли пробное значение правильным.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet36.fs)]

Следующий код вызывает `makeGame`, отправка значение `7` для `target`. Идентификатор `playGame` привязан к возвращаемому лямбда-выражению. Таким образом `playGame` — функция, которая принимает в качестве одного аргумента значение для `guess`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet37.fs)]
    
## <a name="curried-functions"></a>Каррированные функции

Во многих примерах предыдущего раздела можно написать более кратко, используя преимущества неявный *каррирования* в объявлениях функций F #. Каррирование — это процесс преобразования функции, которая имеет более одного параметра в ряд встроенных функций, каждая из которых принимает один параметр. В языке F # по своей природе каррированные функции, имеющие более одного параметра. Например `compose` из предыдущего раздела можно написать, как показано в следующем кратком стиле, с тремя параметрами.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet38.fs)]

Тем не менее, результат зависит от один параметр, который возвращает функция одного параметра, который в свою очередь, возвращает другую функцию одного параметра, как показано в `compose4curried`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet39.fs)]

Можно получить доступ к этой функции несколькими способами. В каждом из следующих примеров возвращает и отображает 18. Можно заменить `compose4` с `compose4curried` ни в одном из примеров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet40.fs)]

Чтобы убедиться, что функция по-прежнему будет работать как раньше, повторите попытку исходных тестовых случаев.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet41.fs)]
    
>[!NOTE] 
Вы можете ограничить каррирование, поместив параметры в кортежи. Дополнительные сведения см. в разделе «Шаблоны параметров» в [параметры и аргументы](../language-reference/parameters-and-arguments.md).

В следующем примере неявное каррирование для написания краткая версия `makeGame`. Сведения о том, как `makeGame` создает и возвращает `game` функции являются менее явными в этом формате, но можно проверить с помощью исходных тестовых случаев, результат равен.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet42.fs)]

Дополнительные сведения о каррировании. в разделе «Частичное приложения из аргументы» в [функции](../language-reference/functions/index.md).


## <a name="identifier-and-function-definition-are-interchangeable"></a>Идентификатор и определение функции являются взаимозаменяемыми
Имя переменной `num` в предыдущих примерах имеет значение целого числа 10, и не удивительно, где `num` является допустимым, 10 допустим также. То же самое справедливо для идентификаторов функций и их значений: везде, где можно использовать имя функции, можно использовать лямбда-выражение, к которому он привязан.

В следующем примере определяется `Boolean` функция, вызываемая `isNegative`, а затем попеременно использует имя функции и определение функции. Следующие три примера возвращают и отображают `False`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet43.fs)]

Чтобы смотреть дальнейшей, заменить значение, `applyIt` привязывается к `applyIt`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet44.fs)]

## <a name="functions-are-first-class-values-in-f"></a>Функции являются значения первого класса в языке F # #

В примерах в предыдущих разделах показано, что функции в F # удовлетворяют критерии для значений первого класса в языке F #:

- Идентификатор можно привязать к определению функции.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet21.fs)]

- Функцию можно хранить в структуре данных.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet45.fs)]

- Функцию можно передать в качестве аргумента.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet46.fs)]

- Функция может возвращать в качестве значения вызова функции.
[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet32.fs)]

Дополнительные сведения о F # см. в разделе [Справочник по языку F #](../language-reference/index.md).

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий код содержит все примеры в этом разделе.

### <a name="code"></a>Код

[!code-fsharp[Main](../../../samples/snippets/fsharp/contour/snippet47.fs)]
    
## <a name="see-also"></a>См. также

[Списки](../language-reference/lists.md)

[Кортежи](../language-reference/tuples.md)

[Функции](../language-reference/functions/index.md)

[`let` Привязки](../language-reference/functions/let-bindings.md)

[Лямбда-выражения: `fun` ключевое слово](../language-reference/functions/lambda-expressions-the-fun-keyword.md)
