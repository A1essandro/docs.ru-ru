---
title: "Учебник по F #"
description: "Изучите некоторые основные возможности программирования языка в этом обзоре с образцами кода F #."
keywords: "Visual f #, f #, функционального программирования, .NET, Обзор"
author: cartermp
ms.author: phcart
ms.date: 01/24/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 49775139-082e-442f-b5a2-dd402399b5d2
ms.openlocfilehash: c027e6b71f35fc3b58750eb164124de145244825
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="tour-of-f"></a>Учебник по F # #

Дополнительные сведения о F # рекомендуется для чтения и записи кода F #.  В этой статье будет играть роль обзор некоторых основных возможностей языка F # и предоставляют некоторые фрагменты кода, которые могут выполняться на компьютере.  Дополнительные сведения о настройке среды разработки, извлечь [Приступая к работе](tutorials/getting-started/index.md).

В языке F # имеются две основные концепции: функции и типы.  Этот учебник будет подчеркнуть языковые возможности, которые попадают в этих двух основных понятиях.

## <a name="how-to-run-the-code-samples"></a>Запуск примеров кода

>[!NOTE]
Ниже приведены два варианта для запуска примеров кода [повторите F #](http://www.tryfsharp.org/Create) (требуется Silverlight) и [F # для ноутбуков Azure](https://notebooks.azure.com/Microsoft/libraries/fsharp/html/FSharp%20for%20Azure%20Notebooks.ipynb) в Microsoft Azure.

— Самый быстрый способ запустить эти примеры кода для использования [F # Interactive](tutorials/fsharp-interactive/index.md).  Просто скопировать и вставить примеры кода и их запуска.  В качестве альтернативы можно настроить проект для компиляции и выполнения кода в консольном приложении.  В разделе [начать](./get-started/index.md) раздел для получения дополнительных сведений.

## <a name="functions-and-modules"></a>Функций и модулей

Самый основной части любой программы на F #, ***функции*** организованы ***модулей***.  [Функции](language-reference/functions/index.md) работать над входные данные для создания выходных значений, и они группируются по [модулей](language-reference/modules.md), которые являются основным способом сгруппировать объекты в F #.  Они определяются с помощью [ `let` привязки](language-reference/functions/let-bindings.md), которой имя функции и определение его аргументов.

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

`let`привязки, также как связать значение с именем, похожа на переменную на других языках.  `let`привязки-это ***неизменяемый*** по умолчанию, что означает, что после привязки значения или функции с именем, его нельзя изменить на месте.  В отличие от переменных в других языках, которые являются ***изменяемый***, то есть их значения можно изменить в любой момент времени.  Если требуется изменяемый привязки можно использовать `let mutable ...` синтаксиса.

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a>Строки, числа и логические значения

Как .NET язык F # поддерживает тот же базовый [типов-примитивов](language-reference/primitive-types.md) , существующие в .NET.

Вот, как различные числовые типы представлены в языке F #.

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

Вот какие логические значения и выполнении основных условную логику выглядит следующим образом:

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

А вот какие basic [строка](language-reference/strings.md) манипуляции выглядит следующим образом:

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a>Кортежи

[Кортежи](language-reference/tuples.md) являются ничего страшного в языке F #.  Они представляют собой группы без имени, но упорядоченных значений, которые можно рассматривать как сами значения.  Рассматривать их как значения, которые объединяются с другими значениями.  Они имеют различных целей, например удобно возврат несколько значений из функции группирования, и значения для некоторых специальных удобства.

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

Начиная с F # 4.1, можно также создать `struct` кортежей.  Они также настроить взаимодействие полностью с C# 7 или Visual Basic 15 кортежи, представляющие собой также `struct` кортежей:

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

Важно обратить внимание, что поскольку `struct` кортежей являются типами значений, не могут быть преобразованы неявно для ссылки на кортежи, или наоборот.  Кроме того, необходимо явным образом преобразовать между кортеж ссылок и структуры.

## <a name="pipelines-and-composition"></a>Конвейеры и компоновка

Передать операторы (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) и композиции операторов (`>>` и `<<`) широко используются при обработке данных в языке F #.  Эти операторы — это функции, которые позволяют установить «конвейеры» функций гибко.  Следующий пример рассматриваются как может воспользоваться преимуществами этих операторов для создания простой работы конвейера.

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L300)]

Приведенном выше примере внесены используется многими функциями F #, включая обработку список функций, функций первого класса и [частичное применение](language-reference/functions/index.md#partial-application-of-arguments).  Несмотря на то, что глубокого понимания каждого из этих понятий, могут стать несколько сложных, следует учитывать как легко функции могут использоваться для обработки данных при построении конвейеров.

## <a name="lists-arrays-and-sequences"></a>Списки, массивы и последовательности

Списки, массивы и последовательности находятся три типа основная коллекция, в основной библиотеке F #.

[Перечислены](language-reference/lists.md) — это упорядоченная, неизменная коллекции элементов того же типа.  Они являются однонаправленных списков, что означает, что они предназначены для перечисления, но плохим выбором для произвольного доступа и объединения, если они имеют большой.  Это отличается от списки в других популярных языков, которые обычно не используется однонаправленного связного списка для представления списков.

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

[Массивы](language-reference/arrays.md) являются фиксированного размера, *изменяемый* коллекции элементов того же типа.  Они поддерживают быстрый произвольный доступ элементов и работают быстрее, чем F # перечислены, поскольку они являются просто смежных блоков памяти.

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

[Последовательности](language-reference/sequences.md) — это логический ряд элементов, все того же типа.  Это более общий тип, чем списки и массивы, может быть «представления» в любой логический ряд элементов.  Также выделяются, так как они могут быть ***отложенной***, что означает, что элементы можно вычислить только в том случае, если они требуются.

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a>Рекурсивные функции

Обработка коллекций или последовательностей элементов обычно выполняется с [рекурсии](language-reference/functions/index.md#recursive-functions) в языке F #.  Несмотря на то, что F # поддерживает циклов и императивного программирования, рекурсии является предпочтительным, поскольку он проще обеспечить правильность.

>[!NOTE]
Следующий пример использует сопоставление шаблонов через `match` выражение.  Эта конструкция фундаментальные рассматривается далее в этой статье.

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

F # также обеспечивает полную поддержку оптимизация вызова с префиксом Tail, который дает возможность оптимизировать рекурсивных вызовов, которые просто так же быстро, как конструкция цикла.

## <a name="record-and-discriminated-union-types"></a>Запись и типы размеченного объединения

Типы объединений и записи — это два типа основных данных, используемые в коде F # и чаще всего это лучший способ представления данных в программе F #.  Несмотря на то, что это делает их классы в других языках, один из их основных различий является наличие семантикой структурного равенства.  Это означает, они «изначально» сравнимы и равенства несложно — просто проверить один равен ли другой.

[Записи](language-reference/records.md) являются агрегатную функцию именованных значений, с необязательным члены (методы).  Если вы знакомы с C# или Java, затем они должно быть аналогично POCO или POJOs - только с структурное равенство, а также сократить процедуры.

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

Начиная с F # 4.1, может также представлять записи в виде `struct`s.  Это делается с `[<Struct>]` атрибута:

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

[Размеченные объединения (DUs)](language-reference/discriminated-unions.md) являются значения, которые может быть несколько именованных форм или случаев.  Данные, хранящиеся в тип может быть одним из нескольких различных значений.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

Можно также использовать DUs как *одиночным размеченные объединения*, чтобы помочь с доменом, моделирование по типов-примитивов.  Зачастую, строк и других типов-примитивов, используются для представления и таким образом, получают определенного значения.  Однако использование только примитивные представление данных может привести ошибочно назначение неверное значение!  Представляет каждый тип сведений, как объединение различных одиночным можно принудительно задать правильность в этом сценарии.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

Как показано в приведенном выше примере, чтобы получить базовое значение в одном случае размеченные объединения, необходимо явно разворачивать его.

Кроме того DUs также поддерживают рекурсивные определения, что позволяет легко представления деревьев и по своей природе рекурсивных данных.  Например, вот как можно представить двоичного дерева поиска с `exists` и `insert` функции.

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

Поскольку DUs можно представить рекурсивную структуру дерева в тип данных, работы с этой структуры рекурсивного прост и гарантирует правильность.  Также поддерживается в сопоставлении шаблонов, как показано ниже.

Кроме того, может представлять DUs как `struct`s с `[<Struct>]` атрибута:

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

Однако есть два важных момента при этом следует учитывать:

1. Структура DU не может быть определен рекурсивно.
2. Структура DU должны иметь уникальные имена для каждого из его вариантов.

Для выполнения указанных выше приведет к ошибке компиляции.

## <a name="pattern-matching"></a>Сопоставление шаблонов

[Шаблон сопоставления](language-reference/pattern-matching.md) -функция F #, которая обеспечивает правильность для работы с типами F #.  В примерах выше, возможно вы обратили внимание довольно `match x with ...` синтаксиса.  Эта конструкция позволяет компилятору, который позволяет понять типов данных, чтобы включить учетную запись для всех возможных вариантов, при использовании типа данных через то, что известно как полное соответствие шаблону «формы».  Это очень мощный инструмент, правильность и продуманно используется для «точности прогнозов» обычно было бы значения времени выполнения в во время компиляции.

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L739)]

Также можно использовать сокращенный синтаксис `function` конструкция для сравнения с шаблоном, что полезно при написании функции, которые делают использование [частичное применение](language-reference/functions/index.md#partial-application-of-arguments):

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L741-L759)]

Что-то, возможно, вы заметили является использование класса `_` шаблон.  Это называется [Шаблон подстановочного знака](language-reference/pattern-matching.md#wildcard-pattern), который является иначе говоря, «Не волнует, что-то не».  Несмотря на то что удобный, можно случайно обхода полное соответствие шаблону и больше не пользуются принудительные применения компиляции следует соблюдать осторожность при использовании `_`.  Лучше всего использовать, если вас не интересует определенные фрагменты разложенные типа при шаблон соответствия или последнего предложения после перечисления всех вариантов может применяться в выражении шаблона.

[Активные шаблоны](language-reference/active-patterns.md) являются другой мощные конструкции для использования с сопоставлением шаблонов.  Они позволяют секционировать входные данные в пользовательских формах, декомпозиция их во время вызова соответствия шаблону.  Они могут также быть параметризованы, позволяя определить секцию как функции.  Расширение поддержки активные шаблоны из предыдущего примера выглядит следующим образом:

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L761-L783)]

## <a name="optional-types"></a>Дополнительные типы

Один особый случай типы размеченного объединения является тип параметра, используемое таким образом, он входит в состав библиотеки ядра F #.

[Тип параметра](language-reference/options.md) имеет тип, который представляет одно из двух следующих случаях: значение или ничего вообще.  Он используется в любом сценарии, где значение может существовать или не могут быть связаны с конкретной операции.  Затем приходится учетной записи для обоих вариантов, сделав его значения во время компиляции, а не значения времени выполнения.  Они часто используются в API-интерфейсы где `null` используется для представления «nothing», вместо этого, тем самым устраняя необходимость беспокоиться о `NullReferenceException` во многих ситуациях.

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L791-L811)]

## <a name="units-of-measure"></a>Единицы измерения

Уникальной возможностью системы типов F # — возможность предоставить контекст для числовых литералов через единицы измерения.

[Единицы измерения](language-reference/units-of-measure.md) позволяют сопоставить числовой тип единицы, например метрах, и иметь функции работы с единицы, а не числовые литералы.  Это позволяет компилятору проверять, что типы числовых литералов, передаваемых в смысла в определенном контексте, тем самым устраняя ошибки времени выполнения, связанные с такого рода рабочих.

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L818-L839)]

Библиотеки ядра F # определяет множество SI следующие типы единиц измерения и преобразования единиц измерения.  Для получения дополнительных сведений ознакомьтесь [Microsoft.FSharp.Data.unitsystems.SI-пространство имен](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).

## <a name="classes-and-interfaces"></a>Классы и интерфейсы

F # также обеспечивает полную поддержку классов .NET [интерфейсы](language-reference/interfaces.md), [абстрактные классы](language-reference/abstract-classes.md), [наследования](language-reference/inheritance.md), и т. д.

[Классы](language-reference/classes.md) — это типы, представляющие объекты .NET, который может иметь свойства, методы и события его [члены](language-reference/members/index.md).

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L848-L877)]

Определение универсальных классов также очень проста.

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L884-L905)]

Для реализации интерфейса можно использовать любой `interface ... with` синтаксиса или [выражение объекта](language-reference/object-expressions.md).

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L912-L931)]

## <a name="which-types-to-use"></a>Какие типы для использования

Наличие классов, записи, размеченные объединения и кортежи приводит к важный вопрос: что следует использовать?  Как и большинство все в жизни ответ зависит от обстоятельств.

Кортежи прекрасно подходят для возвращения несколько значений из функции и нерегламентированных статистическое вычисление значений в качестве само значение.

Записи являются «шаг вверх» из кортежей, с именем метки и поддержка дополнительных членов.  Они прекрасно подходят для процедуры низкий представление данных во время передачи по программе.  Из-за наличия структурное равенство, они легко использовать с функцией сравнения.

Размеченные объединения имеют множество применений, но основное преимущество заключается в не сможет использовать их совместно с шаблоном для учетной записи для всех возможных «фигур», может иметь данных.  

Классы прекрасно подходят для множество причин, например, при необходимости представляют сведения, а также привязать эту информацию для функции.  Как правило при наличии функциональные возможности, которые логически привязывается к некоторым данным с помощью классов и принципы об объектно-ориентированном программировании является большим преимуществом.  Классы являются также предпочтительный тип данных при взаимодействии с C# и Visual Basic, как эти языки используют классы для практически полностью.

## <a name="next-steps"></a>Дальнейшие действия

Теперь, когда мы рассмотрели некоторые основные функции языка, вы будете готовы к записи первого программ F #!  Извлечение [Приступая к работе](tutorials/getting-started/index.md) чтобы узнать, как настроить среду разработки и написать код.

Следующие шаги для получения дополнительных сведений может быть любым, но мы рекомендуем [функции как значения первого класса](introduction-to-functional-programming/functions-as-first-class-values.md) <!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> для успешной работы с основными механизмами функционального программирования.  Они очень важны для построения надежных программ на языке F #.

Кроме того, ознакомьтесь [Справочник по языку F #](language-reference/index.md) для просмотра всеобъемлющий набор концептуальное содержимое на языке F #.
