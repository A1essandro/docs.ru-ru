---
title: "Ссылочные ячейки (F#)"
description: "Узнайте, как ссылочные ячейки F # — это места хранения, которые позволяют создавать изменяющиеся значения с семантикой ссылок."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 09a0b221-ea21-45c4-bae8-5e4a339750c4
ms.openlocfilehash: c7470c9a36cf2cd24dd89ceffcf6e90c6dc4d2dd
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="reference-cells"></a>Ссылочные ячейки

*Ссылочные ячейки* — это места хранения, которые позволяют создавать изменяющиеся значения с семантикой ссылок.

## <a name="syntax"></a>Синтаксис

```fsharp
ref expression
```

## <a name="remarks"></a>Примечания
Для создания новой ссылочной ячейки, инкапсулирующей значение, перед значением ставится оператор `ref`. Базовое значение затем можно изменить, так как оно является изменяемым.

Ссылочная ячейка содержит фактическое значение; это не просто адрес. При создании ссылочной ячейки с помощью оператора `ref` создается копия базового значения в качестве инкапсулированного изменяемого значения.

Разыменовать ссылочную ячейку можно с помощью оператора `!` (восклицательного знака).

Следующий пример кода иллюстрирует объявление и использование ссылочных ячеек.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2201.fs)]

В результате получается `50`.

Ссылочные ячейки являются экземплярами универсального типа записей `Ref`, который объявляется следующим образом.

```fsharp
type Ref<'a> =
{ mutable contents: 'a }
```

Тип `'a ref` является синонимом `Ref<'a>`. В интегрированной среде разработки в компиляторе и в IntelliSense отображается первое обозначение данного типа, однако базовым определением является второе.

Оператор `ref` создает новую ссылочную ячейку. Следующий код представляет собой объявление оператора `ref`.

```fsharp
let ref x = { contents = x }
```

В следующей таблице перечислены возможности, доступные для ссылочной ячейки.

|Оператор, член или поле|Описание|Тип|Определение|
|--------------------------|-----------|----|----------|
|`!` (оператор разыменования)|Возвращает базовое значение.|`'a ref -> 'a`|`let (!) r = r.contents`|
|`:=` (оператор присваивания)|Изменяет базовое значение.|`'a ref -> 'a -> unit`|`let (:=) r x = r.contents <- x`|
|`ref` (оператор)|Инкапсулирует значение в новую ссылочную ячейку.|`'a -> 'a ref`|`let ref x = { contents = x }`|
|`Value` (свойство)|Получает или задает базовое значение.|`unit -> 'a`|`member x.Value = x.contents`|
|`contents` (поле записи)|Получает или задает базовое значение.|`'a`|`let ref x = { contents = x }`|
Существует несколько способов доступа к базовому значению. Значение, возвращаемое оператором разыменования (`!`), не является присваиваемым значением. Следовательно, при изменении базового значения нужно вместо этого оператора использовать оператор присваивания (`:=`).

И свойство `Value`, и поле `contents` являются присваиваемыми значениями. Следовательно, их можно использовать для доступа к базовому значению или его изменения, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2203.fs)]

Выходные данные выглядят следующим образом.

```
10
10
11
12
```

Поле `contents` предусмотрено для совместимости с другими версиями языка ML, и его наличие приводит к выводу предупреждения в процессе компиляции. Для отключения этого предупреждения используется параметр компилятора `--mlcompatibility`. Дополнительные сведения см. в разделе [Параметры компилятора](compiler-options.md).

Следующий код иллюстрирует использование ссылочных ячеек при передаче параметров. Тип Incrementor имеет метод шаг приращения, принимает параметр, включающий byref в типе параметра. Byref в типе параметра указывает, что вызывающие объекты должны передавать ссылочную ячейку или адрес обычной переменной заданного типа в этом вариантов int. Остальная часть кода иллюстрирует вызов метода приращения с обоими этими типами аргументов и показано, как использовать оператор ref в переменной для создания ссылочной ячейки (ref myDelta1). Затем показано использование оператора взятия адреса (&amp;) для формирования соответствующего аргумента. Наконец метод Increment вызывается снова путем использования ссылочной ячейки, объявленной с помощью привязки let. В последней строке кода демонстрируется использование! оператор разыменования ссылочной ячейки для печати.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2204.fs)]

Дополнительные сведения о передаче по ссылке см. в разделе [параметры и аргументы](parameters-and-arguments.md).

>[!NOTE]
Программистам на C# следует знать, что этой ссылки по-разному работает в языке F #, чем в C#. Например использование ref при передаче аргумента имеет тот же эффект в языке F #, нежели в C#.

## <a name="consuming-c-ref-returns"></a>Использование C# `ref` возвращает

Начиная с версии 4.1 F #, можно будет использовать `ref` возвращает созданный в C#.  Результат такого вызова — `byref<_>` указателя.

Следующий метод C#:

```csharp
namespace RefReturns
{
    public static class RefClass
    {
        public static ref int Find(int val, int[] vals)
        {
            for (int i = 0; i < vals.Length; i++)
            {
                if (vals[i] == val)
                {
                    return ref numbers[i]; // Returns the location, not the value
                }
            }

            throw new IndexOutOfRangeException($"{nameof(number)} not found");
        }
    }
}
```

Может прозрачно вызываться F # с не специальный синтаксис:

```fsharp
open RefReturns

let consumeRefReturn() =
    let result = RefClass.Find(3, [| 1; 2; 3; 4; 5 |]) // 'result' is of type 'byref<int>'.
    ()
```

Можно также объявить функции, которые занимают `ref` возвращают в качестве входных данных, например:

```fsharp
let f (x: byref<int>) = &x
```

В настоящее время нет возможности для создания `ref` возврата в F #, который может использоваться в C#.

## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)

[Параметры и аргументы](parameters-and-arguments.md)

[Справочник символов и операторов](symbol-and-operator-reference/index.md)
