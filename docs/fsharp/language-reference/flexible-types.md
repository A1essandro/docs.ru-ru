---
title: Гибкие типы (F#)
description: 'Сведения об использовании языка F # гибкий тип заметки, который указывает, что параметр, переменная или значение имеет тип, совместимый с указанным типом.'
ms.date: 05/16/2016
ms.openlocfilehash: a54d462d04e4e65680a4612f58da72173f04d1f7
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="flexible-types"></a>Гибкие типы

Объект *гибкий тип заметки* указывает, что параметр, переменная или значение имеет тип, совместимый с указанным типом, где совместимости определяется положением в объектно ориентированного иерархии классов или интерфейсов. Гибкие типы полезны в тех случаях, особенно в том случае, когда не происходит автоматического преобразования в типы, расположенные выше в иерархии типов, но все еще хотите включить функциональность работала с любым типом в иерархии или любой тип, реализующий интерфейс.

## <a name="syntax"></a>Синтаксис

```fsharp
#type
```

## <a name="remarks"></a>Примечания

В предыдущем синтаксисе *тип* представляет собой базовый тип или интерфейс.

Гибкий тип эквивалентен универсальный тип, который имеет ограничение, которое ограничивает разрешенные типы к типам, совместимым с типом базового типа или интерфейса. То есть следующие две строки кода эквивалентны.

```fsharp
#SomeType

'T when 'T :> SomeType
```

Гибкие типы полезны в нескольких случаях. Например если имеется функция высшего порядка (функция принимает в качестве аргумента), часто бывает удобно иметь гибкий тип возвращаемого значения функции. В следующем примере использование гибкого типа с аргументом последовательности в `iterate2` позволяет работать с функциями, формирующими последовательности, массивы, списки и перечислимый тип функции высшего порядка.

Рассмотрим следующие две функции, одна из которых возвращает последовательность, а вторая возвращает гибкий тип.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

В качестве другого примера рассмотрим [Seq.concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712) функции библиотеки:

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

Эту функцию можно передать любой из следующих перечислимых последовательностей:

- Списки
- Список массивов
- Массив списков
- Массив последовательностей
- Другие сочетания перечислимых последовательностей.

В следующем коде используется `Seq.concat` для демонстрации сценариев, которые можно поддерживать, используя гибкие типы.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

Выходные данные выглядят следующим образом.

```
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

В F # как и других объектно ориентированных языках существуют контексты, в которых производные типы или типы, реализующие интерфейсы, автоматически преобразуются в базовый тип или тип интерфейса. Эти автоматические преобразования происходят в непосредственных аргументах, но не в том случае, если тип находится в подчиненном положении, в рамках более сложного типа, такие как тип возвращаемого значения тип функции или как аргумент типа. Таким образом запись гибкого типа удобен в основном тип, которое вы хотите применить его к является частью более сложного типа.

## <a name="see-also"></a>См. также

[Справочник по языку F#](index.md)

[Универсальные шаблоны](generics/index.md)
