---
title: Гибкие типы (F#)
description: Сведения об использовании F# заметка с гибким типом, который указывает, что параметр, переменная или значение имеет тип, совместимый с указанным типом.
ms.date: 05/16/2016
ms.openlocfilehash: b6c97c3cc19f15b2c8db74b2c55660a16b2858f7
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "47210049"
---
# <a name="flexible-types"></a>Гибкие типы

Объект *заметка с гибким типом* указывает, что параметр, переменная или значение имеет тип, который совместим с указанным типом, где совместимость определяется положением в объектно ориентированного иерархии классов или интерфейсов. Гибкие типы полезны в тех случаях, в частности в том случае, когда не происходит автоматического преобразования в типы, расположенные выше в иерархии типов, но вы по-прежнему хотите включить функциональные возможности по работе для работы с любым типом в иерархии или любой тип, реализующий интерфейс.

## <a name="syntax"></a>Синтаксис

```fsharp
#type
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе *тип* представляет базовый тип или интерфейс.

Гибкий тип соответствует универсальный тип, который имеет ограничение, которое ограничивает допустимых типов для типов, которые совместимы с типом базового типа или интерфейса. То есть следующие две строки кода эквивалентны.

```fsharp
#SomeType

'T when 'T :> SomeType
```

Гибкие типы можно использовать в нескольких случаях. Например если у вас есть функция высшего порядка (функции, которая принимает в качестве аргумента), часто бывает удобно иметь гибкий тип возвращаемого значения функции. В следующем примере, использование гибкий тип с аргументом последовательности в `iterate2` позволяет функции высшего порядка для работы с функциями, которые создают последовательности, массивы, списки и любой другой перечисляемый тип.

Рассмотрим следующие две функции, один из которых возвращает последовательность, а вторая возвращает гибкий тип.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4101.fs)]

В качестве другого примера рассмотрим [Seq.concat](https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712) функция библиотеки:

```fsharp
val concat: sequences:seq<#seq<'T>> -> seq<'T>
```

Для этой функции можно передать любой из следующих последовательностей enumerable:

- Список списков
- Список массивов
- Массив списков
- Массив из последовательности
- Любые комбинации перечисляемые последовательности

В следующем коде используется `Seq.concat` для демонстрации сценариев, которые может поддерживать, используя гибкие типы.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4102.fs)]

Выходные данные выглядят следующим образом.

```
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
seq [1; 2; 3; 4; ...]
```

В F# как и в других объектно ориентированных языках существуют контексты, в которых производные типы или типы, реализующие интерфейсы автоматически преобразуются в базовый тип или тип интерфейса. Эти автоматические преобразования происходят в прямой аргументов, но не в том случае, если тип находится в подчиненном положении, как часть более сложного типа, такие как тип возвращаемого значения тип функции или как аргумент типа. Таким образом нотация гибкий тип является особенно удобно использовать, когда типа, которое вы хотите применить его к является частью более сложного типа.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Универсальные шаблоны](generics/index.md)
