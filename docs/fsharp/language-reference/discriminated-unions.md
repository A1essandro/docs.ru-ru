---
title: "Размеченные объединения (F#)"
description: "Сведения об использовании языка F # размеченные объединения."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 16e2a011-c785-48c8-859f-79df7f3a0e29
ms.openlocfilehash: a374f521bcde7506bb3a9eebb627eaffcd8b94a7
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="discriminated-unions"></a>Размеченные объединения

Размеченные объединения обеспечивают поддержку значений, которые может принимать одно из множества именованных вариантов, возможно, с разными значениями и типами. Размеченные объединения удобны для разнородных данных; данные, которые могут иметь особые случаи, включая допустимые и ошибочные; данные, зависит от одного экземпляра типа в другой. и в качестве альтернативы иерархии небольших объектов. Кроме того, рекурсивные размеченные объединения используются для представления структуры данных.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type type-name =
    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]
    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]
...
```

## <a name="remarks"></a>Примечания
Размеченные объединения аналогичны типы объединений на других языках, но существуют различия. Как с типом объединения в C++ или типа variant в Visual Basic, данные, хранящиеся в значение не будет устранена; он может принимать одно из нескольких отдельных вариантов. В отличие от объединений в этих других языках, однако, каждый из возможных вариантов присваивается *идентификатор обращения*. Case идентификаторы — это имена для различных типов возможных значений, которые могут быть объекты этого типа; значения являются необязательными. Если значения отсутствуют, случай эквивалентен варианту перечисления. Если имеются значения, каждое значение может представлять одно значение заданного типа или кортеж, объединяющий несколько полей из одной или разных типов. Начиная с версии 3.1 языка F # отдельного поля можно присвоить имя, но имя необязательно, даже если другие поля в том же регистре с именем.

Например рассмотрим следующее объявление типа фигуры.

```fsharp
type Shape =
    | Rectangle of width : float * length : float
    | Circle of radius : float
    | Prism of width : float * float * height : float
```

Предыдущий код объявляет размеченного объединения фигуры, который может принимать значения любого из трех случаях: прямоугольник, круг и призмы. Каждый вариант имеет набор полей. Прямоугольник, case имеет два именованных полей, оба типа `float`, имеющие имена ширины и длины. Circle case имеет только одно именованное поле radius. В случае призмы содержатся три поля, два из которых (ширина и высота) с именем поля. Неименованные поля называются анонимного поля.

Создаваемые объекты, предоставляя значения для полей именованные и анонимные согласно следующие примеры.

```fsharp
let rect = Rectangle(length = 1.3, width = 10.0)
let circ = Circle (1.0)
let prism = Prism(5., 2.0, height = 3.0)
```

Этот код показывает, что можно использовать именованные поля в инициализации, или можно полагаться на упорядочивание полей в объявлении и просто укажите значения для каждого поля, в свою очередь. Вызов конструктора для `rect` в предыдущем коде использует указанных полей, но вызов конструктора для `circ` использует порядок. Можно комбинировать упорядоченный поля и с именем поля, как в построении `prism`.

`option` Тип — простой размеченного объединения в основной библиотеке F #. `option` Тип объявляется следующим образом.

```fsharp
// The option type is a discriminated union.
type Option<'a> =
    | Some of 'a
    | None
```

Предыдущий код указывает, что тип `Option` является размеченного объединения, имеющее два варианта `Some` и `None`. `Some` Case имеет соответствующее значение, состоит из одного анонимного поля, тип которого представлен параметром типа `'a`. `None` Варианта не имеет связанного значения. Таким образом `option` тип указывает универсальный тип, который либо имеет значение некоторого типа, либо не имеет значения. Тип `Option` также имеет псевдоним в нижнем регистре, `option`, то есть несколько часто используемых.

Идентификаторы вариантов может использоваться в качестве конструкторов типа размеченного объединения. Например, следующий код используется для создания значений `option` типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2001.fs)]

Идентификаторы варианта также используются в выражениях сопоставления шаблонов. В выражении шаблона идентификаторы предоставляются для значений, связанных с отдельными вариантами. Например, в следующем коде `x` идентификатор получает значение, с которым связан `Some` вариант `option` типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2002.fs)]

В выражениях сопоставления шаблонов можно использовать именованного поля для указания размеченные объединения совпадений. Для фигуры типа, который был объявлен ранее можно использовать именованного поля, как показывает следующий код для извлечения значений полей.

```fsharp
let getShapeHeight shape =
    match shape with
    | Rectangle(height = h) -> h
    | Circle(radius = r) -> 2. * r
    | Prism(height = h) -> h
```

Как правило идентификаторы варианта можно использовать без указания имени объединения. Если необходимо, чтобы имя всегда указываться с именем объединения, можно применить [RequireQualifiedAccess](https://msdn.microsoft.com/library/8b9b6ade-0471-4413-ac5d-638cd0de5f15) определению типа объединения атрибут.

### <a name="unwrapping-discriminated-unions"></a>Распаковки размеченные объединения

В объединениях размеченные F # часто используются в моделировании домена для упаковки одного типа. Извлеките базового значения с помощью сравнения с шаблоном также упрощается. Не нужно использовать выражения match для одного объекта:
```fsharp
let ([UnionCaseName] [values]) = [UnionValue]
```

Следующий пример демонстрирует это:

```fsharp
type ShaderProgram = | ShaderProgram of id:int

let someMethodUsingShaderProgram shaderProgram =
    let (ShaderProgram id) = shaderProgram
    // Use the unwrapped value
    ..
```

## <a name="struct-discriminated-unions"></a>Структура размеченные объединения

Начиная с версии 4.1 F #, может также представлять размеченные объединения как структуры.  Это делается с `[<Struct>]` атрибута.

```fsharp
[<Struct>]
type SingleCase = Case of string

[<Struct>]
type Multicase =
    | Case1 of string
    | Case2 of int
    | Case3 of double
```

Поскольку эти типы значений и ссылочные типы не, существуют дополнительные рекомендации по сравнению со ссылкой размеченные объединения:

1. Они будут скопированы в качестве типов значений и имеют семантика типа значения.
2. Рекурсивное определение типа нельзя использовать со структурой multicase размеченные объединения.
3. Необходимо указать уникальные имена вариантов структуры multicase размеченные объединения.

## <a name="using-discriminated-unions-instead-of-object-hierarchies"></a>Использование размеченных объединений вместо иерархий объектов
Размеченные объединения часто можно использовать как более простой альтернативой небольшой иерархии объектов. Например, следующий размеченного объединения может использоваться вместо `Shape` базового класса, имеющего производные классы для окружности, квадрата и т. д.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2003.fs)]

Вместо этого виртуального метода для вычисления площади или периметра, который бы использовался в объектно ориентированной реализации, можно использовать сопоставление шаблонов для выбора соответствующих формул для вычисления этих величин. В следующем примере различные формулы используются для вычисления в области, в зависимости от фигуры.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2004.fs)]

Выходные данные выглядят следующим образом:

```
Area of circle that has radius 15.000000: 706.858347
Area of square that has side 10.000000: 100.000000
Area of rectangle that has height 5.000000 and width 10.000000 is 50.000000
```

## <a name="using-discriminated-unions-for-tree-data-structures"></a>Использование размеченных объединений для древовидных структур данных
Размеченные объединения могут быть рекурсивными, это означает, что само объединение может быть включено в тип одного или нескольких случаях. Рекурсивные размеченные объединения можно использовать для создания древовидных структур, которые используются для моделирования выражений в языках программирования. В следующем коде рекурсивные размеченные объединения используется для создания древовидной структуры двоичных данных. Объединение состоит из двух случаях `Node`, которая является узлом с целым значением, а также левую и правую ветви и `Tip`, завершающий дерево.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2005.fs)]

В приведенном выше коде `resultSumTree` имеет значение 10. Ниже показана структура дерева для `myTree`.

![Древовидная структура для myTree](../media/TreeStructureDiagram.png)

Размеченные объединения хорошо работают, если узлы дерева являются разнородными. В следующем коде тип `Expression` представляет дерева абстрактного синтаксиса выражения в простом языке программирования, поддерживающем сложение и умножение чисел и переменных. Некоторые из вариантов объединения не являются рекурсивными и представляют либо числа (`Number`) или переменных (`Variable`). Другие варианты являются рекурсивными и представляют операции (`Add` и `Multiply`), в которых операнды также являются выражениями. `Evaluate` Функции используется выражение match для рекурсивной обработки дерева синтаксиса.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2006.fs)]

При выполнении этого кода, значение `result` равно 5.

## <a name="common-attributes"></a>Общие атрибуты

Следующие атрибуты часто встречается размеченные объединения:

* `[RequireQualifiedAccess]`
* `[NoEquality]`
* `[NoComparison]`
* `[Struct]`(F # 4.1 и более поздние версии)

## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)
