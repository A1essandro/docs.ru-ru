---
title: Универсальные шаблоны (F#)
description: 'Сведения об использовании F # универсальные функции и типы, которые позволяют создавать код, который работает с множеством типов без повторения кода.'
keywords: visual f#, f#, функциональное программирование
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: a9f2e2ee-bcb1-4ce3-8531-850aa183040f
ms.openlocfilehash: e7a5712fddf4d372d1ada86927f50e394a59a410
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="generics"></a><span data-ttu-id="cfdcc-104">Универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="cfdcc-104">Generics</span></span>

<span data-ttu-id="cfdcc-105">Значения функции, методы, свойства и агрегатные типы, например классы, записи и размеченные объединения, в F# могут быть *универсальными*.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-105">F# function values, methods, properties, and aggregate types such as classes, records, and discriminated unions can be *generic*.</span></span> <span data-ttu-id="cfdcc-106">Универсальные конструкции содержат по меньшей мере один параметр типа, который обычно задается пользователем такой конструкции.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-106">Generic constructs contain at least one type parameter, which is usually supplied by the user of the generic construct.</span></span> <span data-ttu-id="cfdcc-107">Универсальные функции и типы позволяют писать код, который работает с множеством типов без повторения кода для каждого из них.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-107">Generic functions and types enable you to write code that works with a variety of types without repeating the code for each type.</span></span> <span data-ttu-id="cfdcc-108">В F# можно легко сделать код универсальным, так как зачастую код неявно определяется как универсальный механизмами определения типов и автоматического обобщения в компиляторе.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-108">Making your code generic can be simple in F#, because often your code is implicitly inferred to be generic by the compiler's type inference and automatic generalization mechanisms.</span></span>


## <a name="syntax"></a><span data-ttu-id="cfdcc-109">Синтаксис</span><span class="sxs-lookup"><span data-stu-id="cfdcc-109">Syntax</span></span>

```fsharp
// Explicitly generic function.
let function-name<type-parameters> parameter-list =
function-body

// Explicitly generic method.
[ static ] member object-identifer.method-name<type-parameters> parameter-list [ return-type ] =
method-body

// Explicitly generic class, record, interface, structure,
// or discriminated union.
type type-name<type-parameters> type-definition
```

## <a name="remarks"></a><span data-ttu-id="cfdcc-110">Примечания</span><span class="sxs-lookup"><span data-stu-id="cfdcc-110">Remarks</span></span>
<span data-ttu-id="cfdcc-111">Объявления явно универсальной функции или явно универсального типа похоже на объявление неуниверсальных функций или типов, за исключением задания (и использования) параметров типа в угловых скобках после имени функции или типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-111">The declaration of an explicitly generic function or type is much like that of a non-generic function or type, except for the specification (and use) of the type parameters, in angle brackets after the function or type name.</span></span>

<span data-ttu-id="cfdcc-112">Объявления часто являются неявно универсальными.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-112">Declarations are often implicitly generic.</span></span> <span data-ttu-id="cfdcc-113">Если вы не указываете полностью тип каждого параметра, составляющего функцию или тип, компилятор пытается определить тип каждого параметра, значения и переменной из написанного кода.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-113">If you do not fully specify the type of every parameter that is used to compose a function or type, the compiler attempts to infer the type of each parameter, value, and variable from the code you write.</span></span> <span data-ttu-id="cfdcc-114">Дополнительные сведения см. в статье [Определение типа](../type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-114">For more information, see [Type Inference](../type-inference.md).</span></span> <span data-ttu-id="cfdcc-115">Если код для типа или функции не ограничивают типы параметров иным образом, то функция или тип являются неявно универсальными.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-115">If the code for your type or function does not otherwise constrain the types of parameters, the function or type is implicitly generic.</span></span> <span data-ttu-id="cfdcc-116">Этот процесс называется *автоматическим обобщением*.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-116">This process is named *automatic generalization*.</span></span> <span data-ttu-id="cfdcc-117">Автоматическое обобщение имеет некоторые ограничения.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-117">There are some limits on automatic generalization.</span></span> <span data-ttu-id="cfdcc-118">Например, если компилятору F# не удается определить типы для универсальной конструкции, он выдает ошибку, ссылающуюся на ограничение под названием *ограничение значения*.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-118">For example, if the F# compiler is unable to infer the types for a generic construct, the compiler reports an error that refers to a restriction called the *value restriction*.</span></span> <span data-ttu-id="cfdcc-119">В этом случае может потребоваться добавить некоторые заметки с типом.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-119">In that case, you may have to add some type annotations.</span></span> <span data-ttu-id="cfdcc-120">Дополнительные сведения об автоматическом обобщении и ограничении значения, а также об изменении кода для решения этой проблемы см. в статье [Автоматическое обобщение](automatic-generalization.md).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-120">For more information about automatic generalization and the value restriction, and how to change your code to address the problem, see [Automatic Generalization](automatic-generalization.md).</span></span>

<span data-ttu-id="cfdcc-121">В приведенном выше синтаксисе *type-parameters* — это разделенный запятыми список параметров, представляющих неизвестные типы, каждый из которых начинается с одинарной кавычки. Может также присутствовать предложение ограничения, которое дополнительно ограничивает перечень допустимых типов для этого параметра типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-121">In the previous syntax, *type-parameters* is a comma-separated list of parameters that represent unknown types, each of which starts with a single quotation mark, optionally with a constraint clause that further limits what types may be used for that type parameter.</span></span> <span data-ttu-id="cfdcc-122">Синтаксис для различных предложений ограничения и прочие сведения об ограничениях см. в статье [Ограничения](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-122">For the syntax for constraint clauses of various kinds and other information about constraints, see [Constraints](constraints.md).</span></span>

<span data-ttu-id="cfdcc-123">Компонент *type-definition* в синтаксисе совпадает с определением типа для неуниверсального типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-123">The *type-definition* in the syntax is the same as the type definition for a non-generic type.</span></span> <span data-ttu-id="cfdcc-124">Он содержит параметры конструктора для типа класса, необязательное предложение `as`, символ равенства, поля записей, предложение `inherit`, варианты для размеченного объединения, привязки `let` и `do`, определения элементов и все остальное, что разрешено в определении неуниверсального типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-124">It includes the constructor parameters for a class type, an optional `as` clause, the equal symbol, the record fields, the `inherit` clause, the choices for a discriminated union, `let` and `do` bindings, member definitions, and anything else permitted in a non-generic type definition.</span></span>

<span data-ttu-id="cfdcc-125">Остальные компоненты синтаксиса являются такими же, что и в неуниверсальных функциях и типах.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-125">The other syntax elements are the same as those for non-generic functions and types.</span></span> <span data-ttu-id="cfdcc-126">Например, *object-identifier* — это идентификатор, представляющий сам содержащий объект.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-126">For example, *object-identifier* is an identifier that represents the containing object itself.</span></span>

<span data-ttu-id="cfdcc-127">Свойства, поля и конструкторы не могут быть более универсальными, чем включающий тип.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-127">Properties, fields, and constructors cannot be more generic than the enclosing type.</span></span> <span data-ttu-id="cfdcc-128">Кроме того, значения в модуле не могут быть универсальными.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-128">Also, values in a module cannot be generic.</span></span>


## <a name="implicitly-generic-constructs"></a><span data-ttu-id="cfdcc-129">Неявно универсальные конструкции</span><span class="sxs-lookup"><span data-stu-id="cfdcc-129">Implicitly Generic Constructs</span></span>
<span data-ttu-id="cfdcc-130">Когда компилятор F# определяет типы в коде, он автоматически рассматривает как универсальную любую функцию, которая может быть таковой.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-130">When the F# compiler infers the types in your code, it automatically treats any function that can be generic as generic.</span></span> <span data-ttu-id="cfdcc-131">Если указать тип явно, например, тип параметра, автоматическое обобщение не выполняется.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-131">If you specify a type explicitly, such as a parameter type, you prevent automatic generalization.</span></span>

<span data-ttu-id="cfdcc-132">В следующем примере кода `makeList` является универсальной, хотя ни она, ни ее параметры не объявляются явно как универсальные.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-132">In the following code example, `makeList` is generic, even though neither it nor its parameters are explicitly declared as generic.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1700.fs)]

<span data-ttu-id="cfdcc-133">Подпись функции определяется как `'a -> 'a -> 'a list`.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-133">The signature of the function is inferred to be `'a -> 'a -> 'a list`.</span></span> <span data-ttu-id="cfdcc-134">Обратите внимание, что `a` и `b` в этом примере определяются, как имеющие одинаковый тип.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-134">Note that `a` and `b` in this example are inferred to have the same type.</span></span> <span data-ttu-id="cfdcc-135">Это вызвано тем, что они включаются в список вместе, а все элементы списка должны иметь один тип.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-135">This is because they are included in a list together, and all elements of a list must be of the same type.</span></span>

<span data-ttu-id="cfdcc-136">Кроме того, функцию можно сделать универсальной, применив синтаксис с одинарной кавычкой в заметке типа, чтобы показать, что тип параметра является параметром универсального типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-136">You can also make a function generic by using the single quotation mark syntax in a type annotation to indicate that a parameter type is a generic type parameter.</span></span> <span data-ttu-id="cfdcc-137">В следующем коде `function1` является универсальной, так как ее параметры объявляются указанным образом — как параметры типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-137">In the following code, `function1` is generic because its parameters are declared in this manner, as type parameters.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1701.fs)]
    
## <a name="explicitly-generic-constructs"></a><span data-ttu-id="cfdcc-138">Явно универсальные конструкции</span><span class="sxs-lookup"><span data-stu-id="cfdcc-138">Explicitly Generic Constructs</span></span>
<span data-ttu-id="cfdcc-139">Вы также можете сделать функцию универсальной, явно объявив ее параметры типа в угловых скобках (`<type-parameter>`).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-139">You can also make a function generic by explicitly declaring its type parameters in angle brackets (`<type-parameter>`).</span></span> <span data-ttu-id="cfdcc-140">Это проиллюстрировано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-140">The following code illustrates this.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1703.fs)]
    
## <a name="using-generic-constructs"></a><span data-ttu-id="cfdcc-141">Использование универсальных конструкций</span><span class="sxs-lookup"><span data-stu-id="cfdcc-141">Using Generic Constructs</span></span>
<span data-ttu-id="cfdcc-142">При использовании универсальных функций или методов вам может быть не нужно указывать аргументы типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-142">When you use generic functions or methods, you might not have to specify the type arguments.</span></span> <span data-ttu-id="cfdcc-143">Компилятор использует определение типа для выведения подходящих аргументов типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-143">The compiler uses type inference to infer the appropriate type arguments.</span></span> <span data-ttu-id="cfdcc-144">Если по-прежнему присутствует неоднозначность, можно указать аргументы типа в угловых скобках, разделяя их запятыми.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-144">If there is still an ambiguity, you can supply type arguments in angle brackets, separating multiple type arguments with commas.</span></span>

<span data-ttu-id="cfdcc-145">Следующий код показывает использование функций, определенных в предыдущих разделах.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-145">The following code shows the use of the functions that are defined in the previous sections.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1702.fs)]
    
>[!NOTE]
<span data-ttu-id="cfdcc-146">Сослаться на универсальный тип по имени можно двумя способами.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-146">There are two ways to refer to a generic type by name.</span></span> <span data-ttu-id="cfdcc-147">Например, `list<int>` и `int list` представляют два способа сослаться на универсальный тип `list` с одним аргументом типа `int`.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-147">For example, `list<int>` and `int list` are two ways to refer to a generic type `list` that has a single type argument `int`.</span></span> <span data-ttu-id="cfdcc-148">Последняя форма обычно используется только со встроенными типами F#, такими как `list` и `option`.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-148">The latter form is conventionally used only with built-in F# types such as `list` and `option`.</span></span> <span data-ttu-id="cfdcc-149">При наличии нескольких аргументов типа обычно используется синтаксис `Dictionary<int, string>`, но можно также использовать синтаксис `(int, string) Dictionary`.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-149">If there are multiple type arguments, you normally use the syntax `Dictionary<int, string>` but you can also use the syntax `(int, string) Dictionary`.</span></span>

## <a name="wildcards-as-type-arguments"></a><span data-ttu-id="cfdcc-150">Подстановочные знаки как аргументы типа</span><span class="sxs-lookup"><span data-stu-id="cfdcc-150">Wildcards as Type Arguments</span></span>
<span data-ttu-id="cfdcc-151">Чтобы указать, что аргумент типа должен определяться компилятором, можно использовать символ подчеркивания или подстановочный знак (`_`) вместо именованного аргумента типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-151">To specify that a type argument should be inferred by the compiler, you can use the underscore, or wildcard symbol (`_`), instead of a named type argument.</span></span> <span data-ttu-id="cfdcc-152">Это показано в приведенном ниже коде.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-152">This is shown in the following code.</span></span>

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1704.fs)]
    
## <a name="constraints-in-generic-types-and-functions"></a><span data-ttu-id="cfdcc-153">Ограничения в универсальных типах и функциях</span><span class="sxs-lookup"><span data-stu-id="cfdcc-153">Constraints in Generic Types and Functions</span></span>
<span data-ttu-id="cfdcc-154">В определении универсального типа или универсальной функции можно использовать только те конструкции, которые доступны для параметра универсального типа.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-154">In a generic type or function definition, you can use only those constructs that are known to be available on the generic type parameter.</span></span> <span data-ttu-id="cfdcc-155">Это необходимо для проверки вызовов функций и методов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-155">This is required to enable the verification of function and method calls at compile time.</span></span> <span data-ttu-id="cfdcc-156">Если вы объявляете параметры типа явно, можно применить к параметру универсального типа явное ограничение, чтобы уведомить компилятор о доступности некоторых методов и функций.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-156">If you declare your type parameters explicitly, you can apply an explicit constraint to a generic type parameter to notify the compiler that certain methods and functions are available.</span></span> <span data-ttu-id="cfdcc-157">Тем не менее, если разрешить компилятору F# выводить универсальные типы параметров, он самостоятельно определит подходящие ограничения.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-157">However, if you allow the F# compiler to infer your generic parameter types, it will determine the appropriate constraints for you.</span></span> <span data-ttu-id="cfdcc-158">Дополнительные сведения см. в статье [Ограничения](constraints.md).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-158">For more information, see [Constraints](constraints.md).</span></span>


## <a name="statically-resolved-type-parameters"></a><span data-ttu-id="cfdcc-159">Статически разрешаемые параметры типов</span><span class="sxs-lookup"><span data-stu-id="cfdcc-159">Statically Resolved Type Parameters</span></span>
<span data-ttu-id="cfdcc-160">Существует два вида параметров типа, которые можно использовать в программах на языке F#.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-160">There are two kinds of type parameters that can be used in F# programs.</span></span> <span data-ttu-id="cfdcc-161">Первый — это параметры универсального типа, описанные в предыдущих разделах.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-161">The first are generic type parameters of the kind described in the previous sections.</span></span> <span data-ttu-id="cfdcc-162">Первый вид параметров типа эквивалентен параметрам универсального типа, которые используются в таких языках, как Visual Basic и C#.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-162">This first kind of type parameter is equivalent to the generic type parameters that are used in languages such as Visual Basic and C#.</span></span> <span data-ttu-id="cfdcc-163">Другой вид параметров типа имеется только в F# и называется *статически разрешаемым параметром типа*.</span><span class="sxs-lookup"><span data-stu-id="cfdcc-163">Another kind of type parameter is specific to F# and is referred to as a *statically resolved type parameter*.</span></span> <span data-ttu-id="cfdcc-164">Сведения об этих конструкциях см. в статье [Статически разрешаемые параметры типов](statically-resolved-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="cfdcc-164">For information about these constructs, see [Statically Resolved Type Parameters](statically-resolved-type-parameters.md).</span></span>


## <a name="examples"></a><span data-ttu-id="cfdcc-165">Примеры</span><span class="sxs-lookup"><span data-stu-id="cfdcc-165">Examples</span></span>
[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet1705.fs)]
    
## <a name="see-also"></a><span data-ttu-id="cfdcc-166">См. также</span><span class="sxs-lookup"><span data-stu-id="cfdcc-166">See Also</span></span>
[<span data-ttu-id="cfdcc-167">Справочник по языку</span><span class="sxs-lookup"><span data-stu-id="cfdcc-167">Language Reference</span></span>](../index.md)

[<span data-ttu-id="cfdcc-168">Типы</span><span class="sxs-lookup"><span data-stu-id="cfdcc-168">Types</span></span>](../fsharp-types.md)

[<span data-ttu-id="cfdcc-169">Статически разрешаемые параметры типов</span><span class="sxs-lookup"><span data-stu-id="cfdcc-169">Statically Resolved Type Parameters</span></span>](statically-resolved-type-parameters.md)

[<span data-ttu-id="cfdcc-170">Универсальные шаблоны в платформе .NET Framework</span><span class="sxs-lookup"><span data-stu-id="cfdcc-170">Generics in the .NET Framework</span></span>](~/docs/standard/generics/index.md)

[<span data-ttu-id="cfdcc-171">Автоматическое обобщение</span><span class="sxs-lookup"><span data-stu-id="cfdcc-171">Automatic Generalization</span></span>](automatic-generalization.md)

[<span data-ttu-id="cfdcc-172">Ограничения</span><span class="sxs-lookup"><span data-stu-id="cfdcc-172">Constraints</span></span>](constraints.md)
