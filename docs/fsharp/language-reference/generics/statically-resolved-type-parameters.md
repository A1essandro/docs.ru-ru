---
title: "Статически разрешаемые параметры типа (F#)"
description: "Сведения об использовании языка F # статически разрешаемый параметр типа, который заменяется фактическим типом во время компиляции, а не во время выполнения."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: b3797415-3e49-4f8a-a8ee-fa614c5721aa
ms.openlocfilehash: 88b4590a4323e75949c1915503b51793283792de
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="statically-resolved-type-parameters"></a>Статически разрешаемые параметры типов

Объект *статически разрешаемый параметр типа* является параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения. Они предваряются символом крышки (^).


## <a name="syntax"></a>Синтаксис

```
ˆtype-parameter
```

## <a name="remarks"></a>Примечания
В языке F # существует два различных типа параметров типа. Первый тип — Стандартная универсального параметра типа. Такие параметры обозначаются апостроф ('), как и в `'T` и `'U`. Они эквивалентны параметров универсального типа в других языках .NET Framework. Статически разрешаемые другого типа и обозначается символом крышки, как в `^T` и `^U`.

Статически разрешаемые параметры типа, в первую очередь используются в связи с ограничениями членов, которые являются ограничения, которые позволяют указать, что аргумент типа должен иметь определенный элемент или элементы для использования. Нет возможности для создания такого типа ограничения с помощью обычного универсального параметра типа.

В следующей таблице перечислены сходства и различия между двумя типами параметров типа.

|Функция|Универсальный|Статически разрешаемые|
|-------|-------|-------------------|
|Синтаксис|`'T`, `'U`|`^T`, `^U`|
|Время разрешения|Выполнение|Время компиляции|
|Ограничения элементов|Не может использоваться с ограничениями членов.|Может использоваться с ограничениями членов.|
|Создание кода|Тип (или метод) со стандартными параметрами универсального типа приводит к формированию одного универсального типа или метода.|Создаются несколько экземпляров типов и методов, для каждого типа, который нужно.|
|Использование с типами|Может использоваться с типами.|Не может использоваться с типами.|
|Использование со встроенными функциями|Нет. Встроенная функция не может быть параметризовано с параметром standard универсального типа.|Да. Статически разрешаемые параметры типа нельзя использовать в функции или методы, не являющиеся встроенными.|

Многие основные функции библиотеки F #, особенно операторы статически разрешаемые параметры типов. Эти функции и операторы в строке и привести к созданию эффективного кода для численных вычислений.

Встроенные методы и функции, использующие операторы или использовать другие функции, которые статически разрешаемые параметры типов, можно также использовать статически разрешаемые параметры типа самостоятельно. Часто такие встроенные функции, имеющие статически разрешаемые параметры типа определяются определение типа. В следующем примере показано определение оператора, который определяется содержат параметр статически разрешаемые типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet401.fs)]

Разрешить тип `(+@)` основан на использование обоих `(+)` и `(*)`, оба из благодаря чему вывод типа ограничениям членов на статически разрешаемые параметры типа. Разрешенный тип, как показано в интерпретатору F #, будет следующим.

```fsharp
^a -> ^c -> ^d
when (^a or ^b) : (static member (+) : ^a * ^b -> ^d) and
(^a or ^c) : (static member (+) : ^a * ^c -> ^b)
```

Выходные данные выглядят следующим образом.

```
2
1.500000
```

Начиная с версии 4.1 F # можно также указать имена конкретных типов в сигнатурах статически разрешаемые типа параметра.  В предыдущих версиях языка имя типа могут быть выведены фактически компилятором, но фактически не удается задать в сигнатуре.  Начиная с F # 4.1 можно также указать имена конкретных типов в сигнатурах статически разрешаемые типа параметра. Ниже приведен пример:

```fsharp
type CFunctor() = 
      static member inline fmap (f: ^a -> ^b, a: ^a list) = List.map f a
      static member inline fmap (f: ^a -> ^b, a: ^a option) =
        match a with
        | None -> None
        | Some x -> Some (f x)

      // default implementation of replace
      static member inline replace< ^a, ^b, ^c, ^d, ^e when ^a :> CFunctor and (^a or ^d): (static member fmap: (^b -> ^c) * ^d -> ^e) > (a, f) =
        ((^a or ^d) : (static member fmap : (^b -> ^c) * ^d -> ^e) (konst a, f))

      // call overridden replace if present
      static member inline replace< ^a, ^b, ^c when ^b: (static member replace: ^a * ^b -> ^c)>(a: ^a, f: ^b) =
        (^b : (static member replace: ^a * ^b -> ^c) (a, f))

let inline replace_instance< ^a, ^b, ^c, ^d when (^a or ^c): (static member replace: ^b * ^c -> ^d)> (a: ^b, f: ^c) =
      ((^a or ^c): (static member replace: ^b * ^c -> ^d) (a, f))

// Note the concrete type 'CFunctor' specified in the signature
let inline replace (a: ^a) (f: ^b): ^a0 when (CFunctor or  ^b): (static member replace: ^a *  ^b ->  ^a0) =
    replace_instance<CFunctor, _, _, _> (a, f)
```

## <a name="see-also"></a>См. также
[Универсальные шаблоны](index.md)

[Вывод типа](../type-inference.md)

[Автоматическое обобщение](automatic-generalization.md)

[Ограничения](constraints.md)

[Встраиваемые функции](../functions/inline-functions.md)
