---
title: Статически разрешаемые параметры типа (F#)
description: 'Сведения об использовании языка F # статически разрешаемый параметр типа, который заменяется фактическим типом во время компиляции, а не во время выполнения.'
ms.date: 05/16/2016
ms.openlocfilehash: 30a7de0a3bc523ef17c1f89d6f88549069f752f8
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="statically-resolved-type-parameters"></a>Статически разрешаемые параметры типов

Объект *статически разрешаемый параметр типа* является параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения. Они предваряются символом крышки (^).


## <a name="syntax"></a>Синтаксис

```
ˆtype-parameter
```

## <a name="remarks"></a>Примечания
В языке F # существует два различных типа параметров типа. Первый тип — Стандартная универсального параметра типа. Такие параметры обозначаются апостроф ('), как и в `'T` и `'U`. Они эквивалентны параметров универсального типа в других языках .NET Framework. Статически разрешаемые другого типа и обозначается символом крышки, как в `^T` и `^U`.

Статически разрешаемые параметры типа, в первую очередь используются в связи с ограничениями членов, которые являются ограничения, которые позволяют указать, что аргумент типа должен иметь определенный элемент или элементы для использования. Нет возможности для создания такого типа ограничения с помощью обычного универсального параметра типа.

В следующей таблице перечислены сходства и различия между двумя типами параметров типа.

|Функция|Универсальный|Статически разрешаемые|
|-------|-------|-------------------|
|Синтаксис|`'T`, `'U`|`^T`, `^U`|
|Время разрешения|Выполнение|Время компиляции|
|Ограничения элементов|Не может использоваться с ограничениями членов.|Может использоваться с ограничениями членов.|
|Создание кода|Тип (или метод) со стандартными параметрами универсального типа приводит к формированию одного универсального типа или метода.|Создаются несколько экземпляров типов и методов, для каждого типа, который нужно.|
|Использование с типами|Может использоваться с типами.|Не может использоваться с типами.|
|Использование со встроенными функциями|Нет. Встроенная функция не может быть параметризовано с параметром standard универсального типа.|Да. Статически разрешаемые параметры типа нельзя использовать в функции или методы, не являющиеся встроенными.|

Многие основные функции библиотеки F #, особенно операторы статически разрешаемые параметры типов. Эти функции и операторы в строке и привести к созданию эффективного кода для численных вычислений.

Встроенные методы и функции, использующие операторы или использовать другие функции, которые статически разрешаемые параметры типов, можно также использовать статически разрешаемые параметры типа самостоятельно. Часто такие встроенные функции, имеющие статически разрешаемые параметры типа определяются определение типа. В следующем примере показано определение оператора, который определяется содержат параметр статически разрешаемые типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet401.fs)]

Разрешить тип `(+@)` основан на использование обоих `(+)` и `(*)`, оба из благодаря чему вывод типа ограничениям членов на статически разрешаемые параметры типа. Разрешенный тип, как показано в интерпретатору F #, будет следующим.

```fsharp
^a -> ^c -> ^d
when (^a or ^b) : (static member ( + ) : ^a * ^b -> ^d) and
(^a or ^c) : (static member ( * ) : ^a * ^c -> ^b)
```

Выходные данные выглядят следующим образом.

```
2
1.500000
```

Начиная с версии 4.1 F # можно также указать имена конкретных типов в сигнатурах статически разрешаемые типа параметра.  В предыдущих версиях языка имя типа могут быть выведены фактически компилятором, но фактически не удается задать в сигнатуре.  Начиная с F # 4.1 можно также указать имена конкретных типов в сигнатурах статически разрешаемые типа параметра. Ниже приведен пример:

```fsharp
type CFunctor() = 
      static member inline fmap (f: ^a -> ^b, a: ^a list) = List.map f a
      static member inline fmap (f: ^a -> ^b, a: ^a option) =
        match a with
        | None -> None
        | Some x -> Some (f x)

      // default implementation of replace
      static member inline replace< ^a, ^b, ^c, ^d, ^e when ^a :> CFunctor and (^a or ^d): (static member fmap: (^b -> ^c) * ^d -> ^e) > (a, f) =
        ((^a or ^d) : (static member fmap : (^b -> ^c) * ^d -> ^e) (konst a, f))

      // call overridden replace if present
      static member inline replace< ^a, ^b, ^c when ^b: (static member replace: ^a * ^b -> ^c)>(a: ^a, f: ^b) =
        (^b : (static member replace: ^a * ^b -> ^c) (a, f))

let inline replace_instance< ^a, ^b, ^c, ^d when (^a or ^c): (static member replace: ^b * ^c -> ^d)> (a: ^b, f: ^c) =
      ((^a or ^c): (static member replace: ^b * ^c -> ^d) (a, f))

// Note the concrete type 'CFunctor' specified in the signature
let inline replace (a: ^a) (f: ^b): ^a0 when (CFunctor or  ^b): (static member replace: ^a *  ^b ->  ^a0) =
    replace_instance<CFunctor, _, _, _> (a, f)
```

## <a name="see-also"></a>См. также
[Универсальные шаблоны](index.md)

[Вывод типа](../type-inference.md)

[Автоматическое обобщение](automatic-generalization.md)

[Ограничения](constraints.md)

[Встраиваемые функции](../functions/inline-functions.md)
