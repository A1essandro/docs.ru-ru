---
title: "Автоматическое обобщение (F#)"
description: "Узнайте, как F # автоматически обобщаются аргументы и типы функций, чтобы они работали с несколькими типами, когда это возможно."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 14a3554c-3fad-4eba-a93d-8ba07d1245b4
ms.openlocfilehash: d60831084cef76ce29f64322362b4920520f71d2
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="automatic-generalization"></a>Автоматическое обобщение

F # используется определение типа для определения типов, функций и выражения. В этом разделе описывается, как F # автоматически обобщаются аргументы и типы функций, чтобы они работали с несколькими типами, когда это возможно.


## <a name="automatic-generalization"></a>Автоматическое обобщение
Компилятор F # при выполнении определение типа для функции, определяет ли заданный параметр быть универсальным. Компилятор проверяет каждый параметр и определяет, является ли функция имеет зависимость от конкретного типа этого параметра. Если нет, тип определяется универсальным.

В следующем примере кода показано, функции, компилятор выводит быть универсальными.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet101.fs)]

Тип определяется как `'a -> 'a -> 'a`.

Тип указывает, что это функция, которая принимает два аргумента же неизвестного типа и возвращает значение того же типа. Одной из причин, которые могут быть предыдущую функцию универсального больше,-оператор (`>`) сам является универсальным. Больше-оператор имеет сигнатуру, чем `'a -> 'a -> bool`. Не все операторы являются универсальными, и если код в функции использует тип параметра вместе с неуниверсальной функцией или оператор, такой тип параметра не удается подготовить.

Поскольку `max` является универсальным, он может использоваться с типами например `int`, `float`и так далее, как показано в следующих примерах.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet102.fs)]

Тем не менее двух аргументы должны быть одного типа. Подпись является `'a -> 'a -> 'a`, а не `'a -> 'b -> 'a`. Таким образом следующий код приводит к ошибке, поскольку типы не совпадают.

```fsharp
// Error: type mismatch.
let biggestIntFloat = max 2.0 3
```

`max` Функция также работает с любым типом, который поддерживает больше-оператор. Таким образом может также используется со строками, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet104.fs)]
    
## <a name="value-restriction"></a>Ограничение значения
Компилятор выполняет Автоматическое обобщение только для полных определений функций, имеющие явные аргументы и для простых постоянных значений.

Это означает, что компилятор выдает ошибку при попытке скомпилировать код, который является достаточной степени не ограничен конкретным типом, но не также обобщению. Сообщение об ошибке для этой проблемы ссылается на это ограничение на Автоматическое обобщение значений как *значение ограничения*.

Как правило ошибки ограничения значений происходит, когда требуется конструкция универсальным, но компилятор имеет недостаточно информации для ее обобщения или при достаточной информации о типе в неуниверсальной конструкции непреднамеренно опускаются. Решения для ошибки ограничения значений является более явный информацию для более полного устранения проблемы вывода типа одним из следующих способов:


- Сделайте тип неуниверсальным, добавив явной аннотацией типа значения или параметра.

- Если проблемы с помощью необобщаемой конструкции для задания универсальной функции, например объединения функций или неполностью примененных аргументов каррированные функции, попробуйте переписать эту функцию как обычное определение функции.

- Если проблема заключается выражение, которое слишком сложен для обобщения, сделать в функцию, добавив дополнительный неиспользуемый параметр.

- Добавьте параметры явной универсального типа. Этот параметр используется редко.

- В следующем примере кода демонстрируется каждый из этих сценариев.

Вариант 1: Слишком сложное выражение. В этом примере список `counter` должно быть `int option ref`, но он не определен как простое постоянное значение.

```fsharp
let counter = ref None
// Adding a type annotation fixes the problem:
let counter : int option ref = ref None
```

Вариант 2: Использование необобщаемой конструкции для задания универсальной функции. В этом примере конструкция является необобщаемой, так как он содержит частичного применения аргументов функции.

```fsharp
let maxhash = max << hash
// The following is acceptable because the argument for maxhash is explicit:
let maxhash obj = (max << hash) obj
```

Вариант 3: Добавление дополнительного неиспользуемого параметра. Так как это выражение не сложно для обобщения, компилятор выдает ошибку ограничения значения.

```fsharp
let emptyList10 = Array.create 10 []
// Adding an extra (unused) parameter makes it a function, which is generalizable.
let emptyList10 () = Array.create 10 []
```

Вариант 4: Добавление параметров типа.

```fsharp
let arrayOf10Lists = Array.create 10 []
// Adding a type parameter and type annotation lets you write a generic value.
let arrayOf10Lists<'T> = Array.create 10 ([]:'T list)
```

В последнем случае значение преобразуется в тип функции, который может использоваться для создания значений различных типов, например следующим образом:

```fsharp
let intLists = arrayOf10Lists<int>
let floatLists = arrayOf10Lists<float>
```

## <a name="see-also"></a>См. также
[Вывод типа](../type-inference.md)

[Универсальные шаблоны](index.md)

[Статически разрешаемые параметры типов](statically-resolved-type-parameters.md)

[Ограничения](constraints.md)

