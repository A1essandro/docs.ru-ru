---
title: Конструкторы (F#)
description: 'Узнайте, как определить и использовать конструкторы в языке F # для создания и инициализации объектов классов и структур.'
ms.date: 05/16/2016
ms.openlocfilehash: 1773c111e0398aa83951afe14979d8a4ebc4907f
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33564437"
---
# <a name="constructors"></a>Конструкторы

В этом разделе описывается определение и использование конструкторов для создания и инициализации объектов классов и структур.


## <a name="construction-of-class-objects"></a>Создание объектов классов
Объекты типов классов имеют конструкторы. Существует два типа конструкторов. Он первичного конструктора, параметры которого отображаются в круглых скобках после имени типа. Второй — необязательные дополнительные конструкторы, которые задаются с помощью `new` ключевое слово. Такие дополнительные конструкторы необходимо вызвать первичного конструктора.

Главный конструктор содержит `let` и `do` привязок, которые записываются в начале определения класса. Объект `let` привязки объявляет закрытые поля и методы класса; `do` код выполняется привязка. Дополнительные сведения о `let` . в разделе привязок в конструкторах классов [ `let` привязок в классах](let-bindings-in-classes.md). Дополнительные сведения о `do` . в разделе привязок в конструкторах, [ `do` привязок в классах](do-bindings-in-classes.md).

Независимо от того, необходимо вызвать конструктор основной или дополнительный, можно создать объекты с помощью `new` выражение с или без необязательный `new` ключевое слово. Инициализация объектов вместе с аргументами конструктора либо путем перечисления аргументов в порядке и разделены запятыми и заключены в круглые скобки, или с помощью именованных аргументов и значений в круглых скобках. Вы можно также задать свойства объекта во время создания объекта, используя имена свойств и присвоение значений, как можно использовать именованные аргументы конструктора.

Следующий код иллюстрирует классом, имеющим различные способы создания объектов и конструктора.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3501.fs)]

Выходные данные выглядят следующим образом.

```console
Initialized object that has coordinates (1, 2, 3)
Initialized object that has coordinates (4, 5, 6)
Initialized object that has coordinates (7, 8, 9)
Initialized object that has coordinates (0, 0, 0)
```

## <a name="construction-of-structures"></a>Создание структур
Структуры имеют все правила классов. Таким образом, может иметь первичный конструктор, и можно задать дополнительные конструкторы с помощью `new`. Однако есть одно важное отличие между структурами и классами: структуры могут иметь конструктор по умолчанию (то есть без аргументов), даже если определена без первичного конструктора. Конструктор по умолчанию инициализирует все поля к значению по умолчанию для этого типа, обычно ноль или его эквивалент. Все конструкторы, которые задаются для структуры должны иметь по крайней мере один аргумент, чтобы они не конфликтовали с конструктором по умолчанию.

Кроме того, структуры часто имеют поля, создаваемые с помощью `val` ключевого слова; классы также могут иметь эти поля. Структуры и классы, имеющие поля, определенные с помощью `val` ключевое слово могут также инициализироваться в дополнительных конструкторах с помощью выражений записей, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3502.fs)]

Дополнительные сведения см. в разделе [явные поля: `val` ключевое слово](explicit-fields-the-val-keyword.md).


## <a name="executing-side-effects-in-constructors"></a>Выполнение побочных эффектов в конструкторах
Главный конструктор в классе может выполнять код в `do` привязки. Однако, что делать, если необходимо выполнить код в дополнительном конструкторе без `do` привязки? Чтобы сделать это, используйте `then` ключевое слово.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3503.fs)]

Побочные эффекты главного конструктора по-прежнему выполняются. Таким образом выходные данные выглядят следующим образом.

```console
Created a person object.
Created a person object.
Created an invalid person object.
```

## <a name="self-identifiers-in-constructors"></a>Собственные идентификаторы в конструкторах
В других членов укажите имя для текущего объекта в определении каждого члена. Также можно поместить собственный идентификатор в первой строке определения класса с помощью `as` ключевое слово сразу после параметров конструктора. Следующий пример иллюстрирует этот синтаксис.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3504.fs)]

В дополнительных конструкторах также можно определить собственный идентификатор, поместив `as` предложение сразу же после параметров конструктора. Следующий пример иллюстрирует этот синтаксис.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3505.fs)]

При попытке использовать объект, пока она полностью определена, могут возникнуть проблемы. Таким образом использует собственный идентификатор может привести к компилятору выдавать предупреждение, а также вставлять дополнительные проверки, чтобы убедиться, что отсутствие обращения к членам объекта до инициализации объекта. Следует использовать только собственный идентификатор в `do` привязки первичного конструктора или после `then` ключевое слово в дополнительных конструкторов.

Имя данного идентификатора не обязательно `this`. Это может быть любой допустимый идентификатор.


## <a name="assigning-values-to-properties-at-initialization"></a>Присвоение значений свойствам при инициализации
Можно присваивать значения свойствам объекта класса в коде инициализации, добавив список назначений формы `property = value` на список аргументов для конструктора. Это показано в следующем примере кода.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Следующая версия приведенного выше кода иллюстрирует сочетание обычных аргументов, необязательные аргументы и параметры свойств в одном вызове конструктора.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-2/snippet3507.fs)]
    
## <a name="constructors-in-inherited-class"></a>Конструкторы в унаследованном классе
При наследовании от базового класса, который содержит конструктор, необходимо указать ее аргументы в предложении наследовать. Дополнительные сведения см. в разделе [конструкторы и наследование](../inheritance.md#constructors-and-inheritance).

## <a name="static-constructors-or-type-constructors"></a>Статические конструкторы или конструкторы типов
Помимо задания кода для создания объектов, статические `let` и `do` привязок, которые могут быть созданы на типы классов, которые выполняются до первого использования типа для инициализации на уровне типа. Дополнительные сведения см. в разделе [ `let` привязок в классах](let-bindings-in-classes.md) и [ `do` привязок в классах](do-bindings-in-classes.md).

## <a name="see-also"></a>См. также
[Члены](index.md)
