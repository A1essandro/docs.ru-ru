---
title: Свойства (F#)
description: 'Дополнительные сведения о F # свойства, являющиеся членами, которые представляют значения, связанные с объектом.'
ms.date: 05/16/2016
ms.openlocfilehash: 7aa71b1801b44fedcb420b824078004c6c240dc2
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566166"
---
# <a name="properties"></a>Свойства

*Свойства* , члены, представляющие собой значения, связанные с объектом.


## <a name="syntax"></a>Синтаксис

```fsharp
// Property that has both get and set defined.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with [accessibility-modifier] get() =
    get-function-body
and [accessibility-modifier] set parameter =
    set-function-body

// Alternative syntax for a property that has get and set.
[ attributes-for-get ]
[ static ] member [accessibility-modifier-for-get] [self-identifier.]PropertyName =
    get-function-body
[ attributes-for-set ]
[ static ] member [accessibility-modifier-for-set] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName =
    get-function-body

// Alternative syntax for property that has get only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with get() =
    get-function-body

// Property that has set only.
[ attributes ]
[ static ] member [accessibility-modifier] [self-identifier.]PropertyName
with set parameter =
    set-function-body

// Automatically implemented properties.
[ attributes ]
[ static ] member val [accessibility-modifier] PropertyName = initialization-expression [ with get, set ]
```

## <a name="remarks"></a>Примечания
Свойства представляют» имеет «связь в объектно ориентированное программирование, представляющий данные, связанные с экземплярами объекта или для статических свойств с типом.

Можно объявить свойства двумя способами, в зависимости от того, требуется ли явно указать (также называемый резервным хранилищем) базовое значение для свойства или если вы хотите разрешить компилятора для автоматического создания резервного хранилища для вас. Как правило если свойство имеет только Простая оболочка для значения или переменной следует использовать более явным образом, если свойство имеет нетривиальный реализацию и автоматическим способом. Чтобы объявить свойство явно, используйте `member` ключевое слово. Это декларативный синтаксис следуют синтаксис, определяющий `get` и `set` методов, тоже именуемый *методы доступа*. Различные виды явного синтаксиса, показанного в разделе "синтаксис" используются для чтения и записи свойств только для чтения и только для записи. Для свойства только для чтения, определяется только `get` метода; для свойства только для записи, определите только `set` метод. Обратите внимание, что, когда свойство имеет и `get` и `set` доступа к свойствам альтернативный синтаксис позволяет указать атрибуты и модификаторы, которые различны для каждого метода доступа, как показано в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3201.fs)]

Для свойств чтения и записи, которые оба имеют `get` и `set` метод, порядок `get` и `set` , могут быть отменены. Кроме того, можно предоставить синтаксис, показанный для `get` только и синтаксис, показанный для `set` только вместо использования комбинированного синтаксиса. Это упрощает закомментировать отдельно `get` или `set` метод, если что-то может потребоваться сделать это. Это альтернатива использованию комбинированного синтаксиса показана в следующем коде.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3203.fs)]

Закрытые значения данных для свойств, называются удержанием *резервными хранилищами*. Чтобы компилятор автоматически создать резервное хранилище, используйте ключевые слова `member val`, пропущен идентификатор самого себя, а затем задать выражение для инициализации свойства. Если свойство является изменяемым, включите `with get, set`. Например следующий тип класса содержит два автоматически реализуемого свойства. `Property1` доступно только для чтения и инициализируется значением аргумента, предоставленного для первичного конструктора и `Property2` можно задать свойство инициализации на пустую строку:

```fsharp
type MyClass(property1 : int) =
member val Property1 = property1
member val Property2 = "" with get, set
```

Автоматически реализованные свойства являются частью инициализации типа, поэтому они должны быть включены до определения членов других так же, как `let` привязок и `do` привязок в определении типа. Обратите внимание, что выражение, которое инициализирует автоматически реализуемое свойство вычисляются только при инициализации, а не каждый раз, чтобы обращение к свойству. Это поведение отличается от поведения-точно реализованное свойство. Что фактически означает, что код для инициализации этих свойств будет добавлен в конструктор класса. Рассмотрим следующий код, который показывает это различие.

```fsharp
type MyClass() =
    let random  = new System.Random()
    member val AutoProperty = random.Next() with get, set
    member this.ExplicitProperty = random.Next()

let class1 = new MyClass()

printfn "class1.AutoProperty = %d" class1.AutoProperty
printfn "class1.AutoProperty = %d" class1.AutoProperty
printfn "class1.ExplicitProperty = %d" class1.ExplicitProperty
printfn "class1.ExplicitProperty = %d" class1.ExplicitProperty
```

**Вывод**

```
class1.AutoProperty = 1853799794
class1.AutoProperty = 1853799794
class1.ExplicitProperty = 978922705
class1.ExplicitProperty = 1131210765
```

Результат выполнения предыдущего кода показывает, что значение AutoProperty не изменяется при вызывается многократно, тогда как ExplicitProperty изменяется каждый раз, когда он вызывается. Этот пример демонстрирует для автоматически реализуемого свойства выражение не вычисляется каждый раз, как метод считывания для явного свойства.


>[!WARNING]
Существуют некоторые библиотеки, такие как Entity Framework (`System.Data.Entity`), выполнить пользовательские операции в конструкторы базовых классов, которые не могут работать с инициализации автоматически реализуемого свойства. В таком случае попробуйте использовать явную свойства.

Свойства могут быть членами классов, структур, размеченные объединения, записи, интерфейсы и расширения типов и также могут определяться в выражениях объектов.

Атрибуты могут применяться к свойствам. Чтобы применить атрибут к свойству, запишите атрибут на отдельной строке перед свойством. Дополнительные сведения см. в разделе [Атрибуты](../attributes.md).

По умолчанию свойства являются открытыми. Модификаторы доступности могут также применяться к свойствам. Чтобы применить модификатор доступности, добавьте его непосредственно перед именем свойства, если он должен применяться к обоим `get` и `set` методов; добавьте его перед `get` и `set` ключевые слова, если другой уровень доступа требуется для каждого метода доступа. *Модификатор доступа* может принимать одно из следующих действий: `public`, `private`, `internal`. Дополнительные сведения см. в статье [Управление доступом](../access-control.md).

Реализации свойств выполняются каждый раз, когда к свойству.


## <a name="static-and-instance-properties"></a>Статические методы и свойства экземпляра
Свойства могут быть статическими или свойства экземпляра. Статические свойства могут вызываться без экземпляра и используются для значений, связанных с типом, а не с отдельными объектами. Для статических свойств опустите идентификатор самого себя. Для свойства экземпляра требуется идентификатор самого себя.

Следующее определение статического свойства основан на сценарии, в котором имеется статическое поле `myStaticValue` , резервным хранилищем для свойства.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3204.fs)]

Свойства могут также быть-массив, в этом случае они называются *индексированных свойств*. Дополнительные сведения см. в разделе [индексированные свойства](indexed-properties.md).


## <a name="type-annotation-for-properties"></a>Аннотация типа для свойств
Во многих случаях компилятор имеет достаточно информации для определения типа свойства из типа резервного хранилища, но можно задать тип явно, добавив аннотацию типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3205.fs)]

## <a name="using-property-set-accessors"></a>С помощью свойства методы доступа set
Можно задавать свойства, предоставляющие `set` методы доступа с помощью `<-` оператор.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3206.fs)]

Выходные данные выглядят **20**.


## <a name="abstract-properties"></a>Абстрактные свойства
Свойства могут быть абстрактными. Как и для методов, `abstract` просто означает, что виртуальный диспетчеризации, связанное со свойством. Абстрактные свойства не может быть истинно абстрактными, то есть определение в том же классе. Таким образом, класс, который содержит это свойство является абстрактным. Кроме того абстрактный может означать только свойство является виртуальным, что в этом случае определение должно находиться в том же классе. Обратите внимание, что абстрактные свойства не должно быть закрытым, если один метод доступа является абстрактным, второй также должен быть абстрактным. Дополнительные сведения об абстрактных классах см. в разделе [абстрактные классы](../abstract-classes.md).

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-1/snippet3207.fs)]

## <a name="see-also"></a>См. также
[Члены](index.md)

[Методы](methods.md)
