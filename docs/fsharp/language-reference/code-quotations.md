---
title: "Цитирование кода (F#)"
description: "Дополнительные сведения о F # Цитирование кода, функция языка, предназначенное для создания и работы с выражения кода F #, программными средствами."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 4559e659-2b04-48bd-8a0b-8527920eec95
ms.openlocfilehash: f7a08013bc6487b570a62576bb01ca2dd65ce8b1
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="code-quotations"></a>Цитирование кода

> [!NOTE]
Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описывается *кавычки кода*, функция языка, предназначенное для создания и работы с выражения кода F #, программными средствами. Эта функция позволяет создавать дерева абстрактного синтаксиса, представляющее код F #. Дерева абстрактного синтаксиса можно просматривать и обрабатываются в соответствии с требованиями приложения. Например по дереву можно использовать для создания кода F #, или создание кода в некоторых других языков.


## <a name="quoted-expressions"></a>Заключенные в кавычки выражения
Объект *выражение в кавычках* выражение F # в коде, выделенное таким образом, не компилируется как часть программы, а компилируется в объект, представляющий выражение языка F #. Вы можете пометить заключенные в кавычки выражения в одном из двух способов: с помощью сведений о типе или без сведений о типе. Если вы хотите включить сведения о типе, можно использовать символы `<@` и `@>` для разделения выражение в кавычках. Если сведения о типе не требуется, можно использовать символы `<@@` и `@@>`. В следующем коде показано типизированных и нетипизированных предложений.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

Обход большого дерева выражения выполняется быстрее, если не включать сведения о типе. Итоговый тип выражения с символами в кавычках — `Expr<'T>`, где параметр типа имеет тип выражения определяется алгоритм определения типов компилятор F #. При использовании Цитирование кода без сведений о типе, тип, заключенный в кавычки выражения имеет неуниверсального типа [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65). Можно вызвать [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) свойство для типизированного `Expr` класса, чтобы получить нетипизированный `Expr` объекта.

Существует широкий набор статических методов, которые позволяют создавать объектов выражений F # программное `Expr` класса без использования цитируемых выражений.

Обратите внимание, что цитату кода должен содержать полное выражение. Для `let` привязки, например, требуется определение имени привязки и дополнительное выражение, использующее эту привязку. В подробном синтаксисе это выражение, следующее за `in` ключевое слово. На верхнем уровне в модуле это просто следующее выражение в модуле, но в кавычки, он необходим явным образом.

Таким образом следующее выражение не является допустимым.

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

Но следующее выражение допустимо.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

Чтобы использовать Цитирование кода, необходимо добавить объявление импорта (с помощью `open` ключевого слова), которая будет открывать [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) пространства имен.

PowerPack F # обеспечивает поддержку для вычисления и выполнения объектов выражений F #.


## <a name="expr-type"></a>Тип выражения
Экземпляр `Expr` тип представляет выражение языка F #. Универсальные и неуниверсальные `Expr` типы описаны в документации библиотеки F #. Дополнительные сведения см. в разделе [имен Microsoft.FSharp.Quotations](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) и [класс Quotations.Expr](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).


## <a name="splicing-operators"></a>Операторы объединения
Объединение позволяет объединять литеральные цитаты кода с выражениями, созданные программными средствами или из другой цитаты кода. `%` И `%%` операторы позволяют добавить объект выражения языка F # в цитату кода. Вы используете `%` оператор для вставки объекта типизированного выражения в типизированную цитату; вместо этого используйте `%%` оператор для вставки объекта нетипизированного выражения в нетипизированную цитату. Оба оператора являются унарными операторами префикс. Таким образом Если `expr` является нетипизированным выражением типа `Expr`, следующий код является допустимым.

```fsharp
<@@ 1 + %%expr @@>
```

Если `expr` является типизированной цитатой типа `Expr<int>`, следующий код является допустимым.

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание
Следующий пример иллюстрирует использование Цитирование кода, чтобы поместить код F # в объект выражения и напечатайте кода F #, который представляет выражение. Функция `println` определяется, содержащая рекурсивную функцию `print` , отображает объект выражения языка F # (типа `Expr`) в удобном формате. Существует несколько активных шаблонов в [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) и [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) модули, которые могут использоваться для анализа объектов выражений. В этом примере не включает все шаблоны, которые могут отображаться в выражении языка F #. Любой нераспознанный шаблон вызывает сопоставления Шаблон подстановочного знака (`_`) и готовится к просмотру с помощью `ToString` метод, который, в `Expr` введите позволяет определить активный шаблон, чтобы добавить в выражение match.


### <a name="code"></a>Код
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet601.fs)]
    
### <a name="output"></a>Вывод

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a>Пример

### <a name="description"></a>Описание
Можно также использовать три активных шаблона в [ExprShape-модуль](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) для обхода деревьев выражений с меньшим количеством активных шаблонов. Эти активные шаблоны можно использовать при требуется переход по дереву, но не обязательно все сведения большинства узлов. При использовании этих шаблонов все выражения языка F # соответствуют одному из следующих трех шаблонов: `ShapeVar` Если выражение является переменной, `ShapeLambda` Если выражение является лямбда-выражение или `ShapeCombination` Если выражение используется другой. Если обход дерева выражения с помощью активные шаблоны как в предыдущем примере кода, необходимо использовать многие другие шаблоны для обработки всех возможных типов выражений языка F # и код будет более сложным. Дополнительные сведения см. в разделе [ExprShape.ShapeVar &#124; ShapeLambda &#124; ShapeCombination-активный шаблон](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).

В следующем примере кода можно использовать в качестве основы для более сложных обходов. В этом коде дерево выражения создается для выражения, содержащего вызов функции `add`. [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) активный шаблон используется для обнаружения всех вызовов функции `add` в дереве выражения. Этот активный шаблон присваивает аргументы вызова `exprList` значение. В этом случае существует только два, поэтому они извлекаются и функция вызывается рекурсивно от аргументов. Результаты вставляются в цитату кода, который представляет вызов `mul` с помощью оператора объединения (`%%`). `println` Функция из предыдущего примера используется для отображения результатов.

Код из других ветвей активных шаблонов просто заново создает это же дерево выражения, поэтому единственным изменением в результирующем выражении является замена `add` для `mul`.


### <a name="code"></a>Код
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet701.fs)]
    
### <a name="output"></a>Вывод

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)

