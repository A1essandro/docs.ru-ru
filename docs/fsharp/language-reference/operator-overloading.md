---
title: Перегрузка операторов (F#)
description: 'Дополнительные сведения о перегрузка арифметических операторов в классе или тип записи, а также на глобальном уровне в языке F #.'
ms.date: 05/16/2016
ms.openlocfilehash: fc9b7311aa746fd758930365972a187ffdfff0d5
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="operator-overloading"></a>Перегрузка операторов

В этом разделе описывается перегрузка арифметических операторов в классе или тип записи, а также на глобальном уровне.


## <a name="syntax"></a>Синтаксис

```fsharp
// Overloading an operator as a class or record member.
static member (operator-symbols) (parameter-list) =
    method-body
// Overloading an operator at the global level
let [inline] (operator-symbols) parameter-list = function-body
```

## <a name="remarks"></a>Примечания
В предыдущем синтаксисе *символ оператора* является одним из `+`, `-`, `*`, `/`, `=`, и т. д. *Список параметров* задает операнды в том порядке, они отображаются в обычный синтаксис для этого оператора. *Тело метода* создает результирующее значение.

Перегрузки операторов для операторов должны быть статическими. Оператор перегрузки для унарных операторов, таких как `+` и `-`, необходимо использовать тильду (`~`) в *символ оператора* для указания, что оператор является унарным, а бинарного оператора, как показано в следующее объявление.

```fsharp
static member (~-) (v : Vector)
```

Следующий код иллюстрирует векторный класс, имеющий только два оператора унарного минуса и умножения на скаляр. В примере две перегрузки для скалярного умножения нужны, поскольку оператор должен работать независимо от порядка, в котором отображаются вектор и скаляр.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4001.fs)]

## <a name="creating-new-operators"></a>Создание новых операторов
Все стандартные операторы можно перегрузить, но можно также создавать новые операторы из последовательностей определенных символов. Допустимые знаки операторов: `!`, `%`, `&`, `*`, `+`, `-`, `.`, `/`, `<`, `=`, `>`, `?`, `@`, `^`, `|`, и `~`. `~` Символ имеет особое значение делает оператор унарным и не является частью последовательности символов оператора. Не все операторы могут выполняться унарный.

В зависимости от символьной последовательность, в которой используется ваш оператор будет иметь приоритет и ассоциативность операторов. Ассоциативность может быть либо слева направо или справа налево и будет использоваться при каждом операторы одного уровня приоритета появляются в последовательности без скобок.

Символ оператора `.` не влияет на более высокий приоритет, поэтому, например, если вы хотите определить собственную версию умножения, имеет тот же приоритет и ассоциативность, что и обычное умножение, можно создать операторов, таких как `.*`.

Только операторы `?` и `?<-` может начинаться с `?`.

Таблицу, описывающую приоритет всех операторов в языке F # можно найти в [Справочник символов и операторов](symbol-and-operator-reference/index.md).


## <a name="overloaded-operator-names"></a>Имена перегруженных операторов
Когда компилятор F # компилирует выражение с оператором, он создает метод, который имеет имя, созданный компилятором, для этого оператора. Это имя, которое отображается в промежуточный язык Microsoft (MSIL) для метода, а также в отражении и IntelliSense. Обычно необходимо использовать эти имена в коде F #.

В следующей таблице приведены стандартные операторы и соответствующие им генерируемые имена.



|Оператор|Созданное имя|
|--------|--------------|
|`[]`|`op_Nil`|
|`::`|`op_Cons`|
|`+`|`op_Addition`|
|`-`|`op_Subtraction`|
|`*`|`op_Multiply`|
|`/`|`op_Division`|
|`@`|`op_Append`|
|`^`|`op_Concatenate`|
|`%`|`op_Modulus`|
|`&&&`|`op_BitwiseAnd`|
|<code>&#124;&#124;&#124;</code>|`op_BitwiseOr`|
|`^^^`|`op_ExclusiveOr`|
|`<<<`|`op_LeftShift`|
|`~~~`|`op_LogicalNot`|
|`>>>`|`op_RightShift`|
|`~+`|`op_UnaryPlus`|
|`~-`|`op_UnaryNegation`|
|`=`|`op_Equality`|
|`<=`|`op_LessThanOrEqual`|
|`>=`|`op_GreaterThanOrEqual`|
|`<`|`op_LessThan`|
|`>`|`op_GreaterThan`|
|`?`|`op_Dynamic`|
|`?<-`|`op_DynamicAssignment`|
|<code>&#124;></code>|`op_PipeRight`|
|<code><&#124;</code>|`op_PipeLeft`|
|`!`|`op_Dereference`|
|`>>`|`op_ComposeRight`|
|`<<`|`op_ComposeLeft`|
|`<@ @>`|`op_Quotation`|
|`<@@ @@>`|`op_QuotationUntyped`|
|`+=`|`op_AdditionAssignment`|
|`-=`|`op_SubtractionAssignment`|
|`*=`|`op_MultiplyAssignment`|
|`/=`|`op_DivisionAssignment`|
|`..`|`op_Range`|
|`.. ..`|`op_RangeStep`|
Другие сочетания символов операторов, не перечисленных здесь можно использовать в качестве операторов и иметь имена, которые создаются путем объединения имена отдельных символов из следующей таблицы. Например +! становится `op_PlusBang`.



|Символ оператора|name|
|------------------|----|
|`>`|`Greater`|
|`<`|`Less`|
|`+`|`Plus`|
|`-`|`Minus`|
|`*`|`Multiply`|
|`/`|`Divide`|
|`=`|`Equals`|
|`~`|`Twiddle`|
|`%`|`Percent`|
|`.`|`Dot`|
|`&`|`Amp`|
|<code>&#124;</code>|`Bar`|
|`@`|`At`|
|`^`|`Hat`|
|`!`|`Bang`|
|`?`|`Qmark`|
|`(`|`LParen`|
|`,`|`Comma`|
|`)`|`RParen`|
|`[`|`LBrack`|
|`]`|`RBrack`|

## <a name="prefix-and-infix-operators"></a>Префикс и инфиксные операторы
*Префикс* операторы должны размещаться перед операндом или операндами, подобно функции. *Инфиксные* операторы должны размещаться между двумя операндами.

Только определенные операторы могут использоваться как префиксные операторы. Некоторые операторы всегда являются префиксные операторы, другие могут быть инфиксные или префикс и остальные всегда являются инфиксные операторы. Операторы, которые начинаются с `!`, за исключением `!=`и оператор `~`, и не будут повторяться последовательности`~`, всегда являются префиксные операторы. Операторы `+`, `-`, `+.`, `-.`, `&`, `&&`, `%`, и `%%` может быть операторы префиксом или инфиксные операторы. Префиксная версия этих операторов было отличить от версии инфиксные путем добавления `~` в начале префиксный оператор, если она определена. `~` Не используется при использовании оператора, только в том случае, если она определена.

## <a name="example"></a>Пример

Следующий код иллюстрирует использование перегрузки операторов для реализации дробного типа. Дробь представляется числителем и знаменателем. Функция `hcf` используется для определения наибольшего общего делителя, который используется для сокращения доли секунды.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4002.fs)]

**Выходные данные:**

```
3/4 + 1/2 = 5/4
3/4 - 1/2 = 1/4
3/4 * 1/2 = 3/8
3/4 / 1/2 = 3/2
3/4 + 1 = 7/4
```

## <a name="operators-at-the-global-level"></a>Операторы на глобальном уровне
Можно также определить операторы на глобальном уровне. В следующем коде определяется оператор `+?`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4003.fs)]

Результат выполнения приведенного выше кода `12`.

Регулярные арифметические операторы, таким образом можно переопределить, поскольку правила выбора области для F # определяют, что новые определенные операторы имеют приоритет над встроенными операторами.

Ключевое слово `inline` часто используется с глобальными операторами, которые часто оказываются небольшие функции, которые лучше всего интегрируются в вызывающий код. Встроенные функции оператор внесения также позволяет им для работы с статически разрешаемые параметры типа для получения статически разрешаемые универсального кода. Дополнительные сведения см. в разделе [встроенные функции](functions/inline-functions.md) и [статически Разрешить параметры типа](generics/statically-resolved-type-parameters.md).

## <a name="see-also"></a>См. также
[Члены](members/index.md)
