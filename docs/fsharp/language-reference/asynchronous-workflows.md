---
title: Асинхронные рабочие потоки (F#)
description: 'Подробнее о поддержке в языке F # язык программирования для выполнения асинхронных вычислений, которые выполняются без блокировки других операций.'
ms.date: 05/16/2016
ms.openlocfilehash: 5f7a1a623e143e1bedf51c1a1ed477bb867b280a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566367"
---
# <a name="asynchronous-workflows"></a>Асинхронные рабочие потоки

> [!NOTE]
Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описывается поддержка в языке F # для выполнения асинхронных вычислений, то есть, без блокировки других операций. Например асинхронные вычисления можно использовать для написания приложений с интерфейсами пользователя, продолжать отвечать на запросы для пользователей, как приложение выполняет другую работу.

## <a name="syntax"></a>Синтаксис

```fsharp
async { expression }
```

## <a name="remarks"></a>Примечания

В предыдущем синтаксисе представлены вычисления `expression` настроена на запускаются асинхронно, то есть, без блокировки текущего потока вычислений при выполнении операции асинхронной спящего режима, ввода-вывода и других асинхронных операций. Асинхронные вычисления часто запускаются в фоновом потоке, пока выполнение продолжается в текущем потоке. Тип выражения — `Async<'T>`, где `'T` — тип, возвращаемый выражением при `return` используется ключевое слово. Код в таком выражении называется *асинхронным блоком*, или *блоком async*.

Существует множество способов программирования асинхронно и [ `Async` ](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) класс предоставляет методы, поддерживающие несколько сценариев. Общий подход заключается в создании `Async` объектов, представляющих вычисление или вычисления, которые требуется выполнять асинхронно, а затем запустите этих вычислений с помощью одной из функций активации. Различные запускающие функции обеспечивают различные способы выполнения асинхронных вычислений и используемом один зависит от того, требуется ли использовать текущий поток, фоновый поток или объект задачи платформы .NET Framework и определения наличия продолжения функции, которые необходимо выполнить после завершения вычисления. Например, чтобы запустить асинхронное вычисление в текущем потоке, можно использовать [ `Async.StartImmediate` ](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3). При запуске асинхронное вычисление из потока пользовательского интерфейса, не блокируют основной цикл событий, обрабатывающий действия пользователя, такие как нажатия клавиш и действия мыши, поэтому приложение продолжает отвечать на запросы.

## <a name="asynchronous-binding-by-using-let"></a>Асинхронные привязки с помощью let!

В асинхронном рабочем процессе некоторые выражения и операции являются синхронными, а некоторые — больше времени вычислений, которые должны возвращать результат асинхронно. При асинхронном вызове метода вместо обычных `let` привязку, использовать `let!`. Эффект `let!` позволяет продолжать выполнение других вычислений или потоков во время вычисления. После правой части `let!` возвращает привязки, остальная часть асинхронный рабочий процесс возобновляется выполнение.

В следующем коде показано различие между `let` и `let!`. Строки кода, использующего `let` просто создает асинхронное вычисление в виде объекта, который можно запустить позднее с помощью, например, `Async.StartImmediate` или [ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b). Строки кода, использующего `let!` запускает вычисление, а затем выполнение потока приостанавливается, пока не станет доступен результат, после чего выполнение продолжается.

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

В дополнение к `let!`, можно использовать `use!` для выполнения асинхронной привязки. Разница между `let!` и `use!` является таким же, как разница между `let` и `use`. Для `use!`, объект удаляется при закрытии текущей области видимости. Обратите внимание, что в текущем выпуске языка F #, `use!` не допускает значений будет инициализирована имеет значение null, даже если `use` does.

## <a name="asynchronous-primitives"></a>Асинхронные примитивы

Вызывается метод, который выполняет одну асинхронную задачу и возвращает результат *асинхронного примитива*, и они предназначены специально для использования с `let!`. Несколько асинхронных примитивов определяются в основной библиотеке F #. Два метода для веб-приложений определенные в модуле [ `Microsoft.FSharp.Control.WebExtensions` ](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [ `WebRequest.AsyncGetResponse` ](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) и [ `WebClient.AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a). Оба примитива загрузить данные из веб-страницы, заданный URL-адрес. `AsyncGetResponse` Создает `System.Net.WebResponse` объекта, и `AsyncDownloadString` создает строку, которая представляет HTML-код для веб-страницы.

Несколько примитивов для асинхронных операций ввода-вывода, включаются в [ `Microsoft.FSharp.Control.CommonExtensions` ](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) модуля. Эти методы расширения для `System.IO.Stream` класса [ `Stream.AsyncRead` ](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) и [ `Stream.AsyncWrite` ](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).

Доступны дополнительные асинхронные примитивы в [F # PowerTools](https://fsprojects.github.io/VisualFSharpPowerTools/). Можно также написать собственные асинхронные примитивы, определив функцию, все тело заключается в асинхронном блоке.

Чтобы использовать асинхронные методы в платформе .NET Framework, предназначенные для других асинхронных моделей с моделью асинхронного программирования F #, создайте функцию, возвращающую F # `Async` объекта. Библиотеки F # содержит функции, позволяющие это легко сделать.

Примером использования асинхронные рабочие потоки включено Существует множество других в документации по методам [асинхронный класс](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).

В этом примере показано, как использовать асинхронные рабочие процессы для выполнения вычислений в параллельном режиме.

В следующем примере кода функция `fetchAsync` Возвращает HTML-текст, возвращаемый из веб-запроса. `fetchAsync` Функция содержит асинхронный блок кода. Если привязка выполняется к результату асинхронного примитива, в этом случае [ `AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a), позволяют! используется вместо let.

При использовании функции [ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) для выполнения асинхронной операции и ожидать ее результата. Например, можно выполнять несколько асинхронных операций в параллельном режиме с помощью [ `Async.Parallel` ](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) работать вместе с `Async.RunSynchronously` функции. `Async.Parallel` Функция принимает список `Async` объектов, настраивает код для каждого `Async` объект задачи для запуска в параллельном режиме и возвращает `Async` , представляющий параллельные вычисления. Как и в случае одной операции, вызовите `Async.RunSynchronously` для начала выполнения.

`runAll` Функция запускает три асинхронных рабочих процесса и ожидает, пока все они будут завершены.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a>См. также

[Справочник по языку F#](index.md)

[Выражения вычисления](computation-expressions.md)

[Класс Control.Async](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
