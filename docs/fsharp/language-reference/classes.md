---
title: "Классы (F#)"
description: "Узнайте, как классов F # — это типы, представляющие объекты, которые могут иметь свойства, методы и события."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: d58679d5-7753-4b3b-a12f-6e9f00ed5ba3
ms.openlocfilehash: 2a73baba1f7c1b0d3bd09d22c9d6d9f0524daef3
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a><span data-ttu-id="160ec-104">Классы</span><span class="sxs-lookup"><span data-stu-id="160ec-104">Classes</span></span>

<span data-ttu-id="160ec-105">*Классы* — это типы, представляющие объекты, которые могут иметь свойства, методы и события.</span><span class="sxs-lookup"><span data-stu-id="160ec-105">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="160ec-106">Синтаксис</span><span class="sxs-lookup"><span data-stu-id="160ec-106">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="160ec-107">Примечания</span><span class="sxs-lookup"><span data-stu-id="160ec-107">Remarks</span></span>
<span data-ttu-id="160ec-108">Классы представляют фундаментальное Описание типов объектов .NET. класс является основной тип концепция, которая поддерживает объектно ориентированное программирование на F #.</span><span class="sxs-lookup"><span data-stu-id="160ec-108">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="160ec-109">Приведенный выше синтаксис `type-name` — любой допустимый идентификатор.</span><span class="sxs-lookup"><span data-stu-id="160ec-109">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="160ec-110">`type-params` Описывает необязательные параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="160ec-110">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="160ec-111">Он состоит из имена параметров типов и ограничений, заключенной в угловые скобки (`<` и `>`).</span><span class="sxs-lookup"><span data-stu-id="160ec-111">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="160ec-112">Дополнительные сведения см. в разделе [универсальных шаблонов](generics/index.md) и [ограничения](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-112">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="160ec-113">`parameter-list` Описание параметров конструктора.</span><span class="sxs-lookup"><span data-stu-id="160ec-113">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="160ec-114">Первый модификатор доступа относится к типу; Второй относится к первичного конструктора.</span><span class="sxs-lookup"><span data-stu-id="160ec-114">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="160ec-115">В обоих случаях значение по умолчанию — `public`.</span><span class="sxs-lookup"><span data-stu-id="160ec-115">In both cases, the default is `public`.</span></span>

<span data-ttu-id="160ec-116">Укажите базовый класс для класса с помощью `inherit` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="160ec-116">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="160ec-117">Необходимо указать аргументы для конструктора базового класса, в скобках.</span><span class="sxs-lookup"><span data-stu-id="160ec-117">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="160ec-118">Объявления полей или значений, являющихся локальными для класса с помощью функций `let` привязки и необходимо соблюдать общие правила для `let` привязки.</span><span class="sxs-lookup"><span data-stu-id="160ec-118">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="160ec-119">`do-bindings` Раздел содержит код, выполняемый при создании объекта.</span><span class="sxs-lookup"><span data-stu-id="160ec-119">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="160ec-120">`member-list` Состоит из дополнительных конструкторов, экземпляр и объявления статических методов, объявления интерфейса, абстрактные привязки и объявления свойств и событий.</span><span class="sxs-lookup"><span data-stu-id="160ec-120">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="160ec-121">Они описаны в [элементы](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-121">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="160ec-122">`identifier` , Используемый с необязательным `as` ключевого слова, указывает имя переменной экземпляра, или собственный идентификатор, который может использоваться для ссылки на экземпляр типа в определении типа.</span><span class="sxs-lookup"><span data-stu-id="160ec-122">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="160ec-123">Для получения дополнительной информации обратитесь к разделу идентификаторы Self далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="160ec-123">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="160ec-124">Ключевые слова `class` и `end` , отмечающие начало и конец определения являются необязательными.</span><span class="sxs-lookup"><span data-stu-id="160ec-124">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="160ec-125">Взаимно рекурсивные типы, которые являются типами, которые ссылаются друг на друга, объединяются с `and` ключевое слово точно так же, как и взаимно рекурсивные функции.</span><span class="sxs-lookup"><span data-stu-id="160ec-125">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="160ec-126">Например в разделе взаимно рекурсивные типы.</span><span class="sxs-lookup"><span data-stu-id="160ec-126">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="160ec-127">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="160ec-127">Constructors</span></span>
<span data-ttu-id="160ec-128">Конструктор — это код, который создает экземпляр типа класса.</span><span class="sxs-lookup"><span data-stu-id="160ec-128">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="160ec-129">Конструкторы классов работают иначе в языке F # в других языках .NET.</span><span class="sxs-lookup"><span data-stu-id="160ec-129">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="160ec-130">В классе F #, всегда есть главный конструктор, аргументы которого описаны в `parameter-list` , который следует за именем типа и тело которого состоит из `let` (и `let rec`) привязок в начале объявления класса и `do`за ними привязок.</span><span class="sxs-lookup"><span data-stu-id="160ec-130">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="160ec-131">Аргументы главного конструктора находятся в области всего объявления класса.</span><span class="sxs-lookup"><span data-stu-id="160ec-131">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="160ec-132">Можно добавить дополнительные конструкторы с помощью `new` ключевое слово для добавления члена, как показано ниже:</span><span class="sxs-lookup"><span data-stu-id="160ec-132">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="160ec-133">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="160ec-133">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="160ec-134">Тело новый конструктор должен вызвать первичного конструктора, который указан в верхней части объявления класса.</span><span class="sxs-lookup"><span data-stu-id="160ec-134">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="160ec-135">Эта концепция проиллюстрирована в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="160ec-135">The following example illustrates this concept.</span></span> <span data-ttu-id="160ec-136">В следующем коде `MyClass` имеет два конструктора: главный конструктор, который принимает два аргумента и другой конструктор без аргументов.</span><span class="sxs-lookup"><span data-stu-id="160ec-136">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="160ec-137">Let и do-привязки</span><span class="sxs-lookup"><span data-stu-id="160ec-137">let and do Bindings</span></span>

<span data-ttu-id="160ec-138">`let` И `do` привязок в определении класса образуют основную часть главного конструктора, и поэтому они выполняются каждый раз, когда создается экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="160ec-138">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="160ec-139">Если `let` привязки — это функция, то она компилируется в член.</span><span class="sxs-lookup"><span data-stu-id="160ec-139">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="160ec-140">Если `let` привязка имеет значение, которое не используется в любой функции или элемента, то она компилируется в переменную, которая является локальной в конструктор.</span><span class="sxs-lookup"><span data-stu-id="160ec-140">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="160ec-141">В противном случае она компилируется в поле класса.</span><span class="sxs-lookup"><span data-stu-id="160ec-141">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="160ec-142">`do` Выражения компилируются в главный конструктор и выполняют код инициализации для каждого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="160ec-142">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="160ec-143">Поскольку все дополнительные конструкторы всегда вызывают главный конструктор `let` привязок и `do` всегда выполняются, независимо от того, что вызов конструктора.</span><span class="sxs-lookup"><span data-stu-id="160ec-143">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="160ec-144">Поля, которые создаются путем `let` привязки можно обращаться через методы и свойства класса; Однако они недоступны из статических методов, даже если статический метод принимает экземпляр переменной в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="160ec-144">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="160ec-145">Они становятся недоступными, используя собственный идентификатор, если он существует.</span><span class="sxs-lookup"><span data-stu-id="160ec-145">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="160ec-146">Собственные идентификаторы</span><span class="sxs-lookup"><span data-stu-id="160ec-146">Self Identifiers</span></span>

<span data-ttu-id="160ec-147">Объект *собственный идентификатор* — имя, которое представляет текущий экземпляр.</span><span class="sxs-lookup"><span data-stu-id="160ec-147">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="160ec-148">Собственные идентификаторы подобны `this` ключевого слова в C# или C++ или `Me` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="160ec-148">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="160ec-149">Можно определить собственный идентификатор двумя различными способами, в зависимости от того, нужно ли собственный идентификатор в области для всего определения класса или просто для отдельного метода.</span><span class="sxs-lookup"><span data-stu-id="160ec-149">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="160ec-150">Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающей скобки параметра конструктора списка и укажите имя идентификатора.</span><span class="sxs-lookup"><span data-stu-id="160ec-150">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="160ec-151">Чтобы определить собственный идентификатор только один метод, укажите собственный идентификатор в объявлении члена непосредственно перед именем метода и точку (.) в качестве разделителя.</span><span class="sxs-lookup"><span data-stu-id="160ec-151">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="160ec-152">В следующем примере кода показано два способа создания собственного идентификатора.</span><span class="sxs-lookup"><span data-stu-id="160ec-152">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="160ec-153">В первой строке `as` используется ключевое слово, чтобы определить собственный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="160ec-153">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="160ec-154">В пятой строке идентификатор `this` позволяет определить собственный идентификатор, область действия которого ограничивается метод `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="160ec-154">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="160ec-155">В отличие от других языков .NET, можно назвать собственный идентификатор задать; Вы не ограничены имена таких как `self`, `Me`, или `this`.</span><span class="sxs-lookup"><span data-stu-id="160ec-155">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="160ec-156">Собственный идентификатор, объявленный с `as` ключевое слово не инициализируется до после `let` выполнения привязок.</span><span class="sxs-lookup"><span data-stu-id="160ec-156">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="160ec-157">Таким образом, не может использоваться в `let` привязки.</span><span class="sxs-lookup"><span data-stu-id="160ec-157">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="160ec-158">Можно использовать собственный идентификатор в `do` разделе привязок.</span><span class="sxs-lookup"><span data-stu-id="160ec-158">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="160ec-159">Параметры универсального типа</span><span class="sxs-lookup"><span data-stu-id="160ec-159">Generic Type Parameters</span></span>

<span data-ttu-id="160ec-160">Указаны параметры универсального типа в угловых скобках (`<` и `>`), в форме одиночные кавычки, а затем по идентификатору.</span><span class="sxs-lookup"><span data-stu-id="160ec-160">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="160ec-161">Параметры универсального типа разделяются запятыми.</span><span class="sxs-lookup"><span data-stu-id="160ec-161">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="160ec-162">Область действия объявления является параметром универсального типа.</span><span class="sxs-lookup"><span data-stu-id="160ec-162">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="160ec-163">В следующем примере кода показано, как задать параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="160ec-163">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="160ec-164">Типы аргументов определяются при использовании типа.</span><span class="sxs-lookup"><span data-stu-id="160ec-164">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="160ec-165">В следующем коде определяемый тип является последовательностью кортежей.</span><span class="sxs-lookup"><span data-stu-id="160ec-165">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="160ec-166">Указание наследования</span><span class="sxs-lookup"><span data-stu-id="160ec-166">Specifying Inheritance</span></span>

<span data-ttu-id="160ec-167">`inherit` Предложение определяет прямой базовый класс, если он существует.</span><span class="sxs-lookup"><span data-stu-id="160ec-167">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="160ec-168">В языке F # допускается только один прямой базовый класс.</span><span class="sxs-lookup"><span data-stu-id="160ec-168">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="160ec-169">Интерфейсы, реализуемые классом, не считаются базовых классов.</span><span class="sxs-lookup"><span data-stu-id="160ec-169">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="160ec-170">Интерфейсы рассматриваются в [интерфейсы](Interfaces.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="160ec-170">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="160ec-171">Вы доступны методы и свойства базового класса из производного класса с помощью ключевого слова языка `base` как идентификатор, за которым следует точка (.) и имя элемента.</span><span class="sxs-lookup"><span data-stu-id="160ec-171">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="160ec-172">Дополнительные сведения см. в разделе [Наследование](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-172">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="160ec-173">Раздел членов</span><span class="sxs-lookup"><span data-stu-id="160ec-173">Members Section</span></span>
<span data-ttu-id="160ec-174">В этом разделе, можно определить статический или методов экземпляра, свойства, реализации интерфейса, абстрактные члены, объявления событий и дополнительных конструкторов.</span><span class="sxs-lookup"><span data-stu-id="160ec-174">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="160ec-175">Let и привязки не отображаются в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="160ec-175">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="160ec-176">Поскольку элементы могут добавляться для различных типов F #, наряду с классами, они рассматриваются в отдельном разделе [элементы](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-176">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="160ec-177">Взаимно рекурсивные типы</span><span class="sxs-lookup"><span data-stu-id="160ec-177">Mutually Recursive Types</span></span>
<span data-ttu-id="160ec-178">При определении типов, которые ссылаются друг на друга циклически можно передавать вместе определения типов с помощью `and` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="160ec-178">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="160ec-179">`and` Заменяет ключевое слово `type` во всех определениях, кроме первого, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="160ec-179">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="160ec-180">Выводится список всех файлов в текущем каталоге.</span><span class="sxs-lookup"><span data-stu-id="160ec-180">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="160ec-181">Когда следует использовать классы, объединения, записи и структуры</span><span class="sxs-lookup"><span data-stu-id="160ec-181">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="160ec-182">Имеется множество различных типов для выбора, необходимо знать о том, что каждый тип предназначены для выберите подходящий тип для конкретной ситуации.</span><span class="sxs-lookup"><span data-stu-id="160ec-182">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="160ec-183">Классы предназначены для использования в объектно ориентированного программирования контекстах.</span><span class="sxs-lookup"><span data-stu-id="160ec-183">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="160ec-184">Объектно ориентированное программирование является главным парадигме приложений, разработанных для платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="160ec-184">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="160ec-185">Если ваш код F # содержит тесно взаимодействовать с .NET Framework или другую библиотеку объектно ориентированного и особенно в том случае, если необходимо расширить систему объектно ориентированного типов, таких как библиотека пользовательского интерфейса, классы, вероятно, подходят.</span><span class="sxs-lookup"><span data-stu-id="160ec-185">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="160ec-186">При отсутствии тесного взаимодействия с объектно ориентированного кода или если вы пишете код, который является самодостаточным и поэтому защищенные от частого взаимодействия с объектно ориентированного кода, то следует рассмотреть возможность использования записи и размеченные объединения.</span><span class="sxs-lookup"><span data-stu-id="160ec-186">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="160ec-187">Одно тщательно проработанное размеченного объединения, а также соответствующие шаблоны кода, часто оказывается более простой альтернативой иерархии объектов.</span><span class="sxs-lookup"><span data-stu-id="160ec-187">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="160ec-188">Дополнительные сведения о размеченные объединения см. в разделе [размеченные объединения](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-188">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="160ec-189">Записи имеют преимущество проще, чем классов, но превышение накладываемые их простотой требования к типу записи не подходят.</span><span class="sxs-lookup"><span data-stu-id="160ec-189">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="160ec-190">Записи, по сути простые агрегаты значений без отдельных конструкторов, которые могут выполнять пользовательские действия, без скрытых полей и без реализации наследования и интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="160ec-190">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="160ec-191">Несмотря на то, что можно добавить элементы, такие как свойства и методы для записи к усложнению их поведения, полей, сохраненных в записи по-прежнему являются простыми агрегатами значений.</span><span class="sxs-lookup"><span data-stu-id="160ec-191">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="160ec-192">Дополнительные сведения о записях см. в разделе [записи](records.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-192">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="160ec-193">Структуры также могут использоваться для небольших объемов данных, но они отличаются от классов и записей, что они представляют типы значений .NET.</span><span class="sxs-lookup"><span data-stu-id="160ec-193">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="160ec-194">Классы и записи являются ссылочными типами .NET.</span><span class="sxs-lookup"><span data-stu-id="160ec-194">Classes and records are .NET reference types.</span></span> <span data-ttu-id="160ec-195">Семантика типов значений и ссылочных типов отличаются тем, что типы значений передаются по значению.</span><span class="sxs-lookup"><span data-stu-id="160ec-195">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="160ec-196">Это означает, что они копируются бит для бита, при их передача в качестве параметра или возвращаемого функцией.</span><span class="sxs-lookup"><span data-stu-id="160ec-196">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="160ec-197">Они также хранятся в стеке или, если они используются как поле, внедренные в родительский объект, а не хранится в отдельном расположении в куче.</span><span class="sxs-lookup"><span data-stu-id="160ec-197">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="160ec-198">Таким образом структуры подходят для часто используемых данных, при затраты на доступ к куче проблемы.</span><span class="sxs-lookup"><span data-stu-id="160ec-198">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="160ec-199">Дополнительные сведения о структурах см. в разделе [структуры](structures.md).</span><span class="sxs-lookup"><span data-stu-id="160ec-199">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="160ec-200">См. также</span><span class="sxs-lookup"><span data-stu-id="160ec-200">See Also</span></span>
[<span data-ttu-id="160ec-201">Справочник по языку F#</span><span class="sxs-lookup"><span data-stu-id="160ec-201">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="160ec-202">Члены</span><span class="sxs-lookup"><span data-stu-id="160ec-202">Members</span></span>](members/index.md)

[<span data-ttu-id="160ec-203">Наследование</span><span class="sxs-lookup"><span data-stu-id="160ec-203">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="160ec-204">Интерфейсы</span><span class="sxs-lookup"><span data-stu-id="160ec-204">Interfaces</span></span>](interfaces.md)

