---
title: Классы (F#)
description: 'Узнайте, как классов F # — это типы, представляющие объекты, которые могут иметь свойства, методы и события.'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 0bfb45b6481576729bfe8d4bd016fb151757660a
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2018
---
# <a name="classes"></a>Классы

*Классы* — это типы, представляющие объекты, которые могут иметь свойства, методы и события.


## <a name="syntax"></a>Синтаксис

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>Примечания
Классы представляют фундаментальное Описание типов объектов .NET. класс является основной тип концепция, которая поддерживает объектно ориентированное программирование на F #.

Приведенный выше синтаксис `type-name` — любой допустимый идентификатор. `type-params` Описывает необязательные параметры универсального типа. Он состоит из имена параметров типов и ограничений, заключенной в угловые скобки (`<` и `>`). Дополнительные сведения см. в разделе [универсальных шаблонов](generics/index.md) и [ограничения](generics/constraints.md). `parameter-list` Описание параметров конструктора. Первый модификатор доступа относится к типу; Второй относится к первичного конструктора. В обоих случаях значение по умолчанию — `public`.

Укажите базовый класс для класса с помощью `inherit` ключевое слово. Необходимо указать аргументы для конструктора базового класса, в скобках.

Объявления полей или значений, являющихся локальными для класса с помощью функций `let` привязки и необходимо соблюдать общие правила для `let` привязки. `do-bindings` Раздел содержит код, выполняемый при создании объекта.

`member-list` Состоит из дополнительных конструкторов, экземпляр и объявления статических методов, объявления интерфейса, абстрактные привязки и объявления свойств и событий. Они описаны в [элементы](members/index.md).

`identifier` , Используемый с необязательным `as` ключевого слова, указывает имя переменной экземпляра, или собственный идентификатор, который может использоваться для ссылки на экземпляр типа в определении типа. Для получения дополнительной информации обратитесь к разделу идентификаторы Self далее в этом разделе.

Ключевые слова `class` и `end` , отмечающие начало и конец определения являются необязательными.

Взаимно рекурсивные типы, которые являются типами, которые ссылаются друг на друга, объединяются с `and` ключевое слово точно так же, как и взаимно рекурсивные функции. Например в разделе взаимно рекурсивные типы.


## <a name="constructors"></a>Конструкторы
Конструктор — это код, который создает экземпляр типа класса. Конструкторы классов работают иначе в языке F # в других языках .NET. В классе F #, всегда есть главный конструктор, аргументы которого описаны в `parameter-list` , который следует за именем типа и тело которого состоит из `let` (и `let rec`) привязок в начале объявления класса и `do`за ними привязок. Аргументы главного конструктора находятся в области всего объявления класса.

Можно добавить дополнительные конструкторы с помощью `new` ключевое слово для добавления члена, как показано ниже:

`new`(`argument-list`) = `constructor-body`

Тело новый конструктор должен вызвать первичного конструктора, который указан в верхней части объявления класса.

Эта концепция проиллюстрирована в следующем примере. В следующем коде `MyClass` имеет два конструктора: главный конструктор, который принимает два аргумента и другой конструктор без аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a>Let и do-привязки

`let` И `do` привязок в определении класса образуют основную часть главного конструктора, и поэтому они выполняются каждый раз, когда создается экземпляр класса. Если `let` привязки — это функция, то она компилируется в член. Если `let` привязка имеет значение, которое не используется в любой функции или элемента, то она компилируется в переменную, которая является локальной в конструктор. В противном случае она компилируется в поле класса. `do` Выражения компилируются в главный конструктор и выполняют код инициализации для каждого экземпляра. Поскольку все дополнительные конструкторы всегда вызывают главный конструктор `let` привязок и `do` всегда выполняются, независимо от того, что вызов конструктора.

Поля, которые создаются путем `let` привязки можно обращаться через методы и свойства класса; Однако они недоступны из статических методов, даже если статический метод принимает экземпляр переменной в качестве параметра. Они становятся недоступными, используя собственный идентификатор, если он существует.


## <a name="self-identifiers"></a>Собственные идентификаторы

Объект *собственный идентификатор* — имя, которое представляет текущий экземпляр. Собственные идентификаторы подобны `this` ключевого слова в C# или C++ или `Me` в Visual Basic. Можно определить собственный идентификатор двумя различными способами, в зависимости от того, нужно ли собственный идентификатор в области для всего определения класса или просто для отдельного метода.

Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающей скобки параметра конструктора списка и укажите имя идентификатора.

Чтобы определить собственный идентификатор только один метод, укажите собственный идентификатор в объявлении члена непосредственно перед именем метода и точку (.) в качестве разделителя.

В следующем примере кода показано два способа создания собственного идентификатора. В первой строке `as` используется ключевое слово, чтобы определить собственный идентификатор. В пятой строке идентификатор `this` позволяет определить собственный идентификатор, область действия которого ограничивается метод `PrintMessage`.

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

В отличие от других языков .NET, можно назвать собственный идентификатор задать; Вы не ограничены имена таких как `self`, `Me`, или `this`.

Собственный идентификатор, объявленный с `as` ключевое слово не инициализируется до после `let` выполнения привязок. Таким образом, не может использоваться в `let` привязки. Можно использовать собственный идентификатор в `do` разделе привязок.


## <a name="generic-type-parameters"></a>Параметры универсального типа

Указаны параметры универсального типа в угловых скобках (`<` и `>`), в форме одиночные кавычки, а затем по идентификатору. Параметры универсального типа разделяются запятыми. Область действия объявления является параметром универсального типа. В следующем примере кода показано, как задать параметры универсального типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

Типы аргументов определяются при использовании типа. В следующем коде определяемый тип является последовательностью кортежей.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a>Указание наследования

`inherit` Предложение определяет прямой базовый класс, если он существует. В языке F # допускается только один прямой базовый класс. Интерфейсы, реализуемые классом, не считаются базовых классов. Интерфейсы рассматриваются в [интерфейсы](Interfaces.md) раздела.

Вы доступны методы и свойства базового класса из производного класса с помощью ключевого слова языка `base` как идентификатор, за которым следует точка (.) и имя элемента.

Дополнительные сведения см. в разделе [Наследование](inheritance.md).


## <a name="members-section"></a>Раздел членов
В этом разделе, можно определить статический или методов экземпляра, свойства, реализации интерфейса, абстрактные члены, объявления событий и дополнительных конструкторов. Let и привязки не отображаются в этом разделе. Поскольку элементы могут добавляться для различных типов F #, наряду с классами, они рассматриваются в отдельном разделе [элементы](members/index.md).


## <a name="mutually-recursive-types"></a>Взаимно рекурсивные типы
При определении типов, которые ссылаются друг на друга циклически можно передавать вместе определения типов с помощью `and` ключевое слово. `and` Заменяет ключевое слово `type` во всех определениях, кроме первого, как показано ниже.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

Выводится список всех файлов в текущем каталоге.


## <a name="when-to-use-classes-unions-records-and-structures"></a>Когда следует использовать классы, объединения, записи и структуры
Имеется множество различных типов для выбора, необходимо знать о том, что каждый тип предназначены для выберите подходящий тип для конкретной ситуации. Классы предназначены для использования в объектно ориентированного программирования контекстах. Объектно ориентированное программирование является главным парадигме приложений, разработанных для платформы .NET Framework. Если ваш код F # содержит тесно взаимодействовать с .NET Framework или другую библиотеку объектно ориентированного и особенно в том случае, если необходимо расширить систему объектно ориентированного типов, таких как библиотека пользовательского интерфейса, классы, вероятно, подходят.

При отсутствии тесного взаимодействия с объектно ориентированного кода или если вы пишете код, который является самодостаточным и поэтому защищенные от частого взаимодействия с объектно ориентированного кода, то следует рассмотреть возможность использования записи и размеченные объединения. Одно тщательно проработанное размеченного объединения, а также соответствующие шаблоны кода, часто оказывается более простой альтернативой иерархии объектов. Дополнительные сведения о размеченные объединения см. в разделе [размеченные объединения](discriminated-unions.md).

Записи имеют преимущество проще, чем классов, но превышение накладываемые их простотой требования к типу записи не подходят. Записи, по сути простые агрегаты значений без отдельных конструкторов, которые могут выполнять пользовательские действия, без скрытых полей и без реализации наследования и интерфейсов. Несмотря на то, что можно добавить элементы, такие как свойства и методы для записи к усложнению их поведения, полей, сохраненных в записи по-прежнему являются простыми агрегатами значений. Дополнительные сведения о записях см. в разделе [записи](records.md).

Структуры также могут использоваться для небольших объемов данных, но они отличаются от классов и записей, что они представляют типы значений .NET. Классы и записи являются ссылочными типами .NET. Семантика типов значений и ссылочных типов отличаются тем, что типы значений передаются по значению. Это означает, что они копируются бит для бита, при их передача в качестве параметра или возвращаемого функцией. Они также хранятся в стеке или, если они используются как поле, внедренные в родительский объект, а не хранится в отдельном расположении в куче. Таким образом структуры подходят для часто используемых данных, при затраты на доступ к куче проблемы. Дополнительные сведения о структурах см. в разделе [структуры](structures.md).


## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)

[Члены](members/index.md)

[Наследование](inheritance.md)

[Интерфейсы](interfaces.md)

