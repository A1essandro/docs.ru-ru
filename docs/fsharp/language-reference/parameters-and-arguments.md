---
title: Параметры и аргументы (F#)
description: 'Дополнительные сведения о поддержке языка F # для определения параметров и передачи аргументов в функции, методы и свойства.'
ms.date: 05/16/2016
ms.openlocfilehash: 319cf0e7346d498ce34e41a9993fe0160038461a
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566224"
---
# <a name="parameters-and-arguments"></a>Параметры и аргументы

В этом разделе описывается поддержка языком определения параметров и передачи аргументов в функции, методы и свойства. Он содержит сведения о передаче по ссылке и как определять и использовать методы, которые могут принимать переменное число аргументов.


## <a name="parameters-and-arguments"></a>Параметры и аргументы
Термин *параметр* используется для описания имена для значений, которые требуется предоставить. Термин *аргумент* используются значения, предоставляемые для каждого параметра.

Параметры указываются в кортеже или каррированные или некоторое сочетание этих двух. Аргументы можно передать с помощью явно указанного имени параметра. Параметры методов можно объявить необязательным и задано значение по умолчанию.


## <a name="parameter-patterns"></a>Шаблоны параметров
Параметры для функций и методов, как правило, шаблоны, разделяя их пробелами. Это означает, что, в принципе, один из шаблонов, описанных в [выражениях сопоставления](match-expressions.md) можно использовать в списке параметров для функции или члена.

Методы обычно используют кортеже передачи аргументов. Это обеспечивает более четкие результаты с точки зрения других языков .NET, так как в кортеже способ передачи аргументов в методах .NET.

Каррированные чаще всего используется с функциями, созданными с помощью `let` привязки.

Следующий псевдокод отображает примеры кортежа и переданными аргументами.

```fsharp
// Tuple form.
member this.SomeMethod(param1, param2) = ...
// Curried form.
let function1 param1 param2 = ...
```

Комбинированные формы возможны, когда некоторые аргументы имеют кортежей, а некоторые — нет.

```fsharp
let function2 param1 (param2a, param2b) param3 = ...
```

Другие шаблоны могут также использоваться в списках параметров, но если параметр шаблона не соответствует всех возможных входных значений, то возможно неполное соответствие во время выполнения. Исключение `MatchFailureException` генерируется, если значение аргумента не совпадает с шаблонами, указанными в списке параметров. Компилятор выдает предупреждение, если шаблон параметров неполных совпадений. По крайней мере один шаблон часто имеет смысл использовать списки параметров, и это шаблон подстановочного знака. Вы можете использовать этот шаблон в списке параметров, при игнорировать любые аргументы, передаваемые. Следующий код иллюстрирует использование этот шаблон в списке аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3801.fs)]

Этот шаблон может быть полезным, всякий раз, когда нет необходимости аргументы, передаваемые в, как Главная точка входа в программу, если вы не заинтересованы в аргументах командной строки, которые обычно предоставляются в виде строкового массива, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3802.fs)]

Другие шаблоны, которые иногда используются в аргументах, `as` шаблон и идентификатор шаблоны, связанные с размеченные объединения и активные шаблоны. Шаблон размеченного объединения одиночным можно использовать следующим образом.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3803.fs)]

Выходные данные выглядят следующим образом.

```
Data begins at 0 and ends at 4 in string Et tu, Brute?
Et tu
```

Активные шаблоны можно использовать как параметры, например, при преобразовании аргумента в требуемый формат, как показано в следующем примере:

```fsharp
type Point = { x : float; y : float }

let (| Polar |) { x = x; y = y} =
    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )

let radius (Polar(r, _)) = r
let angle (Polar(_, theta)) = theta
```

Можно использовать `as` шаблон для хранения совпадающее значение как локальное значение, как показано в следующей строке кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3805.fs)]

Иногда используется другой шаблон — функция, которая остается имя последнего аргумента, предоставляя в теле функции, лямбда-выражение сразу же выполняет соответствия шаблону неявный аргумент. Примером является следующий код.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3804.fs)]

Этот код определяет функцию, которая принимает универсального списка и возвращает `true` Если список пуст, и `false` в противном случае. Использование таких приемов может сделать код более сложным для восприятия.

В некоторых случаях шаблонов, включающих неполным совпадением полезны, например, если вы знаете, что списки в программе имеют только три элемента, можно использовать шаблон, как показано ниже в списке параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3806.fs)]

Использование шаблонов с неполным совпадением лучше всего зарезервировано для быстрого создания прототипов и других временных задач. Компилятор выдаст предупреждение для такого кода. Такие шаблоны не могут охватывать в общем случае, когда всех возможных входных значений и следовательно, не подходят для компонента API-интерфейсы.

## <a name="named-arguments"></a>Именованные аргументы
Аргументы методов могут указываться по позиции в списке аргументов, разделенных запятыми, или могут быть переданы в метод явно, указав имя, за которым следует знак равенства и значение должны быть переданы в. Если указано, указав имя, они могут отображаться в порядке, отличном от используемого в объявлении.

Именованные аргументы можно сделать код более читаемым и более настраиваться определенные типы изменений в API-Интерфейсе, такие как изменение порядка параметров метода.

Именованные аргументы можно использовать только в методах, не для `let`-связанные функции, значения функции или лямбда-выражения.

В следующем примере кода показано использование именованных аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3807.fs)]

При вызове конструктора класса можно задать значения свойств класса с помощью синтаксиса, аналогичного синтаксису именованных аргументов. В следующем примере показано этот синтаксис.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Дополнительные сведения см. в разделе [конструкторы (F #)](https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05).

## <a name="optional-parameters"></a>Необязательные параметры
Можно указать необязательный параметр для метода, используя знак вопроса перед именем параметра. Необязательные параметры интерпретируются как тип параметра в языке F #, поэтому их можно запрашивать обычным способом, что запрашиваются типы параметров, с помощью `match` выражение с `Some` и `None`. Необязательные параметры можно использовать только для членов, но не для функций, созданных с помощью `let` привязки.

Можно также использовать функцию `defaultArg`, который задает значение по умолчанию для необязательного аргумента. `defaultArg` Функция принимает необязательный параметр в качестве первого аргумента и значение по умолчанию в качестве второго.

Следующий пример иллюстрирует использование необязательных параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3808.fs)]

Выходные данные выглядят следующим образом.

```
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
Baud Rate: 300 Duplex: Half Parity: true
```

## <a name="passing-by-reference"></a>Передача по ссылке
F # поддерживает `byref` ключевое слово, которое указывает, что параметр передается по ссылке. Это означает, что любые изменения значения сохраняются после выполнения функции. Значения, указанные в `byref` параметр должен быть изменяемым. Кроме того можно передавать ссылочные ячейки соответствующего типа.

Передача по ссылке в языках .NET используется как способ возврата более одного значения из функции. В языке F # можно возвращать кортеж для этой цели или использовать в качестве параметра ссылочной ячейки. `byref` Главным образом предназначен для взаимодействия с библиотеками .NET.

Следующие примеры иллюстрируют использование `byref` ключевое слово. Обратите внимание, что при использовании ссылочной ячейки в качестве параметра необходимо создать ссылочную ячейку как именованное значение и использовать его в качестве параметра, не просто добавить `ref` оператора, как показано в первом вызове `Increment` в следующем коде. Поскольку при создании ссылочной ячейки создается копия базового значения, первый вызов увеличивает только временное значение.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3809.fs)]

Кортеж можно использовать в качестве возвращаемого значения для хранения `out` параметрам в методах библиотеки .NET. Кроме того, можно рассматривать `out` параметр как `byref` параметр. В следующем примере кода показаны оба способа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-1/snippet3810.fs)]

## <a name="parameter-arrays"></a>Массивы параметров
Иногда бывает необходимо определить функцию, принимающую произвольное количество параметров различных типов. Не было бы смысл создать все возможные перегруженные методы для учетной записи для всех типов, которые могут использоваться. В реализациях .NET обеспечивают поддержку таких методов за счет функции массивов параметров. Метод, который принимает массив параметров сигнатура может быть указано с произвольным числом параметров. Параметры помещаются в массив. Тип элементов массива определяет типы параметров, которые можно передать в функцию. Если определить массив параметров с `System.Object` как тип элемента, затем клиентский код может передавать значения любого типа.

В F # массивы параметров можно определять только в методах. Их нельзя использовать в отдельных функциях, а также функции, определенные в модулях.

Массив параметров определяются с помощью `ParamArray` атрибута. `ParamArray` Атрибут может применяться только к последнему параметру.

Следующий код иллюстрирует вызов метода .NET, принимающего массив параметров и определение типа в F #, который содержит метод, который принимает массив параметров.

[!code-fsharp[Main](../../../samples/snippets/fsharp/parameters-and-arguments-2/snippet3811.fs)]

При запуске проекта, результат выполнения предыдущего кода выглядит следующим образом:

```
a 1 10 Hello world 1 True
"a"
1
10.0
"Hello world"
1u
true
```

## <a name="see-also"></a>См. также
[Члены](members/index.md)
