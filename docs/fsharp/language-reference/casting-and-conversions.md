---
title: "Приведение и преобразование (F#)"
description: "Узнайте, как на языке программирования F # предоставляет операторы преобразования для преобразования между различными типами-примитивами."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: db30db67-da21-4206-bf0c-9211bd3cb22f
ms.openlocfilehash: f17d3919c59c5881213d28a59cea7ae184493949
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="casting-and-conversions-f"></a>Приведение и преобразование (F#)

В этом разделе описывается поддержка преобразований типов в языке F #.

## <a name="arithmetic-types"></a>Арифметические типы
F # предоставляет операторы преобразования для преобразования между различными типами-примитивами, например между целое число и типы с плавающей запятой. Операторы преобразования целочисленным типом и char проверили и непроверяемые формы; значение с плавающей запятой операторы и `enum` оператор преобразования — нет. Снят флажок формы определяются в `Microsoft.FSharp.Core.Operators` и проверенные формы определяются в `Microsoft.FSharp.Core.Operators.Checked`. Проверяемые на переполнение и создавать исключение времени выполнения, если результирующее значение нарушает ограничения типа целевого объекта.

Каждый из этих операторов имеет имя, совпадающее с именем имя конечного типа. Например, в следующем коде с явно указанными типами слово `byte` имеет два значения. Первое вхождение является типом, а второй — оператор преобразования.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

В следующей таблице показаны операторы преобразования, определенные в языке F #.

|Оператор|Описание|
|--------|-----------|
|`byte`|Преобразуйте в тип byte, 8-разрядного беззнакового типа.|
|`sbyte`|Преобразуйте байт со знаком.|
|`int16`|Преобразуйте в 16-разрядное целое число со знаком.|
|`uint16`|Преобразуйте в 16-разрядное целое число без знака.|
|`int32, int`|Преобразуйте в 32-разрядное целое число со знаком.|
|`uint32`|Преобразуйте в 32-разрядное целое число без знака.|
|`int64`|Преобразуйте в 64-разрядное целое число со знаком.|
|`uint64`|Преобразуйте в 64-разрядное целое число без знака.|
|`nativeint`|Преобразуйте в машинном коде целое число.|
|`unativeint`|Преобразуйте в машинном коде целое число без знака.|
|`float, double`|Преобразование в стандарт IEEE двойной точности 64-разрядное число с плавающей запятой.|
|`float32, single`|Преобразование в стандарт IEEE одинарной точности 32-разрядное число с плавающей запятой.|
|`decimal`|Преобразовать в `System.Decimal`.|
|`char`|Преобразовать в `System.Char`, символ Юникода.|
|`enum`|Преобразуйте в перечисляемый тип.|
Помимо встроенных примитивных типов, эти операторы можно использовать с типами, реализующими `op_Explicit` или `op_Implicit` методы с подходящими сигнатурами. Например `int` оператор преобразования работает с любым типом, который предоставляет статический метод `op_Explicit` , принимает этот тип в качестве параметра и возвращает `int`. В качестве особого исключения из правила, что методы не могут быть перегружены тип возвращаемого значения, это можно сделать `op_Explicit` и `op_Implicit`.

## <a name="enumerated-types"></a>Перечисляемые типы
`enum` Является универсальный оператор, принимающий один параметр типа, представляющий тип `enum` для преобразования. При преобразовании в перечисляемый тип алгоритм определения типа пытается определить тип `enum` , необходимо преобразовать. В следующем примере переменная `col1` не указан явно, но его тип выводится из более поздней версии проверку равенства. Таким образом, компилятор может определить, что перевод `Color` перечисления. Кроме того, можно указывать аннотации типа, как и в `col2` в следующем примере.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]
    
Можно также явно задать целевой тип перечисления как параметр типа, как показано в следующем коде:

```fsharp
let col3 = enum<Color> 3
```

Обратите внимание, что перечисление приводит работы только в том случае, если базовый тип перечисления является совместимым с преобразуемого типа. В следующем коде преобразование вызывает ошибку при компиляции из-за несоответствия между `int32` и `uint32`.

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

Дополнительные сведения см. в разделе [перечисления](enumerations.md).

## <a name="casting-object-types"></a>Приведение типов объектов
Преобразование между типами в иерархии объектов — это основа для объектно ориентированного программирования. Существует два основных типа преобразования: приведение с повышением и приведение с понижением. Приведение с повышением по иерархии означает приведение из производного объекта ссылку на ссылку на базовый объект. Такое приведение будет работать гарантированно при условии, что базовый класс находится в иерархии наследования производного класса. Приведение с понижением по иерархии из базового объекта ссылку на ссылку на объект производного, завершается успешно только в том случае, если объект является экземпляром целевого (производного) типа или типа, производного от типа назначения.

F # предоставляет операторы для этих типах преобразования. `:>` Оператор приводит вверх по иерархии и `:?>` оператор приводит вниз по иерархии.

### <a name="upcasting"></a>Приведение
Во многих языках объектно ориентированного восходящее преобразование происходит неявно; в языке F # правила несколько отличаются. Приведение применяется автоматически при передаче аргументов методов на основе типа объекта. Однако для функций привязки let в модуле, приведение не выполняется автоматически, если тип параметра не объявлена как гибкий тип. Дополнительные сведения см. в разделе [гибкие типы](flexible-Types.md).

`:>` Оператор выполняет статическое приведение, это означает, что успешность приведения определяется во время компиляции. Если приведение с помощью `:>` компиляцию, он является допустимым приведения и имеет вероятность сбоя во время выполнения.

Можно также использовать `upcast` оператор для выполнения такого преобразования. Следующее выражение задает преобразование вверх по иерархии:

```fsharp
upcast expression
```

При использовании оператора приведения с повышением, компилятор пытается определить нужный тип преобразуемых из контекста. Если компилятор не может определить тип объекта, компилятор сообщает об ошибке.

### <a name="downcasting"></a>Приведение
`:?>` Оператор выполняет динамическое приведение, это означает, что успешность приведения определяется во время выполнения. Приведение с помощью `:?>` оператор не проверяется во время компиляции; Однако во время выполнения будет предпринята попытка привести к указанному типу. Если объект совместим с целевым типом, приведение завершается успешно. Если объект не совместим с типом целевого объекта, среда выполнения вызывает `InvalidCastException`.

Можно также использовать `downcast` оператор для преобразования динамического типа. Следующее выражение задает преобразование к типу, определяемому по контексту программы вниз по иерархии:

```fsharp
downcast expression
```

Как для `upcast` оператор, если компилятор не может определить целевой тип из контекста, появляется сообщение об ошибке.

Следующий код иллюстрирует использование `:>` и `:?>` операторы. Код показывает, что `:?>` оператор лучше всего использовать, если известно, преобразование завершится успешно, так как он создает `InvalidCastException` при сбое преобразования. Если вы не знаете, что преобразование будет выполнено успешно, тип теста, который использует `match` выражение лучше, так как позволяет избежать издержек создания исключения.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

Поскольку универсальные операторы `downcast` и `upcast` полагаться на определение типа для определения типа аргументов и возвращаемых в приведенном выше коде, можно заменить

```fsharp
let base1 = d1 :> Base1
```

на

```fsharp
base1 = upcast d1
```

В приведенном выше коде тип аргумента и типы возвращаемых значений являются `Derived1` и `Base1`соответственно.

Дополнительные сведения о тестировании типов см. в разделе [выражениях сопоставления](match-Expressions.md).

## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)
