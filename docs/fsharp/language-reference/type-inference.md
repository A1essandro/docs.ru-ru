---
title: Вывод типа (F#)
description: Узнайте, как компилятор F# определяет типы значений, переменных, параметров и возвращаемых значений.
ms.date: 05/16/2016
ms.openlocfilehash: fd826ac48fb9a70aa6f4ff746599c11b7e21a02e
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "43865700"
---
# <a name="type-inference"></a>Вывод типа

В этом разделе описывается, как компилятор F# определяет типы значений, переменных, параметров и возвращаемых значений.

## <a name="type-inference-in-general"></a>Определение типа в целом

Вывод типа суть в том, что у вас нет для указания типов конструкций F#, за исключением случаев, когда компилятор не может определить тип. Пропуск явные сведения о типах не означает, что F# — динамически типизированный язык, или что значения в языке F# являются нестрого типизированными. F# — это статически типизированный язык, это означает, что компилятор выводит тип точное, для каждой конструкции во время компиляции. Если имеется достаточно информации для компилятору команду выведения типов каждой конструкции, необходимо предоставить дополнительные сведения о типе, обычно путем добавления явные обозначения типов, где-нибудь в коде.

## <a name="inference-of-parameter-and-return-types"></a>Определение параметров и возвращаемых типов

В списке параметров у вас нет для указания типа каждого параметра. И еще, F# является статически типизированным языком, и поэтому каждое значение и выражение имеет определенный тип во время компиляции. Для этих типов, которые явно не указан компилятор выводит тип на основе контекста. Если тип не указан, он определяется как универсальный. Если код использует значение несогласованно, так что нет единственного выведенного типа, который удовлетворяет все случаи использования значения, компилятор сообщает об ошибке.

Тип возвращаемого значения функции определяется типа последнего выражения в функции.

Например, в следующем коде, типы параметров `a` и `b` и тип возвращаемого значения определяется как `int` так как литерал `100` имеет тип `int`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet301.fs)]

Вывод типа, можно изменить, изменив литералы. При внесении `100` `uint32` путем добавления суффикса `u`, типы `a`, `b`, и возвращаемое значение имеют тип `uint32`.

Может также повлиять на определение типа с помощью других конструкций, которые подразумевают ограничения на типы, такие как функции и методы, которые работают с определенным типом.

Кроме того можно применять явные обозначения типов для параметров функции или метода или для переменных в выражениях, как показано в следующих примерах. Если возникают конфликты между различными ограничениями возникать ошибки.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet302.fs)]

Можно явным образом указать возвращаемое значение функции, предоставляя аннотацию типа в конце концов параметры.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet303.fs)]

Распространенный случай, где аннотацию типа полезен для параметра, когда параметр не является типом объекта и вы хотите использовать член.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet304.fs)]

## <a name="automatic-generalization"></a>Автоматическое обобщение

Если код функции не зависит от типа параметра, компилятор считает, что параметр является универсальным. Это называется *Автоматическое обобщение*, и может быть помогать при написании универсального кода без повышения сложности.

Например следующая функция объединяет два параметра любого типа в кортеж.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet305.fs)]

Тип определяется как

```fsharp
'a -> 'b -> 'a * 'b
```

## <a name="additional-information"></a>Дополнительные сведения

Вывод типа описан более подробно в спецификации языка F#.

## <a name="see-also"></a>См. также

- [Автоматическое обобщение](generics/automatic-generalization.md)
