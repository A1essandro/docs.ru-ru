---
title: Расширения типов (F#)
description: 'Узнайте, как расширения типов F # позволяют добавить новые элементы в ранее определенный тип объекта.'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 3399778799fbf0f8eee56e332135656150918a60
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2018
---
# <a name="type-extensions"></a>Расширения типов

Расширения типов позволяют добавлять новые элементы на ранее определенный тип объекта.

## <a name="syntax"></a>Синтаксис

```fsharp
// Intrinsic extension.
type typename with
    member self-identifier.member-name =
        body
    ...
[ end ]

// Optional extension.
type typename with
    member self-identifier.member-name =
        body
    ...
[ end ]
```

## <a name="remarks"></a>Примечания
Существует два вида типов расширений, которые имеют различный синтаксис и поведение. *Встроенное расширение* — это расширение, отображается в том же пространстве имен или модуль, в том же исходном файле и в той же сборки (DLL или исполняемом файле) как расширяемый тип. *Дополнительное расширение* — это расширение, которое находится за пределами исходного модуля, пространства имен или сборке расширяемого типа. Встроенные расширения отображаются на тип, при проверке этого типа с помощью отражения, но дополнительные не. Дополнительное расширение должно содержаться в модулях и они содержат только в области, если модуль, содержащий его модуль открыт.

В предыдущем синтаксисе *typename* представляет тип, который расширяется. Любой тип, который может осуществляться могут быть расширены, но имя типа должно быть фактическое имя типа, не сокращенная форма типа. Можно определить несколько элементов в один тип расширения. *Собственный идентификатор* представляет экземпляр вызываемого объекта, как и обычные элементы.

`end` Ключевое слово является обязательным в упрощенный синтаксис.

Члены, определенные в расширениях типов можно использовать так же, как и других членов в типе класса. Как и другие члены они быть статическим или члены экземпляров. Эти методы также называются *методы расширения*; свойства называются *свойства расширения*, и т. д. Члены дополнительных расширений компилируются на статические члены, для которых экземпляр объекта неявно передается как первый параметр. Тем не менее они работать, как если бы они были экземпляра и статических членов в соответствии с каким образом они объявлены. Неявное расширением элементы включены в качестве членов типа и может использоваться без ограничений.

Методы расширения не может быть виртуальным или абстрактным методам. Они могут перегружать другие методы с тем же именем, но компилятор отдает предпочтение методам без расширения, в случае возникнет Неоднозначный вызов.

Если для одного типа имеется несколько встроенных расширений типа, все члены должны быть уникальными. Для дополнительных расширениях члены различных расширений того же типа могут иметь одинаковые имена. Неоднозначность происходят только в том случае, если код клиента открывает две различные области, определяющие одинаковые имена членов.

В следующем примере тип в модуле с расширением внутреннего типа. Клиентскому коду за пределами модуля расширение типа выглядит как обычный член типа во всех отношениях.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet3701.fs)]

Можно использовать встроенных расширений типа можно разделить определение типа на несколько разделов. Это может быть полезно при управлении большими определениями типов, например, для отделения кода, созданного компилятором и разрабатываемого кода или сгруппировать код, созданный разными людьми или связанные с различные функциональные возможности.

В следующем примере дополнительное расширение типа `System.Int32` типа с методом расширения `FromString` статический член, которая вызывает `Parse`. `testFromString` Метод показывает, что новый член вызывается так же, как и любой другой член экземпляра.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet3702.fs)]

Новый член экземпляра будет отображаться как любой другой метод `Int32` типа в IntelliSense, но только в том случае, если модуль, содержащий расширение находится в открытом или в противном случае в области видимости.

## <a name="generic-extension-methods"></a>Методы расширения
Прежде чем F # 3.1, компилятор F # не поддерживает использование C#-стиля методы расширения с переменной универсального типа, тип массива, тип кортежа или тип функции F #, как параметр «this». 3.1 языка F # поддерживает использование этих элементов расширения.

Например в коде F # 3.1, можно использовать методы расширения с подписями, похожим на следующий синтаксис в C#:

```csharp
static member Method<T>(this T input, T other)
```

Этот подход особенно полезен, если параметр универсального типа ограничен. Кроме того теперь можно объявить члены расширений следующим образом в коде F # и определяют дополнительные, семантически широкий набор методов расширения. В языке F # обычно определяются элементы расширения как показано в следующем примере:

```fsharp
open System.Collections.Generic

type IEnumerable<'T> with
    /// Repeat each element of the sequence n times
    member xs.RepeatElements(n: int) =
        seq { for x in xs do for i in 1 .. n do yield x }
```

Тем не менее для универсального типа, переменная типа может не быть ограничен. Можно объявить C#-расширение элементу стиля в F #, чтобы обойти это ограничение. При объединении этого типа объявления с встроенное средство F # универсальные алгоритмы можно представить как члены расширений.

Рассмотрим следующее объявление:

```fsharp
[<Extension>]
type ExtraCSharpStyleExtensionMethodsInFSharp () =
    [<Extension>]
    static member inline Sum(xs: IEnumerable<'T>) = Seq.sum xs
```

Используя это объявление, можно написать код, подобный приведенному в следующем примере.

```fsharp
let listOfIntegers = [ 1 .. 100 ]
let listOfBigIntegers = [ 1I to 100I ]
let sum1 = listOfIntegers.Sum()
let sum2 = listOfBigIntegers.Sum()
```

В этом коде тот же универсальный код арифметические применяется к спискам два типа без перегрузки, определяя элемент одно расширение.


## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)

[Члены](members/index.md)
