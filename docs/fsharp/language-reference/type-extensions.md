---
title: Расширения типов (F#)
description: Узнайте, как разрешить расширения типов F#, добавлять новые члены в ранее определенный тип объекта.
ms.date: 07/20/2018
ms.openlocfilehash: 27238db1fd0803f62c32755fbc4ab7688f5c107e
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "43874983"
---
# <a name="type-extensions"></a>Расширения типов

Расширения типа (также называется _дополнения_) — это семейство функций, которые позволяют добавлять новые члены в ранее определенный тип объекта. Ниже перечислены три возможности.

* Встроенных расширений типа
* В дополнительных расширениях
* Методы расширения

Каждый может использоваться в различных сценариях и имеет различные компромиссы.

## <a name="syntax"></a>Синтаксис

```fsharp
// Intrinsic and optional extensions
type typename with
    member self-identifier.member-name =
        body
    ...

// Extension methods
open System.Runtime.CompilerServices

[<Extension>]
type Extensions() =
    [static] member self-identifier.extension-name (ty: typename, [args]) =
        body
    ...
```

## <a name="intrinsic-type-extensions"></a>Встроенных расширений типа

Встроенное расширение типа является расширением типа, который расширяет определяемого пользователем типа.

Встроенных расширений типа должен быть определен в том же файле **и** в том же пространстве имен или модуль в качестве типа, они расширяемых. Все другие определения приведет к их, [дополнительных расширениях](type-extensions.md#optional-type-extensions).

Встроенных расширений типа иногда являются более точный способ отделяют функции из объявления типа. В следующем примере показано, как определить встроенное расширение типа:

```fsharp
namespace Example

type Variant =
    | Num of int
    | Str of string
  
module Variant =
    let print v =
        match v with
        | Num n -> printf "Num %d" n
        | Str s -> printf "Str %s" s

// Add a member to Variant as an extension
type Variant with
    member x.Print() = Variant.print x
```

С помощью расширения типа позволяет отделить каждое из перечисленных ниже:

* Объявление `Variant` типа
* Функциональные возможности для печати `Variant` класс в зависимости от его «фигуры»
* Способ доступа к функциональность печати с помощью стиля объекта `.`-нотация

Это является альтернативой для определения всех объектов, как член на `Variant`. Несмотря на то, что он не является по своей сути эффективнее, он может быть очистки представлением функциональные возможности, в некоторых ситуациях.

Встроенных расширений типа компилируются как члены типа, они дополнения и типа отображаются при проверке этого типа с путем отражения.

## <a name="optional-type-extensions"></a>В дополнительных расширениях

Необязательный тип расширения — это расширение, которое находится за пределами исходного модуля, пространства имен или сборке расширяемого типа.

В дополнительных расширениях полезны для расширения типа, который вы не определили самостоятельно. Пример:

```fsharp
module Extensions

open System.Collections.Generic

type IEnumerable<'T> with
    /// Repeat each element of the sequence n times
    member xs.RepeatElements(n: int) =
        seq {
            for x in xs do
                for i in 1 .. n do
                    yield x
        }
```

Теперь вы можете открывать `RepeatElements` как, если он является членом <xref:System.Collections.Generic.IEnumerable%601> , пока `Extensions` модуль открыт в области, в которой вы работаете.

Дополнительные расширения не отображаются в расширенном типе при проверке с помощью отражения. Дополнительное расширение должно содержаться в модулях, и они только в области, когда модуль, содержащий его модуль открыт или область — в противном случае.

Члены дополнительных расширений компилируются в статические члены, для которых экземпляр объекта неявно передается как первый параметр. Тем не менее они действуют как будто они являются членами экземпляра или статические члены в соответствии с, как они определены.

## <a name="generic-limitation-of-intrinsic-and-optional-type-extensions"></a>Ограничение универсального типа встроенных и необязательных расширений

Можно объявить в расширение типа для универсального типа, где переменной типа ограничен. Требование относится, что ограничение объявления расширение соответствует ограничению объявленного типа.

Тем не менее даже в том случае, если ограничения сопоставляются между объявленным типом и расширение типа, это возможно для ограничения могут выводиться в теле расширенный элемент, который накладывает различные требование параметра типа, чем объявленного типа. Пример:

```fsharp
open System.Collections.Generic

// NOT POSSIBLE AND FAILS TO COMPILE!
//
// The member 'Sum' has a different requirement on 'T than the type IEnumerable<'T>
type IEnumerable<'T> with
    member this.Sum() = Seq.sum this
```

Не существует способа получить этот код для работы с расширением необязательный тип:

* Как, `Sum` член имеет различные ограничения `'T` (`static member get_Zero` и `static member (+)`), чем то, что определяет расширение типа.
* Изменение расширения типа иметь такое же ограничение как `Sum` больше не будут соответствовать определенные ограничения на `IEnumerable<'T>`.
* Создание, изменение члена `member inline Sum` вызывает эту ошибку, что ограничения типов совпадают

Что требуется являются статических методов, которые могут быть представлены так, как если бы они расширение типа «float в пространстве». Это, где методы расширения возникает необходимость.

## <a name="extension-methods"></a>Методы расширения

Наконец методы расширения (иногда называется «расширение члены стиля C#») могут быть объявлены в F# метод статический член класса.

Методы расширения полезны для когда нужно определять расширения на универсальный тип, который будет ограничивать тип переменной. Пример:

```fsharp
namespace Extensions

open System.Runtime.CompilerServices

[<Extension>]
type IEnumerableExtensions() =
    [<Extension>]
    static member inline Sum(xs: IEnumerable<'T>) = Seq.sum xs
```

При использовании этого кода поможет вам отображаются так, как если `Sum` определен на <xref:System.Collections.Generic.IEnumerable%601>, при условии что `Extensions` был открыт или находится в области.

## <a name="other-remarks"></a>Другие примечания

Расширения типов также иметь следующие атрибуты:

* Любой тип, который может осуществляться можно расширить.
* Можно определить внутренние и необязательный тип расширения _любой_ тип члена, не только методы. Поэтому свойства расширения возможны также, например.
* `self-identifier` Маркера в [синтаксис](type-extensions.md#syntax) представляет экземпляр типа, вызываемого так же, как обычные элементы.
* Расширенные элементы могут быть статическими или члены экземпляров.
* Переменные типа в расширении типа должны соответствовать ограничениям объявленного типа.

Для расширения типов также имеются следующие ограничения:

* Тип расширения не поддерживают виртуальные и абстрактные методы.
* Тип расширения не поддерживают методы переопределения в качестве дополнения.
* Тип расширения не поддерживают [статически разрешаемые параметры типов](generics/statically-resolved-type-parameters.md).
* Необязательный тип расширения не поддерживают конструкторы в качестве дополнения.
* Расширения типов нельзя определить для [аббревиатуры типов](type-abbreviations.md).
* Тип расширения не являются допустимыми для `byref<'T>` (хотя они могут быть объявлены).
* Расширения типов не допускаются для атрибутов (хотя они могут быть объявлены).
* Можно определять расширения, которые перегружать другие методы с тем же именем, но компилятор F# отдает предпочтение методам, не являющийся расширением методы при возникновении неоднозначного вызова.

Наконец Если для одного типа имеется несколько встроенных расширений типа, все члены должно быть уникальным. Для дополнительных расширениях члены различных расширений типов в тот же тип может иметь одинаковые имена. Ошибок неоднозначности возникают, только в том случае, если код клиента открывает две различные области, определяющие одинаковые имена членов.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Члены](members/index.md)
