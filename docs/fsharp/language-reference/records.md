---
title: Записи (F#)
description: 'Узнайте, как записи F # представляют простые агрегаты именованных значений, Дополнительно с членами.'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 1270bf4eaeba99a15b0f81b5477f4c3b98644f66
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2018
---
# <a name="records"></a>Записи

Записи представляют собой простые агрегаты именованных значений, которые могут иметь элементы.  Начиная с версии 4.1 F #, они могут выступать структуры или ссылочный тип.  Они являются ссылочными типами, по умолчанию.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] typename = {
    [ mutable ] label1 : type1;
    [ mutable ] label2 : type2;
    ...
}
    [ member-list ]
```

## <a name="remarks"></a>Примечания
В предыдущем синтаксисе *typename* — имя типа записи *label1* и *label2* — это имена значений, называют *метки*, и *тип1* и *тип2* типы из следующих значений. *Список членов* — необязательный список членов для типа.  Можно использовать `[<Struct>]` атрибут для создания записи структуры, а не запись, которая является ссылочным типом.

Ниже приведены некоторые примеры.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1901.fs)]

Когда каждая метка находится на отдельной строке, точка с запятой является необязательным.

Можно задать значения в выражениях, называемых *запись выражениях*. Компилятор выводит тип из подписи (если метки в достаточной степени отличаются от других типов записи). Фигурные скобки ({}) заключить выражение записи. Ниже показано выражение записи, инициализирующее запись с тремя элементами с плавающей запятой с метками `x`, `y` и `z`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1907.fs)]

Не используйте сокращенной форме, если может быть другого типа, в которой также совпадают с метками.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1903.fs)]

Метки последнего объявленного типа имеют приоритет над метками ранее объявленного типа, поэтому в предыдущем примере `mypoint3D` определяется как `Point3D`. Можно явно указать тип записи, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1908.fs)]

Методы могут определяться для типов записей, как и в случае типов класса.

## <a name="creating-records-by-using-record-expressions"></a>Создание записей с помощью выражений записей
Записи можно инициализировать с помощью меток, которые определены в записи. Выражение, которое делает это называется *записать выражение*. Используйте фигурные скобки заключите выражения записи и используют в качестве разделителя точку с запятой.

В следующем примере показано, как создать запись.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1904.fs)]

Точка с запятой после последнего поля выражения записи и в определении типа являются необязательными, независимо от того, является ли поля находятся в одной строке.

При создании записи необходимо указать значения для каждого поля. Нельзя ссылаться на значения других полей в выражении инициализации для любого поля.

В следующем коде тип `myRecord2` определяется на основе имен полей. При необходимости можно явно указать имя типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1905.fs)]

Другую форму конструкции записи можно использовать, когда необходимо скопировать существующую запись и при необходимости измените значения полей. Это показано в следующей строке кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1906.fs)]

Эта форма выражения записи называется *копирование и обновление записей выражение*.

Записи являются неизменяемыми по умолчанию; Однако можно легко создать измененные записи с помощью копирования и обновить выражение. Можно также явно указать изменяемого поля.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1909.fs)]

Не используйте атрибут DefaultValue с полями записи. Лучшим подходом является определение экземпляров по умолчанию записи с полями, которые инициализируются значениями по умолчанию, а затем использовать копию и обновления выражения записи, чтобы установить все поля, которые отличаются от значений по умолчанию.

```fsharp
// Rather than use [<DefaultValue>], define a default record.
type MyRecord =
{
    field1 : int
    field2 : int
}

let defaultRecord1 = { field1 = 0; field2 = 0 }
let defaultRecord2 = { field1 = 1; field2 = 25 }

// Use the with keyword to populate only a few chosen fields
// and leave the rest with default values.
let rr3 = { defaultRecord1 with field2 = 42 }
```

## <a name="pattern-matching-with-records"></a>Соответствие шаблону с записями
Записи можно использовать с сопоставлением шаблонов. Можно явно задать некоторые поля и указать переменные, значения для других полей, которые будут назначены при совпадении. Это показано в следующем примере кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1910.fs)]

Результат выполнения этого кода выглядит следующим образом.

```
Point is at the origin.
Point is on the x-axis. Value is 100.000000.
Point is at (10.000000, 0.000000, -1.000000).
```

## <a name="differences-between-records-and-classes"></a>Различия между записями и классами
Поля записей отличаются от классов в том, что они автоматически представляются как свойства, и они используются при создании и копировании записей. Построение записей также отличается от создания класса. В типе записи нельзя определить конструктор. Вместо этого применяется синтаксис конструкции, описанный в этом разделе. Классы не имеют прямых связей между параметрами конструктора, поля и свойства.

Как типы объединения и структуры записи обладают семантикой структурного равенства. Классы имеют ссылки семантику равенства. Это действие представлено в следующем примере кода:

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1911.fs)]

При написании один и тот же код с классами, два объекта класса будут равны, так как два значения будут представлять два объекта в куче и будут сравниваться только адреса (если тип класса не переопределяет `System.Object.Equals` метода).

Если требуется сослаться равенства для записей, добавьте атрибут `[<ReferenceEquality>]` выше записи.

## <a name="see-also"></a>См. также
[Типы языка F#](fsharp-types.md)

[Классы](classes.md)

[Справочник по языку F#](index.md)

[Равенство ссылок](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.referenceequalityattribute-class-%5bfsharp%5d)

[Соответствие шаблону](pattern-matching.md)
