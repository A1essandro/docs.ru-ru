---
title: "Последовательности (F#)"
description: "Узнайте, как использовать F #, при наличии большой упорядоченной коллекции данных, но не планируется обязательное использование всех элементов."
keywords: "visual f#, f#, функциональное программирование"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 23dc7d75-cd26-4df2-9be3-9d1aba5c4443
ms.openlocfilehash: b0562a6efbd2398cd8730bb835a1833955fee1c7
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="sequences"></a>Последовательности

> [!NOTE]
Ссылки на справочник по API в этой статье ведут на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

Объект *последовательности* — это логический ряд элементов одного типа. Последовательностей особенно полезны при наличии большой упорядоченной коллекции данных, но не планируется обязательное использование всех элементов. Отдельные последовательность, в которой элементы вычисляются только при необходимости, поэтому обеспечивает лучшую производительность, чем список в ситуациях, в которых не используются все элементы последовательности. Последовательности представляются `seq<'T>` тип, который является псевдонимом для `System.Collections.Generic.IEnumerable`. Таким образом, любой тип .NET Framework, который реализует `System.IEnumerable` может использоваться как последовательность. [Seq-модуль](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) обеспечивает поддержку операций с последовательностями.

## <a name="sequence-expressions"></a>Выражения последовательности
Объект *последовательности выражений* — это выражение, результатом которого является последовательность. Выражения последовательности могут принимать несколько форм. Самая простая форма указывает диапазон. Например `seq { 1 .. 5 }` создает последовательность, содержащую пять элементов, включая конечные точки 1 и 5. Можно также указать приращение (или уменьшения) между двумя двойными точками. Например следующий код создает последовательность, кратных 10.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

Выражения последовательности состоят из выражений языка F #, возвращающих значения последовательности. Они могут использовать `yield` ключевое слово для получения значений, которые становятся частью последовательности.

Ниже приведен пример.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

Можно использовать `->` оператор вместо `yield`, при этом можно опустить `do` ключевое слово, как показано в следующем примере.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

Следующий код создает список пар координат и индекс в массиве, который представляет сетку.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

`if` Выражение, используемое в последовательности, является фильтром. Например, чтобы создать последовательность простых чисел, при условии, что имеется функция `isprime` типа `int -> bool`, построить последовательность следующим образом.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

При использовании `yield` или `->` во время итерации каждой итерации должен создать единственный элемент последовательности. Если в каждой итерации создается последовательность элементов, используйте `yield!`. В этом случае элементов, созданных в каждой итерации объединяется результирующая последовательность.

Можно использовать несколько выражений вместе в выражении последовательности. Элементы, формируемые каждого выражения объединяются вместе. Например см. в разделе «Примеры» этого раздела.

## <a name="examples"></a>Примеры
В первом примере используется выражение последовательности, содержащий итерации "," Фильтр "и" yield для создания массива. Этот код выводит последовательность простых чисел от 1 до 100 на консоль.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

В следующем коде используется `yield` для создается таблица умножения, состоящий из кортежей из трех элементов, каждый элемент состоит из двух факторов и продукта.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

В следующем примере показано использование `yield!` для объединения нескольких отдельных последовательностей в единую результирующую последовательность. В этом случае в рекурсивной функции, результирующая последовательность объединяются последовательностей в каждом поддереве двоичного дерева.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]
    
## <a name="using-sequences"></a>Использование последовательностей
Последовательности поддерживают многие функции, [перечислены](lists.md). Последовательности также поддерживают операции, такие как Группировка и подсчет с помощью функции создания ключей. Последовательности также поддерживают более сложные функции для извлечения подпоследовательностей.

Многие типы данных, такие как списки, массивы, наборы и карты являются неявно последовательностей, так как они представляют собой перечислимые коллекции. Функция, которая принимает последовательность, так как аргумент работает с любым из распространенных типов данных языка F #, кроме на любой тип данных .NET Framework, который реализует `System.Collections.Generic.IEnumerable<'T>`. Сравните это функции, которая принимает список в качестве аргумента, который может принимать только списки. Тип `seq<'T>` представляет собой сокращенную для `IEnumerable<'T>`. Это означает, что любой тип, реализующий универсальный `System.Collections.Generic.IEnumerable<'T>`, включая массивы, списки, устанавливает и карты в языке F #, а также к большинства типов коллекций .NET Framework, совместимую с `seq` типа и может использоваться везде, где ожидается последовательность.


## <a name="module-functions"></a>Функции модуля
[Seq-модуль](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) в [пространство имен Microsoft.FSharp.Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) содержит функции для работы с последовательностями. Эти функции работают с списков, массивов, схемы и наборы, поскольку эти типы являются перечисляемую и таким образом могут рассматриваться как последовательности.


## <a name="creating-sequences"></a>Создание последовательностей
Можно создать последовательности с помощью выражения последовательности, как описано выше, или с помощью некоторых функций.

Можно создать пустую последовательность, используя [Seq.empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59), или можно создать последовательность всего из одного указанного элемента с помощью [Seq.singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet9.fs)]

Можно использовать [Seq.init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) создать последовательность, элементы которой создаются с помощью функции, который предоставляется. Можно также указать размер для последовательности. Эта функция представляет так же, как [List.init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), за исключением того, что элементы не создаются до итерация по последовательности. Следующий код иллюстрирует использование `Seq.init`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet10.fs)]

Выходные данные:

```
0 10 20 30 40
```

С помощью [Seq.ofArray](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) и [Seq.ofList &#60; " T &#62; Функция](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d), можно создавать последовательности из массивов и списков. Однако можно также преобразовать массивами и списками в последовательности с помощью оператора приведения. В следующем коде показаны оба способа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet11.fs)]

С помощью [Seq.cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334), можно создать последовательность из слабо типизированных коллекций, определенных в `System.Collections`. Такие слабо типизированные коллекции имеют тип элемента `System.Object` и перечисления с помощью неуниверсальные `System.Collections.Generic.IEnumerable&#96;1` типа. Следующий код иллюстрирует использование `Seq.cast` для преобразования `System.Collections.ArrayList` в последовательность.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet12.fs)]

Бесконечные последовательности можно определить с помощью [Seq.initInfinite](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) функции. Для такой последовательности предоставляют функцию, которая создает каждый элемент из индекса элемента. Бесконечные последовательности возможны из-за отложенного вычисления; элементы создаются при необходимости путем вызова функции, указанной вами. В следующем примере кода создается бесконечная последовательность чисел с плавающей запятой, в данном случае чередующихся последовательность обратных величин квадратов последовательных целых чисел.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet13.fs)]

[SEQ.unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) создает последовательность из вычислительной функции, которая принимает состояние и преобразует его для создания каждого последующего элемента в последовательности. Состояние — это значение используется для вычисления каждого элемента, который можно изменить, как каждый элемент является вычисляемым. Второй аргумент `Seq.unfold` начальное значение, которое используется для запуска последовательности. `Seq.unfold`используется тип данных параметра в состояние, которое позволяет завершить последовательность, вернув `None` значение. В следующем коде показано два примера последовательностей, `seq1` и `fib`, которые были созданы путем `unfold` операции. Первый, `seq1`, — это простая последовательность цифр длиной не более 100. Второе, `fib`, использует `unfold` для вычисления последовательности Фибоначчи. Поскольку каждый элемент в последовательности Фибоначчи является суммой двух предыдущих чисел Фибоначчи, значение состояния является кортеж, состоящий из двух предыдущих чисел в последовательности. Начальное значение — `(1,1)`, первые два числа в последовательности.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet14.fs)]

Выходные данные выглядят следующим образом:

```
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

Ниже приведен пример использования большинства функций модуля последовательностей, описанные здесь, для создания и вычисления значений бесконечных последовательностей. Код может занять несколько минут.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet15.fs)]
    
## <a name="searching-and-finding-elements"></a>Поиск и поиск элементов
Последовательности поддерживают функциональные возможности, доступные со списками: [Seq.exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq.exists2](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq.find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq.findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [ SEQ.pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq.tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47), и [Seq.tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a). Версии этих функций, доступные для последовательностей, производят вычисление последовательности только до элемента, на котором выполняется поиск для. Примеры см. в разделе [перечислены](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).


## <a name="obtaining-subsequences"></a>Получение подпоследовательностей
[SEQ.Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) и [Seq.choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) имеют как соответствующие функции, доступные для списков, за исключением того, что фильтрация и выбор вычисления элементов последовательности.

[SEQ.truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) создает последовательность из другой последовательности, но ограничивает ее указанное число элементов. [SEQ.Take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) создает новую последовательность, содержащую только заданное число элементов с начала последовательности. Если в последовательности меньше элементов, чем задано для получения, `Seq.take` вызывает `System.InvalidOperationException`. Разница между `Seq.take` и `Seq.truncate` является то, что `Seq.truncate` сообщает об ошибке, если количество элементов меньше указать.

В следующем коде показано, каким образом и различия между `Seq.truncate` и `Seq.take`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet16.fs)]

Выходные данные, прежде чем произойдет ошибка, будет следующим.

```
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100
```

С помощью [Seq.takeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92), можно указать функцию предиката (логическую функцию) и создать последовательность из другой последовательности, состоящую из тех элементов исходной последовательности, для которых предикат имеет `true`, прерывающуюся Перед первым элементом, для которого предикат возвращает `false`. [SEQ.Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) возвращает последовательность, которая пропускает указанного числа первых элементов другой последовательности и возвращает остальные элементы. [Seq.skipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) возвращает последовательность, которая пропускает первые элементы другой последовательности, при условии, что предикат возвращает `true`, а затем возвращает оставшиеся элементы, начиная с первого элемента, для которого предикат возвращает `false`.

В следующем примере кода демонстрируется поведение и различия между `Seq.takeWhile`, `Seq.skip`, и `Seq.skipWhile`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet17.fs)]

Выходные данные выглядят следующим образом.

```
1 4 9 
36 49 64 81 100 
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a>Преобразование последовательностей
[SEQ.pairwise](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) создает новую последовательность, в которой последовательные элементы входной последовательности группируются в кортежи.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet18.fs)]

[SEQ.windowed](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) подобно `Seq.pairwise`, за исключением того, что вместо создания последовательности кортежей, она создает последовательность массивов, содержащую копии соседних элементов ( *окна*) из последовательности. Количество соседних элементов, которые нужно указать в каждом массиве.

В следующем коде показано использование функции `Seq.windowed`. В этом случае количество элементов в окне равно 3. В примере используется `printSeq`, которая определена в предыдущем примере кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet180.fs)]

Выходные данные выглядят следующим образом.

Начальная последовательность:

```
1.0 1.5 2.0 1.5 1.0 1.5 

Windows of length 3: 
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|] 

Moving average: 
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a>Операции с несколькими последовательностями
[SEQ.ZIP](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) и [Seq.zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) принимают два или три последовательности и создают последовательность кортежей. Эти функции аналогичны соответствующим функциям для [перечислены](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d). Соответствующие функции для разделения одной последовательности на две или более последовательности отсутствуют. Если эта функция необходима для последовательности, преобразуйте ее в список и использовать [List.unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).


## <a name="sorting-comparing-and-grouping"></a>Сортировка, сравнение и группирование
Функции сортировки, поддерживаемые для списков также работают с последовательностями. Сюда входят [Seq.sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) и [Seq.sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f). Эти функции выполняют перебор всей последовательности.

Сравнение двух последовательностей с использованием [Seq.compareWith](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) функции. Функция сравнивает соседних элементов, в свою очередь и останавливается при обнаружении первой несовпадающей пары. Любые дополнительные элементы не влияют на сравнение.

В следующем коде показано использование `Seq.compareWith`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet19.fs)]

В приведенном выше коде вычисляется и проверяется только первый элемент, и возвращается результат-1.

[Seq.countBy](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) принимает функцию, которая создает значение с именем *ключ* для каждого элемента. Ключ создается для каждого элемента путем вызова этой функции для каждого элемента. `Seq.countBy`Возвращает последовательность, которая содержит значения ключей и количество элементов, которые создаются для каждого значения ключа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet201.fs)]

Выходные данные выглядят следующим образом.

```
(1, 34) (2, 33) (0, 33)
```

Предыдущие выходные данные показывают, что 34 элемента исходной последовательности дают значение ключа 1, 33 значения, которые дают значение ключа 2 и 33 дают значение ключа 0.

Элементы последовательности можно сгруппировать, вызвав [Seq.groupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd). `Seq.groupBy`принимает последовательность и функцию, которая создает ключ для элемента. Функция выполняется для каждого элемента последовательности. `Seq.groupBy`Возвращает последовательность кортежей, в которой первый элемент каждого кортежа является ключом, а второй — последовательность элементов, которые создают этот ключ.

В следующем примере кода показано использование `Seq.groupBy` для разбиения последовательности чисел от 1 до 100 на три группы, которые имеют уникальные значения ключей 0, 1 и 2.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet202.fs)]

Выходные данные выглядят следующим образом.

```
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

Можно создать последовательность, которая удаляет повторяющиеся элементы путем вызова [Seq.distinct](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401). Или можно использовать [Seq.distinctBy](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), который использует функцию генерации ключа к вызывается для каждого элемента. Результирующая последовательность содержит элементы исходной последовательности, имеющие уникальные ключи; последующие элементы, дающие повторяющийся ключ с элементом более ранних, не учитываются.

В следующем примере кода показано использование `Seq.distinct`. `Seq.distinct`демонстрируется создание последовательностей, представляющих двоичные числа, а затем демонстрируется, что только различающиеся элементы которой являются 0 и 1.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet22.fs)]

В следующем коде показано `Seq.distinctBy` , начиная с последовательность, которая содержит отрицательных и положительных чисел и используя функцию абсолютного значения функцию генерации ключа. Результирующая последовательность отсутствует положительные числа, соответствующие отрицательные числа в последовательности, так как отрицательные числа отображаются ранее в последовательности и таким образом выбраны вместо положительные числа, которые имеют одинаковые абсолютное значение, или ключ.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet23.fs)]
    
## <a name="readonly-and-cached-sequences"></a>Только для чтения и кэшированные последовательности
[SEQ.ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) создает копию последовательности, доступную только для чтения. `Seq.readonly`полезно, когда имеется коллекция чтения и записи, такие как массив, и вы не хотите изменять исходную коллекцию. Эта функция может использоваться для сохранения инкапсуляции данных. В следующем примере кода создается тип, содержащий массив. Свойство предоставляет массив, но вместо возвращения массива, он возвращает последовательность, которая создается из массива с помощью `Seq.readonly`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/fssequences/snippet24.fs)]

[SEQ.Cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) создает сохраненную версию последовательности. Использовать `Seq.cache` Чтобы избежать повторного вычисления последовательности или при наличии нескольких потоков последовательность, но необходимо убедиться, что каждый элемент применялась только один раз. При наличии последовательности, который используется несколько потоков, может иметь один поток, который выполняет перечисление и вычисление значений исходной последовательности, а остальные потоки могут использовать кэшированную последовательность.


## <a name="performing-computations-on-sequences"></a>Вычисления с последовательностями
Простые арифметические операции, таких как списки, такие как [Seq.average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq.sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq.averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq.sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1), и т. д.

[SEQ.fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq.reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9), и [Seq.scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) имеют как соответствующие функции, которые доступны для списков. Последовательности поддерживают подмножество полной варианты этих функций, поддерживаемых списками. Дополнительные сведения и примеры см. в разделе [перечислены](lists.md).

## <a name="see-also"></a>См. также
[Справочник по языку F#](index.md)

[Типы языка F#](fsharp-types.md)
