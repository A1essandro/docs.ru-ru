---
title: Работа с LINQ
description: В этом руководстве мы научим вас создавать последовательности с помощью LINQ, создавать методы для использования в запросах LINQ, а также различать упреждающее и отложенное вычисление.
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 03/28/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0db12548-82cb-4903-ac88-13103d70aa77
ms.openlocfilehash: c5720d5391eec327aa2f885fd65579aeb6260488
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2018
---
# <a name="working-with-linq"></a>Работа с LINQ

## <a name="introduction"></a>Вступление

Это руководство раскроет для вас некоторые возможности .NET Core и языка C#. Вы узнаете:

*   как создать последовательности с помощью LINQ;
*   как написать методы, которые можно применять в запросах LINQ;
*   как различать упреждающее и отложенное вычисление.

Вы освоите эти методы на примере приложения, которое демонстрирует один из основных навыков любого иллюзиониста: [тасовка по методу фаро](https://en.wikipedia.org/wiki/Faro_shuffle). Так называют метод тасовки, при котором колода делится ровно на две части, а затем собирается заново так, что карты из каждой половины следуют строго поочередно.

Этот метод очень удобен для иллюзионистов, поскольку положение каждой карты после каждой тасовки точно известно, и через несколько циклов порядок карт восстанавливается. 

Здесь же мы используем его в качестве не слишком серьезного примера для процессов управления последовательностями данных. Приложение, которое вы создадите, будет моделировать колоду карт и выполнять для них серию тасовок, выводя новый порядок карт после каждой из них. Вы сможете сравнить новый порядок карт с исходным.

Это руководство описывает несколько шагов. После каждого из них вы сможете запустить приложение и оценить результаты. [Готовый пример](https://github.com/dotnet/docs/blob/master/samples/csharp/getting-started/console-linq) доступен в репозитории dotnet/docs на сайте GitHub. Инструкции по загрузке см. в разделе [Просмотр и скачивание примеров](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).

## <a name="prerequisites"></a>Предварительные требования

Компьютер должен быть настроен для выполнения .NET Core. Инструкции по установке см. на странице [.NET Core](https://www.microsoft.com/net/core). Это приложение можно запустить в ОС Windows, Ubuntu Linux, OS X или в контейнере Docker. Вам потребуется редактор кода, но вы можете выбрать любой привычный для вас. В примерах ниже используется кроссплатформенный редактор [Visual Studio Code](https://code.visualstudio.com/) с открытым исходным кодом. Вы можете заменить его на любое другое средство, с которым вам удобно работать.

## <a name="create-the-application"></a>Создание приложения

Первым шагом является создание нового приложения. Откройте командную строку и создайте новый каталог для приложения. Перейдите в этот каталог. В командной строке введите команду `dotnet new console`. Эта команда создает начальный набор файлов для базового приложения Hello World.

Если вы раньше никогда не работали с C#, изучите структуру программы C# по [этому руководству](console-teleprompter.md). Мы рекомендуем сначала ознакомиться с ним, а затем вернуться сюда и продолжить изучение LINQ. 

## <a name="creating-the-data-set"></a>Создание набора данных

Первым делом мы создадим колоду карт. В этом вам поможет запрос LINQ по двум источникам (один для четырех мастей и второй для тринадцати достоинств). Эти источники объединяются в колоду из 52 карт. Инструкция `Console.WriteLine` в цикле `foreach` отображает карты.

Этот запрос выглядит так:

```csharp
var startingDeck = from s in Suits()
                   from r in Ranks()
                   select new { Suit = s, Rank = r };

foreach (var c in startingDeck)
{
    Console.WriteLine(c);
}
```

Несколько выражений `from` создают запрос `SelectMany`, который формирует одну последовательность из сочетаний каждого элемента первой последовательности с каждым элементом второй последовательности. Для нашего примера важен порядок последовательности. Первый элемент первой последовательности (масти) поочередно сочетается с каждым элементом второй последовательности (достоинства). В итоге мы получаем все тринадцать карт первой масти. Этот процесс повторяется для каждого элемента первой последовательности (масти). Конечным результатом является колода карт, упорядоченная сначала по мастям, а затем по достоинствам.

Теперь нам нужно создать методы Suits() и Ranks(). Начнем мы с самых простых *методов итератора*, которые создают последовательность в виде перечисления строк:

```csharp
static IEnumerable<string> Suits()
{
    yield return "clubs";
    yield return "diamonds";
    yield return "hearts";
    yield return "spades";
}

static IEnumerable<string> Ranks()
{
    yield return "two";
    yield return "three";
    yield return "four";
    yield return "five";
    yield return "six";
    yield return "seven";
    yield return "eight";
    yield return "nine";
    yield return "ten";
    yield return "jack";
    yield return "queen";
    yield return "king";
    yield return "ace";
}
```

Оба эти два метода используют синтаксис `yield return`, создавая последовательность по мере выполнения. Компилятор создаст объект, который реализует интерфейс `IEnumerable<T>`, и сохранит в него последовательность строк по мере их получения.

Теперь давайте выполним пример, который вы создали к этому моменту. Он отобразит все 52 карты колоды. Возможно, вам будет интересно выполнить этот пример в отладчике и проследить за выполнением методов `Suits()` и `Values()`. Вы сможете заметить, что каждая строка в каждой последовательности создается только по мере необходимости.

![Окно консоли с приложением, которое выводит 52 карты](./media/working-with-linq/console.png)

## <a name="manipulating-the-order"></a>Управление порядком

Теперь мы создадим служебный метод, который выполняет тасовку. Сначала он разделит нашу колоду на две части. Эту возможность нам предоставят методы `Take()` и `Skip()`, входящие в интерфейсы API LINQ:

```csharp
var top = startingDeck.Take(26);
var bottom = startingDeck.Skip(26);
```

Метод для тасовки не реализован в стандартной библиотеке, поэтому вам нужно написать собственный. Этот новый метод использует несколько приемов, которые часто нужны в приложениях LINQ. Сейчас мы по порядку объясним вам каждый элемент этого метода.

Сигнатура этого метода создает *метод расширения*:

```csharp
public static IEnumerable<T> InterleaveSequenceWith<T>
    (this IEnumerable<T> first, IEnumerable<T> second)
```

Метод расширения представляет собой специализированный *статический метод.* Как вы видите, для первого аргумента этого метода добавлен модификатор `this`. Это означает, что метод вызывается так, как если бы он был методом-членом и имел тип, указанный для первого аргумента.

Методы расширения можно объявлять только внутри классов `static`, поэтому нам нужен новый статический класс с именем `extensions`. При дальнейшей работе с этим руководством вы будете добавлять дополнительные методы, помещая их в этот же класс.

Такое объявление методов соответствует стандартному принципу, по которому для входа и выхода используется тип `IEnumerable<T>`. Такая практика позволяет объединять методы LINQ в цепочку, чтобы создавать более сложные запросы.

```csharp
using System.Collections.Generic;

namespace LinqFaroShuffle
{
    public static class Extensions
    {
        public static IEnumerable<T> InterleaveSequenceWith<T>
            (this IEnumerable<T> first, IEnumerable<T> second)
        {
            // implementation coming.
        }
    }
}
```

Затем следует одновременно выполнить перечисление обоих последовательностей, поочередно помещая элементы в объединенный объект.  Чтобы создать метод LINQ, который работает с двумя последовательностями, важно хорошо понимать принципы работы `IEnumerable`.

Интерфейс `IEnumerable` содержит один метод: `GetEnumerator()`. Этот метод `GetEnumerator()` возвращает объект, у которого есть метод для перехода к следующему элементу и свойство, которое возвращает текущий элемент в последовательности. С помощью этих двух членов вы выполните перебор всей коллекции и получение элементов. Метод Interleave будет реализован как метод итератора, поэтому вы не будете создавать и возвращать коллекцию, а примените описанный выше синтаксис `yield return`. 

Так выглядит реализация этого метода:

[!CODE-csharp[InterleaveSequenceWith](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet1)]

Теперь, добавив в проект этот метод, вернитесь к методу `Main` и один раз перетасуйте колоду:

```csharp
public static void Main(string[] args)
{
    var startingDeck = from s in Suits()
                       from r in Ranks()
                       select new { Suit = s, Rank = r };

    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
        
    var top = startingDeck.Take(26);
    var bottom = startingDeck.Skip(26);
    var shuffle = top.InterleaveSequenceWith(bottom);

    foreach (var c in shuffle)
    {
        Console.WriteLine(c);
    }
}
```

## <a name="comparisons"></a>Сравнения

Давайте посмотрим, через сколько тасовок колода снова соберется в исходном порядке. Для этого вам нужен метод, который проверяет равенство двух последовательностей. Создав такой метод, вы поместите код тасовки колоды в цикл, в котором будете проверять, расположены ли карты в правильном порядке.

Метод, который сравнивает две последовательности, будет очень простым. По структуре он похож на метод, который мы создали для тасовки колоды. Но теперь вместо команды yield return, которая возвращает элементы, вы будете сравнивать элементы каждой последовательности. Если перечисление последовательности завершилось и все элементы попарно совпадают, то последовательности считаются одинаковыми:

[!CODE-csharp[SequenceEquals](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet2)]

Здесь мы видим в действии второй принцип Linq: терминальные методы. Они принимают последовательность в качестве входных данных (или две последовательности, как в нашем примере) и возвращают скалярное значение. Если вы используете такой метод, он должен быть последним методом в запросе. (Поэтому они так и называются.) 

Этот принцип мы применяем при определении того, находится ли колода в исходном порядке. Поместите код тасовки в цикл, который будет останавливаться в том случае, когда порядок последовательности восстановлен. Для проверки примените метод `SequenceEquals()`. Как вы уже поняли, этот метод всегда будет последним в любом запросе, поскольку он возвращает одиночное значение, а не последовательность:

```csharp
var times = 0;
var shuffle = startingDeck;

do
{
    shuffle = shuffle.Take(26).InterleaveSequenceWith(shuffle.Skip(26));

    foreach (var c in shuffle)
    {
        Console.WriteLine(c);
    }

    Console.WriteLine();
    times++;
} while (!startingDeck.SequenceEquals(shuffle));

Console.WriteLine(times);
```

Запустите пример и следите, как изменяется порядок карт при каждой тасовке. Уже после 8 итераций восстанавливается исходный порядок колоды.

## <a name="optimizations"></a>Оптимизация

Пример, который вы создали к этому моменту, выполняет *внешнюю тасовку*, то есть первая и последняя карты колоды сохраняют свои позиции после каждой итерации. Давайте внесем одно изменение, чтобы реализовать *внутреннюю тасовку*, при которой все 52 карты изменяют свои позиции. Для этого колоду нужно собирать так, чтобы первой картой в колоде стала первая карта из нижней половины. Тогда самой нижней картой станет последняя карта из верхней половины колоды. Нам нужно изменить всего одну строку. Измените вызов тасовки, поменяв местами нижнюю и верхнюю половины колоды.

```csharp
shuffle = shuffle.Skip(26).InterleaveSequenceWith(shuffle.Take(26));
```

Снова запустите программу, и вы увидите, что для восстановления исходного порядка теперь требуется 52 итерации. Также вы могли обратить внимание, что по мере выполнения программы она заметным образом замедляется.

Для этого есть сразу несколько причин. Для начала мы рассмотрим одну из самых существенных — неэффективное использование *отложенного вычисления*.

LINQ запросы обрабатываются отложенным образом. Последовательности создаются только тогда, когда происходит обращение к их элементам. Обычно это дает LINQ огромное преимущество. Но в некоторых программах, таких как в нашем примере, это приводит к экспоненциальному росту времени выполнения.

Исходная колода было создана с помощью запроса LINQ. Каждая последующая тасовка выполняет три запроса LINQ к колоде, полученной на предыдущем этапе. И все эти запросы выполняются отложенно. В частности, это означает, что запросы выполняются каждый раз при обращении к последовательности. Таким образом, пока вы доберетесь до 52-й итерации, исходная колода будет заново создана очень много раз. Чтобы наглядно это продемонстрировать, давайте создадим журнал выполнения. Затем вы исправите эту проблему.

Вот метод ведения журнала, который можно добавить к любому запросу, чтобы зафиксировать его выполнение.

[!CODE-csharp[LogQuery](../../../samples/csharp/getting-started/console-linq/extensions.cs?name=snippet3)]

Теперь давайте дополним определение каждого запроса сообщением для журнала:

```csharp
public static void Main(string[] args)
{
    var startingDeck = (from s in Suits().LogQuery("Suit Generation")
                        from r in Ranks().LogQuery("Rank Generation")
                        select new { Suit = s, Rank = r }).LogQuery("Starting Deck");

    foreach (var c in startingDeck)
    {
        Console.WriteLine(c);
    }
        
    Console.WriteLine();
    var times = 0;
    var shuffle = startingDeck;

    do
    {
        /*
        shuffle = shuffle.Take(26)
            .LogQuery("Top Half")
            .InterleaveSequenceWith(shuffle.Skip(26)
            .LogQuery("Bottom Half"))
            .LogQuery("Shuffle");
        */

        shuffle = shuffle.Skip(26)
            .LogQuery("Bottom Half")
            .InterleaveSequenceWith(shuffle.Take(26).LogQuery("Top Half"))
            .LogQuery("Shuffle");

        foreach (var c in shuffle)
        {
            Console.WriteLine(c);
        }

        times++;
        Console.WriteLine(times);
    } while (!startingDeck.SequenceEquals(shuffle));

    Console.WriteLine(times);
}
```

Обратите внимание, что запись в журнал не нужно выполнять при обращении к запросу. Она выполняется только при создании исходного запроса. Программа по-прежнему работает очень долго, но теперь вы хорошо видите, почему. Если у вас не хватит терпения выполнять внутреннюю тасовку фаро с ведением журнала, переключите программу обратно на внешнюю тасовку. На ней вы также заметите влияние отложенного вычисления. За один запуск программа выполняет 2592 запроса, если учитывать все создания мастей и достоинств.

Есть очень простой способ изменить программу так, чтобы избежать лишних выполнений. Методы LINQ `ToArray()` и `ToList()` позволяют выполнить запрос и сохранить результаты в массив или список, соответственно. Используйте эти методы, чтобы результаты запроса кэшировались, а не создавались заново каждый раз.  К запросам, которые формируют колоды карт, добавьте вызов `ToArray()` и снова запустите запрос:

[!CODE-csharp[Main](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet1)]

При запуске такой программы с внешней тасовкой выполняется всего 30 запросов. Переключите программу на внутреннюю тасовку, и вы заметите аналогичное улучшение. (Теперь она выполняет 162 запроса.)

Но не стоит на основании этого примера делать вывод, что все запросы должны выполняться упреждающе. Этот пример лишь демонстрирует отдельный случай, в котором отложенное вычисление приводит к проблемам с производительностью. Это связано с тем, что каждое новое расположение карт вычисляется на основе предыдущего расположения. Использование отложенного вычисления означает, что каждое расположение колоды строится с самого начала, из исходной колоды, включая вызов кода для создания `startingDeck`. Это создает огромный объем дополнительной работы. 

На практике некоторые алгоритмы работают намного быстрее с упреждающим вычислением, а другие лучше выполняются с отложенным вычислением. (Обычно отложенное вычисление дает более хороший результат, если в качестве источника данных используется отдельный процесс, например база данных. Тогда отложенное вычисление позволяет сложным запросам выполнять только один цикл обращения к процессу базы данных.) LINQ поддерживает как упреждающее, так и отложенное вычисление. Проведите тесты и выберите тот вариант, который даст лучшие результаты.

## <a name="preparing-for-new-features"></a>Подготовка новых функций

Код, который вы написали при изучении этого руководства, служит хорошим примером создания простого прототипа для выполнения работы. Это отличный способ для изучения проблемы, а для многих задач он предоставит оптимальное долгосрочное решение. Вы применили *анонимные типы* для карт, каждая из которых была представлена строковым значением.

*Анонимные типы* дают много преимуществ для производительности. Вам не нужно самостоятельно определять класс, представляющий хранилище. Компилятор создает для вас нужный тип. Тип, созданный компилятором, использует многие современные рекомендации по работе с простыми объектами данных. Он будет *неизменяемым*, то есть ни одно из его свойств нельзя изменить после создания. Анонимные типы являются внутренними для сборки, поэтому они не считаются частью открытого API для этой сборки. Также анонимные типы переопределяют метод `ToString()`, который возвращает форматированную строку с каждым из значений.

Но у анонимных типов есть и недостатки. Они не имеют описательных имен, поэтому их нельзя использовать в качестве возвращаемых значений или аргументов. Возможно, вы обратили внимание, что анонимные типы использовались выше только в универсальных методах. По мере роста приложения и добавления новых функций вас перестанет устраивать переопределение метода `ToString()`. 

Также в этом примере используются строки для представления мастей и достоинств каждой карты. Это слишком многовариантный формат. Система типов C# позволяет улучшить код, используя для таких значений типы `enum`.

Сначала займемся мастями. Самое время применить для них `enum`:

[!CODE-csharp[Suit enum](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet2)]

Для метода `Suits()` также изменится тип и реализация:

[!CODE-csharp[Suit IEnumerable](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet4)]

Затем выполните те же изменения для достоинства карт:

[!CODE-csharp[Rank enum](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet3)]

И для метода, который их создает:

[!CODE-csharp[Rank IEnumerable](../../../samples/csharp/getting-started/console-linq/Program.cs?name=snippet5)]

В качестве финального штриха давайте создадим тип для представления карты, не полагаясь на анонимный тип. Анонимные типы отлично подходят для упрощенных решений и локальных типов, но в нашем примере игральная карта является одним из главных понятий. Она должно быть представлена конкретным типом.

[!CODE-csharp[PlayingCard](../../../samples/csharp/getting-started/console-linq/playingcard.cs?name=snippet1)]

Этот тип использует *автоматически реализуемые свойства только для чтения*, которые устанавливаются в конструкторе и более не могут изменяться. Также в нем используется функция [интерполяции строк](../language-reference/tokens/interpolated.md), которая упрощает форматирование строкового вывода.

Измените запрос, который создает начальную колоду, с учетом нового типа:

```csharp
var startingDeck = (from s in Suits().LogQuery("Suit Generation")
                    from r in Ranks().LogQuery("Value Generation")
                    select new PlayingCard(s, r))
                    .LogQuery("Starting Deck")
                    .ToArray();
```

Скомпилируйте и запустите программу. Выходные данные стали несколько чище, а код намного лучше читается и хорошо поддается расширению.

## <a name="conclusion"></a>Заключение

В этом примере мы продемонстрировали вам некоторые методы, используемые в запросах LINQ. Также вы узнали, как создать собственные методы и легко использовать их в коде с поддержкой LINQ. Мы наглядно продемонстрировали различия между упреждающим и отложенным вычислением, а также потенциальное влияние этого выбора на производительность.

И теперь вы знаете чуть больше о приемах иллюзионистов. Они используют тасовку по методу фаро, потому что она позволяет хорошо контролировать положение каждой карты в колоде. В некоторых фокусах иллюзионист предлагает зрителю положить карту на верх колоды и спокойно тасует колоду несколько раз, при этом точно зная, где эта карта окажется. Для других фокусов может понадобиться колода, сложенная в определенном порядке. Тогда иллюзионист заранее готовит колоду перед выполнением фокуса. Затем он выполняет 5 внешних тасовок фаро. После этого на сцене он демонстрирует зрителям колоду, порядок карт в которой выглядит случайным, выполняет еще 3 внешних тасовки фаро, и колода принимает необходимое состояние.
