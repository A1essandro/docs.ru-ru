### YamlMime:Tutorial
title: <span data-ttu-id="9e595-101">Изучите C# 7.0 — интерактивный учебник по C#</span><span class="sxs-lookup"><span data-stu-id="9e595-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: Изучите C# 7.0 — испытайте новые возможности C# 7.0 в интерактивном режиме с помощью браузера
  description: В этом руководстве для интерактивного изучения C# 7.0 используется браузер. Изучите новые идиомы, которые можно использовать с C# 7.0; они делают код более кратким и удобочитаемым.
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 70f4e93460c69b54702f160d502163827ec73218
  ms.sourcegitcommit: 0aca6c5d166d7961a1e354c248495645b97a1dc5
  ms.translationtype: HT
  ms.contentlocale: ru-RU
  ms.lasthandoff: 03/30/2019
  ms.locfileid: "58675527"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="9e595-105">Это руководство поможет в интерактивном изучении C# 7.0. С помощью браузера вы напишете код на C# и сможете просмотреть результаты его компиляции и выполнения.</span><span class="sxs-lookup"><span data-stu-id="9e595-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="9e595-106">Оно содержит ряд уроков, которые заменят более ранние рекомендации по C# на более новые и краткие возможности C# 7.0.</span><span class="sxs-lookup"><span data-stu-id="9e595-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="9e595-107">В оставшейся части этой статьи приведены общие сведения о каждой из этих функций со ссылкой для изучения каждого компонента.</span><span class="sxs-lookup"><span data-stu-id="9e595-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="9e595-108">Объявления исходящих переменных в месте назначения</span><span class="sxs-lookup"><span data-stu-id="9e595-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"9e595-109\">Существующий синтаксис, поддерживающий параметры `out`, в этой версии был улучшен.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"9e595-110\">Нажмите кнопку *Войти в режим фокусировки*, расположенную в нижней части этой страницы, а затем запустите этот код в интерактивном окне:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"9e595-111\">Переменные `out` можно объявлять в списке аргументов в вызове метода, не записывая отдельный оператор объявления:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"9e595-112\">Объявление можно переместить в вызов метода.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"9e595-113\">Добавьте следующий код в нижней части интерактивного окна:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"9e595-114\">Вы можете заменить объявление `int` на объявление `var`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"9e595-115\">Добавьте приведенный ниже код в интерактивном окне.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"9e595-116\">Новый синтаксис дает два важных преимущества по сравнению с существующим:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"9e595-117\">Код проще читать.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"9e595-118\">Переменная out объявляется при использовании, а не в другой, вышестоящей строке.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"9e595-119\">Назначать начальное значение не нужно.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"9e595-120\">Объявляя переменную `out`, когда она используется при вызове метода, ее нельзя случайно использовать прежде, чем она будет назначена.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"9e595-121\">Область видимости объявленной переменной является областью, в которой стоит инструкция `if`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"9e595-122\">Это позволяет использовать переменную позднее.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"9e595-123\">Замените последний блок `if`, как показано в следующем фрагменте.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="9e595-124">Кортежи — облегченные структуры данных</span><span class="sxs-lookup"><span data-stu-id="9e595-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"9e595-125\">Кортежи — это упрощенные структуры данных, содержащие несколько полей для представления элементов данных.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"9e595-126\">Поля не проверяются, и собственные методы определять невозможно.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"9e595-127\">Кортежи существовали и в версиях C#, предшествовавших версии 7.0, но были неэффективны и не имели языковой поддержки.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"9e595-128\">Это означает, что ссылки на элементы кортежа можно было задавать только в виде `Item1`, `Item2` и т. д.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"9e595-129\">В C# 7.0 реализуется языковая поддержка кортежей, что позволяет работать с семантическими именами полей кортежа с использованием новых, более эффективных типов кортежей.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"9e595-130\">Чтобы создать кортеж, назначьте значение каждому именованному элементу:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"9e595-131\">Кортеж `namedLetters` содержит поля, которые называются `Alpha` и `Beta`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"9e595-132\">Эти имена существуют только во время компиляции и не сохраняются во время выполнения (например, при проверке кортежа посредством отражения во время выполнения).</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"9e595-133\">В назначении кортежа можно также указать имена полей в правой части назначения:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"9e595-134\">Вы можете задать имена для полей как в левой, так и в правой части присваивания, но имена справа игнорируются.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"9e595-135\">Кортежи наиболее полезны в качестве типов возвращаемых значений для методов `private` и `internal`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"9e595-136\">Они позволяют использовать простой синтаксис для возвращения нескольких дискретных значений в этих методах.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"9e595-137\">Гораздо эффективнее и результативнее создать кортеж, чем класс или структуру.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"9e595-138\">Это позволяет определять структуру данных, содержащую больше одного значения, используя более простой, облегченный синтаксис.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"9e595-139\">В представленном ниже примере метод возвращает минимальное и максимальное значения в последовательности целых чисел:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-139\">The example method below returns the minimum and maximum values found in a sequence of integers:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"9e595-140\">В некоторых случаях элементы возвращаемого методом кортежа необходимо распаковать.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-140\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"9e595-141\">С этой целью для каждого значения в этом кортеже объявляется отдельная переменная.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-141\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"9e595-142\">Это называется *деконструкцией* кортежа.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-142\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"9e595-143\">Добавьте приведенный ниже код в браузер, чтобы посмотреть на результат:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-143\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"9e595-144\">При работе с кортежами часто происходит так, что вы используете не все члены результирующего кортежа.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-144\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"9e595-145\">Когда это происходит, вы можете отбросить часть несколько возвращаемых значений, задав `_` вместо переменной.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-145\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"9e595-146\">Добавьте приведенный ниже код в браузер, чтобы посмотреть на результат:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-146\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"9e595-147\">Дополнительные сведения о кортежах см. в [статье о кортежах](../../tuples.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-147\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"9e595-148\">Дополнительные сведения о пустых переменных см. в [статье про пустые переменные](../../discards.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-148\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="9e595-149">Используйте шаблон типа с выражением is</span><span class="sxs-lookup"><span data-stu-id="9e595-149">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="9e595-150">Выражение шаблона `is` позволяет использовать знакомый [оператор `is`](../../language-reference/keywords/is.md#pattern-matching-with-is) для запроса объектов без учета их типов.</span><span class="sxs-lookup"><span data-stu-id="9e595-150">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="9e595-151">Добавьте приведенный ниже код в браузер:</span><span class="sxs-lookup"><span data-stu-id="9e595-151">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="9e595-152">Измените объявление переменной на строковую:</span><span class="sxs-lookup"><span data-stu-id="9e595-152">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="9e595-153">Теперь `is` выражение имеет значение false, поэтому исполняется ветвь `else`.</span><span class="sxs-lookup"><span data-stu-id="9e595-153">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="9e595-154">Попробуйте изменить `count` на `number` в ветви else:</span><span class="sxs-lookup"><span data-stu-id="9e595-154">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="9e595-155">Код выше не будет компилироваться, поскольку `number` не назначается в ветви `else`.</span><span class="sxs-lookup"><span data-stu-id="9e595-155">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="9e595-156">Оно назначается только в ветви `true` инструкции `if`.</span><span class="sxs-lookup"><span data-stu-id="9e595-156">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="9e595-157">Выражения шаблона типа `is` полезны, если есть небольшое количество типов, которые нужно проверять.</span><span class="sxs-lookup"><span data-stu-id="9e595-157">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="9e595-158">Часто может потребоваться проверить несколько типов.</span><span class="sxs-lookup"><span data-stu-id="9e595-158">Often, you may need to test multiple types.</span></span> <span data-ttu-id="9e595-159">Это требует инструкции для сопоставления по шаблону `switch`.</span><span class="sxs-lookup"><span data-stu-id="9e595-159">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="9e595-160">Сопоставление шаблонов в инструкции switch</span><span class="sxs-lookup"><span data-stu-id="9e595-160">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="9e595-161">*Выражение сопоставления* имеет знакомый синтаксис, основанный на операторе `switch`, который уже является частью языка C#.</span><span class="sxs-lookup"><span data-stu-id="9e595-161">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="9e595-162">Давайте начнем с небольшого примере на основе синтаксиса выражений `is`, которые вы изучили на предыдущей странице:</span><span class="sxs-lookup"><span data-stu-id="9e595-162">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="9e595-163">Приведенный выше код проверяет наличие `int` или `null`.</span><span class="sxs-lookup"><span data-stu-id="9e595-163">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="9e595-164">Любые другие типы дадут вариант по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="9e595-164">Every other type reached the default case.</span></span> <span data-ttu-id="9e595-165">Добавьте следующие две строки для проверки поведения:</span><span class="sxs-lookup"><span data-stu-id="9e595-165">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="9e595-166">Выражение `switch` преобразует тип, допускающий значение NULL, в соответствующий тип.</span><span class="sxs-lookup"><span data-stu-id="9e595-166">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="9e595-167">Добавьте для проверки следующее:</span><span class="sxs-lookup"><span data-stu-id="9e595-167">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="9e595-168">В инструкции switch можно добавить любое количество других выражений для шаблона типа.</span><span class="sxs-lookup"><span data-stu-id="9e595-168">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="9e595-169">Добавьте следующее перед вариантом `null`:</span><span class="sxs-lookup"><span data-stu-id="9e595-169">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="9e595-170">Убедитесь, что это работает, добавив следующие проверки:</span><span class="sxs-lookup"><span data-stu-id="9e595-170">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="9e595-171">Кроме того, выражения сопоставления поддерживают константы.</span><span class="sxs-lookup"><span data-stu-id="9e595-171">The match expressions also support constants.</span></span> <span data-ttu-id="9e595-172">Это позволяет экономить время, выделяя простые варианты:</span><span class="sxs-lookup"><span data-stu-id="9e595-172">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="9e595-173">Необходимо добавить предыдущий вариант *перед* выражением `case int:`.</span><span class="sxs-lookup"><span data-stu-id="9e595-173">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="9e595-174">Если добавить его после, компилятор выдает предупреждение о том, что он уже обрабатывается предыдущей меткой case.</span><span class="sxs-lookup"><span data-stu-id="9e595-174">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="9e595-175">Вы можете добавить предложение `when` в любой вариант с шаблоном; таким образом, вы можете проверять другие условия помимо типа или константы.</span><span class="sxs-lookup"><span data-stu-id="9e595-175">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="9e595-176">Попробуйте эту возможность, добавив следующий вариант выше общего `string`:</span><span class="sxs-lookup"><span data-stu-id="9e595-176">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="9e595-177">Для проверки добавьте примерно следующее:</span><span class="sxs-lookup"><span data-stu-id="9e595-177">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="9e595-178">Новый синтаксис для выражений сопоставления шаблонов упрощает процесс создания алгоритмов ветвления на основе типа или других свойств объекта, позволяя использовать ясный и четкий синтаксис.</span><span class="sxs-lookup"><span data-stu-id="9e595-178">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="9e595-179">Выражения сопоставления шаблонов включают эти конструкции для типов данных, не связанных наследованием.</span><span class="sxs-lookup"><span data-stu-id="9e595-179">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="9e595-180">Дополнительные сведения о сопоставлении шаблонов см. в статье, посвященной [сопоставлению шаблонов в C#](../../pattern-matching.md).</span><span class="sxs-lookup"><span data-stu-id="9e595-180">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="9e595-181">Оптимизация памяти хранилища, использующая ссылочные локальные переменные и возвращаемые значения</span><span class="sxs-lookup"><span data-stu-id="9e595-181">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="9e595-182">Эта функция активирует алгоритмы, которые используют и возвращают ссылки на переменные, определенные в другом месте.</span><span class="sxs-lookup"><span data-stu-id="9e595-182">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="9e595-183">В качестве примера можно привести работу с большими матрицами и поиск одного местоположения с определенными характеристиками.</span><span class="sxs-lookup"><span data-stu-id="9e595-183">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="9e595-184">Один метод возвращает два индекса для одного местоположения в матрице:</span><span class="sxs-lookup"><span data-stu-id="9e595-184">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="9e595-185">Этот код можно проверить с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="9e595-185">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="9e595-186">Этот метод `Find` возвращает индексы в элемент матрицы.</span><span class="sxs-lookup"><span data-stu-id="9e595-186">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="9e595-187">В результате вызывающие объекты записывают код, который использует эти индексы, чтобы разыменовать матрицу и изменить отдельный элемент.</span><span class="sxs-lookup"><span data-stu-id="9e595-187">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="9e595-188">Вместо этого лучше написать метод, возвращающий *ссылку* на элемент матрицы, который нужно изменить.</span><span class="sxs-lookup"><span data-stu-id="9e595-188">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="9e595-189">Рассмотрим подробно ряд изменений, чтобы продемонстрировать локальную функцию ref и показать, каким образом создается метод, возвращающий ссылку на внутреннее хранилище.</span><span class="sxs-lookup"><span data-stu-id="9e595-189">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="9e595-190">Параллельно вы узнаете правила возвращаемого значения ref и локальной функции ref, которая защищает вас от случайных ошибок в его использовании.</span><span class="sxs-lookup"><span data-stu-id="9e595-190">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="9e595-191">Для начала изменим объявление метода `Find` таким образом, чтобы вместо кортежа он возвращал `ref int`.</span><span class="sxs-lookup"><span data-stu-id="9e595-191">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="9e595-192">Измените инструкцию return для возвращения элемента с правильными индексами:</span><span class="sxs-lookup"><span data-stu-id="9e595-192">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="9e595-193">Измените итоговый return, чтобы порождалось исключение:</span><span class="sxs-lookup"><span data-stu-id="9e595-193">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="9e595-194">Обратите внимание, что это не будет компилироваться.</span><span class="sxs-lookup"><span data-stu-id="9e595-194">Note that this won't compile.</span></span> <span data-ttu-id="9e595-195">В объявлении метода указывается возврат `ref`, но инструкция return указывает возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="9e595-195">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="9e595-196">Необходимо добавить ключевое слово `ref` в каждый return.</span><span class="sxs-lookup"><span data-stu-id="9e595-196">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="9e595-197">Это обозначает возврат по ссылке и позволяет разработчикам, которые будут читать код позднее, запомнить, что метод возвращается по ссылке:</span><span class="sxs-lookup"><span data-stu-id="9e595-197">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="9e595-198">Теперь, когда метод возвращает ссылку на целочисленное значение в матрице, необходимо изменить место его вызова.</span><span class="sxs-lookup"><span data-stu-id="9e595-198">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="9e595-199">Объявление `var` означает, что `valItem` теперь не кортеж, а `int`.</span><span class="sxs-lookup"><span data-stu-id="9e595-199">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="9e595-200">Измените вызывающий код следующим образом:</span><span class="sxs-lookup"><span data-stu-id="9e595-200">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="9e595-201">Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `42`, а не `24`.</span><span class="sxs-lookup"><span data-stu-id="9e595-201">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="9e595-202">Переменная `valItem` — это `int`, а не `ref int`.</span><span class="sxs-lookup"><span data-stu-id="9e595-202">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="9e595-203">Ключевое слово `var` дает компилятору возможность указать тип, но не позволяет неявно добавить модификатор `ref`.</span><span class="sxs-lookup"><span data-stu-id="9e595-203">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="9e595-204">Вместо этого значение, на которое ссылается `ref return`, *копируется* в переменную в левой части назначения.</span><span class="sxs-lookup"><span data-stu-id="9e595-204">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="9e595-205">Переменная не является локальной переменной `ref`.</span><span class="sxs-lookup"><span data-stu-id="9e595-205">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="9e595-206">Для изменения возвращенной ссылки необходимо добавить модификатор `ref` в объявление локальной переменной перед вызовом `Find`, чтобы в случае, если возвращаемое значение является ссылкой, переменная стала ссылкой.</span><span class="sxs-lookup"><span data-stu-id="9e595-206">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="9e595-207">Измените проверочный код в браузере в соответствии со следующим:</span><span class="sxs-lookup"><span data-stu-id="9e595-207">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="9e595-208">Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `24`, показывая, что хранилище в матрице было изменено.</span><span class="sxs-lookup"><span data-stu-id="9e595-208">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="9e595-209">Локальная переменная объявлена с помощью модификатора `ref` и принимает возвращаемое значение `ref`.</span><span class="sxs-lookup"><span data-stu-id="9e595-209">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="9e595-210">Переменную `ref` необходимо инициализировать при объявлении, отделять объявление от инициализации нельзя.</span><span class="sxs-lookup"><span data-stu-id="9e595-210">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="9e595-211">Язык C# включает три других правила, которые защищают вас от неправильного использования возвращаемых значений и локальных переменных `ref`.</span><span class="sxs-lookup"><span data-stu-id="9e595-211">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="9e595-212">Присвоить локальной переменной `ref` стандартное возвращаемое значение метода нельзя.</span><span class="sxs-lookup"><span data-stu-id="9e595-212">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="9e595-213">Переменную `ref` нельзя возвращать переменной, которая продолжает существовать даже после того, как метод будет выполнен.</span><span class="sxs-lookup"><span data-stu-id="9e595-213">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="9e595-214">Возвращаемые значения и локальные переменные `ref` не могут использоваться с асинхронными методами.</span><span class="sxs-lookup"><span data-stu-id="9e595-214">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="9e595-215">Добавление локальных переменных и возвращаемых значений ref дает возможность использовать более эффективные алгоритмы, поскольку избавляет от необходимости многократно копировать значения или выполнять операции разыменования.</span><span class="sxs-lookup"><span data-stu-id="9e595-215">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="9e595-216">Дополнительные сведения см. в статье [ref (Справочник по C#)](../../language-reference/keywords/ref.md).</span><span class="sxs-lookup"><span data-stu-id="9e595-216">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="9e595-217">Ограничение доступа к коду с помощью локальных функций</span><span class="sxs-lookup"><span data-stu-id="9e595-217">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"9e595-218\">Теперь можно объявлять локальные функции, вложенные в другие функции.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-218\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"9e595-219\">Это позволяет свести к минимуму видимость этих функций.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-219\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"9e595-220\">Существует три очевидных варианта использования локальных функций:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-220\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"9e595-221\">Рекурсивные функции.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-221\">Recursive functions.</span></span>\n- <span data-ttu-id=\"9e595-222\">Методы итератора.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-222\">Iterator methods.</span></span>\n- <span data-ttu-id=\"9e595-223\">Асинхронные методы.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-223\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"9e595-224\">Давайте начнем с рекурсивных методов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-224\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"9e595-225\">Добавьте следующий код в браузере, чтобы вычислить `6!` (факториал):</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-225\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"9e595-226\">Локальные функции являются отличным способом реализации рекурсивных алгоритмов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-226\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"9e595-227\">Другие распространенные варианты — открытые методы итератора и открытые асинхронные методы.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-227\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"9e595-228\">Оба эти типа методов создают код, который сообщает об ошибках позднее, чем могут ожидать программисты.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-228\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"9e595-229\">В случае методов итератора исключения наблюдаются только при вызове кода, перечисляющего возвращенную последовательность.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-229\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"9e595-230\">В случае асинхронных методов исключения наблюдаются только при ожидании возвращаемого объекта `Task`.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-230\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"9e595-231\">Методы итератора легче просматривать в браузере, так что давайте использовать их в этом обзоре.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-231\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"9e595-232\">Попробуйте выполнить следующий код, который вызывает метод итератора в браузере:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-232\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"9e595-233\">Выполните код.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-233\">Run the code.</span></span> <span data-ttu-id=\"9e595-234\">Обратите внимание, что исключение порождается, когда код начинается итерацию по второму результирующему набору.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-234\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"9e595-235\">Код, который выполняет итерацию по первому результирующему набору, уже выполнен.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-235\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"9e595-236\">В этом примере немного кода и не изменяются структуры данных, поэтому он безопасен и его легко исправить.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-236\">This sample is both small and doesn't change any data structures, dso it's harmless and easy to fix.</span></span> <span data-ttu-id=\"9e595-237\">Но в более крупной программе, где два объекта итератора могут быть созданы разными дочерними методами, корневую причину может быть трудно найти.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-237\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"9e595-238\">Если первый метод итератора изменит состояние данных, он может даже вызвать повреждение данных.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-238\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"9e595-239\">Вы бы предпочли получить исключение немедленно, перед выполнением какой-либо дальнейшей работы.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-239\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"9e595-240\">Код можно оптимизировать так, чтобы открытый метод проверял все аргументы, а локальная функция выполняла перечисление:</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-240\">You can refactor the code so that the public method validates all arguments, and a local function that performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"9e595-241\">Приведенная выше версия поясняет, что ссылка на локальный метод возможна только в контексте внешнего метода.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-241\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"9e595-242\">Кроме того, правила для локальных функций не позволяют разработчику случайно вызвать локальную функцию из другого места в классе и обойти проверку аргументов.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-242\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"9e595-243\">Та же методика может применяться с методами `async` для того, чтобы исключения, возникающие при проверке параметров, выдавались до начала асинхронной работы.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-243\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"9e595-244\">Некоторые из макетов, поддерживаемых локальными функциями, также могут выполняться с помощью *лямбда-выражений*.</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-244\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"9e595-245\">Если вам интересно, [прочтите более подробные сведения о различиях](../../local-functions-vs-lambdas.md).</span><span class=\"sxs-lookup\"><span data-stu-id=\"9e595-245\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="9e595-246">Мы завершили подробное описание новых важных функций в C# 7.</span><span class="sxs-lookup"><span data-stu-id="9e595-246">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="9e595-247">Теперь попробуйте их самостоятельно в ваших приложениях.</span><span class="sxs-lookup"><span data-stu-id="9e595-247">Now try them yourself in your applications.</span></span> <span data-ttu-id="9e595-248">Вы найдете полный список в статье [Новые возможности C# 7](../../whats-new/csharp-7.md).</span><span class="sxs-lookup"><span data-stu-id="9e595-248">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
