---
title: "Атрибуты — C# | Microsoft Docs"
description: "Узнайте, как работают атрибуты в C#."
keywords: ".NET .NET Core, C#, атрибуты"
author: mgroves
ms.author: wiwagn
ms.date: 03/06/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: b152cf36-76e4-43a5-b805-1a1952e53b79
ms.translationtype: Human Translation
ms.sourcegitcommit: 4437ce5d344cf06d30e31911def6287999fc6ffc
ms.openlocfilehash: 512a222a727e3e6a032848b87463dda0ae8f7362
ms.contentlocale: ru-ru
ms.lasthandoff: 05/23/2017

---

<a id="using-attributes-in-c" class="xliff"></a>
# Использование атрибутов в C# #

Атрибуты предоставляют возможность декларативно связать информацию с кодом. Также этот элемент можно многократно использовать повторно для разнообразных целевых объектов.

Рассмотрим для примера атрибут `[Obsolete]`. Его можно применять к классам, структурам, методам, конструкторам и т. д. Он _объявляет_, что соответствующий элемент является устаревшим. Компилятор C# проверят наличие этого атрибута и выполняет некоторые действия, если он присутствует.

В этом руководстве мы покажем вам, как можно добавить атрибуты в код, как создавать и применять собственные атрибуты, а также использовать некоторые встроенные атрибуты .NET Core.

<a id="prerequisites" class="xliff"></a>
## Предварительные требования
Компьютер должен быть настроен для выполнения .NET Core. Инструкции по установке см. на странице [.NET Core](https://www.microsoft.com/net/core).
Это приложение можно запустить в ОС Windows, Ubuntu Linux, macOS или в контейнере Docker. Вам потребуется редактор кода, но вы можете выбрать любой привычный для вас. В примерах ниже используется кроссплатформенный редактор [Visual Studio Code](https://code.visualstudio.com/) с открытым исходным кодом. Вы можете заменить его на любое другое средство, с которым вам удобно работать.

<a id="create-the-application" class="xliff"></a>
## Создание приложения

Теперь, когда вы установили все нужные средства, создайте новое приложение .NET Core. Чтобы использовать генератор из командной строки, выполните следующую команду в любой оболочке:

`dotnet new console`

Эта команда создает скелет файлов проекта для .NET Core. Нужно также выполнить команду `dotnet restore`, чтобы восстановить зависимости, необходимые для компиляции проекта.

Чтобы выполнить программу, используйте `dotnet run`. Она выведет в консоль сообщение "Hello, World".

<a id="how-to-add-attributes-to-code" class="xliff"></a>
## Добавление атрибутов к коду

В C# атрибуты представляют собой классы, наследующие от базового класса `Attribute`. Любой класс, который наследует от `Attribute`, можно использовать как своего рода "тег" на другие части кода.
Например, существует атрибут с именем `ObsoleteAttribute`. С его помощью можно обозначить, что код устарел и больше не должен использоваться. Этот атрибут можно поместить в класс, используя квадратные скобки.

[!code-csharp[Пример использования атрибута Obsolete](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample1)]  

Обратите внимание, что полное название класса — `ObsoleteAttribute`, но в коде достаточно указать только `[Obsolete]`. Это стандартное соглашение в C#.
При желании вы можете использовать полное имя `[ObsoleteAttribute]`.

Когда вы отмечаете класс как устаревший, желательно предоставить некоторые сведения о том, *почему* он устарел и (или) *что* можно использовать вместо него. Для этого передайте в атрибут Obsolete строковый параметр.

[!code-csharp[Пример использования атрибута Obsolete с параметрами](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ObsoleteExample2)]

Эта строка передается в качестве аргумента в конструктор `ObsoleteAttribute`, как если бы вы использовали синтаксис `var attr = new ObsoleteAttribute("some string")`.

В конструкторе атрибута можно использовать в качестве параметров только простые типы и литералы `bool, int, double, string, Type, enums, etc` и массивы этих типов.
Нельзя использовать переменные или выражения. Но вы можете свободно использовать позиционные или именованные параметры.

<a id="how-to-create-your-own-attribute" class="xliff"></a>
## Как создать собственный атрибут

Чтобы создать собственный атрибут, достаточно унаследовать его от базового класса `Attribute`.

[!code-csharp[Создание собственного атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample1)]

Добавив такой код, вы сможете использовать `[MySpecial]` (или `[MySpecialAttribute]`) в качестве атрибута в любом месте кода.

[!code-csharp[Использование собственного атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CreateAttributeExample2)]

Атрибуты в библиотеке базовых классов .NET, например `ObsoleteAttribute`, активируют определенный действия компилятора. Но созданные вами атрибуты сами по себе лишь выполняют роль метаданных и не влекут за собой исполнение какого-либо кода в классе атрибута. Вы должны проверять эти метаданные и выполнять необходимые действия в другой части кода (подробнее об этом написано дальше в этом руководстве).

Здесь есть один подвох, которого следует остерегаться. Как упоминалось выше, в качестве аргументов при использовании атрибутов можно передавать только некоторые определенные типы. Но компилятор C# не помешает вам указать другие параметры при создании типа атрибута. В следующем примере кода я создаю атрибут с конструктором, который отлично компилируется.

[!code-csharp[Допустимый конструктор для атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGothca1)]

Но объект с таким конструктором вы не сможете использовать в роли атрибута.

[!code-csharp[Недопустимая попытка использовать конструктор атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeGotcha2)]

Такой код вызовет ошибку компиляции, например такую: `Attribute constructor parameter 'myClass' has type 'Foo', which is not a valid attribute parameter type`

<a id="how-to-restrict-attribute-usage" class="xliff"></a>
## Как ограничить использование атрибута

Атрибуты можно использовать для разных целевых объектов. В примере выше мы применили их для классов, но целевым объектом может быть любой из этого списка:

* Assembly
* Класс
* Конструктор
* Делегат
* Enum
* Событие
* Поле
* универсальный параметр;
* Интерфейс
* Метод
* Модуль
* Параметр
* Свойство
* Возвращаемое значение
* Структура

Когда вы создаете класс атрибута, C# по умолчанию позволяет использовать этот атрибут для любого из допустимых целевых объектов. Если вы хотите, чтобы атрибут можно было использовать только для некоторых из целевых объектов, используйте `AttributeUsageAttribute` в классе атрибута. Да-да, именно так, атрибут для атрибута!

[!code-csharp[Использование собственного атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample1)]

Если вы попробуете применить описанный выше атрибут для сущности, которая не является классом или структурой, вы получите ошибку компиляции такого рода: `Attribute 'MyAttributeForClassAndStructOnly' is not valid on this declaration type. It is only valid on 'class, struct' declarations`

[!code-csharp[Использование собственного атрибута](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#AttributeUsageExample2)]

<a id="how-to-use-attributes-attached-to-a-code-element" class="xliff"></a>
## Как использовать атрибуты, прикрепленные к элементу кода

Атрибуты выполняют роль метаданных. Без применения внешних сил они по сути ничего не делают.

Чтобы находить атрибуты и реагировать на них, обычно используется [отражение](../programming-guide/concepts/reflection.md). Мы не будем здесь подробно описывать отражения, ограничимся лишь основной идеей: отражение позволяет написать на C# код, который проверяет другой код.

Например, с помощью отражения можно получить сведения о классе: 

[!code-csharp[Проверка сведений о типе с помощью отражения](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample1)]

Этот код выведет такие данные: `The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`

Если у вас есть объект `TypeInfo` (или `MemberInfo`, `FieldInfo` и т. д.), вы можете использовать метод `GetCustomAttributes`. Он возвращает коллекцию объектов `Attribute`.
Можно также использовать `GetCustomAttribute`, указав тип атрибута.

Ниже вы видите пример использования `GetCustomAttributes` для экземпляра `MemberInfo` класса `MyClass` (как мы продемонстрировали ранее, он имеет атрибут `[Obsolete]`).

[!code-csharp[Проверка сведений о типе с помощью отражения](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#ReflectionExample2)]

Этот код выведет в консоль текст: `Attribute on MyClass: ObsoleteAttribute`. Попробуйте добавить другие атрибуты для `MyClass`.

Обратите особое внимание, что к таким объектам `Attribute` применяется отложенное создание экземпляров. При вызове `GetCustomAttribute` или `GetCustomAttributes` экземпляры не создаются.
Кроме того, они создаются заново при каждом обращении. Выполнив `GetCustomAttributes` два раза подряд, вы получите два различных экземпляра `ObsoleteAttribute`.

<a id="common-attributes-in-the-base-class-library-bcl" class="xliff"></a>
## Популярные атрибуты в библиотеке базовых классов (BCL)

Атрибуты используются многими средствами и платформами. NUnit использует такие атрибуты, как `[Test]` и `[TestFixture]`, которые нужны для средства тестового запуска NUnit. ASP.NET MVC использует такие атрибуты, как `[Authorize]`, и предоставляет платформу фильтра действий, которая позволяет использовать перекрестные функции для действий MVC. [PostSharp](https://www.postsharp.net) использует синтаксис атрибутов для реализации аспектно-ориентированного программирования на языке C#.

Ниже приведены несколько важных атрибутов, используемых в библиотеках базовых классов .NET Core.

* `[Obsolete]`. Этот атрибут мы уже использовали в примерах выше. Он размещен в пространстве имен `System`. С его помощью удобно создавать декларативную документацию об изменении кодовой базы. К нему можно добавить строковое сообщение, а дополнительный логический параметр позволяет повысить уровень сообщений компилятора с предупреждения до ошибки.

* `[Conditional]`. Этот атрибут находится в пространстве имен `System.Diagnostics`. Его может применять к методам или классам атрибутов. В его конструктор необходимо передать строку.
Если эта строка совпадает с директивой `#define`, то компилятор C# будет удалять все вызовы этого метода (но не сам метод). Обычно это используется для целей отладки или диагностики.

* `[CallerMemberName]`. Этот атрибут можно применить для параметров. Он размещен в пространства имен `System.Runtime.CompilerServices`. Этот атрибут позволяет передать имя метода добавления, который вызывает другой метод. Обычно он используется для устранения "волшебных строк" при реализации INotifyPropertyChanged в различных платформах взаимодействия с пользователем. Вот пример:

[!code-csharp[Использование CallerMemberName при реализации INotifyPropertyChanged](../../../samples/snippets/csharp/tutorials/attributes/Program.cs#CallerMemberName1)]

В приведенном выше коде не обязательно использовать литеральную строку `"Name"`. Это помогает предотвратить ошибки, связанные с опечатками, а также позволяет плавно выполнять рефакторинг и (или) переименование.

<a id="summary" class="xliff"></a>
## Сводка

Атрибуты предоставляют в C# мощь декларативного синтаксиса. Но они лишь позволяют использовать в коде метаданных, и выполняют сами никаких действий.

