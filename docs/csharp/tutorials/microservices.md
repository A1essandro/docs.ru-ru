---
title: Микрослужбы, размещенные в Docker. Язык C#
description: Узнайте, как создать службы ASP.NET Core, выполняемые в контейнерах Docker
ms.date: 06/08/2017
ms.assetid: 87e93838-a363-4813-b859-7356023d98ed
ms.openlocfilehash: b1f7159a222ab4d68715844e9997ca922676bc80
ms.sourcegitcommit: b22705f1540b237c566721018f974822d5cd8758
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/19/2018
ms.locfileid: "49454490"
---
# <a name="microservices-hosted-in-docker"></a>Микрослужбы, размещенные в Docker

В этом руководстве описан процесс построения и развертывания микрослужбы ASP.NET Core в контейнере Docker. В ходе работы с этим руководством вы узнаете:

* как создать приложение ASP.NET Core;
* как создать среду разработки Docker;
* как создать образ Docker на основе существующего образа;
* как развертывать службы в контейнер Docker.

Одновременно с этим вы увидите примеры использования некоторых возможностей языка C#:

* как преобразовать объекты C# в полезные данные JSON;
* как создать неизменяемые объекты передачи данных;
* как обрабатывать входящие запросы HTTP и формировать HTTP-ответы;
* как использовать типы значений, допускающих значение NULL.

Вы можете [просмотреть или скачать пример приложения](https://github.com/dotnet/samples/tree/master/csharp/getting-started/WeatherMicroservice) для этого раздела. Инструкции по загрузке см. в разделе [Просмотр и скачивание примеров](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).

## <a name="why-docker"></a>Преимущества Docker

Docker позволяет легко создавать стандартные образы виртуальной машины для размещения служб в центре обработки данных или в общедоступном облаке. Docker позволяет настраивать образ и реплицировать его по мере необходимости для масштабирования приложения.

Весь код, представленный в этом руководстве, будет работать в любой среде .NET Core.
Дополнительные задачи по установке Docker совместимы с приложением ASP.NET Core. 

## <a name="prerequisites"></a>Предварительные требования

Компьютер должен быть настроен для выполнения .NET Core. Инструкции по установке см. на странице [.NET Core](https://www.microsoft.com/net/core).
Это приложение можно запустить в ОС Windows, Linux, macOS или в контейнере Docker.
Вам потребуется редактор кода, но вы можете выбрать любой привычный для вас. В примерах ниже используется кроссплатформенный редактор [Visual Studio Code](https://code.visualstudio.com/) с открытым исходным кодом. Вы можете заменить его на любое другое средство, с которым вам удобно работать.

Также необходимо установить подсистему Docker. На [странице установки Docker](https://docs.docker.com/install/overview/) вы найдете инструкции для вашей платформы.
Docker можно установить на многих дистрибутивах Linux, macOS или Windows. Указанная выше страница содержит разделы для каждой из доступных установок.

## <a name="create-the-application"></a>Создание приложения

После установки всех средств создайте новое приложение ASP.NET Core в каталоге "WeatherMicroservice", выполнив следующую команду в предпочитаемой оболочке:

```console
dotnet new web -o WeatherMicroservice
```

Команда `dotnet` запускает средства, необходимые для разработки в среде .NET. Каждая команда соответствует определенному средству.

Команда `dotnet new` используется для создания проектов .Net Core.

Параметр `-o WeatherMicroservice` после команды `dotnet new` указывает расположение, в котором будет создано приложение ASP.NET Core.

Для этой микрослужбы нам нужно как можно более простое и легкое веб-приложение, поэтому мы использовали шаблон "ASP.NET Core Empty", указав его краткое имя `web`.

Шаблон создает четыре файла:

* Файл Startup.cs. Этот файл содержит основу для приложения.
* Файл Program.cs. Этот файл содержит точку входа для приложения.
* Файл WeatherMicroservice.csproj. Это файл сборки для нашего приложения.
* Файл Properties/launchSettings.json. Этот файл содержит параметры отладки, используемые интегрированными средами разработки.

Теперь можно запустить приложение, созданное на основе шаблона:

```console
dotnet run
```

Эта команда сначала восстановит зависимости, необходимые для сборки приложения, а затем соберет приложение.

В конфигурации по умолчанию приложение прослушивает адрес `http://localhost:5000`. Откройте браузер и перейдите на эту страницу. Вы должны увидеть приветствие Hello World !".

Когда закончите, завершите работу приложения, нажав <kbd>Ctrl</kbd>+<kbd>C</kbd>.

### <a name="anatomy-of-an-aspnet-core-application"></a>Анатомия приложений ASP.NET Core

Теперь у вас есть готовое приложение. Давайте на его примере рассмотрим реализацию функциональных возможностей. Из созданных файлов приложения нам пока наиболее интересны вот эти два: WeatherMicroservice.csproj и Startup.cs. 

CSPROJ-файл содержит сведения о проекте.
Нас интересуют два узла: `<TargetFramework>` и `<PackageReference>`.

Узел `<TargetFramework>` определяет версию .NET, где будет выполняться это приложение.

Каждый узел `<PackageReference>` используется для указания пакета, который необходим для этого приложения.

Само приложение реализовано в файле Startup.cs. Этот файл содержит класс Startup.

Инфраструктура ASP.NET Core вызывает два метода этого класса для настройки и запуска приложения. Метод `ConfigureServices` описывает службы, которые необходимы для приложения. Наша служба не использует никакие ресурсы, и для нее не нужны никакие зависимости. Метод `Configure` настраивает обработчики для входящих HTTP-запросов. Шаблон создает простой обработчик, который в ответ на любой запрос возвращает текст "Hello World!".

## <a name="build-a-microservice"></a>Сборка микрослужбы

Служба, которую вы разрабатываете, будет доставлять сведения о погоде в любой точке земного шара. В рабочем приложении вы будете обращаться к реальным службам для получения данных о погоде. Но для этого примера нам достаточно создать случайный прогноз погоды. 

Чтобы получить его, мы выполним несколько задач:

* синтаксический анализ входящего запроса для получения широты и долготы;
* создание случайных данных для прогноза;
* преобразование случайных данных прогноза из объектов C# в пакеты JSON;
* установка заголовка ответа, который будет обозначать отправку данных в формате JSON;
* создание текста ответа.

В следующем разделе описаны шаги для выполнения каждой из этих задач.

### <a name="parsing-the-query-string"></a>Синтаксический анализ строки запроса

Прежде всего нужно выполнить синтаксический анализ строки запроса. Служба будет принимать в строке запроса аргументы lat и long в следующем формате:

```
http://localhost:5000/?lat=-35.55&long=-12.35
```

Все изменения, которые нужно выполнить, относятся к лямбда-выражению, которое определено в классе запуска в качестве аргумента для метода `app.Run`.

В лямбда-выражении нас интересует аргумент `HttpContext`, представляющий запрос. Одним из его свойств является объект `Request`. Объект `Request` имеет свойство `Query`, которое содержит словарь всех значений, переданных в строке запроса. Сначала добавьте строки для поиска значений широты и долготы:

[!code-csharp[ReadQueryString](../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#ReadQueryString "read variables from the query string")]

Словарные значения `Query` имеют тип `StringValue`. Этот тип может содержать коллекцию строк. Для нашей службы погоды каждое значение должно содержать одну строку. Поэтому в приведенном выше коде мы вызываем метод `FirstOrDefault()`. 

Теперь нам нужно преобразовать эти строки в тип Double. Для преобразования строки в значение типа double мы используем метод `double.TryParse()`:

```csharp
bool TryParse(string s, out double result);
```

Этот метод использует параметры вывода C#, чтобы определить возможность преобразования входной строки к типу double. Если строка содержит допустимое представление для типа double, метод возвращает значение true, а аргумент `result` содержит преобразованное значение. Если строка не представляет допустимого представления для типа double, метод возвращает значение false.

Этот API можно дополнить *методом расширения*, который возвращает *тип double, допускающий значение NULL*. *Тип, допускающий значение NULL*, может содержать значения некоторого типа или значение NULL, которое обозначает отсутствие значения. Чтобы использовать тип, допускающий значения NULL, добавьте к объявлению типа символ `?`. 

Методы расширения представляют собой методы, которые определяются как обычные статические методы, но с модификатором `this` для первого параметра. Такие методы можно вызывать так, как будто они являются членами этого класса. Методы расширения можно определять только в статических классах. Вот пример определения класса с методом расширения для синтаксического анализа:

[!code-csharp[TryParseExtension](../../../samples/csharp/getting-started/WeatherMicroservice/Extensions.cs#TryParseExtension "try parse to a nullable")]

Перед вызовом метода расширения выберите инвариантные язык и региональные параметры:

[!code-csharp[SetCulture](../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#SetCulture "set current culture to invariant")]

Таким образом, ваше приложение будет одинаково анализировать числа на любом сервере независимо от языка и региональных параметров по умолчанию.

Теперь этот метод расширения можно использовать для преобразования аргументов строки запроса в тип double:

[!code-csharp[UseTryParse](../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#UseTryParse "Use the try parse extension method")]

Чтобы быстро проверить работу кода для синтаксического анализа, включите значения аргументов в возвращаемый ответ:

[!code-csharp[WriteResponse](../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#WriteResponse "Write the output response")]

На этом этапе можно запустить веб-приложение и убедиться, работает ли код для синтаксического анализа. В строке запроса браузера добавьте какие-либо значения, обновите страницу и убедитесь, что они правильно возвращаются.

### <a name="build-a-random-weather-forecast"></a>Создание случайного прогноза погоды

Теперь мы переходим к созданию случайного прогноза погоды. Для этого нам в первую очередь нужен контейнер, который содержит значения для прогноза погоды:

```csharp
public class WeatherReport
{
    private static readonly string[] PossibleConditions =
    {
        "Sunny",
        "Mostly Sunny",
        "Partly Sunny",
        "Partly Cloudy",
        "Mostly Cloudy",
        "Rain"
    };

    public int HighTemperatureFahrenheit { get; }
    public int LowTemperatureFahrenheit { get; }
    public int AverageWindSpeedMph { get; }
    public string Condition { get; }
}
```

Теперь создайте конструктор, который задает эти значения случайным образом. Этот конструктор использует значения широты и долготы в качестве начального значения для генератора чисел `Random`. Это означает, что для каждого набора координат всегда будет возвращаться одинаковый прогноз. Если вы измените значения для аргументов широты и долготы, вы получите другой прогноз (поскольку начальное значение для генератора случайных чисел будет другим).

[!code-csharp[WeatherReportConstructor](../../../samples/csharp/getting-started/WeatherMicroservice/WeatherReport.cs#WeatherReportConstructor "Weather Report Constructor")]

Создайте в методе ответа прогноз на 5 дней:

```csharp
if (latitude.HasValue && longitude.HasValue)
{
    var forecast = new List<WeatherReport>();
    for (var days = 1; days <= 5; days++)
    {
        forecast.Add(new WeatherReport(latitude.Value, longitude.Value, days));
    }
}
```

### <a name="build-the-json-response"></a>Оформление ответа в формате JSON

Последней задачей, которую выполняет код на сервере, будет преобразование списка `WeatherReport` в документ JSON и отправка этого пакета клиенту. Здесь нам нужно сначала создать документ JSON. В список зависимостей добавьте сериализатор Newtonsoft JSON. Для этого используйте команду `dotnet`:

```console
dotnet add package Newtonsoft.Json
```

Теперь примените класс `JsonConvert`, чтобы преобразовать наш объект в строку:

[!code-csharp[ConvertToJson](../../../samples/csharp/getting-started/WeatherMicroservice/Startup.cs#ConvertToJSON "Convert objects to JSON")]

Приведенный выше код преобразует объект прогноза (список объектов `WeatherForecast`) в документ JSON. Когда документ с ответом будет готов, укажите для него тип содержимого `application/json` и возвратите строку.

Теперь наше приложение создает и возвращает случайные прогнозы погоды.

## <a name="build-a-docker-image"></a>Создание образа Docker

Последней задачей в этой статье будет запуск приложения в Docker. Мы создадим контейнер Docker, который выполняет образ Docker с созданным ранее приложением.

Объект ***образа Docker*** — это файл, который определяет среду для запуска приложения.

***Контейнер Docker*** представляет запущенный экземпляр образа Docker.

Для упрощения понимания вы можете представить *образ Docker* как *класс*, а *контейнер Docker* — как объект или экземпляр этого класса.  

Следующий файл Dockerfile будет использоваться для наших целей:

```
FROM microsoft/dotnet:2.1-sdk AS build
WORKDIR /app

# Copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out

# Build runtime image
FROM microsoft/dotnet:2.1-aspnetcore-runtime
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT ["dotnet", "WeatherMicroservice.dll"]
```

Давайте изучим его содержимое.

Первая строка задает источник образа, используемого для сборки приложения:

```
FROM microsoft/dotnet:2.1-sdk AS build
```

Docker позволяет настроить образ компьютера на основе исходного шаблона. Это значит, что при запуске вам не придется указывать все параметры компьютера. Достаточно указать лишь изменения параметров, если они потребуются. Здесь таким изменением станет запуск нашего приложения.

В этом примере мы будем использовать версию `2.1-sdk` образа `dotnet`. Это самый простой способ создать рабочую среду Docker. Этот образ содержит среду выполнения .NET Core и пакет SDK для .NET Core.
Это упрощает начало работы и сборку, но приводит к созданию более крупного образа, поэтому мы будем использовать этот образ для сборки приложения, а для запуска возьмем другой образ.

Следующие строки выполняют настройку и сборку приложения:

```
WORKDIR /app

# Copy csproj and restore as distinct layers
COPY *.csproj ./
RUN dotnet restore

# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out
```

Здесь файл проекта копируется из текущего каталога на виртуальную машину Docker, а также восстанавливаются все пакеты. Мы используем Dotnet CLI, а значит образ Docker должен включать пакет SDK для .NET Core. После этого копируется остальная часть приложения, а команда `dotnet
publish` выполняет сборку и упаковку приложения.

Наконец, мы создадим второй образ Docker, который запустит приложение:

```
# Build runtime image
FROM microsoft/dotnet:2.1-aspnetcore-runtime
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT ["dotnet", "WeatherMicroservice.dll"]
```

Этот образ использует версию `2.1-aspnetcore-runtime` образа `dotnet`, который содержит все компоненты, необходимые для запуска приложений ASP.NET Core, но не включает пакет SDK для .NET Core. Это означает, что этот образ не может использоваться для сборки приложений .NET Core, но он позволяет уменьшить размер окончательного образа.

Для этого мы копируем собранное приложение из первого образа во второй.

Команда `ENTRYPOINT` сообщает Docker, какая команда запускает службу.

## <a name="building-and-running-the-image-in-a-container"></a>Сборка и выполнение образа в контейнере

Теперь мы создадим образ и запустим службу в контейнере Docker. Вам не нужно, чтобы в образ копировались все файлы из локального каталога. Поэтому приложение следует собирать в контейнере. Для этого создайте файл `.dockerignore` и перечислите в нем каталоги, которые не нужно копировать в образ. Например, вам не нужно, чтобы копировались активы сборки. Укажите каталоги для сборки и публикации в файле `.dockerignore`:

```
bin/*
obj/*
out/*
```

Для сборки образа используется команда `docker build`. Выполните следующую команду из каталога, содержащего код приложения.

```console
docker build -t weather-microservice .
```

Эта команда собирает контейнер изображения, используя информацию из файла Dockerfile. Аргумент `-t` содержит тег (имя) для создаваемого образа контейнера. В приведенной выше командной строке для контейнера Docker указан тег `weather-microservice`. Когда завершится выполнение этой команды, у вас будет готовый контейнер для запуска новой службы. 

Выполните следующую команду, чтобы запустить созданный контейнер и соответствующую службу:

```console
docker run -d -p 80:80 --name hello-docker weather-microservice
```

Параметр `-d` указывает, что контейнер следует отсоединить от текущего терминала. Это означает, что вы не увидите выходные данные команды в окне терминала. Параметр `-p` настраивает сопоставление портов между службой и узлом. В этом примере все входящие запросы на порт 80 будут перенаправляться на порт контейнера 80. Мы используем порт 80, потому что он совпадает с портом, от которого ваша служба ожидает передачи данных. Это порт по умолчанию для приложений в производственной среде. Аргумент `--name` задает имя для выполняемого контейнера. Здесь вы можете указать любое удобное для вас имя, которое упростит работу с этим контейнером.

С помощью следующей команды вы можете проверить, выполняется ли образ:

```console
docker ps
```

Если контейнер работает, вы увидите строку с его именем в списке запущенных процессов. (Возможно, это будет единственная строка в этом списке.)

Вы можете проверить работу вашей службы, открыв локальный адрес localhost в окне браузера и введя значения для широты и долготы:

```
http://localhost/?lat=35.5&long=40.75
```

## <a name="attaching-to-a-running-container"></a>Присоединение к работающему контейнеру

Когда вы запускали службу в командном окне, для каждого запроса вы получали диагностические сведения. Теперь, когда контейнер работает в отсоединенном режиме, вы больше не видите эту информацию. Команда Docker attach дает возможность присоединиться к выполняющемуся контейнеру, чтобы просмотреть данные журнала.  В окне командной строки выполните следующую команду:

```console
docker attach --sig-proxy=false hello-docker
```

Аргумент `--sig-proxy=false` означает, что команды <kbd>Ctrl</kbd>+<kbd>C</kbd> не передаются в процесс контейнера, а просто останавливают выполнение команды `docker attach`. Последний аргумент обозначает имя, присвоенное контейнеру ранее, при выполнении команды `docker run`. 

> [!NOTE]
> Также для ссылки на любой контейнер вы можете использовать назначенный Docker идентификатор контейнера. Если в команде `docker run` не указано имя контейнера, необходимо использовать идентификатор контейнера.

Откройте браузер и перейдите к адресу вашей службы. В командном окне вы увидите диагностические сообщения, генерируемые присоединенным контейнером.

Чтобы остановить этот процесс, нажмите <kbd>Ctrl</kbd>+<kbd>C</kbd>.

Когда вы завершите работу с контейнером, его можно остановить:

```console
docker stop hello-docker
```

При этом контейнер и образ останутся доступны, и их можно запустить заново.  Если вы хотите удалить контейнер с компьютера, используйте следующую команду:

```console
docker rm hello-docker
```

Если вы хотите удалить с компьютера все неиспользуемые контейнеры, используйте следующую команду:

```console
docker rmi weather-microservice
```

## <a name="conclusion"></a>Заключение 

В этом руководстве вы создали микрослужбу ASP.NET Core и добавили в нее несколько простых функций.

Вы создали образ контейнера Docker для этой службы и запустили его на компьютере. Также вы подключили к службе окно терминала и увидели диагностические сообщения от службы.

В процессе изучения вы также узнали, как используются некоторые функции языка C#.
