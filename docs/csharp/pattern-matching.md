---
title: Сопоставление шаблонов | Руководство по C#
description: Сведения о выражениях сопоставления шаблонов в C#
ms.date: 01/24/2017
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 635ab45c89a38f3dedac2d60ea1e31ebf394c9b2
ms.sourcegitcommit: 2ad7d06f4f469b5d8a5280ac0e0289a81867fc8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2018
ms.locfileid: "35231480"
---
# <a name="pattern-matching"></a><span data-ttu-id="8162e-103">Сопоставление шаблонов</span><span class="sxs-lookup"><span data-stu-id="8162e-103">Pattern Matching</span></span> #

<span data-ttu-id="8162e-104">Шаблоны проверяют, содержит ли значение определенную *фигуру* и может ли оно *извлекать* сведения из значения с соответствующей фигурой.</span><span class="sxs-lookup"><span data-stu-id="8162e-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="8162e-105">Сопоставление шаблонов позволяет использовать сокращенный синтаксис для тех алгоритмов, которые вы уже применяете.</span><span class="sxs-lookup"><span data-stu-id="8162e-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="8162e-106">Вы уже создали алгоритмы сопоставления шаблонов с помощью существующего синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="8162e-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="8162e-107">Для проверки значений можно написать операторы `if` и `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="8162e-108">Если операторы совпадают, данные из этого значения извлекаются и используются.</span><span class="sxs-lookup"><span data-stu-id="8162e-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="8162e-109">Новые элементы синтаксиса — это расширения для операторов, с которыми вы уже знакомы: `is` и `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-109">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="8162e-110">В этих расширениях объединяются проверка значения и извлечение данных.</span><span class="sxs-lookup"><span data-stu-id="8162e-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="8162e-111">В данном разделе мы рассмотрим новый синтаксис и покажем, как с его помощью можно создавать удобочитаемый, краткий код.</span><span class="sxs-lookup"><span data-stu-id="8162e-111">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="8162e-112">Сопоставление шаблонов включает идиомы, в которых данные и код отделены, в отличие от объектно-ориентированных структур, в которых данные и методы манипуляции с данными тесно связаны.</span><span class="sxs-lookup"><span data-stu-id="8162e-112">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="8162e-113">Чтобы проиллюстрировать новые идиомы, поработаем со структурами, представляющими геометрические фигуры, применив операторы сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="8162e-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="8162e-114">Вы должны уже знать, как строить иерархии классов и создавать [виртуальные и переопределенные методы](methods.md#inherited) и настраивать поведение объектов исходя из их типа среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="8162e-114">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="8162e-115">Эти методы недоступны для данных, не структурированных в иерархии классов.</span><span class="sxs-lookup"><span data-stu-id="8162e-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="8162e-116">Если данные отделены от методов, вам потребуются другие инструменты.</span><span class="sxs-lookup"><span data-stu-id="8162e-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="8162e-117">Новые конструкции *сопоставления шаблонов* включают более четкий синтаксис для проверки данных и манипуляций с потоком управления с учетом условий этих данных.</span><span class="sxs-lookup"><span data-stu-id="8162e-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="8162e-118">Вы уже писали операторы `if` и `switch`, тестирующие значение переменной,</span><span class="sxs-lookup"><span data-stu-id="8162e-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="8162e-119">и операторы `is`, проверяющие тип переменной.</span><span class="sxs-lookup"><span data-stu-id="8162e-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="8162e-120">*Сопоставление шаблонов* расширяет возможности этих операторов.</span><span class="sxs-lookup"><span data-stu-id="8162e-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="8162e-121">В этом разделе мы создадим метод, вычисляющий площадь различных геометрических фигур.</span><span class="sxs-lookup"><span data-stu-id="8162e-121">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="8162e-122">Однако при этом мы не будем применять повторную сортировку в объектно-ориентированные методы и собирать иерархию классов для разных форм.</span><span class="sxs-lookup"><span data-stu-id="8162e-122">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="8162e-123">Вместо этого прибегнем к *сопоставлению шаблонов*.</span><span class="sxs-lookup"><span data-stu-id="8162e-123">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="8162e-124">Чтобы дополнительно подчеркнуть тот факт, что наследование не используется, каждая форма у нас будет не классом, а `struct`.</span><span class="sxs-lookup"><span data-stu-id="8162e-124">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="8162e-125">Обратите внимание на то, что разные типы `struct` не могут определять общий пользовательский базовый тип, поскольку наследование использовать нельзя.</span><span class="sxs-lookup"><span data-stu-id="8162e-125">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="8162e-126">Изучите этот пример и сравните код с его возможной структурой в виде иерархии объектов.</span><span class="sxs-lookup"><span data-stu-id="8162e-126">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="8162e-127">Данные, которые вам необходимо запрашивать и использовать при выполнении операций, не являются иерархией классов; сопоставление шаблонов позволяет создавать удобные структуры.</span><span class="sxs-lookup"><span data-stu-id="8162e-127">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="8162e-128">Вместо того, чтобы начать с абстрактного определения фигуры и добавления различных конкретных классов фигур, составим для каждой геометрической фигуры определения, содержащие только простые данные:</span><span class="sxs-lookup"><span data-stu-id="8162e-128">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="8162e-129">Опираясь на эти структуры, напишем метод, вычисляющий площадь определенной фигуры.</span><span class="sxs-lookup"><span data-stu-id="8162e-129">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="8162e-130">Выражение шаблона для типа `is`</span><span class="sxs-lookup"><span data-stu-id="8162e-130">The `is` type pattern expression</span></span>

<span data-ttu-id="8162e-131">До выхода C# 7.0 каждый тип необходимо было тестировать в ряде операторов `if` и `is`:</span><span class="sxs-lookup"><span data-stu-id="8162e-131">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="8162e-132">Приведенный выше код представляет собой классическое выражение *шаблона типа*: он тестирует переменную, чтобы определить ее тип, и выполняет различные действия с учетом этого типа.</span><span class="sxs-lookup"><span data-stu-id="8162e-132">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="8162e-133">Код упрощается за счет расширений, которые добавляются в выражение `is` для назначения переменной в случае успешного завершения теста:</span><span class="sxs-lookup"><span data-stu-id="8162e-133">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="8162e-134">В этой обновленной версии выражение `is` и проверяет переменную, и присваивает ее новой переменной соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="8162e-134">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="8162e-135">Обратите внимание также на то, что эта версия включает тип `Rectangle`, который представляет собой `struct`.</span><span class="sxs-lookup"><span data-stu-id="8162e-135">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="8162e-136">Новое выражение `is` работает и с типами значений, и со ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="8162e-136">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="8162e-137">Правила языка для выражений сопоставления шаблонов защищают от неправильного использования результатов примененного выражения match.</span><span class="sxs-lookup"><span data-stu-id="8162e-137">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="8162e-138">В приведенном выше примере переменные `s`, `c` и `r` находятся в области действия и назначаются явно, только если соответствующие выражения сопоставления шаблонов содержат результат `true`.</span><span class="sxs-lookup"><span data-stu-id="8162e-138">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="8162e-139">При попытке использовать одну из этих переменных в другом месте кода возникнут ошибки компилятора.</span><span class="sxs-lookup"><span data-stu-id="8162e-139">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="8162e-140">Рассмотрим оба эти правила подробно, начиная с области действия.</span><span class="sxs-lookup"><span data-stu-id="8162e-140">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="8162e-141">Переменная `c` находится в области действия только в ветви `else` первого оператора `if`.</span><span class="sxs-lookup"><span data-stu-id="8162e-141">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="8162e-142">Переменная `s` находится в области действия в методе `ComputeAreaModernIs`.</span><span class="sxs-lookup"><span data-stu-id="8162e-142">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="8162e-143">Это связано с тем, что каждая ветвь оператора `if` задает отдельную область действия для переменных.</span><span class="sxs-lookup"><span data-stu-id="8162e-143">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="8162e-144">Сам оператор `if` это не делает.</span><span class="sxs-lookup"><span data-stu-id="8162e-144">However, the `if` statement itself does not.</span></span> <span data-ttu-id="8162e-145">Это значит, что переменные, объявленные в операторе `if`, находятся в той же области действия, что и оператор `if` (в данном случае это метод). Такое поведение не связано с сопоставлением шаблонов, но представляет собой поведение, определенное для области действия переменных и операторов `if` и `else`.</span><span class="sxs-lookup"><span data-stu-id="8162e-145">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="8162e-146">Переменные `c` и `s` назначаются, если соответствующие операторы `if` имеют значение true, поскольку явно назначаются при использовании механизма true.</span><span class="sxs-lookup"><span data-stu-id="8162e-146">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="8162e-147">Примеры в этом разделе включают рекомендуемую конструкцию, в которой выражение сопоставления шаблонов `is` явно назначает переменную сопоставления в ветви `true` оператора `if`.</span><span class="sxs-lookup"><span data-stu-id="8162e-147">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="8162e-148">Эту логику можно изменить, указав `if (!(shape is Square s))`, после чего переменная `s` будет явно назначаться только в ветви `false`.</span><span class="sxs-lookup"><span data-stu-id="8162e-148">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="8162e-149">В C# это допустимо, но не рекомендуется, поскольку в этом случае логику проследить сложно.</span><span class="sxs-lookup"><span data-stu-id="8162e-149">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="8162e-150">Эти правила защищают от случайного доступа к результату выражения сопоставления шаблонов в отсутствие соответствия.</span><span class="sxs-lookup"><span data-stu-id="8162e-150">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="8162e-151">Использование операторов сопоставления шаблонов `switch`</span><span class="sxs-lookup"><span data-stu-id="8162e-151">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="8162e-152">Со временем вам может потребоваться поддержка других типов фигур.</span><span class="sxs-lookup"><span data-stu-id="8162e-152">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="8162e-153">Чем больше условий нужно проверять, тем более громоздкими становятся выражения сопоставления шаблонов `is`.</span><span class="sxs-lookup"><span data-stu-id="8162e-153">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="8162e-154">Кроме того, что для каждого проверяемого типа требуются операторы `if`, выражения `is` позволяют осуществлять тестирование, только если входные данные соответствуют одному типу.</span><span class="sxs-lookup"><span data-stu-id="8162e-154">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="8162e-155">В этом случае лучше отдать предпочтение выражениям сопоставления шаблонов `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-155">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="8162e-156">Традиционный оператор `switch` был выражением шаблона: он поддерживал шаблон константы.</span><span class="sxs-lookup"><span data-stu-id="8162e-156">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="8162e-157">Переменную можно сравнивать с любой константой в операторе `case`:</span><span class="sxs-lookup"><span data-stu-id="8162e-157">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="8162e-158">Единственным шаблоном, который поддерживался оператором `switch`, был шаблон константы.</span><span class="sxs-lookup"><span data-stu-id="8162e-158">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="8162e-159">Кроме того, он ограничивался числовыми типами и типом `string`.</span><span class="sxs-lookup"><span data-stu-id="8162e-159">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="8162e-160">Эти ограничения были устранены, и теперь оператор `switch` можно записывать, используя шаблон типа:</span><span class="sxs-lookup"><span data-stu-id="8162e-160">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="8162e-161">В операторе сопоставления шаблона `switch` используется синтаксис, знакомый тем разработчикам, которые имели дело с традиционным для C оператором `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-161">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="8162e-162">Вычисляется каждый оператор `case`, и выполняется код, лежащий в основе условия, которое соответствует входной переменной.</span><span class="sxs-lookup"><span data-stu-id="8162e-162">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="8162e-163">Выполнение кода не может передаваться из одного выражения в следующее; синтаксис оператора `case` требует, чтобы каждый оператор `case` всегда заканчивался на `break`, `return` или `goto`.</span><span class="sxs-lookup"><span data-stu-id="8162e-163">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="8162e-164">Операторы `goto` для перехода к другой метке доступны только для шаблона с константами (классический оператор switch).</span><span class="sxs-lookup"><span data-stu-id="8162e-164">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="8162e-165">Теперь оператор `switch` регулируют два новых правила.</span><span class="sxs-lookup"><span data-stu-id="8162e-165">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="8162e-166">Ограничения на тип переменной в выражении `switch` удалены.</span><span class="sxs-lookup"><span data-stu-id="8162e-166">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="8162e-167">Можно использовать любой тип, как, например, `object` в этом примере.</span><span class="sxs-lookup"><span data-stu-id="8162e-167">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="8162e-168">Выражения case больше не ограничиваются постоянными значениями.</span><span class="sxs-lookup"><span data-stu-id="8162e-168">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="8162e-169">Устранение этого ограничения означает, что изменение в порядке следования разделов `switch` может изменить поведение программы.</span><span class="sxs-lookup"><span data-stu-id="8162e-169">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="8162e-170">При ограничении постоянными значениями значению выражения `switch` может соответствовать только одна метка `case`.</span><span class="sxs-lookup"><span data-stu-id="8162e-170">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="8162e-171">В сочетании с правилом, запрещающим передавать все разделы `switch` в следующий раздел, это означало, что разделы `switch` можно было располагать в любом порядке, не влияя на поведение программы.</span><span class="sxs-lookup"><span data-stu-id="8162e-171">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="8162e-172">Теперь, когда выражения `switch` стали более обобщенными, порядок разделов имеет значение.</span><span class="sxs-lookup"><span data-stu-id="8162e-172">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="8162e-173">Выражения `switch` вычисляются в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="8162e-173">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="8162e-174">Выполнение переходит к первой метке `switch`, соответствующей выражению `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-174">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="8162e-175">Обратите внимание на то, что вариант `default` будет выполнен только в отсутствие совпадений с метками других вариантов.</span><span class="sxs-lookup"><span data-stu-id="8162e-175">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="8162e-176">Вариант `default` вычисляется последним, независимо от его текстуального порядка.</span><span class="sxs-lookup"><span data-stu-id="8162e-176">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="8162e-177">Если варианта `default` нет и ни с одним другим оператором `case` совпадение не обнаружено, выполнение продолжается с оператора, следующего за оператором `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-177">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="8162e-178">Ни один код с меткой `case` не выполняется.</span><span class="sxs-lookup"><span data-stu-id="8162e-178">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="8162e-179">Предложения `when` в выражениях `case`</span><span class="sxs-lookup"><span data-stu-id="8162e-179">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="8162e-180">Для фигур с нулевой площадью можно создать специальные варианты, вставив предложение `when` в метку `case`.</span><span class="sxs-lookup"><span data-stu-id="8162e-180">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="8162e-181">Квадрат с длиной стороны 0 или круг с радиусом 0 имеют нулевую площадь.</span><span class="sxs-lookup"><span data-stu-id="8162e-181">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="8162e-182">Это условие задается с помощью предложения `when` в метке `case`:</span><span class="sxs-lookup"><span data-stu-id="8162e-182">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="8162e-183">Это изменение демонстрирует несколько важных моментов, связанных с новым синтаксисом.</span><span class="sxs-lookup"><span data-stu-id="8162e-183">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="8162e-184">Во-первых, к одному разделу `switch` можно применить сразу несколько меток `case`.</span><span class="sxs-lookup"><span data-stu-id="8162e-184">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="8162e-185">Этот блок оператора выполняется, если одна из этих меток — `true`.</span><span class="sxs-lookup"><span data-stu-id="8162e-185">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="8162e-186">В данном случае если выражение `switch` представляет круг или квадрат с нулевой площадью, метод возвращает константу 0.</span><span class="sxs-lookup"><span data-stu-id="8162e-186">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="8162e-187">В этом примере представлены две различные переменные в двух метках `case` для первого блока `switch`.</span><span class="sxs-lookup"><span data-stu-id="8162e-187">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="8162e-188">Обратите внимание на то, что операторы в этом блоке `switch` не включают переменные `c` (для круга) или `s` (для квадрата).</span><span class="sxs-lookup"><span data-stu-id="8162e-188">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="8162e-189">Ни одна из этих переменных не назначается в этом блоке `switch` явно.</span><span class="sxs-lookup"><span data-stu-id="8162e-189">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="8162e-190">Разумеется, в случае совпадения с одним из вариантов одна из переменных назначается.</span><span class="sxs-lookup"><span data-stu-id="8162e-190">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="8162e-191">При этом сказать, *какая* из них была назначена во время компиляции, нельзя, поскольку во время выполнения возможно совпадение с любым из этих вариантов.</span><span class="sxs-lookup"><span data-stu-id="8162e-191">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="8162e-192">В связи с этим в большинстве случаев, когда для одного и того же блока задается сразу несколько меток `case`, новую переменную вводить в оператор `case` не следует, иначе будет использоваться только переменная в предложении `when`.</span><span class="sxs-lookup"><span data-stu-id="8162e-192">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="8162e-193">Теперь, когда мы добавили формы с нулевой площадью, добавим еще пару типов фигур — прямоугольник и треугольник:</span><span class="sxs-lookup"><span data-stu-id="8162e-193">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="8162e-194">Этот набор изменений добавляет метки `case` для вырожденного варианта, а также метки и блоки для каждой из новых фигур.</span><span class="sxs-lookup"><span data-stu-id="8162e-194">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="8162e-195">Наконец, можно добавить вариант `null`, чтобы в качестве аргумента не использовался `null`:</span><span class="sxs-lookup"><span data-stu-id="8162e-195">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="8162e-196">Особый случай с шаблоном `null` интересен тем, что константа `null` в этом шаблоне не имеет типа, но может быть преобразована в любой ссылочный тип или тип, допускающий значение NULL.</span><span class="sxs-lookup"><span data-stu-id="8162e-196">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="8162e-197">Вместо того, чтобы преобразовывать значение `null` в любой тип, в языке определяется, что значение `null` не будет соответствовать какому-либо шаблону типа, независимо от типа переменной во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="8162e-197">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="8162e-198">Такой подход позволяет обеспечить согласованность нового шаблона типа на основе `switch` с оператором `is`: операторы `is` всегда возвращают значение `false`, если проверяемое значение равно `null`.</span><span class="sxs-lookup"><span data-stu-id="8162e-198">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="8162e-199">Более того, это проще, поскольку после проверки типа не требуется дополнительно выполнять проверку на значения NULL.</span><span class="sxs-lookup"><span data-stu-id="8162e-199">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="8162e-200">Это видно из того факта, что в приведенном выше примере ни в одном блоке case не выполняется проверка на значения NULL. Это излишне, поскольку сопоставление с шаблоном типа уже гарантирует отсутствие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="8162e-200">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="8162e-201">Объявления `var` в выражениях `case`</span><span class="sxs-lookup"><span data-stu-id="8162e-201">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="8162e-202">Вследствие введения `var` в качестве одного из выражений сопоставления начинают действовать новые правила в отношении сопоставления шаблонов.</span><span class="sxs-lookup"><span data-stu-id="8162e-202">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="8162e-203">Первое правило заключается в том, что объявление `var` подчиняется обычным правилам определения типа: тип определяется как статический тип выражения выбора вариантов.</span><span class="sxs-lookup"><span data-stu-id="8162e-203">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="8162e-204">Согласно этому правилу, тип всегда является соответствующим.</span><span class="sxs-lookup"><span data-stu-id="8162e-204">From that rule, the type always matches.</span></span>

<span data-ttu-id="8162e-205">Второе правило заключается в том, что в объявлении `var` нет проверки значения NULL, которая предусмотрена в других выражениях шаблона для типа.</span><span class="sxs-lookup"><span data-stu-id="8162e-205">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="8162e-206">Это означает, что переменная может иметь значение NULL и в этом случае требуется проверка значения NULL.</span><span class="sxs-lookup"><span data-stu-id="8162e-206">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="8162e-207">Из этих двух правил следует, что во многих случаях объявление `var` в выражении `case` соответствует тем же условиям, что и выражение `default`.</span><span class="sxs-lookup"><span data-stu-id="8162e-207">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="8162e-208">Так как любой вариант, отличный от варианта по умолчанию, предпочтительнее варианта `default`, вариант `default` никогда не выполняется.</span><span class="sxs-lookup"><span data-stu-id="8162e-208">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="8162e-209">Компилятор не выдает предупреждения в случаях, когда вариант `default` записан, но не выполняется.</span><span class="sxs-lookup"><span data-stu-id="8162e-209">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="8162e-210">Это согласуется с текущим поведением оператора `switch`, когда перечислены все возможные варианты.</span><span class="sxs-lookup"><span data-stu-id="8162e-210">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="8162e-211">Третье правило относится к случаям, когда может быть полезен вариант `var`.</span><span class="sxs-lookup"><span data-stu-id="8162e-211">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="8162e-212">Предположим, производится сопоставление шаблона, причем входные данные представляют собой строку и нужно найти известные значения команд.</span><span class="sxs-lookup"><span data-stu-id="8162e-212">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="8162e-213">Код может выглядеть так:</span><span class="sxs-lookup"><span data-stu-id="8162e-213">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="8162e-214">Вариант `var` соответствует `null`, пустой строке или любой строке, которая содержит только пробелы.</span><span class="sxs-lookup"><span data-stu-id="8162e-214">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="8162e-215">Обратите внимание на то, что в приведенном выше коде используется оператор `?.`, чтобы случайно не произошло исключение <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="8162e-215">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="8162e-216">Вариант `default` обрабатывает все остальные строковые значения, которые не распознает этот анализатор команд.</span><span class="sxs-lookup"><span data-stu-id="8162e-216">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="8162e-217">Это один из примеров ситуации, в которой может требоваться выражение для варианта выбора `var`, отличное от выражения `default`.</span><span class="sxs-lookup"><span data-stu-id="8162e-217">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="8162e-218">Выводы</span><span class="sxs-lookup"><span data-stu-id="8162e-218">Conclusions</span></span>

<span data-ttu-id="8162e-219">*Конструкции сопоставления шаблонов* позволяют легко управлять потоком управления между различными переменными и типами, не связанными иерархией наследования.</span><span class="sxs-lookup"><span data-stu-id="8162e-219">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="8162e-220">Логику управления можно настроить на использование любого условия, которое вы тестируете в переменной.</span><span class="sxs-lookup"><span data-stu-id="8162e-220">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="8162e-221">Она включает шаблоны и идиомы, которые вам потребуются при создании более распределенных приложений, в которых данные и методы манипуляции этими данными разделены.</span><span class="sxs-lookup"><span data-stu-id="8162e-221">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="8162e-222">Как видите, структуры фигур в этом примере не включают никакие методы, только свойства, доступные исключительно для чтения.</span><span class="sxs-lookup"><span data-stu-id="8162e-222">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="8162e-223">Сопоставление шаблонов работает с любым типом данных.</span><span class="sxs-lookup"><span data-stu-id="8162e-223">Pattern Matching works with any data type.</span></span> <span data-ttu-id="8162e-224">Выражения записываются для изучения объекта и управления потоком управления решениями, которые принимаются на основе этих условий.</span><span class="sxs-lookup"><span data-stu-id="8162e-224">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="8162e-225">Сравните код из этого примера со структурой, которая начинается с создания иерархии классов для абстрактной фигуры `Shape` и ряда производных фигур, каждая из которых включает собственную реализацию виртуального метода для вычисления площади.</span><span class="sxs-lookup"><span data-stu-id="8162e-225">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="8162e-226">Выражения сопоставления шаблонов часто полезны при работе с данными, если аспекты хранилища данных необходимо отделить от аспектов поведения.</span><span class="sxs-lookup"><span data-stu-id="8162e-226">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

