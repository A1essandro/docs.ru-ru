---
title: "Кортежи | Руководство по C#"
description: "Сведения о типах именованных и неименованных кортежей в C#"
keywords: .NET, .NET Core, C#
author: BillWagner
ms-author: wiwagn
ms.date: 11/23/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.translationtype: Human Translation
ms.sourcegitcommit: 6b30f41e3fb07a962542a09a41c698efee7ebb5a
ms.openlocfilehash: 0ea7299d87dc69784e3bed93e48d83e4a0076a20
ms.contentlocale: ru-ru
ms.lasthandoff: 04/26/2017

---

# <a name="c-tuple-types"></a>Типы кортежей в C# #

Кортежи в C# — эти типы, которые определяются с помощью упрощенного синтаксиса. Преимущества: более простой синтаксис, правила преобразований с учетом количества (так называемой "арности") и типов полей, а также единые правила для копий и назначений. При этом кортежи не поддерживают некоторые объектно-ориентированные идиомы, связанные с наследованием. Общие сведения см. в подразделе "Кортежи" раздела [Новые возможности C# 7](whats-new/csharp-7.md#tuples).

В этом разделе вы узнаете, какие правила языка регулируют кортежи в C# 7 и каким образом их можно использовать, получите вводные рекомендации по работе с кортежами.

> [!NOTE]
> Для новых функций кортежа требуется тип `System.ValueTuple`. Для Visual Studio 2017 необходимо добавить пакет NuGet [System.ValueTuple](https://www.nuget.org/packages/System.ValueTuple/) из коллекции NuGet.
> Если этого не сделать, может возникать ошибка компиляции вида `error CS8179: Predefined type 'System.ValueTuple``2' is not defined or imported` или `error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found.`.

Для начала обсудим, почему была добавлена поддержка кортежей. Методы возвращают один объект. Кортежи позволяют легко упаковать в этот объект сразу несколько значений. 

Платформа .NET Framework уже включает универсальные классы `Tuple`, которые, однако, имеют два серьезных ограничения. Например, классы `Tuple` присваивают своим полям имена `Item1`, `Item2` и т. д. Никакой семантической информации в этих именах нет. Эти типы `Tuple` не позволяют сообщить пользователю значение каждого из полей. Другой недостаток связан с тем, что классы `Tuple` имеют ссылочный тип. При использовании типов `Tuple` происходит распределение объектов. В критических путях это может заметно влиять на производительность приложения.

Чтобы избежать этих недостатков, можно создать `class` или `struct`, включающие несколько полей. К сожалению, это означает дополнительную работу и искажает цель вашего проекта. Создание `struct` или `class` означает, что определение типа включает и данные, и поведение. Во многих случаях все, что вам нужно, — это сохранить в одном объекте несколько значений.

Новые возможности языка для работы с кортежами в комбинации с новым набором классов в инфраструктуре устраняют эти недостатки. В новых кортежах используются новые универсальные структуры `ValueTuple`. Как следует из названия, этот тип представляет собой `struct`, а не `class`. Для поддержки кортежей с различным количеством полей предусмотрены различные версии этой структуры. Новая языковая поддержка предоставляет семантические имена для полей типа кортежа, а также функции, упрощающие создание полей кортежа или доступ к этим полям.

Возможности языка и универсальные структуры `ValueTuple` обеспечивают соблюдение правила, запрещающего добавлять поведение (методы) в эти типы кортежей.
Все типы `ValueTuple` представляют собой *изменяемые структуры*. Все поля членов открыты, что делает их очень простыми. В то же время это означает, что кортежи не стоит использовать в случаях, когда важна неизменность.

Кортежи — это более простые и более гибкие контейнеры данных, чем типы `class` и `struct`. Рассмотрим эти различия.

## <a name="named-and-unnamed-tuples"></a>Именованные и неименованные кортежи

Структура `ValueTuple` включает поля с именами `Item1`, `Item2`, `Item3` и т. д., аналогичные свойствам, определенным в существующих типах `Tuple`.
Только эти имена можно использовать для *неименованных кортежей*. Если никакие альтернативные имена полей кортежу не предоставлены, значит, вы создали неименованный кортеж:

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple "Неименованный кортеж")]

В то же время при инициализации кортежа можно использовать новые возможности языка, позволяющие присваивать всем полям более понятные имена. При этом создается *именованный кортеж*.
Именованные кортежи тоже содержат имена с полями `Item1`, `Item2`, `Item3` и т. д.
В то же время у них есть синонимы для всех полей, которым вы присвоили имена.
Для создания именованного кортежа необходимо указать имя для каждого поля. Один из способов — указать имена в процессе инициализации кортежа:

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple "Именованный кортеж")]

Эти синонимы обрабатываются компилятором и языком, что позволяет эффективно использовать именованные кортежи. Интегрированные среды разработки и редакторы читают эти семантические имена с помощью API Roslyn. Это позволяет ссылаться на поля именованного кортежа по семантическим именам в любой части сборки. При создании компилированных выходных данных компилятор заменяет имена, определенные с помощью эквивалентов `Item*`. Скомпилированный MSIL не включает имена, которые вы присвоили этим полям. 

Компилятор должен передавать созданные вами имена для кортежей, возвращаемых открытыми методами и свойствами. В подобных случаях компилятор добавляет к методу атрибут `TupleElementNames`. Этот атрибут содержит свойство списка `TransformNames`, которое содержит имена, присвоенные каждому полю в кортеже. 

> [!NOTE]
> Средства разработки, такие как Visual Studio, также считывают эти метаданные и предоставляют IntelliSense и другие возможности, используя имена полей метаданных.

Знать основы работы с новыми кортежами и типом `ValueTuple` необходимо для того, чтобы понимать правила назначения именованных кортежей друг другу.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Язык поддерживает назначения между типами кортежей с одинаковым количеством полей и неявные преобразования типов для каждого из этих полей. Другие преобразования в контексте назначений не учитываются. Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation "Создание переменной")]

Первые две переменные, `unnamed` и `anonymous`, не имеют предоставленных полям семантических имен. Имена полей — `Item1` и `Item2`.
Последние две переменные, `named` и `differentName`, имеют предоставленные полям семантические имена. Обратите внимание на то, что поля в этих двух кортежах называются по-разному.

Все четыре этих кортежа имеют одинаковое число полей (так называемую "арность"), а типы этих полей идентичны. Таким образом, все эти назначения работают:

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment "Назначение переменной")]

Обратите внимание на то, что имена кортежей не назначаются. Значения полей назначаются в соответствии с порядком полей в кортеже.

Кортежи различных типов или с различным количеством полей не назначаются:

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Чаще всего кортежи используются как возвращаемое методом значение. Разберем конкретный пример. Рассмотрим метод, который вычисляет стандартное отклонение для последовательности чисел:

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation "Расчет стандартного отклонения")]

> [!NOTE]
> Код в этих примерах вычисляет стандартное отклонение неисправленной выборки.
> Формула стандартного отклонения исправленной выборки делит сумму квадратов разности со средним значением на (N-1), как и метод расширения `Average`. Дополнительные сведения о различиях между этими формулами для расчета стандартного отклонения см. в тексте по статистике.

Это соответствует учебной формуле для стандартного отклонения. Она позволяет получить правильный ответ, однако эта реализация крайне неэффективна. Этот метод перечисляет последовательность дважды: один раз для получения среднего, а второй — для получения среднего значения квадратов разницы со средним.
(Запомните, что запросы LINQ вычисляются в отложенном режиме, поэтому разница со средним значением и среднее этих разниц вычисляются в один прием.)

Существует альтернативная формула, которая вычисляет стандартное отклонение, используя только одно перечисление последовательности.  В результате этого вычисления выдаются два значения, поскольку оно перечисляет последовательность: сумма всех элементов в последовательности и сумма квадратов всех значений:

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula "Вычисление стандартного отклонения с использованием суммы квадратов")]

Эта версия перечисляет последовательность ровно один раз. В то же время этот код не слишком подходит для повторного использования. По мере работы вы узнаете, что во многих статистических вычислениях используется число элементов в последовательности, сумма последовательности и сумма квадратов последовательности. Выполним рефакторинг этого метода и напишем служебный метод, выдающий все три из этих значений.

Именно в этом случае удобно использовать кортеж. 

Обновим этот метод таким образом, чтобы все три значения, вычисляемые при перечислении, сохранялись в кортеж. В результате создается следующая версия:

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion "Выполнение рефакторинга для использования кортежей")]

Поддержка рефакторинга в Visual Studio позволяет легко извлекать функции основной статистики в закрытый метод. В результате вы получаете метод `private static`, возвращающий тип кортежа с тремя значениями — `Sum`, `SumOfSquares` и `Count`:

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion "После извлечения служебного метода")]
 
Язык позволяет использовать несколько дополнительных параметров, с помощью которых можно внести несколько быстрых изменений вручную. Во-первых, объявление `var` можно использовать для инициализации результата кортежа из вызова метода `ComputeSumAndSumOfSquares`. Кроме того, в методе `ComputeSumAndSumOfSquares` можно создать три дискретные переменные. Окончательная версия показана ниже:

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion "После итоговой очистки")]

Окончательную версию можно применять к любому методу, которому требуются эти три значения, а также к любому их подмножеству.

Язык поддерживает другие параметры управления именами полей в методах, возвращающих кортежи.

Имена полей можно удалить из объявления возвращаемого значения и вернуть неименованный кортеж:

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

К полям этого кортежа можно обращаться по именам `Item1`, `Item2` и `Item3`.
Для полей кортежей, возвращаемых из методов, рекомендуется указывать семантические имена.

Еще одна идиома, в которой могут пригодиться кортежи, — это создание запросов LINQ, итоговым результатом которых является проекция, содержащая некоторые, но не все свойства выбранных объектов.

Обычно результаты запроса проецируются в последовательность объектов анонимного типа. С этим связано множество ограничений, в первую очередь потому, что анонимным типам нельзя присваивать удобные имена в возвращаемом типе для метода. Альтернативные варианты с типом результата `object` или `dynamic` вызывают серьезные потери в производительности.

Выполнить возврат последовательности с типом кортежа легко, а имена и типы полей можно получить во время компиляции и с помощью средств IDE.
В качестве примера рассмотрим приложение ToDo. Определите класс следующего вида — он будет представлять одну запись в списке дел ToDo:

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem "Пункт в списке дел")]

Мобильные приложения могут поддерживать компактную форму текущих пунктов в списке дел, когда отображается только заголовок. Этот запрос LINQ выполняет проекцию, включающую только идентификатор и заголовок. Эту модель очень хорошо демонстрирует метод, возвращающий последовательность кортежей:

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple "Запрос, возвращающий кортеж")]

Именованный кортеж может быть частью сигнатуры. Это позволяет компилятору и средствам IDE статически проверять, правильно ли используются результаты. Именованный кортеж также несет в себе данные статического типа, избавляя от необходимости использовать для работы с результатами дорогостоящие функции среды выполнения, такие как отражение или динамическая привязка.

## <a name="deconstruction"></a>Деконструкция

Все элементы в кортеже можно распаковать, выполнив *деконструкцию* возвращаемого методом кортежа. Деконструкцию кортежей можно выполнять двумя различными способами.  Во-первых, можно явно объявить тип каждого поля, заключив его в круглые скобки, чтобы создать дискретные переменные для каждого поля в кортеже:

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct "Деконструкция")]

Типизированные переменные для каждого поля в кортеже можно также объявить неявно, используя ключевое слово `var` за скобками:

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar "Деконструкция в переменную")]

Кроме того, в объявлении одной или всех переменных можно также свободно использовать ключевое слово `var`, заключив его в скобки. 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```
Обратите внимание на то, что определенный тип использовать за скобками нельзя, даже если каждое поле в кортеже имеет одинаковый тип.

### <a name="deconstructing-user-defined-types"></a>Деконструкция пользовательских типов

Любой тип кортежа можно деконструировать, как показано выше. Деконструкцию можно легко активировать для любого пользовательского типа (классов, структур и даже интерфейсов).

Автор типа может определить один или несколько методов `Deconstruct`, присваивающих значения любому количеству переменных `out`, которые представляют составляющие этот тип элементы данных. Например, следующий тип `Person` определяет метод `Deconstruct`, который деконструирует объект person в поля, представляющие имя и фамилию:

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod "Тип с методом deconstruct")]

Метод deconstruct позволяет выполнять назначение из объекта `Person` в две строки, представляющие свойства `FirstName` и `LastName`:

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType "Деконструкция типа класса")]

Вы можете включить деконструкцию даже для типов, которые не создавали.
Метод `Deconstruct` может быть методом расширения, который распаковывает доступные элементы данных в объекте. В следующем примере показан тип `Student`, производный от типа `Person`, и метод расширения, который разбивает `Student` на три переменные, представляющие `FirstName`, `LastName` и `GPA`:

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod "Тип с методом расширения deconstruct")]

Теперь у объекта `Student` есть два доступных метода `Deconstruct`: метод расширения, объявленный для типов `Student`, и элемент типа `Person`. Оба из них входят в область, что позволяет разбить `Student` либо на две, либо на три переменные.
Если учащийся назначается трем переменным, возвращается все — имя, фамилия и GPA. Если учащийся назначается двум переменным, возвращаются только имя и фамилия.

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension "Деконструкция типа класса с использованием метода расширения")]

Определять нескольких методов `Deconstruct` в классе или иерархии классов необходимо очень осторожно. Несколько методов `Deconstruct` с одинаковым числом параметров `out` могут быстро вызвать неоднозначность. В итоге вызывающие объекты могут лишиться возможности вызвать желаемый метод `Deconstruct`.

В этом примере вероятность неоднозначного вызова минимальна, поскольку метод `Deconstruct` для `Person` имеет два параметра вывода, а метод `Deconstruct` для `Student` — три.

## <a name="conclusion"></a>Заключение 

Добавленная в язык и библиотеку поддержка именованных кортежей значительно упрощает работу с проектами, в которых используются структуры данных, хранящие несколько полей, но не определяющие поведение подобно классам или структурам. Для этих типов удобно использовать кортежи. Они дают вам все преимущества статической поддержки типов и в то же время избавляют от необходимости создавать типы с использованием более подробного синтаксиса `class` или `struct`. И все же наибольшую пользу они приносят при использовании со служебными методами, имеющими атрибут `private` или `internal`. Создавайте пользовательские типы, `class` или `struct`, если ваши открытые методы возвращают значение с несколькими полями.

