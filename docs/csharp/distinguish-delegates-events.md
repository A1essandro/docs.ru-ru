---
title: "Различия между делегатами и событиями"
description: "Сведения о различиях между делегатами и событиями, а также о том, когда следует использовать каждый из этих компонентов в .NET Core."
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 3026a0d853cb17dcf05d3b98d814044d743e48dc
ms.contentlocale: ru-ru
ms.lasthandoff: 07/28/2017

---

# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="aebdf-104">Различия между делегатами и событиями</span><span class="sxs-lookup"><span data-stu-id="aebdf-104">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="aebdf-105">Назад</span><span class="sxs-lookup"><span data-stu-id="aebdf-105">Previous</span></span>](modern-events.md)

<span data-ttu-id="aebdf-106">Разработчики, не имеющие опыта работы с платформой .NET Core, часто не могут решить, что следует выбрать: структуру на основе `delegates` или на основе `events`.</span><span class="sxs-lookup"><span data-stu-id="aebdf-106">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="aebdf-107">Это сложный вопрос, так как эти две возможности языка очень похожи.</span><span class="sxs-lookup"><span data-stu-id="aebdf-107">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="aebdf-108">Более того, события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.</span><span class="sxs-lookup"><span data-stu-id="aebdf-108">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="aebdf-109">И те и другие обеспечивают сценарии позднего связывания, в которых взаимодействие компонента осуществляется путем вызова метода, известного только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="aebdf-109">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="aebdf-110">И те и другие поддерживают методы с одним или несколькими подписчиками.</span><span class="sxs-lookup"><span data-stu-id="aebdf-110">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="aebdf-111">Иногда это называют поддержкой одноадресности и многоадресности.</span><span class="sxs-lookup"><span data-stu-id="aebdf-111">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="aebdf-112">Синтаксис добавления и удаления обработчиков в обоих случаях похож.</span><span class="sxs-lookup"><span data-stu-id="aebdf-112">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="aebdf-113">Наконец, при вызове событий и делегатов используется абсолютно одинаковый синтаксис вызова методов.</span><span class="sxs-lookup"><span data-stu-id="aebdf-113">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="aebdf-114">Более того, поддерживается одинаковый синтаксис метода `Invoke()` для использования с оператором `?.`.</span><span class="sxs-lookup"><span data-stu-id="aebdf-114">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="aebdf-115">Учитывая такое сходство, легко могут возникнуть проблемы с выбором подходящего механизма в той или иной ситуации.</span><span class="sxs-lookup"><span data-stu-id="aebdf-115">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="aebdf-116">Прослушивание событий необязательно</span><span class="sxs-lookup"><span data-stu-id="aebdf-116">Listening to Events is Optional</span></span>

<span data-ttu-id="aebdf-117">Самым важным фактором при выборе подходящего механизма является обязательность наличия подключенного подписчика.</span><span class="sxs-lookup"><span data-stu-id="aebdf-117">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="aebdf-118">Если ваш код должен вызывать код, предоставленный подписчиком, следует использовать структуру на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="aebdf-118">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="aebdf-119">Если код может выполнить все задачи, не вызывая подписчики, следует использовать структуру на основе событий.</span><span class="sxs-lookup"><span data-stu-id="aebdf-119">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="aebdf-120">Обратите внимание на примеры, рассматривавшиеся в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="aebdf-120">Consider the examples built during this section.</span></span> <span data-ttu-id="aebdf-121">Код, который вы создавали с помощью `List.Sort()`, должен содержать функцию сравнения для правильной сортировки элементов.</span><span class="sxs-lookup"><span data-stu-id="aebdf-121">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="aebdf-122">Запросам LINQ необходимо предоставить делегаты для определения элементов, которые следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="aebdf-122">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="aebdf-123">В обоих случаях использовалась структура на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="aebdf-123">Both used a design built with delegates.</span></span>

<span data-ttu-id="aebdf-124">Рассмотрим событие `Progress`.</span><span class="sxs-lookup"><span data-stu-id="aebdf-124">Consider the `Progress` event.</span></span> <span data-ttu-id="aebdf-125">Оно сообщает о ходе выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="aebdf-125">It reports progress on a task.</span></span>
<span data-ttu-id="aebdf-126">Задача продолжает выполняться вне зависимости от того, есть ли прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="aebdf-126">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="aebdf-127">Еще один пример — `FileSearcher`.</span><span class="sxs-lookup"><span data-stu-id="aebdf-127">The `FileSearcher` is another example.</span></span> <span data-ttu-id="aebdf-128">Нахождение всех искомых файлов производится, даже если не подключены обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="aebdf-128">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="aebdf-129">Элементы управления UX продолжают работать правильно, даже если нет подписчиков, прослушивающих события.</span><span class="sxs-lookup"><span data-stu-id="aebdf-129">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="aebdf-130">В обоих примерах используются структуры на основе событий.</span><span class="sxs-lookup"><span data-stu-id="aebdf-130">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="aebdf-131">Для возвращаемых значений требуются делегаты</span><span class="sxs-lookup"><span data-stu-id="aebdf-131">Return Values Require Delegates</span></span>

<span data-ttu-id="aebdf-132">Еще одним аспектом является прототип метода, который требуется для метода делегата.</span><span class="sxs-lookup"><span data-stu-id="aebdf-132">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="aebdf-133">Как вы уже видели, все делегаты, используемые для событий, имеют тип возвращаемого значения void.</span><span class="sxs-lookup"><span data-stu-id="aebdf-133">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="aebdf-134">Вы уже также знаете, что есть идиомы для создания обработчиков событий, которые передают информацию обратно источникам событий, изменяя свойства объекта аргумента события.</span><span class="sxs-lookup"><span data-stu-id="aebdf-134">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="aebdf-135">Хотя такие идиомы работают, они не так естественны, как возвращение значения из метода.</span><span class="sxs-lookup"><span data-stu-id="aebdf-135">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="aebdf-136">Обратите внимание на то, что часто используются оба этих эвристических метода: если метод делегата возвращает значение, то оно, скорее всего, будет каким-либо образом влиять на алгоритм.</span><span class="sxs-lookup"><span data-stu-id="aebdf-136">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="aebdf-137">Прослушиватели событий часто имеют более длительный срок существования</span><span class="sxs-lookup"><span data-stu-id="aebdf-137">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="aebdf-138">Это не столь важный фактор.</span><span class="sxs-lookup"><span data-stu-id="aebdf-138">This is a slightly weaker justification.</span></span> <span data-ttu-id="aebdf-139">Однако структура на основе событий может оказаться более естественной, когда источник событий инициирует события в течение длительного периода времени.</span><span class="sxs-lookup"><span data-stu-id="aebdf-139">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="aebdf-140">Примерами могут служить элементы управления UX во многих системах.</span><span class="sxs-lookup"><span data-stu-id="aebdf-140">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="aebdf-141">После подписания на событие источник события может вызывать события в течение всего времени существования программы.</span><span class="sxs-lookup"><span data-stu-id="aebdf-141">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="aebdf-142">(Когда события больше не нужны, вы можете отменить подписку на них.)</span><span class="sxs-lookup"><span data-stu-id="aebdf-142">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="aebdf-143">Сравните это с часто встречающимися структурами на основе делегатов, когда делегат применяется в качестве аргумента метода и не используется после того, как метод возвращает управление.</span><span class="sxs-lookup"><span data-stu-id="aebdf-143">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="aebdf-144">Тщательно оценивайте ситуацию</span><span class="sxs-lookup"><span data-stu-id="aebdf-144">Evaluate Carefully</span></span>

<span data-ttu-id="aebdf-145">Приведенные выше указания не являются строгими правилами.</span><span class="sxs-lookup"><span data-stu-id="aebdf-145">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="aebdf-146">Они представляют собой лишь рекомендации, которые могут помочь вам выбрать правильный вариант в конкретном случае.</span><span class="sxs-lookup"><span data-stu-id="aebdf-146">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="aebdf-147">Так как эти механизмы схожи, вы можете смоделировать и тот и другой, чтобы проверить, какой из них окажется естественнее.</span><span class="sxs-lookup"><span data-stu-id="aebdf-147">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="aebdf-148">Оба они хорошо подходят для сценариев с поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="aebdf-148">They both handle late binding scenarios well.</span></span> <span data-ttu-id="aebdf-149">Используйте тот механизм, который лучше соответствует вашим требованиям.</span><span class="sxs-lookup"><span data-stu-id="aebdf-149">Use the one that communicates your design the best.</span></span>

