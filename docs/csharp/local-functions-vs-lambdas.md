---
title: "Локальные функции или лямбда-выражения"
description: "Узнайте, чем локальные функции могут быть лучше лямбда-выражений."
keywords: "C# .NET, .NET Core, новейшие возможности, новые локальные функции, лямбда-выражения"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: visual-studio-dev-15
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.translationtype: HT
ms.sourcegitcommit: 4582cb0ee091526423cce3fc1d8243029f34f59c
ms.openlocfilehash: 366d7465433f2786960e22418b8aa46ba10e1fd1
ms.contentlocale: ru-ru
ms.lasthandoff: 08/16/2017

---

### <a name="local-functions-compared-to-lambda-expressions"></a>Сравнение локальных функций и лямбда-выражений

На первый взгляд [локальные функции](programming-guide/classes-and-structs/local-functions.md) и [лямбда-выражения](lambda-expressions.md) во многом похожи.
В зависимости от ваших требований локальные функции зачастую позволяют реализовать более простое и эффективное решение.

Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения. В первой версии используется локальная функция:

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Рекурсивный факториал с использованием локальной функции")]

Сравните эту реализацию с версией, в которой используются лямбда-выражения:

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Рекурсивный факториал с использованием лямбда-выражений")]

Во-первых, лямбда-выражения реализуются путем создания экземпляра делегата и вызова этого делегата. Локальные функции реализуются как вызовы методов.
Создание экземпляра, необходимое для лямбда-выражений, означает выделение дополнительной памяти, что в критически важном коде может ухудшить производительность.
Локальные функции не создают этой перегрузки. В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.

Этот рекурсивный метод настолько прост, что локальная функция реализуется в виде частного метода, имя которого создается компилятором. Единственное отличие от частных методов заключается в том, что семантическая область действия в этом случае находится внутри внешней функции.

Во-вторых, локальные функции можно вызывать до того, как они будут определены. Лямбда-выражения перед определением необходимо объявлять. Это значит, что локальные функции проще использовать в рекурсивных алгоритмах, как показано выше.

Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить. В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.
Рекурсивные алгоритмы легче создавать, используя локальные функции.

В-третьих, для лямбда-выражений компилятору необходимо всегда создавать анонимный класс и экземпляр этого класса, в котором будут храниться все переменные, попавшие в замыкание. Рассмотрим следующий асинхронный пример:

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Метод с лямбда-выражением, возвращающий задачу")]

Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`. При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`. Это позволит сократить объем выделяемой памяти.

> [!NOTE]
> В эквивалентном этому методе на основе локальной функции также используется класс для замыкания. Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации. Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Метод с локальной функцией, возвращающий задачу")]

Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.

Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.
Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.

