---
title: "Локальные функции или лямбда-выражения"
description: "Узнайте, чем локальные функции могут быть лучше лямбда-выражений."
keywords: "C# .NET, .NET Core, новейшие возможности, новые локальные функции, лямбда-выражения"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a>Локальные функции по сравнению с лямбда-выражения

На первый взгляд [локальные функции](programming-guide/classes-and-structs/local-functions.md) и [лямбда-выражения](lambda-expressions.md) во многом похожи. Во многих случаях выбор между использованием лямбда-выражения и локальные функции сводится к стилю, языку и предпочтениями. Однако различаются реальные где можно использовать одно из них следует обратить внимание.

Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения. В первой версии используется локальная функция:

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

Сравните эту реализацию с версией, в которой используются лямбда-выражения:

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

Локальные функции имеют имена. Лямбда-выражения являются анонимных методов, которые назначаются переменным, `Func` или `Action` типов. При объявлении локальной функции, типы аргументов и тип возвращаемого значения являются частью объявления функции. А не часть тела лямбда-выражения, выражения, типы аргументов и тип возвращаемого значения являются частью объявления переменной типа лямбда-выражение. Эти два различия может привести к более четкое кода.

Локальные функции имеют различные правила для определенного присваивания, чем лямбда-выражения. Локальное объявление функции можно ссылаться из любого места кода, где он находится в области. Лямбда-выражение, которое должно быть определено переменной делегата, до его можно получить доступ к (или вызывать через delgate, ссылающиеся на лямбда-выражения.) Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить. В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.
Эти различия означают, что рекурсивных алгоритмов проще создавать, используя локальные функции. Можно объявить и определить локальный функцию, которая вызывает саму себя. Лямбда-выражения должно быть объявлено и присвоено значение по умолчанию, прежде чем они могут быть переназначены текст, который ссылается на одном лямбда-выражение.

Правила определенного присваивания также влияют на все переменные, которые были зарегистрированы в локальном epression функции или лямбда-выражение. Локальные функции и лямбда-выражение выражение правила требовать, что все переменные, захваченные определенно назначаются в точке при локальной функции или лямбда-выражение преобразуется в делегат. Разница заключается в том, что лямбда-выражения преобразуются в делегатов, когда они объявлены. Локальные функции преобразуются в делегаты только в том случае, если использовать в качестве делегата. Если объявить локальную функцию и ссылаться только путем вызова его как метод, он не преобразуются в делегат. Это правило позволяет объявить локальную функцию в любом удобном месте в включающей его области. Объявите локальные функции в конце родительского метода после любой инструкции return чаще.

В-третьих компилятор может выполнять статического анализа, позволяющий локальные функции для явного присвоения захваченным переменным во внешней области. Рассмотрим следующий пример.

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

Компилятор может определить, что `Local` определенно назначает `y` при вызове. Поскольку `Local` вызывается перед `return` инструкции `y` definitiely назначен в `return` инструкции.

Анализ, позволяющий, что анализ позволяет четвертый разницу.
В зависимости от их использования локальные функции можно избежать выделений кучи, которые всегда необходимы для лямбда-выражения. Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченные локальная функция захватывается другими лямбда-выражения или локальные функции, которые преобразуются в делегаты, компилятор может избежать выделений памяти в куче. 

Рассмотрим следующий асинхронный пример:

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`. При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`. Структура типа будут передаваться по ссылке на локальные функции. Эта разница в реализации сэкономить на выделение.

При создании экземпляра, необходимые для лямбда-выражений означает выделения дополнительной памяти, которых может быть коэффициент производительности в путях срочного кода.
Локальные функции не создают этой перегрузки. В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.

> [!NOTE]
> В эквивалентном этому методе на основе локальной функции также используется класс для замыкания. Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации. Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений. `yield return` В лямбда-выражениях не допускаются.

Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.
Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.
