---
title: "Локальные функции или лямбда-выражения"
description: "Узнайте, чем локальные функции могут быть лучше лямбда-выражений."
keywords: "C# .NET, .NET Core, новейшие возможности, новые локальные функции, лямбда-выражения"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="239fb-104">Локальные функции по сравнению с лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="239fb-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="239fb-105">На первый взгляд [локальные функции](programming-guide/classes-and-structs/local-functions.md) и [лямбда-выражения](lambda-expressions.md) во многом похожи.</span><span class="sxs-lookup"><span data-stu-id="239fb-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="239fb-106">Во многих случаях выбор между использованием лямбда-выражения и локальные функции сводится к стилю, языку и предпочтениями.</span><span class="sxs-lookup"><span data-stu-id="239fb-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="239fb-107">Однако различаются реальные где можно использовать одно из них следует обратить внимание.</span><span class="sxs-lookup"><span data-stu-id="239fb-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="239fb-108">Рассмотрим различия в реализации алгоритма вычисления факториала с использованием локальной функции и лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="239fb-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="239fb-109">В первой версии используется локальная функция:</span><span class="sxs-lookup"><span data-stu-id="239fb-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="239fb-110">Сравните эту реализацию с версией, в которой используются лямбда-выражения:</span><span class="sxs-lookup"><span data-stu-id="239fb-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="239fb-111">Локальные функции имеют имена.</span><span class="sxs-lookup"><span data-stu-id="239fb-111">The local functions have names.</span></span> <span data-ttu-id="239fb-112">Лямбда-выражения являются анонимных методов, которые назначаются переменным, `Func` или `Action` типов.</span><span class="sxs-lookup"><span data-stu-id="239fb-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="239fb-113">При объявлении локальной функции, типы аргументов и тип возвращаемого значения являются частью объявления функции.</span><span class="sxs-lookup"><span data-stu-id="239fb-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="239fb-114">А не часть тела лямбда-выражения, выражения, типы аргументов и тип возвращаемого значения являются частью объявления переменной типа лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="239fb-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="239fb-115">Эти два различия может привести к более четкое кода.</span><span class="sxs-lookup"><span data-stu-id="239fb-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="239fb-116">Локальные функции имеют различные правила для определенного присваивания, чем лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="239fb-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="239fb-117">Локальное объявление функции можно ссылаться из любого места кода, где он находится в области.</span><span class="sxs-lookup"><span data-stu-id="239fb-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="239fb-118">Лямбда-выражение, которое должно быть определено переменной делегата, до его можно получить доступ к (или вызывать через delgate, ссылающиеся на лямбда-выражения.) Обратите внимание на то, что версия с использованием лямбда-выражения должна объявить и инициализировать лямбда-выражение `nthFactorial`, прежде чем его определить.</span><span class="sxs-lookup"><span data-stu-id="239fb-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="239fb-119">В противном случае возникает ошибка компилятора, связанная со ссылкой на объект `nthFactorial`, который еще не был назначен.</span><span class="sxs-lookup"><span data-stu-id="239fb-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="239fb-120">Эти различия означают, что рекурсивных алгоритмов проще создавать, используя локальные функции.</span><span class="sxs-lookup"><span data-stu-id="239fb-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="239fb-121">Можно объявить и определить локальный функцию, которая вызывает саму себя.</span><span class="sxs-lookup"><span data-stu-id="239fb-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="239fb-122">Лямбда-выражения должно быть объявлено и присвоено значение по умолчанию, прежде чем они могут быть переназначены текст, который ссылается на одном лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="239fb-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="239fb-123">Правила определенного присваивания также влияют на все переменные, которые были зарегистрированы в локальном epression функции или лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="239fb-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="239fb-124">Локальные функции и лямбда-выражение выражение правила требовать, что все переменные, захваченные определенно назначаются в точке при локальной функции или лямбда-выражение преобразуется в делегат.</span><span class="sxs-lookup"><span data-stu-id="239fb-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="239fb-125">Разница заключается в том, что лямбда-выражения преобразуются в делегатов, когда они объявлены.</span><span class="sxs-lookup"><span data-stu-id="239fb-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="239fb-126">Локальные функции преобразуются в делегаты только в том случае, если использовать в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="239fb-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="239fb-127">Если объявить локальную функцию и ссылаться только путем вызова его как метод, он не преобразуются в делегат.</span><span class="sxs-lookup"><span data-stu-id="239fb-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="239fb-128">Это правило позволяет объявить локальную функцию в любом удобном месте в включающей его области.</span><span class="sxs-lookup"><span data-stu-id="239fb-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="239fb-129">Объявите локальные функции в конце родительского метода после любой инструкции return чаще.</span><span class="sxs-lookup"><span data-stu-id="239fb-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="239fb-130">В-третьих компилятор может выполнять статического анализа, позволяющий локальные функции для явного присвоения захваченным переменным во внешней области.</span><span class="sxs-lookup"><span data-stu-id="239fb-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="239fb-131">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="239fb-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="239fb-132">Компилятор может определить, что `Local` определенно назначает `y` при вызове.</span><span class="sxs-lookup"><span data-stu-id="239fb-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="239fb-133">Поскольку `Local` вызывается перед `return` инструкции `y` definitiely назначен в `return` инструкции.</span><span class="sxs-lookup"><span data-stu-id="239fb-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="239fb-134">Анализ, позволяющий, что анализ позволяет четвертый разницу.</span><span class="sxs-lookup"><span data-stu-id="239fb-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="239fb-135">В зависимости от их использования локальные функции можно избежать выделений кучи, которые всегда необходимы для лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="239fb-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="239fb-136">Если локальная функция никогда не преобразуется в делегат и ни одна из переменных, захваченные локальная функция захватывается другими лямбда-выражения или локальные функции, которые преобразуются в делегаты, компилятор может избежать выделений памяти в куче.</span><span class="sxs-lookup"><span data-stu-id="239fb-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="239fb-137">Рассмотрим следующий асинхронный пример:</span><span class="sxs-lookup"><span data-stu-id="239fb-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="239fb-138">Замыкание для этого лямбда-выражения содержит переменные `address`, `index` и `name`.</span><span class="sxs-lookup"><span data-stu-id="239fb-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="239fb-139">При использовании локальных функций объект, который реализует замыкание, может иметь тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="239fb-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="239fb-140">Структура типа будут передаваться по ссылке на локальные функции.</span><span class="sxs-lookup"><span data-stu-id="239fb-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="239fb-141">Эта разница в реализации сэкономить на выделение.</span><span class="sxs-lookup"><span data-stu-id="239fb-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="239fb-142">При создании экземпляра, необходимые для лямбда-выражений означает выделения дополнительной памяти, которых может быть коэффициент производительности в путях срочного кода.</span><span class="sxs-lookup"><span data-stu-id="239fb-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="239fb-143">Локальные функции не создают этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="239fb-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="239fb-144">В приведенном выше примере в версии с локальной функцией используется на 2 меньше операции выделения памяти по сравнению с версией на основе лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="239fb-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="239fb-145">В эквивалентном этому методе на основе локальной функции также используется класс для замыкания.</span><span class="sxs-lookup"><span data-stu-id="239fb-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="239fb-146">Реализация замыкания для локальной функции в формате `class` или `struct` зависит от особенностей реализации.</span><span class="sxs-lookup"><span data-stu-id="239fb-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="239fb-147">Локальная функция может использовать `struct`, тогда как в лямбда-выражениях всегда используется `class`.</span><span class="sxs-lookup"><span data-stu-id="239fb-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="239fb-148">Еще одно преимущество локальных функций, которое не показано в этом примере, заключается в том, что они могут быть реализованы в качестве итераторов с использованием синтаксиса `yield return` для создания последовательности значений.</span><span class="sxs-lookup"><span data-stu-id="239fb-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="239fb-149">`yield return` В лямбда-выражениях не допускаются.</span><span class="sxs-lookup"><span data-stu-id="239fb-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="239fb-150">Локальные функции могут показаться избыточными для лямбда-выражений, поскольку обычно применяются иначе и в других целях.</span><span class="sxs-lookup"><span data-stu-id="239fb-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="239fb-151">Локальные функции более эффективны в случаях, когда вам нужно написать функцию, которая будет вызываться только из контекста другого метода.</span><span class="sxs-lookup"><span data-stu-id="239fb-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
