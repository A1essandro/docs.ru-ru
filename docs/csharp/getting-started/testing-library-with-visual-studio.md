---
title: "Тестирование библиотеки классов с помощью .NET Core в Visual Studio 2017"
description: "Сведения о тестировании библиотеки классов, написанной на языке C#, с помощью Visual Studio 2017"
keywords: ".NET Core, библиотека стандартных классов .NET, Visual Studio 2017, модульное тестирование"
author: stevehoag
ms.author: shoag
ms.date: 11/16/2016
ms.topic: article
ms.prod: .net-core
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 069ad711-3eaa-45c6-94d7-b40249cc8b99
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: ee21799706b971f0ec13285b0771b32b4367f570
ms.lasthandoff: 03/13/2017

---

# <a name="testing-a-class-library-with-net-core-in-visual-studio-2017"></a>Тестирование библиотеки классов с помощью .NET Core в Visual Studio 2017 #

В статье [Building a class library with C# and .NET Core in Visual Studio 2017](library-with-visual-studio-2017.md) (Создание библиотеки классов для C# и .NET Core в Visual Studio 2017) мы уже создали простую библиотеку классов, которая добавляет метод расширения к классу @System.String. Теперь мы создадим модульный тест и убедимся, что все работает правильно. Новый проект модульного теста мы добавим к решению, созданному в предыдущей статье.

## <a name="creating-a-unit-test-project"></a>Создание проекта модульного теста ##

Чтобы создать проект модульного теста, выполните следующие действия.

1. В обозревателе решений откройте контекстное меню для узла решения **ClassLibraryProject** и выберите в нем **Добавить**, **Новый проект**.

   <!-- Need a VS 2017 version  [!NOTE] In addition to a Unit Test project, you can also use Visual Studio to create an XUnit test project for .NET Core. For a walkthrough that includes an XUnit test project, see [Getting started with .NET Core on Windows, using Visual Studio 2015](../../core/tutorials/using-on-windows.md). --> 

1. В диалоговом окне **Добавление нового проекта** разверните узлы **Visual C#** и **.NET Core**, затем выберите шаблон проекта **Проект модульного теста (.NET Core)** и присвойте ему имя `StringLibraryTest`, как показано на следующем рисунке.

   ![Изображение](./media/testproject.jpg)

1. Нажмите кнопку **ОК**, чтобы создать проект. Visual Studio создаст проект и откроет файл `UnitTest1.cs` в окне кода, как показано на следующем рисунке.

   ![Изображение](./media/unit_test_code_window.jpg)

   Исходный код, созданный шаблоном модульного теста, выполняет следующие действия.

   - Он импортирует пространство имен [Microsoft.VisualStudio.TestTools.UnitTesting](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.aspx), которое содержит типы, используемые для модульного тестирования.

   - Он применяет атрибут [\[TestClass\]](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.testclassattribute.aspx) к классу `UnitTest1`. При запуске модульного теста будут автоматически выполняться все методы теста в тестовом классе, помеченные атрибутом \[TestMethod\].

   - Он применяет атрибут [\[TestMethod\]](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.testmethodattribute.aspx) к `TestMethod1`, чтобы обозначить его как метод теста, который будет автоматически выполняться при запуске модульного теста.

1. В обозревателе решений откройте контекстное меню узла **Зависимости** в проекте **StringLibraryTest** и выберите действие **Добавить ссылку**. Это действие добавляет ссылку на наш проект библиотеки классов (`StringLibrary`). 

1. В диалоговом окне **диспетчера ссылок** разверните узел **Проекты** и выберите **Решение**, и затем установите флажок рядом с элементом **StringLibrary**, как показано на следующем рисунке. Добавление ссылки на сборку `StringLibrary` позволяет компилятору разрешать вызовы методов из библиотеки **StringLibrary**.

   ![Изображение](./media/add_reference.jpg)

1. Щелкните кнопку **ОК**, чтобы закрыть диалоговое окно **Диспетчер ссылок**.

## <a name="adding-and-running-unit-test-methods"></a>Добавление и выполнение методов модульных тестов ##

При запуске модульного теста Visual Studio выполняет каждый метод, помеченный атрибутом [\[TestMethod\]](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.testmethodattribute.aspx), из класса модульных тестов (это класс, к которому применен атрибут [\[TestClass\]](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.testclassattribute.aspx)). Метод теста завершается, когда происходит первый сбой или когда все тесты, содержащиеся в методе, будут успешно выполнены.

Самый распространенный вид тестов вызывает члены класса [Assert](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.assert.aspx). Многие методы утверждения (Assert) принимают по крайней мере два параметра, из которых один представляет ожидаемый результат теста, а второй — фактический результат теста. Ниже перечислены его самые популярные методы.

- `Assert.AreEqual` проверяет равенство двух значений или объектов. Утверждение не выполняется, если значения или объекты не равны.

- `Assert.AreSame` проверяет, что две объектные переменные ссылаются на один и тот же объект. Утверждение не выполняется, если переменные ссылаются на разные объекты.

- `Assert.IsFalse` проверяет, что полученное условие имеет значение False. Утверждение не выполняется, если условие имеет значение True.

- `Assert.IsNotNull` проверяет, что объект не имеет значения `null`. Утверждение не выполняется, если объект является `null`.

Кроме того, можно использовать атрибут [\[ExpectedException\]](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.expectedexceptionattribute.aspx), чтобы указать тип исключения, которое должен создать метод теста. Это полезно для проверки условий, которые должны приводить к созданию исключений. Такой тест считается не выполненным, если заявленное исключение не было создано.

Для тестирования метода `StringLibrary.StartsWithUpper` нам нужно предоставить несколько строк, которые начинаются с символов верхнего регистра. Мы ожидаем, что метод в этих случаях вернет `True`, поэтому мы используем метод [Assert.IsTrue (логическое значение, строка)](https://msdn.microsoft.com/library/ms243754.aspx). Также мы будем предоставлять несколько строк, которые не начинаются с символов верхнего регистра. Мы ожидаем, что метод в этих случаях вернет False, поэтому мы используем метод [Assert.IsFalse (логическое значение, строка)](https://msdn.microsoft.com/library/ms243805.aspx).

Поскольку наш метод библиотеки обрабатывает строки, нам нужно проверить правильность обработки [пустых строк](xref:System.String.Empty) (так называется допустимая строка, которая не содержит символов и для которой свойство @System.String.Length имеет значение 0) и строк `null` (это строка, которая не была инициализирована). Если `StartsWithUpper` вызывается в качестве метода расширения для экземпляра @System.String, ему нельзя передавать строку `null`. Но мы можем вызвать его непосредственно в качестве статического метода и передать ему один аргумент типа @System.String.

Мы определим три метода, каждый из которых поочередно вызывает метод [Assert](https://msdn.microsoft.com/library/microsoft.visualstudio.testtools.unittesting.assert.aspx) для каждого элемента в массиве строк. Поскольку метод теста завершается ошибкой при первом же сбое, мы вызовем перегруженную версию метода, которая позволяет передать строку и указать строковое значение, используемое в вызове метода.

Теперь создайте методы теста.

1. Замените код, отображаемый в окне кода, следующим текстом.

   [!CODE-csharp[Test#1](../../../samples/snippets/csharp/getting_started/with_visual_studio_2017/testlib1.cs#1)]

   Обратите внимание, что наш тест на символы верхнего регистра в методе `TestStartsWithUpper` включает заглавную греческую букву "альфа" (U+0391) и заглавную кириллическую букву "М" (U+041C). Тест на символы нижнего регистра в методе `TestDoesNotStartWithUpper` включает строчную греческую букву "альфа" (U+03B1) и строчную кириллическую букву "г" (U+0433).

1. В строке меню выберите **Файл**, **Сохранить UnitTest1.cs как...**. В диалоговом окне **Сохранить файл как** щелкните стрелку рядом с кнопкой **Сохранить** и выберите вариант **Сохранить с кодировкой...***.

1. В диалоговом окне "Подтверждение сохранения" нажмите кнопку **Да**, чтобы сохранить файл.

1. В раскрывающемся списке **Кодировка** диалогового окна **Дополнительные параметры сохранения** выберите вариант **Юникод (UTF-8, с сигнатурой) кодовая страница 65001** и нажмите кнопку **ОК**.

   Если вы не сохраните исходный код в кодировке UTF8, Visual Studio может сохранить его как файл ASCII. Тогда среда выполнения не сможет правильно определить символы за пределами стандартного диапазона ASCII, и результаты теста будут неточными.

1. В строке меню выберите **Тест**, **Выполнить**, **Все тесты**. Должно открыться окно **обозревателя тестов**, которое сообщит об успешном выполнении обоих тестов, как показано на следующем рисунке. Обратите внимание, что в разделе **Пройденные тесты** перечислены три теста, а раздел **Сводка** содержит результат тестового запуска.

   ![Изображение](./media/first_test.jpg)

## <a name="handling-test-failures"></a>Обработка сбоев при тестах ##

Тестовый запуск прошел без ошибок, а теперь давайте немного изменим его, чтобы один из методов теста завершался сбоем:

1. Измените массив `words` в методе `TestDoesNotStartWithUpper` так, чтобы он содержал строку "Error". Теперь этот оператор будет выглядеть так:

   ```csharp
   string[] words = { "alphabet", "Error", "zebra", "abc", "αυτοκινητοβιομηχανία", "государство",
                      "1234", ".", ";", " " };
   ```

1. Запустите тест, выбрав пункты меню **Тест**, **Выполнить**, **Все тесты**. Теперь окно **обозревателя тестов** демонстрирует, что два тесты выполнены успешно, а один завершился сбоем, как показано на следующем рисунке.

   ![Изображение](./media/failed_test.jpg)

1. Выберите тест `TestDoesNotStartWith`, который завершился неудачно, в разделе **Неудачные тесты**. На панели внизу окна **Обозреватель тестов** отображается сообщение, созданное в утверждении: "Assert.IsFalse failed. Expected for 'Error': false; actual: True" (Сбой Assert.IsFalse. Ожидалось значение "Error:false", получено значение "True"), как показано на следующем изображении окна **Обозреватель тестов**. Из-за этого сбоя все строки в массиве, расположенные после слова "Error", не проверялись.

   ![Изображение](./media/failed_test2.jpg)

1. Удалите код, который вы добавили ранее (`"Error", `) и повторите выполнение теста. Теперь он должен снова выполняться успешно.

## <a name="testing-the-release-version-of-the-library"></a>Тестирование версии выпуска для библиотеки ##

До сих пор мы выполняли тесты с отладочной версией библиотеки. Теперь, когда все созданные тесты пройдены и мы достаточно подробно проверили работу библиотеки, следует запустить все тесты еще раз, теперь уже для сборки выпуска библиотеки. Некоторые факторы, например оптимизации компилятора, иногда могут вызывать разное поведение сборки в режимах отладки и выпуска.

Протестируйте сборку выпуска следующим образом.

1. В панели инструментов Visual Studio измените конфигурацию сборки с режима **Отладка** на **Выпуск**. На следующем рисунке показана часть панели инструментов.

   ![Изображение](./media/lib_release.jpg)

1. В **обозревателе решений** откройте контекстное меню для проекта **StringLibrary**и выберите действие **Сборка**, чтобы выполнить повторную компиляцию библиотеки.

1. Повторно запустите модульные тесты, выбрав пункты **Тест**, **Выполнить**, **Все тесты** из меню Visual Studio. Все тесты должны пройти успешно.

Теперь вы полностью завершили тестирование библиотеки, и ее можно предоставить пользователям. Ее можно включить в состав любого приложения или нескольких приложений, а также предоставить в виде пакета NuGet. Сведения о том, как это сделать, вы найдете в статье [Consuming a class library with .NET Core in Visual Studio 2017](./consuming-library-with-visual-studio-2017.md) (Использование стандартной библиотеки классов для .NET Core в Visual Studio 2017).

