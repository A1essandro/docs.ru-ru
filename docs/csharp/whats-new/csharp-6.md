---
title: "Новые возможности C# 6 - руководство по C#"
description: "Сведения о новых возможностях в C# 6"
keywords: .NET, .NET Core
author: BillWagner
ms.date: 09/22/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 4d879f69-f889-4d3f-a781-75194e143400
ms.openlocfilehash: f3e7a515b1dde52461ab6abf8a9adbe84d27b7c1
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="whats-new-in-c-6"></a>Новые возможности C# 6

Версия C# 6.0 содержит множество функций, помогающих повысить производительность труда разработчиков. Ниже приведены функции в этом выпуске.

* [Автосвойства, доступные только для чтения](#read-only-auto-properties).
    - Можно создавать автосвойства только для чтения, задаваемые только в конструкторах.
* [Инициализаторы автосвойств](#auto-property-initializers).
    - Можно написать выражения инициализации для задания первоначального значения автосвойства.
* [Члены функции, воплощающие выражение](#expression-bodied-function-members).
    - Можно создавать однострочные методы с помощью лямбда-выражения.
* [using static](#using-static).
    - Можно импортировать все методы одного класса в текущее пространство имен.
* [NULL — условные операторы](#null-conditional-operators).
    - Краткий и безопасный доступ к членам объекта с проверкой значения NULL с помощью условного оператора NULL.
* [Интерполяция строк](#string-interpolation).
    - Можно написать выражения форматирования строк, используя встроенные выражения вместо позиционных аргументов.
* [Фильтры исключений](#exception-filters).
    - Можно перехватывать выражения на основе свойств исключения или другого состояния программы. 
* [Выражения nameof](#nameof-expressions).
    - Можно разрешить компилятору создавать строковые представления символов.
* [Выражение Await в блоках Catch и Finally](#await-in-catch-and-finally-blocks).
    - Можно использовать выражения `await` в расположениях, где раньше они были запрещены.
* [Инициализаторы индекса](#index-initializers).
    - Можно создавать выражения инициализации для ассоциативных контейнеров, а также контейнеров последовательности.
* [Методы расширения для инициализаторов коллекций](#extension-add-methods-in-collection-initializers).
    - Инициализаторы коллекций могут зависеть от доступных методов расширения в дополнение к методам-членам.
* [Улучшенное разрешение перегрузки](#improved-overload-resolution).
    - Некоторые конструкции, которые ранее создавали неоднозначные вызовы методов, теперь разрешаются правильно.

Общим эффектом этих функций является написание более краткого кода, который также является более удобным для чтения. Синтаксис содержит меньше формальных элементов для многих общих рекомендаций. Благодаря краткости становится проще понять назначение кода. Хорошо изучив эти возможности, вы сможете работать более производительно, создавая более читаемый код и уделяя больше внимания основным функциям, а не конструкциям языка.

В оставшейся части этого раздела приводятся сведения о каждой из этих функций.

## <a name="auto-property-enhancements"></a>Усовершенствования автосвойств 

Синтаксис автоматически реализуемых свойств (обычно называемых "автосвойствами") значительно упростил создание свойств с простыми методами доступа get и set:

[!code-csharp[ClassicAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicAutoProperty)]

Тем не менее этот простой синтаксис ограничивает типы проектов, в которых поддерживаются автосвойства. В C# 6 улучшены возможности автосвойств, чтобы их можно было использовать в более широком ряде сценариев. Вам не потребуется слишком часто возвращаться к более подробному синтаксису объявления и обработки резервного поля вручную.

Новый синтаксис адреса сценарии для свойств, доступных только для чтения и инициализация переменной хранения за свойства auto.

### <a name="read-only-auto-properties"></a>Автосвойства, доступные только для чтения

*Автосвойства только для чтения* предоставляют более краткий синтаксис для создания неизменяемых типов. Ближайшим аналогом неизменяемых типов в более ранних версиях C# являлось объявление закрытых методов задания:

[!code-csharp[ClassicReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/oldcode.cs#ClassicReadOnlyAutoProperty)]
 
При использовании этого синтаксиса компилятор не гарантирует, что тип будет действительно неизменяемым. Он гарантирует только то, что свойства `FirstName` и `LastName` не изменяются из кода за пределами класса.

Автосвойства только для чтения обеспечивают фактическое поведение "только для чтения". Автосвойство объявляется с помощью только метода доступа get:

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

Свойства `FirstName` и `LastName` могут задаваться только в теле конструктора:

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

Попытка задать `LastName` в другом методе создает ошибку компиляции `CS0200`:

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

Эта функция обеспечивает действительную поддержку создания неизменяемых типов на уровне языка и использование более краткого и удобного синтаксиса автосвойств.

### <a name="auto-property-initializers"></a>Инициализаторы автосвойств

*Инициализаторы автосвойств* позволяют объявлять начальное значение для автосвойства при объявлении свойства.  В более ранних версиях эти свойства должны были иметь методы задания, которые вы бы использовали для инициализации хранилища данных, используемого резервным полем. Рассмотрим этот класс для учащихся, который содержит имена и список их оценок.

[!code-csharp[Construction](../../../samples/snippets/csharp/new-in-6/oldcode.cs#Construction)]
 
По мере роста этого класса можно включать другие конструкторы. Каждый конструктор должен инициализировать это поле, или будут создаваться ошибки.

C# 6 позволяет задать начальное значение для хранилища, используемого автосвойством в объявлении автосвойства:

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

Член `Grades` инициализируется там, где он объявлен. Это упрощает выполнение инициализации ровно один раз. Инициализация является частью объявления свойства, упрощая уравнение выделения хранилища с открытым интерфейсом для объектов `Student`.

Инициализаторы свойств можно использовать свойства чтения/записи, а также свойства только для чтения, как показано здесь.

[!code-csharp[ReadWriteInitialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadWriteInitialization)]

## <a name="expression-bodied-function-members"></a>Члены функции, воплощающие выражение

Тело многих создаваемых нами членов состоит только из одного оператора, который может быть представлен как выражение. Можно сократить этот синтаксис, написав член, воплощающий выражение. Он работает для методов и свойств, доступных только для чтения. Например, переопределение `ToString()` часто бывает отличным кандидатом:

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

Также можно использовать выражение телом члены в свойства только для чтения:

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

## <a name="using-static"></a>using static

Усовершенствование *using static* позволяет импортировать статические методы одного класса. Ранее оператор `using` импортировал все типы в пространство имен. 

Мы часто используем статические методы класса в коде. Постоянное повторение имени класса может затруднить понимание кода. Так, например, происходит при написании классов, выполняющих много числовых вычислений.
Код будет засорен <xref:System.Math.Sin%2A>, <xref:System.Math.Sqrt%2A> и другими вызовами в различные методы в классе <xref:System.Math>. Новый синтаксис `using static` повышает читаемость этих классов. Необходимо указать класс, который вы используете:

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

И теперь можно использовать любой статический метод в классе <xref:System.Math> без уточнения класса <xref:System.Math>. Класс <xref:System.Math> является отличным примером использования этой функции, так как он не содержит никаких методов экземпляра. `using static` можно также использовать для импорта статических методов класса для класса, который содержит как статические методы, так и методы экземпляра. Одним из наиболее полезных примеров является <xref:System.String>:

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> В операторе static using необходимо использовать полное имя класса, `System.String`. Нельзя использовать вместо него ключевое слово `string`. 

Теперь мы можем вызвать статические методы, определенные в классе <xref:System.String>, без уточнения этих методов как членов данного класса:

[!code-csharp[UsingStaticString](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticString)]

Функция `static using` и методы расширения взаимодействуют интересными способами, и схема языка включает некоторые правила, касающиеся этих взаимодействий. Их целью является сведение к минимуму вероятности всех критических изменений в существующих базах кода, включая ваши.

Методы расширения находятся в области только при вызове с помощью синтаксиса вызова метода расширения, но не при вызове в качестве статического метода.
Это часто встречается в запросах LINQ. Шаблон LINQ можно импортировать путем импорта <xref:System.Linq.Enumerable>.

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

При этом импортируются все методы в классе <xref:System.Linq.Enumerable>.
Однако методы расширения находятся в области только при вызове в качестве методов расширения. Они не находятся в области, если они вызываются с помощью синтаксиса статического метода:

[!code-csharp[UsingStaticLinqMethod](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticLinkMethod)]

Так происходит, поскольку обычно методы расширения вызываются с помощью выражения вызова метода расширения. В редких случаях, когда они вызываются с помощью синтаксиса вызова статического метода, это реализуется для устранения неоднозначности.
Требование имени класса в рамках вызова кажется разумным.

Есть еще одна последняя функция `static using`. Директива `static using` также импортирует все вложенные типы. Это позволяет ссылаться на любые вложенные типы без указания полного имени.

## <a name="null-conditional-operators"></a>Условные операторы NULL

Значения NULL усложняют код. Вам приходится проверять каждый случай доступа переменных, чтобы убедиться, что не происходит разыменование `null`. *Условный оператор NULL* существенно упрощает такие проверки.

Просто замените доступ к члену `.` оператором `?.`:

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

В предыдущем примере переменная `first` назначается `null`, если объект person имеет значение `null`. В противном случае назначается значение свойства `FirstName`. Важно то, что `?.` означает, что эта строка кода не создает `NullReferenceException`, если переменная `person` имеет значение `null`. Вместо этого выполняется сокращенное вычисление и создание `null`.

Кроме того, обратите внимание, что это выражение возвращает `string`, независимо от значения `person`.
В случае сокращенного вычисления возвращаемое значение `null` имеет тип для сопоставления с полным выражением.

Эта конструкция часто используется с оператором *объединения со значением NULL* для присвоения значений по умолчанию, если одно из свойств имеет значение `null`:

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

Правый операнд оператора `?.` не ограничивается свойствами или полями.
Его также можно использовать для условного вызова методов. Чаще всего функции-члены с условным оператором NULL используются для безопасного вызова делегатов (или обработчиков событий), которые могут иметь значение `null`.  Это реализуется путем вызова метода `Invoke` делегата с помощью оператора `?.` для доступа к члену. Пример можно увидеть в разделе, посвященном  
[шаблонам делегатов](../delegates-patterns.md#handling-null-delegates).

Правила оператора `?.` гарантируют, что левая часть оператора вычисляется только один раз. Это важно и обеспечивает поддержку многих идиом, включая пример с использованием обработчиков событий. Начнем с использования обработчика событий. В предыдущих версиях C# вам рекомендовалось писать код следующим образом:

```csharp
var handler = this.SomethingHappened;
if (handler != null)
    handler(this, eventArgs);
```

Это было предпочтительнее, чем упрощенный синтаксис:

```csharp
// Not recommended
if (this.SomethingHappened != null)
    this.SomethingHappened(this, eventArgs);
```

> [!IMPORTANT]
> Предыдущий пример представляет состояние гонки. Событие `SomethingHappened` может иметь подписчики при проверке на соответствие условию `null`, и эти подписчики могли быть удалены до возникновения события. При этом будет создано исключение <xref:System.NullReferenceException>.

Во второй версии обработчик событий `SomethingHappened` может не иметь значение NULL при тестировании, но если другой код удаляет обработчик, он может иметь значение NULL при вызове обработчика событий.

Компилятор создает код для оператора `?.`, который гарантирует, что левая сторона (`this.SomethingHappened`) выражения `?.` вычисляется один раз и результат кэшируется:

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

Гарантия того, что левая часть вычисляется только один раз, также позволяет использовать любое выражение, включая вызовы методов, слева от оператора `?.`. Даже если возникнут побочные эффекты, при однократном вычислении они возникнут только один раз. Пример можно увидеть в разделе, посвященном [событиям](../events-overview.md#language-support-for-events).

## <a name="string-interpolation"></a>Интерполяция строк

C# 6 содержит новый синтаксис для составления строк из строки формата и выражений, которые могут вычисляться для получения других строковых значений.

Традиционно приходилось использовать позиционные параметры в методе, подобном `string.Format`:

[!code-csharp[stringFormat](../../../samples/snippets/csharp/new-in-6/oldcode.cs#stringFormat)]

В C# 6 новая функция интерполяции строк позволяет внедрить выражения в строку формата. Просто добавьте в строку префикс `$`:

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

В этом начальном примере для замененных выражений используются выражения переменных. Можно расширить этот синтаксис и использовать любое выражение. Например, можно вычислить средний балл учащегося как часть интерполяции:

[!code-csharp[stringInterpolationExpression](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationExpression)]

Выполняя предыдущий пример, вы могли увидеть, что выходные данные для `Grades.Average()` имеют больше десятичных разрядов, чем хотелось бы. Синтаксис интерполяции строк поддерживает все строки формата, доступные с помощью методов форматирования прежних версий. Строки формата добавляются внутри фигурных скобок. Добавьте `:`, за которым следует форматируемое выражение:

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

Предыдущая строка кода отформатирует значение для `Grades.Average()` как число с плавающей запятой с двумя десятичными разрядами.

`:` всегда интерпретируется как разделитель между форматируемым выражением и строкой формата. Это может вызвать проблемы, если выражение использует `:` другим способом, например как условный оператор:

```csharp
public string GetGradePointPercentages() =>
    $"Name: {LastName}, {FirstName}. G.P.A: {Grades.Any() ? Grades.Average() : double.NaN:F2}";
```

В предыдущем примере `:` анализируется как начало строки формата, а не часть условного оператора. Во всех случаях, когда это происходит, можно заключить выражение в круглые скобки, чтобы заставить компилятор интерпретировать выражение нужным образом:

[!code-csharp[stringInterpolationConditional](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationConditional)]

Нет никаких ограничений на выражения, которые можно поместить в фигурные скобки. Можно выполнить сложный запрос LINQ внутри интерполированной строки для выполнения вычислений и отображения результата:

[!code-csharp[stringInterpolationLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationLinq)]

Из этого примера мы видим, что можно даже вкладывать одно выражение интерполяции строк в другое выражение интерполяции строк. Этот пример слишком сложный, для того чтобы использовать его в рабочем коде.
Он приведен, скорее, с целью продемонстрировать широту применения функции. Любое выражение C# можно поместить между фигурными скобками интерполированной строки.

### <a name="string-interpolation-and-specific-cultures"></a>Интерполяция строк и конкретные языки и региональные параметры

Все примеры, приведенные в предыдущем разделе, форматируют строки с использованием текущего языка и региональных параметров на компьютере, где выполняется код. Часто требуется отформатировать строку, полученную с использованием конкретного языка и региональных параметров.
Объект, полученный при интерполяции строк, — это тип, который имеет неявное преобразование в <xref:System.String> или <xref:System.FormattableString>.

Тип <xref:System.FormattableString> содержит строку формата и результаты вычисления аргументов перед их преобразованием в строки. Вы можете использовать открытые методы <xref:System.FormattableString> для указания языка и региональных параметров при форматировании строки. Например, следующий код создает строку, используя немецкий язык в качестве языка и региональных параметров. (В качестве десятичного разделителя будет использоваться символ ",", а "." — в качестве разделителя тысяч.)

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = string.Format(null, 
    System.Globalization.CultureInfo.CreateSpecificCulture("de-de"),
    str.GetFormat(), str.GetArguments());
```

> [!NOTE]
> Предыдущий пример не поддерживается в версии .NET Core 1.0.1. Он поддерживается только в .NET Framework.

Как правило, выражения интерполяции строк создают строки в качестве выходных данных. Тем не менее, если вам требуется больший контроль над языком и региональными параметрами, используемыми для форматирования строк, можно указать конкретные выходные данные.  Если вы часто используете эту функцию, можно создать удобные методы, такие как методы расширения, для поддержки простого форматирования с помощью конкретного языка и региональных параметров.

## <a name="exception-filters"></a>Фильтры исключений

Другая новая функция в C# 6 — *фильтры исключений*. Фильтры исключений — это предложения, которые определяют, когда должно применяться данное предложение catch.
Если выражение, используемое для фильтра исключений, принимает значение `true`, предложение catch выполняет обычную обработку исключения. Если выражение принимает значение `false`, то предложение `catch` пропускается.

Например, эту функцию можно использовать для просмотра сведений об исключении, чтобы определить, может ли предложение `catch` обработать исключение:

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

Код, созданный фильтрами исключений, предоставляет больше информации об исключении, которое создано и не обработано. До добавления фильтров исключений в язык приходилось создавать код, аналогичный следующему:

[!code-csharp[ExceptionFilterOld](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilterOld)]

Точка, где создается исключение, неодинакова в этих двух примерах.
В предыдущем коде, где используется предложение `throw`, любой анализ трассировки стека или анализ аварийных дампов выведет только то исключение, которое было вызвано из оператора `throw` в предложении catch. Фактический объект исключения будет содержать исходный стек вызовов, однако все остальные сведения обо всех переменных в стеке вызовов между этой точкой создания исключения и расположением исходной точки создания исключения будут утеряны. 

Сравните это с обработкой кода, использующего фильтр исключений: выражение фильтра исключений принимает значение `false`. Таким образом, выполнение никогда не входит в предложение `catch`. Поскольку предложение `catch` не выполняется, развертывание стека не происходит. Это означает, что исходное расположение исключения сохраняется для любых действий отладки, которые будет выполняться позже.

Для обработки полей или свойств исключения, не полагаясь исключительно на тип исключения, используйте фильтр исключений для сохранения дополнительных отладочных сведений.

Другим рекомендуемым примером применения фильтров исключений является их использование для операций ведения журнала. В этом случае также используется подход, в котором точка создания исключения сохраняется, если фильтр исключений принимает значение `false`.

Методом ведения журнала будет метод, аргументом которого является исключение, безусловно возвращающее `false`:

[!code-csharp[ExceptionFilterLogging](../../../samples/snippets/csharp/new-in-6/ExceptionFilterHelpers.cs#ExceptionFilterLogging)]

Каждый раз, когда требуется записать исключение в журнал, можно добавить предложение catch и использовать этот метод в качестве фильтра исключений:

[!code-csharp[LogException](../../../samples/snippets/csharp/new-in-6/program.cs#LogException)]

Исключения никогда не перехватываются, так как метод `LogException` всегда возвращает `false`. Такой фильтр исключений, всегда имеющий значение false, означает, что вы можете поместить этот обработчик ведения журнала перед любым другим обработчиком исключений:

[!code-csharp[LogExceptionRecovery](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionRecovery)]

Предыдущий пример демонстрирует очень важный аспект фильтров исключений.
Фильтры исключений поддерживают сценарии, в которых более общие предложения перехвата исключений могут предшествовать более конкретным предложениям. Кроме того, один тип исключения может появляться в нескольких предложениях catch:

[!code-csharp[HandleNotChanged](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#HandleNotChanged)]

Другой рекомендуемый способ использования помогает предотвратить обработку предложениями catch исключений, если подключен отладчик. Этот метод позволяет запускать приложения с помощью отладчика и останавливать выполнение при возникновении исключения.

Добавьте в свой код фильтр исключений, чтобы любой код восстановления выполнялся только в том случае, если отладчик не подключен:

[!code-csharp[LogExceptionDebugger](../../../samples/snippets/csharp/new-in-6/program.cs#LogExceptionDebugger)]

После добавления этого кода задайте для отладчика прерывание по всем необработанным исключениям. Запустите программу в отладчике, и отладчик будет прерывать выполнение при каждом вызове `PerformFailingOperation()` исключения `RecoverableException`.
Отладчик прерывает выполнение программы, так как предложение catch не выполняется из-за фильтра исключения, возвращающего значение false.

## <a name="nameof-expressions"></a>Выражения `nameof`

Результатом выражения `nameof` является имя символа. Это отличный способ заставить инструменты работать, если вам требуется имя переменной, свойства или поля члена.

Одно из наиболее распространенных применений `nameof` — предоставление имени символа, который вызвал исключение:

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

Другая сфера применения — с приложениями на основе XAML, реализующими интерфейс `INotifyPropertyChanged`:

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

Преимущество использования оператора `nameof` по сравнению со строковой константой заключается в том, что инструменты могут распознать символ. При использовании инструментов рефакторинга для переименования символа он будет переименован в выражение `nameof`. Константные строки не обеспечивают такого преимущества. Попробуйте сделать это в своем любимом редакторе: переименуйте переменную, и все выражения `nameof` также обновятся.

Выражение `nameof` создает неполное имя своего аргумента (`LastName` в предыдущих примерах) даже при использовании для аргумента полного имени:

[!code-csharp[QualifiedNameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#QualifiedNameofNotify)]

Это выражение `nameof` создает `FirstName`, а не `UXComponents.ViewModel.FirstName`.

## <a name="await-in-catch-and-finally-blocks"></a>Выражение Await в блоках Catch и Finally

В C# 5 было несколько ограничений в отношении размещения выражений `await`.
Одно из них удалено в C# 6. Теперь вы можете использовать `await` в выражениях `catch` или `finally`. 

Может показаться, что добавление выражений await в блоки catch и finally усложняет их обработку. Добавим пример, чтобы рассмотреть этот случай. В любом асинхронном методе можно использовать выражение await в предложении finally.

В C# 6 ожидание также может выполняться в выражениях catch. Чаще всего это используется в сценариях ведения журнала:

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

Реализация добавления поддержки `await` внутри предложений `catch` и `finally` гарантирует согласованность поведения с поведением для синхронного кода. Если код, выполняемый в предложении `catch` или `finally`, создает исключение, выполнение ищет подходящее предложение `catch` в следующем окружающем блоке. При наличии текущего исключения это исключение будет потеряно. То же самое происходит с ожидаемыми выражениями в предложениях `catch` и `finally`: выполняется поиск подходящего `catch`, а текущее исключение (при наличии) утрачивается.  

> [!NOTE]
> Это поведение лежит в основе рекомендации тщательного написания предложений `catch` и `finally` во избежание внесения новых исключений.

## <a name="index-initializers"></a>См. раздел Инициализаторы индекса.

*Инициализаторы индекса* — это одна из двух функций, обеспечивающих согласованность инициализаторов коллекций. В более ранних версиях C# можно было использовать *инициализаторы коллекций* только с коллекциями типа последовательности:

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#ListInitializer)]

Теперь их можно также использовать с коллекциями <xref:System.Collections.Generic.Dictionary%602> и других аналогичных типов:

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

Эта функция означает, что ассоциативные контейнеры могут быть инициализированы с помощью синтаксиса, аналогичного используемому для контейнеров последовательностей для нескольких версий.

### <a name="extension-add-methods-in-collection-initializers"></a>Методы расширения `Add` в инициализаторах коллекций

Еще одна функция, упрощающая инициализацию коллекций, — это возможность использования *метода расширения* для метода `Add`. Эта функция была добавлена для согласования с Visual Basic. 

Она наиболее удобна при наличии пользовательского класса коллекции, имеющего метод с другим именем для семантического добавления новых элементов.

Например, рассмотрим коллекцию учащихся:

[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]

Метод `Enroll` добавляет учащихся. Однако он не соответствует шаблону `Add`.
В предыдущих версиях C# нельзя было использовать инициализаторы коллекций с объектом `Enrollment`:

[!code-csharp[InitializeEnrollment](../../../samples/snippets/csharp/new-in-6/classList.cs#InitializeEnrollment)]

Теперь вы можете это сделать, но только в том случае, если создадите метод расширения, который сопоставляет `Add` с `Enroll`:

[!code-csharp[ExtensionAdd](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAdd)]

Эта функция сопоставляет любой метод, который добавляет элементы в коллекцию, с методом `Add` путем создания метода расширения: 

[!code-csharp[Enrollment](../../../samples/snippets/csharp/new-in-6/enrollment.cs#Enrollment)]
[!code-csharp[ExtensionAddSample](../../../samples/snippets/csharp/new-in-6/classList.cs#ExtensionAddSample)]

## <a name="improved-overload-resolution"></a>Улучшенное разрешение перегрузки

Эта последняя функция, на которую вы, вероятно, не обратите внимания. Есть примеры того, что предыдущая версия компилятора C# могла определять некоторые вызовы методов, работающих с лямбда-выражениями, как неоднозначные. Рассмотрим этот метод:

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

В более ранних версиях C# вызов этого метода с использованием синтаксиса группы методов приведет к сбою:

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]
 
Компилятор прежних версий не мог правильно различать методы `Task.Run(Action)` и `Task.Run(Func<Task>())`. В предыдущих версиях вам бы потребовалось использовать лямбда-выражение в качестве аргумента:

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

Компилятор C# 6 правильно определяет, что `Task.Run(Func<Task>())` является лучшим вариантом.
