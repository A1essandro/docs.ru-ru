---
title: История языка C# (руководство по C#)
description: На что был похож этот язык в ранних версиях и во что он превратился сейчас?
author: erikdietrich
ms.date: 09/20/2017
ms.openlocfilehash: 5e8ecdd971a043dc47c50b10c974d86f836818dc
ms.sourcegitcommit: d88024e6d6d8b242feae5f4007a709379355aa24
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2018
ms.locfileid: "49316263"
---
# <a name="the-history-of-c"></a>История языка C# #

На что был похож этот язык в ранних версиях? И во что он превратился спустя годы?

## <a name="c-version-10"></a>C# версии 1.0

Если взглянуть на C# версии 1.0, станет очевидно его сходство с Java. В число [поставленных перед ECMA задач проектирования](http://feeldotneteasy.blogspot.com/2011/01/c-design-goals.html) входило создание "простого и современного объектно-ориентированного языка общего назначения".  В то время схожесть с Java означала достижение этих ранних целей проектирования.

Однако если взглянуть на C# 1.0 сейчас, вам может стать немного не по себе. В этой версии не было встроенных асинхронных возможностей и некоторых функций для универсальных шаблонов, к которым вы уже привыкли. Фактически, в ней вообще не было универсальных шаблонов.  А [LINQ](../linq/index.md)? Еще нет. Для добавления этих возможностей потребовалось несколько лет.

По современным меркам C# версии 1.0 не предоставлял практически никаких возможностей. Вам пришлось бы писать довольно подробный код. Однако надо же было с чего-то начинать. C# версии 1.0 был достойной альтернативой Java на платформе Windows.

Основные возможности C# 1.0 включали следующие компоненты:

- [Классы](../programming-guide/classes-and-structs/classes.md)
- [Структуры](../programming-guide/classes-and-structs/structs.md)
- [Интерфейсы](../programming-guide/interfaces/index.md)
- [События](../events-overview.md)
- [Свойства](../properties.md)
- [Делегаты](../delegates-overview.md)
- [Выражения](../programming-guide/statements-expressions-operators/expressions.md)
- [Операторы](../programming-guide/statements-expressions-operators/statements.md)
- [Атрибуты](../programming-guide/concepts/attributes/index.md)
- Литералы

## <a name="c-version-12"></a>Версия для C# 1.2

Версия C# 1.2 входит в состав Visual Studio 2003. Она содержит ряд небольших улучшений языка. Наиболее значительным изменением является то, что начиная с этой версии код, создаваемый в цикле `foreach`, вызывает <xref:System.IDisposable.Dispose%2A> в <xref:System.Collections.IEnumerator>, если <xref:System.Collections.IEnumerator> реализует <xref:System.IDisposable>.

## <a name="c-version-20"></a>C# версии 2.0

Вот теперь все становится гораздо интереснее. Давайте рассмотрим некоторые основные возможности языка C# 2.0, выпущенного в 2005 году вместе с Visual Studio 2005:

- [Универсальные шаблоны](../programming-guide/generics/index.md)
- [Разделяемые типы](../programming-guide/classes-and-structs/partial-classes-and-methods.md#partial-classes)
- [Анонимные методы](../programming-guide/statements-expressions-operators/anonymous-methods.md)
- [Типы, допускающие значения NULL](../programming-guide/nullable-types/index.md)
- [Итераторы](../programming-guide/concepts/iterators.md)
- [Ковариантность и контравариантность](../programming-guide/concepts/covariance-contravariance/index.md)

Другие возможности C# 2.0 расширяли существующие возможности:

- Отдельный доступ к методу получения и методу задания
- Преобразования групп методов (делегаты)
- Статические классы
- Выведение делегата

Хотя сначала C# и был универсальным объектно-ориентированным языком, в C# версии 2.0 все кардинально изменилось. Нащупав опору под ногами, команда уделила внимание решению серьезных проблем, с которыми сталкивались разработчики. И они подошли к делу с огоньком.

Благодаря универсальным шаблонам вы получаете типы и методы, которые могут работать с произвольным типом, при этом обеспечивая безопасность типа. В результате, например, наличие <xref:System.Collections.Generic.List%601> позволяет использовать `List<string>` или `List<int>` и совершать типобезопасные операции с этими строками или целыми числами, выполняя итерацию по ним. Использовать универсальные шаблоны удобнее, чем создавать `ListInt`, производный от `ArrayList`, или выполнять приведение из `Object` для каждой операции.

В C# версии 2.0 появились итераторы. Если кратко, итераторы позволяют изучать все элементы в `List` (или других перечислимых типов) с помощью цикла `foreach`. Наличие итераторов в качестве первоклассного компонента в языке значительно улучшило удобочитаемость языка и способность воспринимать код.

А еще C# продолжил играть в салки с Java. Для Java уже были выпущены версии, включающие универсальные шаблоны и итераторы. Но вскоре этому было суждено измениться, так как языки продолжили развиваться независимо.

## <a name="c-version-30"></a>C# версии 3.0

C# версии 3.0 был выпущен в конце 2007 года вместе с Visual Studio 2008, однако существенно набор возможностей языка пополнится только в .NET Framework версии 3.5. Эта версия ознаменовала кардинальное изменение развития C#. Она доказала, что C# действительно является достойным языком программирования. Давайте рассмотрим некоторые основные возможности в этой версии:

- [Автоматически реализуемые свойства](../programming-guide/classes-and-structs/auto-implemented-properties.md)
- [Анонимные типы](../programming-guide/classes-and-structs/anonymous-types.md)
- [Выражения запросов](../linq/query-expression-basics.md)
- [Лямбда-выражение](https://www.daedtech.com/introduction-to-c-lambda-expressions/)
- [Деревья выражений](https://blogs.msdn.microsoft.com/charlie/2008/01/31/expression-tree-basics/)
- [Методы расширения](https://www.codeproject.com/Tips/709310/Extension-Method-In-Csharp)
- [Неявно типизированные локальные переменные](../language-reference/keywords/var.md)
- [Разделяемые методы](../language-reference/keywords/partial-method.md)
- [Инициализаторы объектов и коллекций](../programming-guide/classes-and-structs/object-and-collection-initializers.md)

Если оглянуться назад, становится ясно, что многие из этих возможностей не могли не появиться или появиться отдельно друг от друга. Все они образуют единый и стратегически значимый набор. Принято считать, что уникальным преимуществом C# было выражение запроса, которое также называется LINQ.

Немного углубившись, можно отметить деревья выражений, лямбда-выражения и анонимные типы как основу для создания LINQ. Однако в любом случае в C# 3.0 была представлена революционная концепция. Версия C# 3.0 начала закладывать фундамент для превращения C# в гибридный объектно-ориентированный/функциональный язык.

Среди прочего, теперь вы можете создавать декларативные запросы в стиле SQL для выполнения операций с коллекциями. Вместо создания цикла `for` для вычисления среднего значения из списка целых чисел теперь вам достаточно использовать `list.Average()`. Сочетание выражений запросов и методов расширения позволяет сделать работу со списком целых чисел гораздо интеллектуальнее.

Людям потребовалось некоторое время, чтобы принять эту концепцию и начать применять ее, но это у них получилось. А теперь, спустя несколько лет, код стал гораздо более кратким, простым и функциональным.

## <a name="c-version-40"></a>C# версии 4.0

Версии C# 4.0 пришлось приложить серьезные усилия, чтобы не отставать от новаторской версии 3.0. С появлением версии 3.0 язык C# смог выйти из тени Java и занять доминирующее положение. Он быстро становился утонченным и элегантным.

Следующая версия представила ряд интересных функций:

- [Динамическая привязка](../language-reference/keywords/dynamic.md)
- [Именованные/дополнительные аргументы](../programming-guide/classes-and-structs/named-and-optional-arguments.md)
- [Универсальная ковариантность и контравариантность](../../standard/generics/covariance-and-contravariance.md)
- [Внедренные типы взаимодействия](https://stackoverflow.com/questions/20514240/whats-the-difference-setting-embed-interop-types-true-and-false-in-visual-studi)

Внедренные типы взаимодействия помогли сделать развертывание более удобным. Универсальная ковариантность и контравариантность расширяют возможности применения универсальных шаблонов, однако эти функции несколько академичны и высоко оценены авторами, создающими платформы и библиотеки. Именованные и дополнительные параметры позволяют избавиться от многих перегрузок методов и сделать работу более удобной. Однако ни одна из этих функций не является кардинальным изменением.

Значимым событием стало появление ключевого слова `dynamic`. Благодаря ключевому слову `dynamic` в C# версии 4.0 появилась возможность переопределять компилятор при типизации во время компиляции. Используя это ключевое слово, вы можете создавать конструкции, характерные для языков с динамической типизацией, таких как JavaScript. Вы можете создать `dynamic x = "a string"` и добавить туда шестерку, отложив решение о дальнейших действиях во времени выполнения.

Динамическое связывание подвержено ошибкам, однако открывает великолепные возможности внутри языка.

## <a name="c-version-50"></a>C# версии 5.0

Версия C# 5.0 была крайне целенаправленной. Практически все нововведения в этой версии касались другой инновационной концепции: модели `async` и `await` для асинхронного программирования.  Ниже приведен список основных функций:

- [Асинхронные члены](../async.md)
- [Информационные атрибуты вызывающего объекта](../programming-guide/concepts/caller-information.md)

### <a name="see-also"></a>См. также

* [Проект кода. Информационные атрибуты вызывающего объекта в C# 5.0](https://www.codeproject.com/Tips/606379/Caller-Info-Attributes-in-Csharp)

Информационный атрибут вызывающего объекта позволяет легко получать сведения о контексте, в котором выполняется работа, не прибегая к массивному стандартному коду отражения. Он находит обширное применение в задачах диагностики и ведения журнала.

Однако настоящими звездами этого выпуска являются `async` и `await`. После появления этих функций в 2012 г. C# удалось снова взять быка за рога, первоклассным образом внедрив асинхронность в язык. Если вы когда-либо сталкивались с длительными операциями и реализацией переплетающихся обратных вызовов, эта возможность, скорее всего, вам понравится.

## <a name="c-version-60"></a>C# версии 6.0

Версии 3.0 и 5.0 добавили в объектно-ориентированный язык C# несколько впечатляющих возможностей. Версия 6.0 отступает от проторенного пути по реализации уникальных возможностей и концентрируется на предоставлении незначительных функций, с которыми программирование на C# становится гораздо эффективнее. Вот некоторые из них:

- [Статические импорты](../language-reference/keywords/using-static.md)
- [Фильтры исключений](https://www.thomaslevesque.com/2015/06/21/exception-filters-in-c-6/)
- [Инициализаторы свойств](http://geekswithblogs.net/WinAZ/archive/2015/06/30/whatrsquos-new-in-c-6.0-auto-property-initializers.aspx)
- [Элементы, воплощающие выражение](https://lostechies.com/jimmybogard/2015/12/17/c-6-feature-review-expression-bodied-function-members/)
- [Null-распространитель](https://davefancher.com/2014/08/14/c-6-0-null-propagation-operator/)
- [Интерполяция строк](../language-reference/tokens/interpolated.md)
- [Оператор nameof](https://stackoverflow.com/questions/31695900/what-is-the-purpose-of-nameof)
- [Инициализаторы индекса](csharp-6.md#index-initializers)

Другие новые возможности:

- Выражение Await в блоках Catch и Finally
- Значения по умолчанию для свойств метода получения

Каждая из этих функций интересна сама по себе. Но если взглянуть на них вместе, заметна интересная особенность. В этой версии C# избавился от стандартного текста, чтобы сделать код более сжатым и удобочитаемым. Поэтому эта версия, несомненно, привлечет сторонников простого и понятного кода.

Еще одно новшество, связанное с этой версией, не является функцией языка в обычном понимании. Состоялся выпуск [компилятора Roslyn в виде службы](https://github.com/dotnet/roslyn). Теперь компилятор C# написан на C#, и вы можете использовать его при программировании.

## <a name="c-version-70"></a>C# версии 7.0

Сейчас последним основным номером версии для C# является 7.0. В этой версии получили развитие некоторые функции из версии C# 6.0, однако компилятор в виде службы отсутствует. Ниже приведены некоторые из новых функций:

- [Переменные Out](https://www.c-sharpcorner.com/article/out-variables-in-c-sharp-7-0/)
- [Кортежи и деконструкция](https://www.thomaslevesque.com/2016/08/23/tuple-deconstruction-in-c-7/)
- [Сопоставление шаблонов](./csharp-7.md#pattern-matching)
- [Локальные функции](https://www.infoworld.com/article/3182416/application-development/c-7-in-depth-exploring-local-functions.html)
- [Расширенные элементы, воплощающие выражение](./csharp-7.md#more-expression-bodied-members)
- [Локальные переменные и возвращаемые значения Ref](./csharp-7.md#ref-locals-and-returns)

Другие возможности:

- [Операции удаления](../discards.md)
- [Двоичные литералы](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/binary-literals.md)
- [Разделители между цифрами](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/digit-separators.md)
- Возвращаемые ссылочные значения и локальные переменные
- [Выражения throw](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.0/throw-expression.md)

Все это предоставляет разработчиком множество новых возможностей и позволяет писать более понятный код. Важным аспектом является доработка объявления переменных путем использования ключевого слова `out` и поддержки нескольких возвращаемых значений благодаря кортежу.

Но при этом сфера применения C# продолжает расширяться. Теперь .NET Core подходит для любой операционной системы, а также уверенно движется в направлении облачных технологий и портативности.  Очевидно, что разработчики активно занимаются этими новыми возможностями наравне с добавлением новых функций.

_Статья_ [_изначально опубликована в блоге NDepend_](https://blog.ndepend.com/c-versions-look-language-history/)_, с разрешения Эрика Дитриха (Erik Dietrich) и Патрика Смачиа (Patrick Smacchia)._
