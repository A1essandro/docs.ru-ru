---
title: Новые возможности C# 7.0. Руководство по языку C#
description: Общие сведения о возможностях новой версии 7 языка C#.
ms.date: 12/21/2016
ms.assetid: fd41596d-d0c2-4816-b94d-c4d00a5d0243
ms.openlocfilehash: 08e9b9d1a991c6dd18477214dec60fba95afc6c9
ms.sourcegitcommit: b56d59ad42140d277f2acbd003b74d655fdbc9f1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2019
ms.locfileid: "54415732"
---
# <a name="whats-new-in-c-70"></a>Новые возможности C# 7.0

В C# 7.0 язык C# получает ряд новых возможностей:
* [Переменные `out`](#out-variables)
    - Значения `out` можно объявить внутри как аргументы для метода, в котором они используются.
* [Кортежи](#tuples)
    - Вы можете создать простые, неименованные типы, содержащие несколько открытых полей. Компиляторы и инструменты IDE понимают семантику этих типов.
* [Операции удаления](#discards)
    - Пустые переменные представляют собой временные переменные, доступные только для записи, которые используются при присвоении в тех случаях, когда присваиваемое значение не важно. Они особенно полезны при деконструкции кортежей и пользовательских типов, а также при вызове методов с параметрами `out`.
* [Соответствие шаблону](#pattern-matching)
    - На основе произвольных типов и значений их членов можно создать логику ветвления.
* [Локальные переменные и возвращаемые значения `ref`](#ref-locals-and-returns)
    - Локальные переменные метода и возвращаемые значения могут быть ссылками на другое хранилище.
* [Локальные функции](#local-functions)
    - Функции можно вкладывать в другие функции, чтобы ограничить область их действия и видимость.
* [Другие элементы, воплощающие выражение](#more-expression-bodied-members)
    - Список элементов, которые можно создавать с помощью выражений, увеличился.
* [Выражения `throw`](#throw-expressions)
    - Исключения могут возникать в конструкциях кода, которые ранее не допускались, поскольку `throw` был оператором. 
* [Обобщенные асинхронные типы возвращаемых значений](#generalized-async-return-types)
    - Методы, объявленные с модификатором `async`, могут возвращать другие типы помимо `Task` и `Task<T>`.
* [Усовершенствования в синтаксисе числовых литералов](#numeric-literal-syntax-improvements)
    - Новые маркеры делают числовые константы более удобочитаемыми.

В остальной части этого раздела рассматривается каждая из этих функций. Каждая функция сопровождается обоснованием. Вы изучите синтаксис и увидите несколько примеров сценариев, в которых новая функция повышает производительность разработчика. 

## <a name="out-variables"></a>Переменные `out`

Существующий синтаксис, поддерживающий параметры `out`, в этой версии был улучшен.  

Раньше объявление переменной out и ее инициализацию необходимо было разбивать на два отдельных оператора:

[!code-csharp[OutVariableOldStyle](../../../samples/snippets/csharp/new-in-7/program.cs#03_OutVariableOldStyle "classic out variable declaration")]

Переменные `out` можно объявлять в списке аргументов в вызове метода, не записывая отдельный оператор объявления:

[!code-csharp[OutVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#01_OutVariableDeclarations "Out variable declarations")]

Для ясности можно указать тип переменной `out`, как показано выше. В то же время язык поддерживает использование неявно типизированной локальной переменной:

[!code-csharp[OutVarVariableDeclarations](../../../samples/snippets/csharp/new-in-7/program.cs#02_OutVarVariableDeclarations "Implicitly typed Out variable")]

* Код проще читать. 
    - Переменная out объявляется при использовании, а не в другой, вышестоящей строке.
* Назначать начальное значение не нужно.
    - Объявляя переменную `out`, когда она используется при вызове метода, ее нельзя случайно использовать прежде, чем она будет назначена.

Чаще всего эта функция используется в шаблоне `Try`. В этом шаблоне метод возвращает `bool`, который указывает на успех или неудачу, и переменную `out`, которая содержит результат, если метод выполняется успешно.

Если используется объявление переменной `out`, объявленная переменная "утекает" во внешний диапазон оператора if. Это позволяет использовать переменную позднее:

```csharp
if (!int.TryParse(input, out int result))
{    
    return null;
}

return result;
```

## <a name="tuples"></a>Кортежи

> [!NOTE]
> Для новых функций кортежа требуются типы <xref:System.ValueTuple>.
> Для использования на платформах, которые не включают эти типы, необходимо добавить пакет NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/).
>
> Это похоже на другие функции языка, использующие типы, предоставляемые на платформе. В качестве примера можно привести функции `async` и `await`, использующие интерфейс `INotifyCompletion`, а также LINQ на базе `IEnumerable<T>`. Тем не менее по мере увеличения степени независимости .NET от платформы механизм доставки изменяется. Периодичность поставки новых выпусков .NET Framework не всегда совпадает с выпусками обновлений для компилятора языка. Если новые функции языка используют новые типы, эти типы будут предоставляться в виде пакетов NuGet при выпуске таких новых функций. Как только эти новые типы будут добавлены в стандартный API-интерфейс .NET и включены в состав платформы, требование обязательно использовать пакет NuGet будет снято.

C# предоставляет расширенный синтаксис для классов и структур, который используется для объяснения цели проекта. Однако в некоторых случаях расширенный синтаксис требует дополнительной работы с минимальной результативностью. Зачастую требуется написание методов, которым нужна простая структура, состоящая из более чем одного элемента данных. Для поддержки этих сценариев в C# были добавлены *кортежи*. Кортежи — это упрощенные структуры данных, содержащие несколько полей для представления элементов данных.
Поля не проверяются, и собственные методы определять нельзя.

> [!NOTE]
> Кортежи существовали и в версиях C#, предшествовавших версии 7.0, но были неэффективны и не имели языковой поддержки.
> Это означает, что ссылки на элементы кортежа можно было задавать только в виде `Item1`, `Item2` и т. д. В C# 7.0 реализуется языковая поддержка кортежей, что позволяет работать с семантическими именами полей кортежа с использованием новых, более эффективных типов кортежей.

Чтобы создать кортеж, назначьте значение каждому элементу:

[!code-csharp[UnnamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#04_UnnamedTuple "Unnamed tuple")]

Это присваивание создает кортеж с членами `Item1` и `Item2`, который можно использовать так же, как и <xref:System.Tuple>. Изменив синтаксис, вы можете создать кортеж, каждый член которого будет иметь семантические имена.

[!code-csharp[NamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#05_NamedTuple "Named tuple")]

Кортеж `namedLetters` содержит поля, которые называются `Alpha` и `Beta`. Эти имена существуют только во время компиляции и не сохраняются, например при проверке кортежа посредством отражения во время выполнения.

В назначении кортежа можно также указать имена полей в правой части назначения:

[!code-csharp[ImplicitNamedTuple](../../../samples/snippets/csharp/new-in-7/program.cs#06_ImplicitNamedTuple "Implicitly named tuple")]

Вы можете задать имена для полей как в левой, так и в правой части присваивания.

[!code-csharp[NamedTupleConflict](../../../samples/snippets/csharp/new-in-7/program.cs#07_NamedTupleConflict "Named tuple conflict")]

Приведенная выше строка создает предупреждение `CS8123`, сообщающее, что имена в правой части назначения, `Alpha` и `Beta`, игнорируются, поскольку конфликтуют с именами в левой части назначения, `First` и `Second`.

В приведенных выше примерах показан базовый синтаксис для объявления кортежей. Кортежи наиболее полезны в качестве типов возвращаемых значений для методов `private` и `internal`. Они позволяют использовать простой синтаксис для возвращения нескольких дискретных значений в этих методах и не тратить время на создание объекта `class` или `struct`, определяющего возвращаемый тип. Создавать новый тип не нужно,

гораздо эффективнее и результативнее создать кортеж.
Он позволяет определять структуру данных, содержащую больше одного значения, используя более простой, облегченный синтаксис. В представленном ниже примере метод возвращает минимальное и максимальное значения в последовательности целых чисел:

[!code-csharp[TupleReturningMethod](../../../samples/snippets/csharp/new-in-7/program.cs#08_TupleReturningMethod "Tuple returning method")]

Подобное использование кортежей позволяет получить сразу несколько преимуществ:

* Позволяет не тратить время на создание объекта `class` или `struct`, определяющего возвращаемый тип. 
* Позволяет не создавать новый тип.
* Усовершенствования языка избавляют от необходимости вызывать методы <xref:System.Tuple.Create``1(``0)>.

Объявление метода включает имена для полей возвращаемого кортежа. При вызове метода возвращаемое значение представляет собой кортеж с полями`Max` и `Min`:

[!code-csharp[CallingTupleMethod](../../../samples/snippets/csharp/new-in-7/program.cs#09_CallingTupleMethod "Calling a tuple returning method")]

В некоторых случаях элементы возвращаемого методом кортежа необходимо распаковать.  С этой целью для каждого значения в этом кортеже объявляется отдельная переменная. Это называется *деконструкцией* кортежа:

[!code-csharp[CallingWithDeconstructor](../../../samples/snippets/csharp/new-in-7/program.cs#10_CallingWithDeconstructor "Deconstructing a tuple")]

Аналогичную деконструкцию можно обеспечить для любого типа в .NET. Для этого метод `Deconstruct` нужно написать как элемент класса. Метод `Deconstruct` предоставляет набор аргументов `out` для каждого из свойств, которые нужно извлечь. Рассмотрим этот класс `Point`, предоставляющий метод deconstructor, который извлекает координаты `X` и `Y`:

[!code-csharp[PointWithDeconstruction](../../../samples/snippets/csharp/new-in-7/point.cs#11_PointWithDeconstruction "Point with deconstruction method")]
 
Отдельные поля можно извлекать, назначая кортежу метод `Point`:

[!code-csharp[DeconstructPoint](../../../samples/snippets/csharp/new-in-7/program.cs#12_DeconstructPoint "Deconstruct a point")]

Имена, определенные в методе `Deconstruct`, использовать необязательно. Переменные извлечения можно переименовать в назначении:  

[!code-csharp[DeconstructNames](../../../samples/snippets/csharp/new-in-7/program.cs#13_DeconstructNames "Deconstruct with new names")]

Дополнительные сведения о кортежах см. в [разделе о кортежах](../tuples.md).

## <a name="discards"></a>Пустые переменные

При деконструкции кортежа или вызове метода с параметрами `out` часто требуется определить переменную, которую вы не планируете использовать и значение которой не важно. Для работы в таких сценариях в C# реализована поддержка *пустых переменных*. Пустая переменная представляет собой доступную только для записи переменную с именем `_` (знак подчеркивания). Вы можете назначить одной переменной все значения, которые не потребуются в дальнейшем. Пустая переменная является аналогом неприсвоенной переменной и не может использоваться в коде где-либо, за исключением оператора присваивания.

Пустые переменные поддерживается в следующих случаях.

* При деконструкции кортежей или пользовательских типов.

* При вызове методов с параметрами [out](../language-reference/keywords/out-parameter-modifier.md).

* В операции сопоставления шаблонов с выражениями [is](../language-reference/keywords/is.md) и [switch](../language-reference/keywords/switch.md).

* В качестве автономного идентификатора в тех случаях, когда требуется явно идентифицировать значение присваивания как пустую переменную.

В следующем примере определяется метод `QueryCityDataForYears`, который возвращает кортеж из 6 элементов, содержащий данные по городу за два разных года. В вызове метода в этом примере учитываются только два возвращаемых методом значения population, поэтому при деконструкции кортежа оставшиеся значения обрабатываются как пустые переменные.

[!code-csharp[Tuple-discard](../../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

Дополнительные сведения см. в разделе [Пустые переменные](../discards.md).

## <a name="pattern-matching"></a>Регулярные выражения

*Сопоставление шаблонов* — это функция, которая позволяет применять отправку метода для свойств, а не для типа объекта. Возможно, вы уже знакомы с отправкой метода на основе типа объекта. В объектно-ориентированном программировании виртуальные и переопределяющие методы предоставляют синтаксис языка, позволяющий отправлять метод, исходя из типа объекта. Базовый и производный классы предусматривают различные реализации. Выражения сопоставления шаблонов расширяют эту концепцию, позволяя легко внедрять аналогичные шаблоны отправки для типов и элементов данных, не связанных иерархией наследования. 

Сопоставление шаблонов поддерживает выражения `is` и `switch`. Каждое из них позволяет проверять объект и его свойства и определять, соответствует ли этот объект искомому шаблону. Для добавления правил в шаблон используется ключевое слово `when`.

### <a name="is-expression"></a>Выражение `is`

Выражение шаблона `is` позволяет использовать знакомый [оператор `is`](../language-reference/keywords/is.md#pattern-matching-with-is) для запроса объектов без учета их типов.

Начнем с простого сценария. Добавим в него возможности, демонстрирующие, каким образом выражения сопоставления шаблонов упрощают создание алгоритмов, работающих с несвязанными типами. Начнем с метода, который вычисляет сумму чисел, выпавших на игральном кубике:

[!code-csharp[SumDieRolls](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#14_SumDieRolls "Sum die rolls")]

Легко понять, что сумму чисел, выпавших при броске, необходимо вычислять с учетом того, что кубиков может быть больше одного. При этом вместо отдельного значения входная последовательность может содержать сразу несколько результатов:

[!code-csharp[SumDieRollsWithGroups](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#15_SumDieRollsWithGroups "Sum die rolls with groups")]

Выражение шаблона `is` работает в этом сценарии довольно хорошо. Для проверки типа вы пишете инициализацию переменной. При этом создается новая переменная проверенного типа среды выполнения.

По мере расширения сценария может оказаться, что число созданных операторов `if` и `else if` возросло. Если код становится слишком громоздким, следует перейти на выражения шаблонов `switch`.

### <a name="switch-statement-updates"></a>Обновления оператора `switch`

*Выражение сопоставления* имеет знакомый синтаксис, основанный на операторе `switch`, который уже является частью языка C#. Переведем существующий код таким образом, чтобы перед добавлением новых случаев использовалось выражение сопоставления: 

[!code-csharp[SumUsingSwitch](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#16_SumUsingSwitch "Sum using switch")]

Выражения сопоставления несколько отличаются по своему синтаксису от выражений `is`, где тип и переменная объявляются в начале выражения `case`.

Кроме того, выражения сопоставления поддерживают константы. Это позволяет экономить время, выделяя простые варианты:

[!code-csharp[SwitchWithConstants](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#17_SwitchWithConstants "Switch with constants")]

Приведенный выше код добавляет вариант `0` как частный вариант `int`, а `null` — как частный вариант, когда входных данных нет. Этот пример демонстрирует одну важную новую особенность в переключении выражений шаблонов: теперь порядок выражений `case` имеет значение. Вариант `0` должен отображаться до общего варианта `int`. В противном случае, даже если значение равно `0`, первым шаблоном, с которым будет выполняться сопоставление, станет вариант `int`. Если вы случайно расположите выражения сопоставления так, что более поздний вариант будет обработан раньше, компилятор это отметит и выдаст ошибку.

Именно это поведение позволяет задавать для пустой входной последовательности частный вариант.
Как видите, вариант для элемента `IEnumerable` должен отображаться раньше общего случая `IEnumerable`.

В этой версии также добавлен вариант `default`. Вариант `default` всегда вычисляется последним независимо от порядка отображения вариантов в источнике. В связи с этим вариант `default` принято указывать последним.

Наконец, добавим еще один, последний `case` для нового стиля кубиков. В некоторых играх для представления расширенного диапазона значений используется процентный кубик. 

> [!NOTE]
> Два десятигранных кубика позволяют получить любое число от 0 до 99. Грани одного кубика обозначены как `00`, `10`, `20`, ... `90`. Грани другого кубика обозначены как `0`, `1`, `2`, ... `9`. Сложив значения на двух кубиках, можно получить любое число от 0 до 99.

Чтобы добавить такой кубик в коллекцию, в первую очередь определите тип, представляющий процентные кубики. В свойстве `TensDigit` хранятся значения `0`, `10`, `20`, вплоть до `90`.

[!code-csharp[18_PercentileDice](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#18_PercentileDice "Percentile Die type")]

Затем добавьте выражение сопоставления `case` для нового типа:

[!code-csharp[SwitchWithNewTypes](../../../samples/snippets/csharp/new-in-7/patternmatch.cs#19_SwitchWithNewTypes "Include Percentile Die type")]

Новый синтаксис для выражений сопоставления шаблонов упрощает процесс создания алгоритмов отправки на основе типа или других свойств объекта, позволяя использовать ясный и четкий синтаксис. Выражения сопоставления шаблонов включают эти конструкции для типов данных, не связанных наследованием.

Дополнительные сведения о сопоставлении шаблонов см. в разделе, посвященном [сопоставлению шаблонов в C#](../pattern-matching.md).

## <a name="ref-locals-and-returns"></a>Локальные переменные и возвращаемые значения Ref

Эта функция активирует алгоритмы, которые используют и возвращают ссылки на переменные, определенные в другом месте. В качестве примера можно привести работу с большими матрицами и поиск одного местоположения с определенными характеристиками. Один метод возвращает два индекса для одного местоположения в матрице:

[!code-csharp[FindReturningIndices](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#20_FindReturningIndices "Find returning indices")]

С этим кодом связано много сложностей. Во-первых, это открытый метод, который возвращает кортеж. Язык это поддерживает, однако для открытых API предпочтительнее использовать типы, определенные пользователями (классы или структуры).

Во-вторых, этот метод возвращает индексы в элемент матрицы.
В результате вызывающие объекты записывают код, который использует эти индексы, чтобы разыменовать матрицу и изменить отдельный элемент:

[!code-csharp[UpdateItemFromIndices](../../../samples/snippets/csharp/new-in-7/program.cs#21_UpdateItemFromIndices "Update Item From Indices")]

Вместо этого лучше написать метод, возвращающий *ссылку* на элемент матрицы, который нужно изменить. Это можно сделать только одним способом —применив небезопасный код и вернув указатель в `int` в предыдущих версиях.

Рассмотрим подробно ряд изменений, чтобы продемонстрировать локальную функцию ref и показать, каким образом создается метод, возвращающий ссылку на внутреннее хранилище.
Параллельно вы узнаете правила возвращаемого значения ref и локальной функции ref, которая защищает вас от случайных ошибок в его использовании.

Для начала изменим объявление метода `Find` таким образом, чтобы вместо кортежа он возвращал `ref int`. Затем изменим оператор return, сделав так, чтобы вместо двух индексов он возвращал значение, хранящееся в матрице:

```csharp
// Note that this won't compile. 
// Method declaration indicates ref return,
// but return statement specifies a value return.
public static ref int Find2(int[,] matrix, Func<int, bool> predicate)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
        for (int j = 0; j < matrix.GetLength(1); j++)
            if (predicate(matrix[i, j]))
                return matrix[i, j];
    throw new InvalidOperationException("Not found");
}
```

Объявляя, что метод возвращает переменную `ref`, в каждый оператор return необходимо также добавить ключевое слово `ref`. Это обозначает возврат по ссылке и позволяет разработчикам, которые будут читать код позднее, запомнить, что метод возвращается по ссылке:

[!code-csharp[FindReturningRef](../../../samples/snippets/csharp/new-in-7/MatrixSearch.cs#22_FindReturningRef "Find returning by reference")]

Теперь, когда метод возвращает ссылку на целочисленное значение в матрице, необходимо изменить место его вызова.  Объявление `var` означает, что `valItem` теперь не кортеж, а `int`:

[!code-csharp[AssignRefReturnToValue](../../../samples/snippets/csharp/new-in-7/program.cs#23_AssignRefReturnToValue "Assign ref return to value")]

Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `42`, а не `24`. Переменная `valItem` — это `int`, а не `ref int`. Ключевое слово `var` дает компилятору возможность указать тип, но не позволяет неявно добавить модификатор `ref`. Вместо этого значение, на которое ссылается `ref return`, *копируется* в переменную в левой части назначения. Переменная не является локальной переменной `ref`.

Для получения нужного результата необходимо добавить модификатор `ref` в объявление локальной переменной, чтобы в случае, если возвращаемое значение является ссылкой, переменная стала ссылкой:

[!code-csharp[AssignRefReturn](../../../samples/snippets/csharp/new-in-7/program.cs#24_AssignRefReturn "Assign ref return")]

Второй оператор `WriteLine` в приведенном выше примере выводит на экран значение `24`, показывая, что хранилище в матрице было изменено. Локальная переменная объявлена с помощью модификатора `ref` и принимает возвращаемое значение `ref`. Переменную `ref` необходимо инициализировать при объявлении, отделять объявление от инициализации нельзя.

Язык C# включает три других правила, которые защищают вас от неправильного использования возвращаемых значений и локальных переменных `ref`.

* Присвоить локальной переменной `ref` стандартное возвращаемое значение метода нельзя.
    - Это запрещает использовать операторы вида `ref int i = sequence.Count();`
* Переменную `ref` нельзя возвращать переменной, которая продолжает существовать даже после того, как метод будет выполнен.
    - Это означает невозможность возвращения ссылки на локальную переменную или переменную с аналогичной областью.
* Возвращаемые значения и локальные переменные `ref` не могут использоваться с асинхронными методами.
    - На момент, когда асинхронный метод возвращает значение, компилятору неизвестно, присвоено ли переменной, на которую указывает ссылка, окончательное значение.

Добавление локальных переменных и возвращаемых значений ref дает возможность использовать более эффективные алгоритмы, поскольку избавляет от необходимости многократно копировать значения или выполнять операции разыменования.

Добавление `ref` для возврата значения является [изменением, совместимым на уровне исходного кода](version-update-considerations.md#source-compatible-changes). Существующий код компилируется, но возвращаемое значение ссылочного типа копируется при назначении. Вызывающие объекты должны изменить переменную хранилища для возвращаемого значения на локальную переменную `ref`, чтобы это значение хранилось в качестве ссылки.

Дополнительные сведения см. в статье [ref (Справочник по C#)](../language-reference/keywords/ref.md).

## <a name="local-functions"></a>Локальные функции

Модели многих классов включают методы, вызываемые только из одного места. Эти дополнительные закрытые методы делают каждый метод небольшим и направленным. В то же время они могут затруднять понимание класса при первом прочтении. Эти методы должны быть понятны и вне контекста единой точки вызова.

В подобных моделях *локальные функции* позволяют объявлять методы в контексте другого метода. В результате читателям класса проще увидеть, что локальный метод вызывается только из того контекста, в котором он был объявлен.

Существуют два очень общих варианта использования локальных функций: открытые методы итератора и открытые асинхронные методы. Оба эти типа методов создают код, который сообщает об ошибках позднее, чем могли ожидать программисты. В случае методов итератора исключения наблюдаются только при вызове кода, перечисляющего возвращенную последовательность. В случае асинхронных методов исключения наблюдаются только при ожидании возвращаемого объекта `Task`.

Начнем с метода итератора:

[!code-csharp[IteratorMethod](../../../samples/snippets/csharp/new-in-7/Iterator.cs#25_IteratorMethod "Iterator method")]

Изучите следующий код, который вызывает метод итератора неправильно:

[!code-csharp[CallIteratorMethod](../../../samples/snippets/csharp/new-in-7/program.cs#26_CallIteratorMethod "Call iterator method")]

Исключение возникает при итерации `resultSet`, а не при создании `resultSet`.
В этом примере большинство разработчиков смогут быстро диагностировать проблему. Однако в больших базах кода код, который создает итератор, часто не так близок к коду, перечисляющему результат. Код можно оптимизировать так, чтобы открытый метод проверял все аргументы, а закрытый метод создавал перечисление:

[!code-csharp[IteratorMethodRefactored](../../../samples/snippets/csharp/new-in-7/Iterator.cs#27_IteratorMethodRefactored "Iterator method refactored")]

Оптимизированная версия сразу выдает исключения, поскольку открытый метод не является методом итератора; синтаксис `yield return` использует только закрытый метод. В то же время при оптимизации могут возникнуть проблемы. Закрытый метод следует вызывать только из открытого метода интерфейса, поскольку иначе проверка всех аргументов будет пропущена.
Читатели класса должны обнаружить это, прочитав весь класс и выполнив поиск всех остальных ссылок на метод `alphabetSubsetImplementation`.

Эту цель проекта можно сделать более очевидной, объявив `alphabetSubsetImplementation` как локальную функцию в открытом методе API:

[!code-csharp[22_IteratorMethodLocal](../../../samples/snippets/csharp/new-in-7/Iterator.cs#28_IteratorMethodLocal "Iterator method with local function")]

Приведенная выше версия поясняет, что ссылка на локальный метод возможна только в контексте внешнего метода. Кроме того, правила для локальных функций не позволяют разработчику случайно вызвать локальную функцию из другого места в классе и обойти проверку аргументов.

Та же технология может применяться с методами `async` для того, чтобы исключения, возникающие при проверке параметров, выдавались до начала асинхронной работы:

[!code-csharp[TaskExample](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

> [!NOTE]
> Некоторые из макетов, поддерживаемых локальными функциями, также могут выполняться с помощью *лямбда-выражений*. Если вам интересно, [прочтите более подробные сведения о различиях](../local-functions-vs-lambdas.md).

## <a name="more-expression-bodied-members"></a>Другие элементы, воплощающие выражение

В C# версии 6 появились [элементы, воплощающие выражение](csharp-6.md#expression-bodied-function-members), для функций-членов и свойств, доступных только для чтения. В C# 7.0 расширен список допустимых членов, которые могут быть реализованы как выражения. В C# 7.0 можно реализовать *конструкторы*, *методы завершения*, а также методы доступа `get` и `set` для *свойств* и *индексаторов*. В следующем коде показаны примеры каждого из них:

[!code-csharp[ExpressionBodiedMembers](../../../samples/snippets/csharp/new-in-7/expressionmembers.cs#36_ExpressionBodiedEverything "new expression-bodied members")]

> [!NOTE]
> В этом примере метод завершения не требуется, он приводится для демонстрации синтаксиса. Метод завершения следует реализовывать в классе только в том случае, если это необходимо для высвобождения неуправляемых ресурсов. Кроме того, вместо управления неуправляемыми ресурсами напрямую можно воспользоваться классом <xref:System.Runtime.InteropServices.SafeHandle>.

Новые расположения для элементов, составляющих выражение, представляют важный этап развития языка C#. Эти функции были реализованы членами сообщества, работающими над проектом [Roslyn](https://github.com/dotnet/Roslyn) с открытым исходным кодом.

Изменение метода на элемент, воплощающий выражение, является [совместимым на уровне двоичного кода](version-update-considerations.md#binary-compatible-changes).

## <a name="throw-expressions"></a>Выражения throw

В C# `throw` всегда был оператором. Поскольку `throw` — оператор, а не выражение, конструкции C# находились там, где использовать их было невозможно. Они включали условные выражения, выражения объединения со значением NULL и некоторые лямбда-выражения. Добавление элементов, воплощающих выражение, расширяет список мест, в которых могут пригодиться выражения `throw`. Для записи этих конструкций в C# 7.0 представлены *выражения throw*.

При этом используется тот же синтаксис, что и для операторов `throw`. Единственное отличие состоит в том, что теперь эти конструкции можно размещать в новых местах, таких как условное выражение:

[!code-csharp[Throw_ExpressionExample](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#37_Throw_ExpressionExample "conditional throw expressions")]

Эта функция позволяет использовать выражения throw в выражениях инициализации:

[!code-csharp[ThrowInInitialization](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#38_ThrowInInitialization "conditional throw expressions")]

Ранее эти инициализации должны были находиться в конструкторе, а операторы throw — в теле конструктора:


[!code-csharp[ThrowInConstructor](../../../samples/snippets/csharp/new-in-7/throwexpressions.cs#39_ThrowInConstructor "throw statements")]

> [!NOTE]
> При построении объекта обе представленные выше конструкции вызывают исключения. Устранить их, как правило, непросто.
> По этой причине макеты, вызывающие исключения в процессе построения, использовать не рекомендуется.

## <a name="generalized-async-return-types"></a>Обобщенные асинхронные типы возвращаемых значений

В некоторых случаях возврат объекта `Task` из асинхронных методов может вызывать сложности. `Task` — это тип ссылки, поэтому его применение означает распределение объекта. В случаях, когда метод, объявленный с модификатором `async`, возвращает кэшированный результат или завершается синхронно, лишние распределения могут вызывать серьезные потери времени при выполнении фрагментов кода, зависящих от производительности. Эта проблема встает особенно серьезно, если распределения происходят в коротких циклах.

Новая возможность языка означает, что помимо `Task`, `Task<T>` и `void`, асинхронные методы могут возвращать и другие типы. Возвращаемый тип должен по-прежнему соответствовать асинхронному шаблону, а значит, метод `GetAwaiter` должен быть доступен. Конкретный пример: в .NET Framework добавлен новый тип `ValueTask`, позволяющий использовать эту новую возможность языка: 

[!code-csharp[UsingValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#30_UsingValueTask "Using ValueTask")]

> [!NOTE]
> Чтобы использовать тип <xref:System.Threading.Tasks.ValueTask%601>, необходимо добавить пакет NuGet [`System.Threading.Tasks.Extensions`](https://www.nuget.org/packages/System.Threading.Tasks.Extensions/).

В качестве простой оптимизации вместо используемой раньше структуры `Task` можно использовать структуру `ValueTask`. При этом, если дополнительные оптимизации нужно выполнить вручную, можно кэшировать результаты из асинхронной работы и применить их повторно в последующих вызовах. Структура `ValueTask` включает конструктор с параметром `Task`, что позволяет собрать `ValueTask` из возвращаемого значения любого существующего асинхронного метода:

[!code-csharp[AsyncOptimizedValueTask](../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#31_AsyncOptimizedValueTask "Return async result or cached value")]

Как и в случае с остальными рекомендациями по повышению производительности, прежде чем вносить в код значительные изменения, обе версии необходимо протестировать.

Если возвращаемое значение является целевым объектом инструкции `await`, изменение API с <xref:System.Threading.Tasks.Task%601> на <xref:System.Threading.Tasks.ValueTask%601> считается [совместимым на уровне исходного кода](version-update-considerations.md#source-compatible-changes). Как правило, изменение на `ValueTask` не считается таким.

## <a name="numeric-literal-syntax-improvements"></a>Усовершенствования в синтаксисе числовых литералов

Неправильное толкование числовых констант затрудняет понимание кода при первом прочтении. Это часто случается, когда эти числа используются как битовые маски или иные символьные, а не числовые значения. C# 7.0 содержит две новые возможности для упрощения записи чисел в удобочитаемом виде: *двоичные литералы* и *разделители цифр*.

Если вы создаете битовые маски или двоичное представление числа дает наиболее удобочитаемый код, используйте запись в двоичном формате:

[!code-csharp[BinaryConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#32_BinaryConstants "Binary constants")]

`0b` в начале константы означает, что число записано в двоичном формате.

Двоичные числа могут быть очень длинными, поэтому для удобства работы с битовыми шаблонами можно разделять разряды с помощью символа `_`:

[!code-csharp[ThousandSeparators](../../../samples/snippets/csharp/new-in-7/Program.cs#33_ThousandSeparators "Thousands separators")]

Разделитель разрядов может находиться в любом месте константы. В десятичных числах он обычно используется для разделения тысяч:

[!code-csharp[LargeIntegers](../../../samples/snippets/csharp/new-in-7/Program.cs#34_LargeIntegers "Large integer")]

Разделитель разрядов можно также использовать с типами `decimal`, `float` и `double`:

[!code-csharp[OtherConstants](../../../samples/snippets/csharp/new-in-7/Program.cs#35_OtherConstants "non-integral constants")]

Суммируя вышеизложенное, числовые константы можно объявлять в гораздо более удобочитаемом виде.
