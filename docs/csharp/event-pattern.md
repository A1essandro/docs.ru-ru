---
title: "Стандартный шаблон событий .NET"
description: "Стандартный шаблон событий .NET"
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 8a3133d6-4ef2-46f9-9c8d-a8ea8898e4c9
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 8a72fd817270412da38ce89b456f263f931c400c
ms.lasthandoff: 03/13/2017

---

# <a name="the-standard-net-event-pattern"></a>Стандартный шаблон событий .NET

[Назад](events-overview.md)

События .NET обычно следуют нескольким известным шаблонам. Стандартизация на основе этих шаблонов означает, что разработчики могут использовать знание таких стандартных шаблонов, применяя их к любой программе событий .NET.

Мы разберем эти стандартные шаблоны, чтобы снабдить вас знаниями, необходимыми для создания источников стандартных событий, подписки и обработки стандартных событий в коде.

## <a name="event-delegate-signatures"></a>Сигнатуры делегатов событий

Стандартной сигнатурой делегата события .NET является:

```csharp
void OnEventRaised(object sender, EventArgs args);
```

Тип возвращаемого значения — void. События основаны на делегатах и являются делегатами многоадресной рассылки. Это обеспечивает поддержку нескольких подписчиков для любого источника событий. Одно значение, возвращаемое из метода, не масштабируется на несколько подписчиков событий. Какое возвращаемое значение доступно источнику события после возникновения события? Далее в этой статье будет показано, как создавать протоколы событий, которые поддерживают подписчики на события, передающие данные в источник событий.

Список аргументов содержит два аргумента: отправителя и аргументы события. Тип времени компиляции `sender` — `System.Object`, даже если вам, вероятно, известен более производный тип, который всегда является правильным. По соглашению используйте `object`.

Второй аргумент обычно являлся типом, производным от `System.EventArgs`. (В [следующем разделе](modern-events.md) вы увидите, что это соглашение больше не является обязательным.) Даже если тип события не требует дополнительных аргументов, необходимо предоставить оба аргумента.
Существует специальное значение `EventArgs.Empty`, которое следует использовать для обозначения того, что событие не содержит никаких дополнительных сведений.

Создадим класс, который перечисляет соответствующие шаблону файлы в каталоге или любом из его подкаталогов. Этот компонент создает событие для каждого найденного файла, который соответствует шаблону.

Использование модели событий обеспечивает некоторые преимущества разработки. Можно создать несколько прослушивателей событий, которые выполняют разные действия при нахождении искомого файла. Сочетание разных прослушивателей позволяет создавать более надежные алгоритмы.

Ниже показано объявление аргумента исходного события для поиска искомого файла: 

```csharp
public class FileFoundArgs : EventArgs
{
    public string FoundFile { get; }

    public FileFoundArgs(string fileName)
    {
        FoundFile = fileName;
    }
}
```

Несмотря на то, что этот тип выглядит как небольшой тип, содержащий только данные, вы должны выполнить соглашение и назначить его ссылочным типом (`class`). Это означает, что объект аргумента будет передаваться по ссылке, а любые обновления данных будут доступны всем подписчикам. Первая версия является неизменяемым объектом. Рекомендуется сделать свойства в типе аргумента события неизменяемыми. Таким образом, один подписчик не сможет изменить значения до того, как их увидит другой подписчик. (Существуют исключения, как можно будет увидеть ниже.)  

Затем нужно создать объявление события в классе FileSearcher. Использование типа `EventHandler<T>` означает, что вам не требуется создавать еще одно определение типа. Вы просто используете универсальную специализацию.

Заполним класс FileSearcher для поиска файлов, соответствующих шаблону, и вызова правильного события при обнаружении совпадения.

```csharp
public class FileSearcher
{
    public event EventHandler<FileFoundArgs> FileFound;

    public void Search(string directory, string searchPattern)
    {
        foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
        {
            FileFound?.Invoke(this, new FileFoundArgs(file));
        }
    }
}
```

## <a name="definining-and-raising-field-like-events"></a>Определение и вызов событий, подобных полям

Самый простой способ добавить событие в класс — объявить это событие как открытое поле, как показано в приведенном выше примере.

```csharp
public event EventHandler<FileFoundArgs> FileFound;
```

Создание открытых полей не рекомендуется в объектно-ориентированном программировании, поскольку необходимо обеспечить защиту доступа к данным с помощью свойств и методов. Хотя это выглядит нарушением рекомендаций, код, созданный компилятором, создает программы-оболочки, чтобы доступ к объектам событий мог осуществляться только безопасным образом. Единственные операции, доступные для событий, подобных полям, — обработчик add:

```csharp
EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
    Console.WriteLine(eventArgs.FoundFile);
lister.FileFound += onFIleFound;
```

и обработчик remove:

```csharp
lister.FileFound -= onFileFound;
```

Обратите внимание, что для обработчика используется локальная переменная. Если вы используете тело лямбда-выражения, удаление не будет работать корректно. Будет существовать другой экземпляр делегата, не выполняющий никаких действий.

Код вне класса не может вызывать события, а также выполнять другие операции.

## <a name="returning-values-from-event-subscribers"></a>Получение возвращаемых значений от подписчиков на событие

Простая версия работает нормально. Давайте добавим еще одну возможность — отмену.

При вызове события нахождения прослушиватели должны иметь возможность остановить дальнейшую обработку, если этот файл является последним искомым.

Обработчики событий не возвращают значение, поэтому вам нужно выполнить это другим способом. Стандартный шаблон события использует объект EventArgs для включения полей, которые подписчики на события могут использовать для передачи сообщения об отмене.

Для этого случая предусмотрено два разных шаблона, которые можно использовать в зависимости от семантики контракта "Отмена". В обоих случаях в EventArguments добавляется логическое поле для события найденного файла. 

Один шаблон позволяет любому одному подписчику отменить операцию.
Для этого шаблона новое поле инициализируется значением `false`. Любой подписчик можно изменить его на `true`. После того как все подписчики увидят событие, компонент FileSearcher проверяет логическое значение и выполняет действие.

Второй шаблон отменяет операцию, только если все подписчики подтвердили ее отмену. В этом шаблоне новое поле инициализируется для указания того, что операцию следует отменить, и любой подписчик может изменить его, чтобы указать, что следует продолжить операцию.
После того как все подписчики увидят событие, компонент FileSearcher проверяет логическое значение и выполняет действие. В этом шаблоне есть еще один дополнительный шаг: компонент должен знать, все ли подписчики видели событие. Если подписчики отсутствуют, поле неверно сообщит об отмене.

Реализуем первую версию для этого примера. Вам потребуется добавить логическое поле типа FileFoundEventArgs:

```csharp
public class FileFoundArgs : EventArgs
{
    public string FoundFile { get; }
    public bool CancelRequested { get; set; }

    public FileFoundArgs(string fileName)
    {
        FoundFile = fileName;
    }
}
```

Это новое поле должно быть инициализировано значением false, чтобы не выполнять отмену без причины. Это значение по умолчанию для логического поля, поэтому оно задается автоматически. Единственным другим изменением в компоненте является установка флага после вызова события для просмотра, если любой из подписчиков запросил отмену:

```csharp
public void List(string directory, string searchPattern)
{
    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
    {
        var args = new FileFoundArgs(file);
        FileFound?.Invoke(this, args);
        if (args.CancelRequested)
            break;
    }
}
```

Одно из преимуществ этого шаблона заключается в том, что это не является критическим изменением.
Ни один из подписчиков не запросил отмену и не запрашивает до сих пор. Код подписчиков не требует обновления, если не требуется поддержка нового протокола отмены. Они очень слабо связаны.

Изменим подписчик, чтобы он запрашивал отмену, когда обнаруживает первый исполняемый файл:

```csharp
EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
{
    Console.WriteLine(eventArgs.FoundFile);
    eventArgs.CancelRequested = true;
};
```

## <a name="adding-another-event-declaration"></a>Добавление другого объявления события

Добавим еще одну возможность и продемонстрируем другие выражения языка для событий. Добавим перегрузку метода `Search()`, который проходит через все подкаталоги в поиске файлов.

Эта операция может выполняться длительное время в каталоге с большим числом вложенных каталогов. Добавим событие, которое вызывается в начале каждого нового поиска в каталоге. Это позволяет подписчикам отслеживать ход выполнения и сообщать о нем пользователю. Все примеры, которые мы создали до сих пор, являются открытыми. Сделаем это событие внутренним. Это означает, что типы, используемые для аргументов, также можно сделать внутренними.

Вы начнете с создания нового производного класса EventArgs для передачи сведений о новом каталоге и ходе выполнения. 

```csharp
internal class SearchDirectoryArgs : EventArgs
{
    internal string CurrentSearchDirectory { get; }
    internal int TotalDirs { get; }
    internal int CompletedDirs { get; }

    internal SearchDirectoryArgs(string dir, int totalDirs, int completedDirs)
    {
        CurrentSearchDirectory = dir;
        TotalDirs = totalDirs;
        CompletedDirs = completedDirs;
    }
}
``` 

Опять же, вы можете следовать рекомендациям по созданию неизменяемого ссылочного типа для аргументов событий.

Теперь определим событие. На этот раз будет использоваться другой синтаксис. Помимо синтаксиса полей можно явно создать свойство c помощью обработчиков add и remove. В этом примере вам не потребуется дополнительный код в этих обработчиках в данном проекте, тем не менее здесь демонстрируется их создание.

```csharp
internal event EventHandler<SearchDirectoryArgs> DirectoryChanged
{
    add { directoryChanged += value; }
    remove { directoryChanged -= value; }
}
private EventHandler<SearchDirectoryArgs> directoryChanged;
```

По большей части код, созданный здесь, отражает код, создаваемый компилятором для определения полей событий, как было показано ранее. Для создания события используется синтаксис, очень похожий на используемый для [свойств](properties.md). Обратите внимание, что обработчики имеют разные имена: `add` и `remove`. Они вызываются для подписки на событие или отмены подписки на событие. Учтите, что вы также должны объявить закрытое резервное поле для хранения переменной событий. Оно инициализируется значением NULL.

Теперь добавим перегрузку метода Search(), который проходит по подкаталогам и вызывает оба события. Для этого проще всего использовать аргумент по умолчанию для задания поиска по всем каталогам:

```csharp
public void Search(string directory, string searchPattern, bool searchSubDirs = false)
{
    if (searchSubDirs)
    {
        var allDirectories = Directory.GetDirectories(directory, "*.*", SearchOption.AllDirectories);
        var completedDirs = 0;
        var totalDirs = allDirectories.Length + 1;
        foreach (var dir in allDirectories)
        {
            directoryChanged?.Invoke(this,
                new SearchDirectoryArgs(dir, totalDirs, completedDirs++));
            // Recursively search this child directory:
            SearchDirectory(dir, searchPattern);
        }
        // Include the Current Directory:
        directoryChanged?.Invoke(this,
            new SearchDirectoryArgs(directory, totalDirs, completedDirs++));
        SearchDirectory(directory, searchPattern);
    }
    else
    {
        SearchDirectory(directory, searchPattern);
    }
}

private void SearchDirectory(string directory, string searchPattern)
{
    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))
    {
        var args = new FileFoundArgs(file);
        FileFound?.Invoke(this, args);
        if (args.CancelRequested)
            break;
    }
}
```

На этом этапе можно запустить приложение, вызывающее перегруженный метод для поиска всех вложенных каталогов. Для нового события `ChangeDirectory` нет подписчиков, однако благодаря использованию идиомы `?.Invoke()` мы можем гарантировать правильную работу метода.

 Добавим обработчик для написания строки, показывающей ход выполнения в окне консоли. 

```csharp
lister.DirectoryChanged += (sender, eventArgs) =>
{
    Console.Write($"Entering '{eventArgs.CurrentSearchDirectory}'.");
    Console.WriteLine($" {eventArgs.CompletedDirs} of {eventArgs.TotalDirs} completed...");
};
```

Мы познакомились с шаблонами, которые используются во всей экосистеме .NET.
Научившись использовать эти шаблоны и соглашения, вы сможете быстро создавать код C# и .NET на основе идиом.

Далее мы рассмотрим некоторые изменения в этих шаблонах в самой последней версии .NET.

[Далее](modern-events.md)

