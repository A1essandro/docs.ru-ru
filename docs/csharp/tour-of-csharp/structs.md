---
title: Структуры в C#. Краткий обзор языка C#
description: Основная информация о типах значений C# под названием структуры
ms.date: 08/10/2016
ms.assetid: 88a74571-f741-4a31-a2b5-1ccf165535b8
ms.openlocfilehash: 2b1870713b488f706f5f3a54413461052173bab6
ms.sourcegitcommit: d88024e6d6d8b242feae5f4007a709379355aa24
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2018
ms.locfileid: "49323101"
---
# <a name="structs"></a>Структуры

Как и классы, ***структуры*** — это сущности для хранения данных, которые могут содержать данные-члены и функции-члены. Но в отличие от классов, структуры являются типами значений и для них не выделяется память из кучи. Переменная типа структура напрямую хранит все свои данные, а переменная типа класс хранит ссылку на динамически выделяемый объект. Типы структуры не поддерживают определяемое пользователем наследование. Все типы структуры неявно наследуются от типа <xref:System.ValueType>, который, в свою очередь, неявно наследуется от `object`.

Структуры особенно удобны для небольших структур данных, имеющих семантику значений. Хорошими примерами структур можно считать комплексные числа, точки в системе координат или словари с парами ключ-значение. Если использовать структуры вместо классов для небольших структур данных, можно существенно снизить количество операций по выделению памяти в приложении. Например, следующая программа создает и инициализирует массив из 100 точек. Если реализовать `Point` как класс, создаются экземпляры для 101 отдельных объектов — один для массива и еще 100 для его элементов.

[!code-csharp[PointClassUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L5-L13)]

Есть другой вариант — реализовать точки как структуры.

[!code-csharp[PointStruct](../../../samples/snippets/csharp/tour/structs/Point.cs#L3-L11)]

Теперь создается всего один объект (для массива), а экземпляры `Point` хранятся в стеке массива.

Конструкторы структур, как и конструкторы класса, вызываются с помощью оператора `new`. Но вместо того, чтобы динамически выделять объект в управляемой куче и возвращать ссылку на него, конструктор структуры возвращает само значение структуры (обычно сохраняя его во временном расположении в стеке), и затем это значение копируется туда, где оно нужно.

При использовании классов две переменные могут ссылаться на один и тот же объект, поэтому может случиться так, что операции над одной переменной затронут объект, на который ссылается другая переменная. При использовании структур каждая переменная имеет собственную копию данных, и операции над одной переменной не могут затрагивать другую. Например, выходные данные следующего фрагмента кода зависят от того, реализованы ли точки как класс или как структура.

[!code-csharp[PointUse](../../../samples/snippets/csharp/tour/structs/Program.cs#L19-L22)]

Если `Point` является классом, то возвращается значение 20, поскольку a и b ссылаются на один объект. Если Point является структурой, возвращается значение 10, поскольку при сохранении `a` в `b` создается копия значения, и это значение не изменяется при последующем присваивании в `a.x`.

Предыдущий пример демонстрирует два ограничения, действующие для структур. Во-первых, копирование структуры целиком обычно менее эффективно, чем копирование ссылки на объект, поэтому присваивание и передача в качестве параметра потребует больше затрат для структур, чем для ссылочных типов. Во-вторых, вы не можете создавать ссылки на структуры (за исключением параметров `in`, `ref` и `out`), что в некоторых ситуациях мешает их применять.

>[!div class="step-by-step"]
[Назад](classes-and-objects.md)
[Вперед](arrays.md)
