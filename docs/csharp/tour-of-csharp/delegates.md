---
title: "Делегаты в C# | Краткий обзор языка C#"
description: "Информация о позднем связывании с помощью делегатов в C#"
keywords: ".NET, c#, делегат, лямбда-выражения, позднее связывание"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 3cc27357-3ac2-43a1-aad0-86a77b88f884
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 5cb45d7ae09430c87872a12a0ceb451d5b2b5fda
ms.lasthandoff: 03/13/2017

---

# <a name="delegates"></a>Делегаты

***Тип delegate*** представляет ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Принцип работы делегатов близок к указателям функций из некоторых языков, но в отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированными.

Следующий пример кода объявляет и использует тип делегата с именем `Function`.

[!code-csharp[DelegateExample](../../../samples/snippets/csharp/tour/delegates/Program.cs#L3-L37)]

Экземпляр `Function` с типом делегата может ссылаться на любой метод, который принимает аргумент `double` и возвращает значение `double`. Метод `Apply` применяет заданную функцию к элементам `double[]` и возвращает `double[]` с результатами. В методе `Main` используется `Apply` для применения трех различных функций к `double[]`.

Делегат может ссылаться на статический метод (например, `Square` или `Math.Sin` в предыдущем примере) или метод экземпляра (например, `m.Multiply` в предыдущем примере). Делегат, который ссылается на метод экземпляра, содержит и ссылку на конкретный объект. Когда метод экземпляра вызывается через делегат, обращение this в этом вызове применяется к указанному в делегате объекту.

Делегаты могут также создаваться с использованием анонимных функций, то есть создаваемых на ходу "встроенных методов". Анонимные функции могут использовать локальные переменные соседних методов. Таким образом, приведенный выше пример умножения можно записать проще и без использования класса множителя:

[!code-csharp[LambdaExample](../../../samples/snippets/csharp/tour/delegates/Program.cs#L44-L44)]

Также стоит упомянуть о такой интересной и полезной особенности делегата, что он не имеет информации или ограничений в отношении того, к какому классу относится указанный в нем метод. Достаточно лишь, чтобы указанный метод имел такие же типы параметров и возвращаемого значения, которые назначены для делегата.

>[!div class="step-by-step"]
[Назад](enums.md)
[Вперед](attributes.md)

