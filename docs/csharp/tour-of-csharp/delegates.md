---
title: "Делегаты в C# | Краткий обзор языка C#"
description: "Информация о позднем связывании с помощью делегатов в C#"
keywords: ".NET, c#, делегат, лямбда-выражения, позднее связывание"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 3cc27357-3ac2-43a1-aad0-86a77b88f884
ms.translationtype: Human Translation
ms.sourcegitcommit: 19006cc5f24ffc66b92e53e8174c6bd33c249679
ms.openlocfilehash: 9cfefa5f781944b41828ebb61004f960e6cf3d59
ms.contentlocale: ru-ru
ms.lasthandoff: 04/14/2017

---

# <a name="delegates"></a>Делегаты

***Тип delegate*** представляет ссылки на методы с конкретным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Принцип работы делегатов близок к указателям функций из некоторых языков, но в отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированными.

Следующий пример кода объявляет и использует тип делегата с именем `Function`.

[!code-csharp[DelegateExample](../../../samples/snippets/csharp/tour/delegates/Program.cs#L3-L37)]

Экземпляр `Function` с типом делегата может ссылаться на любой метод, который принимает аргумент `double` и возвращает значение `double`. Метод `Apply` применяет заданную функцию к элементам `double[]` и возвращает `double[]` с результатами. В методе `Main` используется `Apply` для применения трех различных функций к `double[]`.

Делегат может ссылаться на статический метод (например, `Square` или `Math.Sin` в предыдущем примере) или метод экземпляра (например, `m.Multiply` в предыдущем примере). Делегат, который ссылается на метод экземпляра, также содержит ссылку на конкретный объект. Когда метод экземпляра вызывается через делегат, этот объект превращается в `this` в вызове.

Делегаты могут также создаваться с использованием анонимных функций, то есть создаваемых на ходу "встроенных методов". Анонимные функции могут использовать локальные переменные соседних методов. Таким образом, приведенный выше пример умножения можно записать проще и без использования класса множителя:

[!code-csharp[LambdaExample](../../../samples/snippets/csharp/tour/delegates/Program.cs#L44-L44)]

Также стоит упомянуть о такой интересной и полезной особенности делегата, что он не имеет информации или ограничений в отношении того, к какому классу относится указанный в нем метод. Достаточно лишь, чтобы указанный метод имел такие же типы параметров и возвращаемого значения, которые назначены для делегата.

>[!div class="step-by-step"]
[Назад](enums.md)
[Вперед](attributes.md)

