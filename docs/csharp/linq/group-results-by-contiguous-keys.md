---
title: Группирование результатов по смежным ключам
description: Сведения о группировании результатов по смежным ключам.
ms.date: 12/1/2016
ms.assetid: cbda9c08-151b-4c9e-82f7-c3d7f3dac66b
ms.openlocfilehash: a8d6ac133932a12154d5b23454065144c7652067
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33281441"
---
# <a name="group-results-by-contiguous-keys"></a>Группирование результатов по смежным ключам

В приведенном ниже примере показано, как сгруппировать элементы в блоки, представляющие последовательности смежных ключей. Например, предположим, что имеется следующая последовательность пар "ключ-значение":  
  
|Ключ|Значение|  
|---------|-----------|  
|А|Мы|  
|А|думаем,|  
|А|что|  
|С|LINQ|  
|В|является|  
|А|действительно|  
|С|известным|  
|С|!|  
  
 Следующие группы будут созданы в таком порядке:  
  
1.  Мы думаем, что  
  
2.  LINQ  
  
3.  является  
  
4.  действительно  
  
5.  известным, !  
  
 Решение реализуется как метод расширения, который является потокобезопасным и возвращает результаты потоковым образом. Иными словами, он создает группы по мере прохода по исходной последовательности. В отличие от операторов `group` и `orderby`, он может начать возвращать группы вызывающему объекту до того, как будет прочитана вся последовательность.  
  
 Потокобезопасность обеспечивается созданием копии каждой группы или блока по мере итерации исходной последовательности, как указывается в комментариях исходного кода. Если исходная последовательность имеет большой набор смежных элементов, среда CLR может создать исключение <xref:System.OutOfMemoryException>.  
  
## <a name="example"></a>Пример  
 В приведенном ниже примере показаны метод расширения и использующий его клиентский код.  
  
 [!code-csharp[cscsrefContiguousGroups#1](../../../samples/snippets/csharp/concepts/linq/how-to-group-results-by-contiguous-keys_1.cs)]  
  
 Чтобы использовать метод расширения в своем проекте, скопируйте статический класс `MyExtensions` в новый или существующий файл исходного кода и, если необходимо, добавьте директиву `using` для пространства имен, в котором он находится.  
  
## <a name="see-also"></a>См. также  
 [Выражения запросов LINQ](index.md)  
 
