---
title: "Свойства"
description: "Свойства"
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 04/03/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 6950d25a-bba1-4744-b7c7-a3cc90438c55
ms.translationtype: Human Translation
ms.sourcegitcommit: f9eab74a3b259037aff30320753191eee95aa974
ms.openlocfilehash: 763a76a8ea0e48fd6935c951ce584efad50dabb9
ms.contentlocale: ru-ru
ms.lasthandoff: 04/25/2017

---

# <a name="properties"></a>Свойства

Свойства являются привилегированными компонентами C#. Язык определяет синтаксис, который позволяет разработчикам писать код, отражающий цели их проекта.

Свойства при обращении к ним ведут себя как поля.
Однако в отличие от полей свойства реализуются с помощью методов доступа, которые определяют инструкции, выполняемые при обращении к свойству или при его назначении.

## <a name="property-syntax"></a>Синтаксис свойства

Синтаксис свойств является естественным расширением полей. Поле определяет место хранения:

```csharp
public class Person
{
    public string FirstName;
    // remaining implementation removed from listing
}
```

Определение свойства содержит объявления для методов доступа `get` и `set`, которые получают и устанавливают значение этого свойства:

```csharp
public class Person
{
    public string FirstName { get; set; }

    // remaining implementation removed from listing
}
```

Синтаксис, показанный выше, является синтаксисом *автосвойств*. Компилятор создает место хранения для поля, поддерживающего свойство. Компилятор также реализует тело методов доступа `get` и `set`.

Бывает, что свойство необходимо инициализировать со значением, отличным от значения по умолчанию для его типа.  C# позволяет это сделать, указав значение после закрывающей фигурной скобки свойства. В этом случае в качестве начального значения для свойства `FirstName` можно задать пустую строку, а не `null`. Для этого используется следующий код:

```csharp
public class Person
{
    public string FirstName { get; set; } = string.Empty;

    // remaining implementation removed from listing
}
```

Как вы увидите далее в этой статье, данная функция особенно полезна для свойств, предназначенных только для чтения.

Вы можете определить хранилище самостоятельно, как показано ниже:

```csharp
public class Person
{
    public string FirstName
    {
        get { return firstName; }
        set { firstName = value; }
    }
    private string firstName;
    // remaining implementation removed from listing
}
```

Если реализация свойства представляет собой одиночное выражение, в качестве метода получения или задания можно использовать *элементы, воплощающие выражение*.

```csharp
public class Person
{
    public string FirstName
    {
        get => firstName;
        set => firstName = value;
    }
    private string firstName;
    // remaining implementation removed from listing
}
```

Такой упрощенный синтаксис будет применяться в этом разделе везде, где это возможно.

В примере выше определяется свойство для чтения и записи. Обратите внимание на ключевое слово `value` в методе доступа set. Метод доступа `set` всегда имеет один параметр с именем `value`. Метод доступа `get` должен возвращать значение, которое можно преобразовать в свойство (`string` в этом примере).
 
Это основные сведения о синтаксисе. Существует множество различных вариантов, поддерживающих разные идиомы. Рассмотрим их, а также соответствующие параметры синтаксиса.

## <a name="scenarios"></a>Сценарии

Приведенные выше примеры демонстрируют один из простейших вариантов определения свойств: свойство для чтения и записи без проверки. Путем написания нужного кода в методах доступа `get` и `set` можно реализовать много разных сценариев.

### <a name="validation"></a>Проверка

Можно написать код в методе доступа `set`, чтобы гарантировать, что значения, представленные свойством, всегда будут допустимыми. Например, предположим, что одно правило для класса `Person` является именем, которое не может быть пустым или содержать только пробелы. Это можно реализовать следующим образом:

```csharp
public class Person
{
    public string FirstName
    {
        get => firstName;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("First name must not be blank");
            firstName = value;
        }
    }
    private string firstName;
    // remaining implementation removed from listing
}
```

В приведенном выше примере код применяет правило о том, что имя не может быть пустым или содержать только пробелы. Если разработчик пишет

```csharp
hero.FirstName = "";
```

Это назначение создает исключение `ArgumentException`. Поскольку метод доступа set свойства должен иметь тип возвращаемого значения void, чтобы сообщить об ошибках в методе доступа set, создается исключение.

Это простой пример проверки. Этот синтаксис можно расширить для любых компонентов в вашем сценарии. Можно проверить отношения между разными свойствами или соответствие любым внешним условиям. Любые допустимые операторы C# являются допустимыми в методе доступа свойства.

### <a name="read-only"></a>Только чтение

До этого момента все примеры определения свойств определяли свойства для чтения и записи с помощью открытых методов доступа. Это не единственные операции доступа для свойств.
Можно создать свойства, доступные только для чтения, или назначить другой уровень доступа для методов set и get. Предположим, ваш класс `Person` должен допускать изменение значения свойства `FirstName` только из других методов этого класса. Вы можете предоставить методу доступа set уровень доступа `private`, а не `public`:

```csharp
public class Person
{
    public string FirstName { get; private set; }

    // remaining implementation removed from listing
}
```

Теперь к свойству `FirstName` можно получать доступ из любого кода, но назначить его можно только из другого кода в классе `Person`.

Вы можете добавить любой ограничивающий модификатор доступа для методов доступа set или get. Модификатор доступа, установленный для отдельного метода доступа, должен задавать более строгие ограничения, чем модификатор доступа для определения свойства. Приведенный выше пример допустим, так как свойство `FirstName` является открытым (`public`) а метод доступа set — закрытым (`private`). Нельзя объявить свойство `private` с методом доступа `public`. Свойство также можно объявить как `protected`, `internal`, `protected internal` или даже `private`.   

Также допускается размещение более строгих модификаторов для метода доступа `get`. Например, свойство `public` может быть открытым, а метод доступа `get` ограничен типом `private`. Этот сценарий редко реализуется на практике.

Кроме того, можно ограничить изменения в свойстве, разрешив задавать его только в конструкторе или инициализаторе свойств. Внести соответствующие изменения в класс `Person` можно следующим образом:

```csharp
public class Person
{
    public Person(string firstName)
    {
        this.FirstName = firstName;
    }

    public string FirstName { get; }

    // remaining implementation removed from listing
}
```

Эта функция чаще всего используется для инициализации коллекций, которые представляются как свойства, доступные только для чтения:

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a>Вычисляемые свойства

Свойство не обязательно должно просто возвращать значение поля члена. Можно создать свойства, возвращающие вычисляемое значение. Расширим объект `Person` так, чтобы он возвращал полное имя, вычисляемое путем объединения имени и фамилии:

```csharp
public class Person
{
    public string FirstName { get; set; }

    public string LastName { get; set; }

    public string FullName { get { return $"{FirstName} {LastName}"; } }
}
```

В примере выше используется синтаксис *интерполяции строк* для создания форматированной строки для полного имени.

Можно также использовать *члены, воплощающие значения*, которые обеспечивают более краткий способ создания вычисляемого свойства `FullName`:

```csharp
public class Person
{
    public string FirstName { get; set; }

    public string LastName { get; set; }

    public string FullName =>  $"{FirstName} {LastName}";
}
```
 
*Члены, воплощающие значения*, используют синтаксис *лямбда-выражений* для определения метода, который содержит одно выражение. Здесь это выражение возвращает полное имя объекта person.

### <a name="lazy-evaluated-properties"></a>Свойства с отложенным вычислением

Вы можете сочетать концепцию вычисляемого свойства с хранением и созданием *свойства с отложенным вычислением*.  Например, можно изменить свойство `FullName` таким образом, чтобы форматирование строки выполнялось только при первом доступе к нему.

```csharp
public class Person
{
    public string FirstName { get; set; }

    public string LastName { get; set; }

    private string fullName;
    public string FullName
    {
        get
        {
            if (fullName == null)
                fullName = $"{FirstName} {LastName}";
            return fullName;
        }
    }
}
```

Обратите внимание, что приведенный выше код содержит ошибку. Если код изменяет значение свойств `FirstName` или `LastName`, ранее вычисленное поле `fullName` является недопустимым. Вам потребуется изменить методы доступа `set` свойств `FirstName` и `LastName`, чтобы вычислить поле `fullName` еще раз:

```csharp
public class Person
{
    private string firstName;
    public string FirstName
    {
        get => firstName;
        set
        {
            firstName = value;
            fullName = null;
        }
    }

    private string lastName;
    public string LastName
    {
        get => lastName;
        set
        {
            lastName = value;
            fullName = null;
        }
    }

    private string fullName;
    public string FullName
    {
        get
        {
            if (fullName == null)
                fullName = $"{FirstName} {LastName}";
            return fullName;
        }
    }
}
```

Эта окончательная версия вычисляет свойство `FullName` только при необходимости.
Если ранее вычисленная версия является допустимой, используется она. Если другое изменение состояния делает ранее вычисленную версию недействительной, она будет пересчитана. Разработчикам, использующим этот класс, необязательно знать детали реализации. Ни одно из этих внутренних изменений не влияет на использование объекта person. Это главная причина для использования свойств для предоставления доступа к членам данных объекта.
 
### <a name="inotifypropertychanged"></a>INotifyPropertyChanged

Последним сценарием, где необходимо написать код в методе доступа к свойству, является поддержка интерфейса `INotifyPropertyChanged`, используемого для уведомления клиентов привязки данных об изменении значения. При изменении значения свойства объект вызывает событие `PropertyChanged`, указывающее на изменение. Библиотеки привязки данных, в свою очередь, изменяют отображаемые элементы на основе этого изменения. В следующем примере кода показано, как можно реализовать свойства `INotifyPropertyChanged` для `FirstName` этого класса person.

```csharp
public class Person : INotifyPropertyChanged
{
    public string FirstName
    {
        get => firstName;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("First name must not be blank");
            if (value != firstName)
            {
                PropertyChanged?.Invoke(this, 
                    new PropertyChangedEventArgs(nameof(FirstName)));
            }
            firstName = value;
        }
    }
    private string firstName;

    public event PropertyChangedEventHandler PropertyChanged;
    // remaining implementation removed from listing
}
```

Оператор `?.` называется оператором *объединения со значением NULL*. Он проверяет наличие пустой ссылки перед вычислением правой стороны оператора. В конечном итоге, если нет подписчиков на событие `PropertyChanged`, код для вызова события не выполняется. В этом случае без такой проверки будет создано исключение `NullReferenceException`. Дополнительные сведения см. на странице [`events`](delegates-events.md). В этом примере также используется новый оператор `nameof` для преобразования символа имени свойства в текстовое представление.
С помощью `nameof` можно сократить количество ошибок, возникающих при неправильном вводе имени свойства.

Кроме того, это пример случая, когда можно писать код в методах доступа для поддержки необходимых сценариев.

## <a name="summing-up"></a>Заключение

Свойства — это своего рода интеллектуальные поля в классе или объекте. Из-за пределов объекта они представляются полями в объекте. Однако для реализации свойства можно использовать полную палитру функциональных возможностей C#.
Вы можете предоставлять разные уровни доступа, выполнять проверки, отложенное вычисление или любые другие требования, необходимые в вашем сценарии.

