---
title: "Описание деревьев выражений"
description: "Сведения о деревьях выражений и их использовании при преобразовании алгоритмов для выполнения кода во внешних средах и его проверки перед выполнением."
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 14673f86d7d228bc1fc17a3154e0337b4c6e5f57
ms.contentlocale: ru-ru
ms.lasthandoff: 07/28/2017

---

# <a name="expression-trees-explained"></a><span data-ttu-id="3731c-104">Описание деревьев выражений</span><span class="sxs-lookup"><span data-stu-id="3731c-104">Expression Trees Explained</span></span>

[<span data-ttu-id="3731c-105">Предыдущий раздел: "Обзор"</span><span class="sxs-lookup"><span data-stu-id="3731c-105">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="3731c-106">Дерево выражения — это структура данных, которая определяет код.</span><span class="sxs-lookup"><span data-stu-id="3731c-106">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="3731c-107">Деревья выражений основаны на тех же структурах, которые компилятор использует для анализа кода и создания скомпилированных выходных данных.</span><span class="sxs-lookup"><span data-stu-id="3731c-107">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="3731c-108">По мере изучения этого раздела вы заметите много общего между деревьями выражений и типами, используемыми в API Roslyn для создания [анализаторов и исправлений кода](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="3731c-108">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="3731c-109">(Анализаторы и исправления кода — это пакеты NuGet, которые осуществляют статический анализ кода и могут предлагать разработчику возможные исправления.) Принципы очень схожи, а конечным результатом является структура данных, которая позволяет осмысленно изучать исходный код.</span><span class="sxs-lookup"><span data-stu-id="3731c-109">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="3731c-110">Однако деревья выражений основаны на совершенно другом наборе классов и интерфейсов API, нежели API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="3731c-110">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>
    
<span data-ttu-id="3731c-111">Рассмотрим простой пример.</span><span class="sxs-lookup"><span data-stu-id="3731c-111">Let's look at a simple example.</span></span>
<span data-ttu-id="3731c-112">Вот строка кода:</span><span class="sxs-lookup"><span data-stu-id="3731c-112">Here's a line of code:</span></span>
```csharp
var sum = 1 + 2;
```
<span data-ttu-id="3731c-113">Если анализировать ее как дерево выражения, то оно содержит несколько узлов.</span><span class="sxs-lookup"><span data-stu-id="3731c-113">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="3731c-114">Внешний узел — это оператор объявления переменной с присваиванием (`var sum = 1 + 2;`). Этот внешний узел содержит несколько дочерних узлов: объявление переменной, оператор присваивания и выражение, представляющее часть справа от знака равенства.</span><span class="sxs-lookup"><span data-stu-id="3731c-114">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="3731c-115">Это выражение далее делится на выражения, представляющие операцию сложения, а также ее левый и правый операнды.</span><span class="sxs-lookup"><span data-stu-id="3731c-115">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="3731c-116">Давайте немного более подробно рассмотрим выражения, составляющие часть справа от знака равенства.</span><span class="sxs-lookup"><span data-stu-id="3731c-116">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="3731c-117">Выражение имеет вид `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="3731c-117">The expression is `1 + 2`.</span></span> <span data-ttu-id="3731c-118">Это двоичное выражение.</span><span class="sxs-lookup"><span data-stu-id="3731c-118">That's a binary expression.</span></span> <span data-ttu-id="3731c-119">Если точнее, это выражение двоичного сложения.</span><span class="sxs-lookup"><span data-stu-id="3731c-119">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="3731c-120">Выражение двоичного сложения имеет два дочерних элемента, представляющих левый и правый узлы выражения сложения.</span><span class="sxs-lookup"><span data-stu-id="3731c-120">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="3731c-121">В этом случае оба узла являются константными выражениями: левый операнд — это значение `1`, а правый — значение `2`.</span><span class="sxs-lookup"><span data-stu-id="3731c-121">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="3731c-122">Визуально весь оператор представляет собой дерево: вы можете начать с корневого узла и переходить к каждому узлу дерева, чтобы просмотреть код, составляющий оператор.</span><span class="sxs-lookup"><span data-stu-id="3731c-122">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="3731c-123">Оператор объявления переменной с присваиванием (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="3731c-123">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
    * <span data-ttu-id="3731c-124">Неявное объявление типа переменной (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="3731c-124">Implicit variable type declaration (`var sum`)</span></span>
        - <span data-ttu-id="3731c-125">Неявное ключевое слово var (`var`)</span><span class="sxs-lookup"><span data-stu-id="3731c-125">Implicit var keyword (`var`)</span></span>
        - <span data-ttu-id="3731c-126">Объявление имени переменной (`sum`)</span><span class="sxs-lookup"><span data-stu-id="3731c-126">Variable name declaration (`sum`)</span></span>
    * <span data-ttu-id="3731c-127">Оператор присваивания (`=`)</span><span class="sxs-lookup"><span data-stu-id="3731c-127">Assignment operator (`=`)</span></span>
    * <span data-ttu-id="3731c-128">Выражение двоичного сложения (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="3731c-128">Binary addition expression (`1 + 2`)</span></span>
        - <span data-ttu-id="3731c-129">Левый операнд (`1`)</span><span class="sxs-lookup"><span data-stu-id="3731c-129">Left operand (`1`)</span></span>
        - <span data-ttu-id="3731c-130">Оператор сложения (`+`)</span><span class="sxs-lookup"><span data-stu-id="3731c-130">Addition operator (`+`)</span></span>
        - <span data-ttu-id="3731c-131">Правый операнд (`2`)</span><span class="sxs-lookup"><span data-stu-id="3731c-131">Right operand (`2`)</span></span>

<span data-ttu-id="3731c-132">Это может показаться сложным, но это очень удобно.</span><span class="sxs-lookup"><span data-stu-id="3731c-132">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="3731c-133">Тем же самым образом можно раскладывать на составные части гораздо более сложные выражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-133">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="3731c-134">Рассмотрим следующее выражение:</span><span class="sxs-lookup"><span data-stu-id="3731c-134">Consider this expression:</span></span>
```csharp
var finalAnswer = this.SecretSauceFuncion(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="3731c-135">Приведенное выше выражение также является объявлением переменной с присваиванием.</span><span class="sxs-lookup"><span data-stu-id="3731c-135">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="3731c-136">В этом экземпляре правая часть присваивания представляет собой гораздо более сложное дерево.</span><span class="sxs-lookup"><span data-stu-id="3731c-136">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="3731c-137">Мы не будем раскладывать это выражение на составные части, но рассмотрим возможные узлы.</span><span class="sxs-lookup"><span data-stu-id="3731c-137">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="3731c-138">Имеются вызовы методов, использующие текущий объект в качестве получателя: в одном случае получатель указан явно `this`; в другом нет.</span><span class="sxs-lookup"><span data-stu-id="3731c-138">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="3731c-139">Имеются вызовы методов, использующие другие объекты-получатели, а также константные аргументы различных типов.</span><span class="sxs-lookup"><span data-stu-id="3731c-139">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="3731c-140">Наконец, имеется оператор двоичного сложения.</span><span class="sxs-lookup"><span data-stu-id="3731c-140">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="3731c-141">В зависимости от типа возвращаемого значения `SecretSauceFunction()` или `MoreSecretSauce()` оператор двоичного сложения может быть вызовом метода, адресованным к переопределенному оператору сложения, который разрешается в вызов статического метода, адресованный к оператору двоичного сложения, определенному для класса.</span><span class="sxs-lookup"><span data-stu-id="3731c-141">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="3731c-142">Несмотря на кажущуюся сложность, приведенное выше выражение образует структуру дерева, по которой можно переходить так же легко, как и в первом примере.</span><span class="sxs-lookup"><span data-stu-id="3731c-142">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="3731c-143">Вы можете обходить дочерние узлы для поиска листовых узлов в выражении.</span><span class="sxs-lookup"><span data-stu-id="3731c-143">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="3731c-144">Родительские узлы содержат ссылки на свои дочерние узлы, и каждый узел имеет свойство, описывающее тип этого узла.</span><span class="sxs-lookup"><span data-stu-id="3731c-144">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="3731c-145">Структура дерева выражения очень согласована.</span><span class="sxs-lookup"><span data-stu-id="3731c-145">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="3731c-146">Изучив основы, вы сможете разобраться даже в самом сложном коде, если он представлен деревом выражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-146">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="3731c-147">Стройность структуры данных объясняет, почему компилятор C# может анализировать самые сложные программы C# и создавать правильные выходные данные на основе исходного кода.</span><span class="sxs-lookup"><span data-stu-id="3731c-147">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="3731c-148">Когда вы разберетесь в структуре деревьев выражений, полученные знания позволят вам работать с множеством еще более сложных сценариев.</span><span class="sxs-lookup"><span data-stu-id="3731c-148">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="3731c-149">Деревья выражений крайне эффективны.</span><span class="sxs-lookup"><span data-stu-id="3731c-149">There is incredible power to expression trees.</span></span>

<span data-ttu-id="3731c-150">Помимо преобразования алгоритмов для выполнения в других средах, деревья выражений можно использовать с целью упростить написание алгоритмов, проверяющих код перед его выполнением.</span><span class="sxs-lookup"><span data-stu-id="3731c-150">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="3731c-151">Можно создать метод, аргументами которого являются выражения, а затем анализировать эти выражения перед выполнением кода.</span><span class="sxs-lookup"><span data-stu-id="3731c-151">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="3731c-152">Дерево выражения — это полное представление кода: вы можете просмотреть значения любого подвыражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-152">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="3731c-153">Вы можете просмотреть имена методов и свойств.</span><span class="sxs-lookup"><span data-stu-id="3731c-153">You can see method and property names.</span></span> <span data-ttu-id="3731c-154">Вы можете узнать значение любого константного выражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-154">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="3731c-155">Кроме того, вы можете преобразовать дерево выражения в исполняемый делегат, а затем выполнить код.</span><span class="sxs-lookup"><span data-stu-id="3731c-155">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="3731c-156">Интерфейсы API для деревьев выражений позволяют создавать деревья, которые представляют практически любую допустимую конструкцию кода.</span><span class="sxs-lookup"><span data-stu-id="3731c-156">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="3731c-157">Однако для обеспечения максимальной простоты некоторые идиомы C# нельзя создавать в дереве выражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-157">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="3731c-158">Одним из примеров являются асинхронные выражения (с ключевыми словами `async` и `await`).</span><span class="sxs-lookup"><span data-stu-id="3731c-158">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="3731c-159">Если требуются асинхронные алгоритмы, то необходимо работать с объектами `Task` напрямую, а не полагаться на поддержку компилятора.</span><span class="sxs-lookup"><span data-stu-id="3731c-159">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="3731c-160">Другой пример — создание циклов.</span><span class="sxs-lookup"><span data-stu-id="3731c-160">Another is in creating loops.</span></span> <span data-ttu-id="3731c-161">Как правило, они создаются с помощью операторов `for`, `foreach`, `while` и `do`.</span><span class="sxs-lookup"><span data-stu-id="3731c-161">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="3731c-162">Как вы увидите [далее в этой серии](expression-trees-building.md), интерфейсы API для деревьев выражений поддерживают единственное выражение цикла, причем повторами управляют выражения `break` и `continue`.</span><span class="sxs-lookup"><span data-stu-id="3731c-162">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="3731c-163">Единственное, чего нельзя сделать, — это изменить дерево выражения.</span><span class="sxs-lookup"><span data-stu-id="3731c-163">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="3731c-164">Деревья выражений являются неизменяемыми структурами данных.</span><span class="sxs-lookup"><span data-stu-id="3731c-164">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="3731c-165">Если необходимо изменить дерево выражения, следует создать копию исходного дерева и внести в нее требуемые изменения.</span><span class="sxs-lookup"><span data-stu-id="3731c-165">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span> 

[<span data-ttu-id="3731c-166">Следующий раздел: "Типы платформ, поддерживающие деревья выражений"</span><span class="sxs-lookup"><span data-stu-id="3731c-166">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)

