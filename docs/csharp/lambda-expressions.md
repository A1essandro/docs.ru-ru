---
title: Лямбда-выражения
description: Сведения об использовании лямбда-выражений, являющихся блоками исполняемого кода, которые могут быть переданы в качестве аргументов.
ms.author: ronpet
author: rpetrusha
ms.date: 11/22/2016
ms.assetid: b6a0539a-8ce5-4da7-adcf-44be345a2714
ms.openlocfilehash: 642422a4cc077ffebb5ee6db9d7ffb937fc1e173
ms.sourcegitcommit: 79066169e93d9d65203028b21983574ad9dcf6b4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57212356"
---
# <a name="lambda-expressions"></a><span data-ttu-id="45e4d-103">Лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="45e4d-103">Lambda expressions</span></span>

<span data-ttu-id="45e4d-104">*Лямбда-выражение* представляет собой блок кода (выражение или блок оператора), который рассматривается как объект.</span><span class="sxs-lookup"><span data-stu-id="45e4d-104">A *lambda expression* is a block of code (an expression or a statement block) that is treated as an object.</span></span> <span data-ttu-id="45e4d-105">Оно может передаваться в качестве аргумента в методы, а также возвращаться вызовами метода.</span><span class="sxs-lookup"><span data-stu-id="45e4d-105">It can be passed as an argument to methods, and it can also be returned by method calls.</span></span> <span data-ttu-id="45e4d-106">Лямбда-выражения широко используются для:</span><span class="sxs-lookup"><span data-stu-id="45e4d-106">Lambda expressions are used extensively for:</span></span>

- <span data-ttu-id="45e4d-107">передачи выполняемого кода в асинхронные методы, такие как <xref:System.Threading.Tasks.Task.Run(System.Action)>;</span><span class="sxs-lookup"><span data-stu-id="45e4d-107">Passing the code that is to be executed to asynchronous methods, such as <xref:System.Threading.Tasks.Task.Run(System.Action)>.</span></span>

- <span data-ttu-id="45e4d-108">написания [выражений запросов LINQ](linq/index.md);</span><span class="sxs-lookup"><span data-stu-id="45e4d-108">Writing [LINQ query expressions](linq/index.md).</span></span>

- <span data-ttu-id="45e4d-109">создания [деревьев выражений](expression-trees-building.md).</span><span class="sxs-lookup"><span data-stu-id="45e4d-109">Creating [expression trees](expression-trees-building.md).</span></span>

<span data-ttu-id="45e4d-110">Лямбда-выражения — это код, который может быть представлен как делегат или дерево выражений, которое компилируется в делегат.</span><span class="sxs-lookup"><span data-stu-id="45e4d-110">Lambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate.</span></span> <span data-ttu-id="45e4d-111">Конкретный тип делегата лямбда-выражения зависит от его параметров и возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="45e4d-111">The specific delegate type of a lambda expression depends on its parameters and return value.</span></span> <span data-ttu-id="45e4d-112">Лямбда-выражения, которые не возвращают значение, соответствуют конкретному делегату `Action` в зависимости от числа параметров.</span><span class="sxs-lookup"><span data-stu-id="45e4d-112">Lambda expressions that don't return a value correspond to a specific `Action` delegate, depending on its number of parameters.</span></span> <span data-ttu-id="45e4d-113">Лямбда-выражения, которые возвращают значение, соответствуют конкретному делегату `Func` в зависимости от числа параметров.</span><span class="sxs-lookup"><span data-stu-id="45e4d-113">Lambda expressions that return a value correspond to a specific `Func` delegate, depending on its number of parameters.</span></span> <span data-ttu-id="45e4d-114">Например, лямбда-выражение, которое имеет два параметра, но не возвращает значение, соответствует делегату <xref:System.Action%602>.</span><span class="sxs-lookup"><span data-stu-id="45e4d-114">For example, a lambda expression that has two parameters but returns no value corresponds to an <xref:System.Action%602> delegate.</span></span> <span data-ttu-id="45e4d-115">Лямбда-выражение, которое имеет один параметр и возвращает значение, соответствует делегату <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="45e4d-115">A lambda expression that has one parameter and returns a value corresponds to <xref:System.Func%602> delegate.</span></span>

<span data-ttu-id="45e4d-116">Лямбда-выражение использует `=>`, [оператор объявления лямбда-выражения](language-reference/operators/lambda-operator.md), для отделения списка параметров лямбда-выражения от исполняемого кода.</span><span class="sxs-lookup"><span data-stu-id="45e4d-116">A lambda expression uses `=>`, the [lambda declaration operator](language-reference/operators/lambda-operator.md), to separate the lambda's parameter list from its executable code.</span></span> <span data-ttu-id="45e4d-117">Чтобы создать лямбда-выражение, необходимо указать входные параметры (если они есть) с левой стороны лямбда-оператора, и поместить блок выражений или операторов с другой стороны.</span><span class="sxs-lookup"><span data-stu-id="45e4d-117">To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side.</span></span> <span data-ttu-id="45e4d-118">Например, однострочное лямбда-выражение `x => x * x` задает параметр с именем `x` и возвращает значение `x` в квадрате.</span><span class="sxs-lookup"><span data-stu-id="45e4d-118">For example, the single-line lambda expression `x => x * x` specifies a parameter that’s named `x` and returns the value of `x` squared.</span></span> <span data-ttu-id="45e4d-119">Можно назначить это выражение типу делегата, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="45e4d-119">You can assign this expression to a delegate type, as the following example shows:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda1.cs#1)]

<span data-ttu-id="45e4d-120">Можно также передать его непосредственно в качестве аргумента метода:</span><span class="sxs-lookup"><span data-stu-id="45e4d-120">Or you can pass it directly as a method argument:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/lambda2.cs#2)]

## <a name="expression-lambdas"></a><span data-ttu-id="45e4d-121">Выражения-лямбды</span><span class="sxs-lookup"><span data-stu-id="45e4d-121">Expression lambdas</span></span>

 <span data-ttu-id="45e4d-122">Лямбда-выражение с выражением с правой стороны оператора => называется *выражением-лямбдой*.</span><span class="sxs-lookup"><span data-stu-id="45e4d-122">A lambda expression with an expression on the right side of the => operator is called an *expression lambda*.</span></span> <span data-ttu-id="45e4d-123">Выражения-лямбды широко используются при конструировании [деревьев выражений](expression-trees.md).</span><span class="sxs-lookup"><span data-stu-id="45e4d-123">Expression lambdas are used extensively in the construction of [expression trees](expression-trees.md).</span></span> <span data-ttu-id="45e4d-124">Выражения-лямбды возвращают результат выражения и принимают следующую основную форму.</span><span class="sxs-lookup"><span data-stu-id="45e4d-124">An expression lambda returns the result of the expression and takes the following basic form:</span></span>

```csharp
(input parameters) => expression
```

<span data-ttu-id="45e4d-125">Если лямбда-выражение имеет только один входной параметр, скобки можно не ставить; во всех остальных случаях они обязательны.</span><span class="sxs-lookup"><span data-stu-id="45e4d-125">The parentheses are optional only if the lambda has one input parameter; otherwise they are required.</span></span> <span data-ttu-id="45e4d-126">Нулевое количество входных параметры задается пустыми скобками:</span><span class="sxs-lookup"><span data-stu-id="45e4d-126">Specify zero input parameters with empty parentheses:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#1)]

<span data-ttu-id="45e4d-127">Два и более входных параметра разделяются запятыми и заключаются в скобки:</span><span class="sxs-lookup"><span data-stu-id="45e4d-127">Two or more input parameters are separated by commas enclosed in parentheses:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#2)]

<span data-ttu-id="45e4d-128">Как правило, компилятор использует определение типа для определения типов параметров.</span><span class="sxs-lookup"><span data-stu-id="45e4d-128">Ordinarily, the compiler uses type inference in determining parameter types.</span></span> <span data-ttu-id="45e4d-129">Тем не менее иногда компилятору бывает трудно или даже невозможно определить входные типы.</span><span class="sxs-lookup"><span data-stu-id="45e4d-129">However, sometimes it is difficult or impossible for the compiler to infer the input types.</span></span> <span data-ttu-id="45e4d-130">В этом случае типы можно указать в явном виде, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="45e4d-130">When this occurs, you can specify the types explicitly, as in the following example:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/expression3.cs#3)]

<span data-ttu-id="45e4d-131">Обратите внимание, что тело выражения-лямбды может состоять из вызова метода, как было показано в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="45e4d-131">Note in the previous example that the body of an expression lambda can consist of a method call.</span></span> <span data-ttu-id="45e4d-132">Но при создании деревьев выражений, которые вычисляются вне .NET Framework, например в SQL Server или Entity Framework (EF), не рекомендуется использовать вызовы методов в лямбда-выражениях, так как методы могут не иметь смысла вне контекста реализации .NET.</span><span class="sxs-lookup"><span data-stu-id="45e4d-132">However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server or Entity Framework (EF), you should refrain from using method calls in lambda expressions, since the methods may have no meaning outside the context of the .NET implementation.</span></span> <span data-ttu-id="45e4d-133">Если вы решите использовать вызовы методов в этом случае, их необходимо тщательно протестировать, чтобы убедиться, что вызовы методов успешно разрешаются.</span><span class="sxs-lookup"><span data-stu-id="45e4d-133">If you do choose to use method calls in this case, be sure to test them thoroughly to ensure that the method calls can be successfully resolved.</span></span>

## <a name="statement-lambdas"></a><span data-ttu-id="45e4d-134">Лямбды операторов</span><span class="sxs-lookup"><span data-stu-id="45e4d-134">Statement lambdas</span></span>

<span data-ttu-id="45e4d-135">Лямбда оператора напоминает выражение-лямбду, за исключением того, что оператор (или операторы) заключается в фигурные скобки:</span><span class="sxs-lookup"><span data-stu-id="45e4d-135">A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:</span></span>

```csharp
(input parameters) => { statement; }
```

<span data-ttu-id="45e4d-136">Тело лямбды оператора может состоять из любого количества операторов; однако на практике обычно используется не более двух-трех.</span><span class="sxs-lookup"><span data-stu-id="45e4d-136">The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/statement1.cs#1)]

<span data-ttu-id="45e4d-137">Лямбды операторов, как и анонимные методы, не могут использоваться для создания деревьев выражений.</span><span class="sxs-lookup"><span data-stu-id="45e4d-137">Statement lambdas, like anonymous methods, cannot be used to create expression trees.</span></span>

## <a name="async-lambdas"></a><span data-ttu-id="45e4d-138">Асинхронные лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="45e4d-138">Async lambdas</span></span>

<span data-ttu-id="45e4d-139">С помощью ключевых слов [async](language-reference/keywords/async.md) и [await](language-reference/keywords/await.md) можно легко создавать лямбда-выражения и операторы, включающие асинхронную обработку.</span><span class="sxs-lookup"><span data-stu-id="45e4d-139">You can easily create lambda expressions and statements that incorporate asynchronous processing by using the [async](language-reference/keywords/async.md) and [await](language-reference/keywords/await.md) keywords.</span></span> <span data-ttu-id="45e4d-140">Например, в примере вызывается метод `ShowSquares`, который выполняется асинхронно.</span><span class="sxs-lookup"><span data-stu-id="45e4d-140">For example, the example calls a `ShowSquares` method that executes asynchronously.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/async1.cs#1)]

<span data-ttu-id="45e4d-141">Дополнительные сведения о создании и использовании асинхронных методов см. в разделе [Асинхронное программирование с использованием ключевых слов Async и Await](programming-guide/concepts/async/index.md).</span><span class="sxs-lookup"><span data-stu-id="45e4d-141">For more information about how to create and use async methods, see [Asynchronous programming with async and await](programming-guide/concepts/async/index.md).</span></span>

## <a name="lambda-expressions-and-tuples"></a><span data-ttu-id="45e4d-142">Лямбда-выражения и кортежи</span><span class="sxs-lookup"><span data-stu-id="45e4d-142">Lambda expressions and tuples</span></span>

<span data-ttu-id="45e4d-143">В C# 7.0 была представлена встроенная поддержка для кортежей.</span><span class="sxs-lookup"><span data-stu-id="45e4d-143">Starting with C# 7.0, the C# language provides built-in support for tuples.</span></span> <span data-ttu-id="45e4d-144">Кортеж можно ввести в качестве аргумента лямбда-выражения, и лямбда-выражение также может возвращать кортеж.</span><span class="sxs-lookup"><span data-stu-id="45e4d-144">You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple.</span></span> <span data-ttu-id="45e4d-145">В некоторых случаях компилятор C# использует определение типа для определения типов компонентов кортежа.</span><span class="sxs-lookup"><span data-stu-id="45e4d-145">In some cases, the C# compiler uses type inference to determine the types of tuple components.</span></span>

<span data-ttu-id="45e4d-146">Кортеж определяется путем заключения в скобки списка его компонентов с разделителями-запятыми.</span><span class="sxs-lookup"><span data-stu-id="45e4d-146">You define a tuple by enclosing a comma-delimited list of its components in parentheses.</span></span> <span data-ttu-id="45e4d-147">В следующем примере кортеж с пятью компонентами используется для передачи последовательности чисел в лямбда-выражение, которое удваивает каждое значение и возвращает кортеж с пятью компонентами, содержащий результат операций умножения.</span><span class="sxs-lookup"><span data-stu-id="45e4d-147">The following example uses tuple with 5 components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with 5 components that contains the result of the multiplications.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples1.cs#1)]

<span data-ttu-id="45e4d-148">Как правило, поля кортежи именуются как `Item1`, `Item2` и т. д. Тем не менее кортеж с именованными компонентами можно определить, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="45e4d-148">Ordinarily, the fields of a tuple are named `Item1`, `Item2`, etc. You can, however, define a tuple with named components, as the following example does.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/tuples2.cs#1)]

<span data-ttu-id="45e4d-149">Дополнительные сведения о поддержке кортежей в C# см. в разделе [Типы кортежей C#](tuples.md).</span><span class="sxs-lookup"><span data-stu-id="45e4d-149">For more information on support for tuples in C#, see [C# Tuple types](tuples.md).</span></span>

## <a name="lambdas-with-the-standard-query-operators"></a><span data-ttu-id="45e4d-150">Лямбда-выражения со стандартными операторами запросов</span><span class="sxs-lookup"><span data-stu-id="45e4d-150">Lambdas with the standard query operators</span></span>

<span data-ttu-id="45e4d-151">В LINQ to Objects, наряду с другими реализациями, есть входной параметр, тип которого принадлежит к семейству универсальных делегатов <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="45e4d-151">LINQ to Objects, among other implementations, have an input parameter whose type is one of the <xref:System.Func%601> family of generic delegates.</span></span> <span data-ttu-id="45e4d-152">Эти делегаты используют параметры типа для определения количества и типов входных параметров, а также тип возвращаемого значения делегата.</span><span class="sxs-lookup"><span data-stu-id="45e4d-152">These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate.</span></span> <span data-ttu-id="45e4d-153">Делегаты`Func` очень полезны для инкапсуляции пользовательских выражений, которые применяются к каждому элементу в наборе исходных данных.</span><span class="sxs-lookup"><span data-stu-id="45e4d-153">`Func` delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data.</span></span> <span data-ttu-id="45e4d-154">Например, рассмотрим делегат <xref:System.Func%601> со следующим синтаксисом.</span><span class="sxs-lookup"><span data-stu-id="45e4d-154">For example, consider the <xref:System.Func%601> delegate, whose syntax is:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#1)]

<span data-ttu-id="45e4d-155">Экземпляр делегата может быть создан с помощью следующего кода,</span><span class="sxs-lookup"><span data-stu-id="45e4d-155">The delegate can be instantiated with code like the following</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#2)]

<span data-ttu-id="45e4d-156">где `int` является входным параметром, а `bool` — возвращаемым значением.</span><span class="sxs-lookup"><span data-stu-id="45e4d-156">where `int` is an input parameter, and `bool` is the return value.</span></span> <span data-ttu-id="45e4d-157">Возвращаемое значение всегда указывается в последнем параметре типа.</span><span class="sxs-lookup"><span data-stu-id="45e4d-157">The return value is always specified in the last type parameter.</span></span> <span data-ttu-id="45e4d-158">Следующий делегат `Func` при вызове возвращает значение true или false, которое показывает, равен ли входной параметр 5:</span><span class="sxs-lookup"><span data-stu-id="45e4d-158">When the following `Func` delegate is invoked, it returns true or false to indicate whether the input parameter is equal to 5:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#3)]

<span data-ttu-id="45e4d-159">Лямбда-выражения также можно использовать, когда аргумент имеет тип <xref:System.Linq.Expressions.Expression%601>, например в стандартных операторах запросов, которые определены в типе <xref:System.Linq.Queryable>.</span><span class="sxs-lookup"><span data-stu-id="45e4d-159">You can also supply a lambda expression when the argument type is an <xref:System.Linq.Expressions.Expression%601>, for example in the standard query operators that are defined in the <xref:System.Linq.Queryable> type.</span></span> <span data-ttu-id="45e4d-160">При указании аргумента <xref:System.Linq.Expressions.Expression%601> лямбда-выражение компилируется в дерево выражения.</span><span class="sxs-lookup"><span data-stu-id="45e4d-160">When you specify an <xref:System.Linq.Expressions.Expression%601> argument, the lambda is compiled to an expression tree.</span></span> <span data-ttu-id="45e4d-161">В следующем примере используется стандартный оператор запроса [System.Linq.Enumerable.Count](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600})).</span><span class="sxs-lookup"><span data-stu-id="45e4d-161">The following example uses the [System.Linq.Enumerable.Count](xref:System.Linq.Enumerable.Count%60%601(System.Collections.Generic.IEnumerable{%60%600})) standard query operator.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#4)]

<span data-ttu-id="45e4d-162">Компилятор может вывести тип входного параметра ввода; но его также можно определить явным образом.</span><span class="sxs-lookup"><span data-stu-id="45e4d-162">The compiler can infer the type of the input parameter, or you can also specify it explicitly.</span></span> <span data-ttu-id="45e4d-163">Данное лямбда-выражение подсчитывает указанные целые значения (`n`), которые при делении на два дают остаток 1.</span><span class="sxs-lookup"><span data-stu-id="45e4d-163">This particular lambda expression counts those integers (`n`) that, when divided by two, have a remainder of 1.</span></span>

<span data-ttu-id="45e4d-164">Следующий пример кода создает последовательность, которая содержит все элементы массива `numbers`, расположенные до 9, поскольку это первое число последовательности, не удовлетворяющее условию.</span><span class="sxs-lookup"><span data-stu-id="45e4d-164">The following example produces a sequence that contains all elements in the `numbers` array that precede the 9, because that's the first number in the sequence that doesn't meet the condition.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#5)]

<span data-ttu-id="45e4d-165">В следующем примере показано, как указать несколько входных параметров путем их заключения в скобки.</span><span class="sxs-lookup"><span data-stu-id="45e4d-165">The following example specifies multiple input parameters by enclosing them in parentheses.</span></span> <span data-ttu-id="45e4d-166">Этот метод возвращает все элементы в массиве чисел до того числа, значение которого меньше его порядкового номера в массиве.</span><span class="sxs-lookup"><span data-stu-id="45e4d-166">The method returns all the elements in the numbers array until it encounters a number whose value is less than its ordinal position in the array.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/query1.cs#6)]

## <a name="type-inference-in-lambda-expressions"></a><span data-ttu-id="45e4d-167">Определение типа в лямбда-выражениях</span><span class="sxs-lookup"><span data-stu-id="45e4d-167">Type inference in lambda expressions</span></span>

<span data-ttu-id="45e4d-168">При написании лямбда-выражений обычно не требуется указывать тип входных параметров, поскольку компилятор может выводить этот тип на основе тела лямбда-выражения, типов параметров и других факторов, как описано в спецификации языка C#.</span><span class="sxs-lookup"><span data-stu-id="45e4d-168">When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors, as described in the C# Language Specification.</span></span> <span data-ttu-id="45e4d-169">Для большинства стандартных операторов запросов первой входное значение имеет тип элементов в исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="45e4d-169">For most of the standard query operators, the first input is the type of the elements in the source sequence.</span></span> <span data-ttu-id="45e4d-170">При запросе `IEnumerable<Customer>` входная переменная считается объектом `Customer`, а это означает, что у вас есть доступ к его методам и свойствам.</span><span class="sxs-lookup"><span data-stu-id="45e4d-170">If you are querying an `IEnumerable<Customer>`, then the input variable is inferred to be a `Customer` object, which means you have access to its methods and properties:</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/infer1.cs#1)]

<span data-ttu-id="45e4d-171">Общие правила определения типа для лямбда-выражений формулируются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="45e4d-171">The general rules for type inference for lambdas are:</span></span>

- <span data-ttu-id="45e4d-172">лямбда-выражение должно содержать то же число параметров, что и тип делегата;</span><span class="sxs-lookup"><span data-stu-id="45e4d-172">The lambda must contain the same number of parameters as the delegate type.</span></span>

- <span data-ttu-id="45e4d-173">каждый входной аргумент в лямбда-выражении должен быть неявно преобразуемым в соответствующий параметр делегата;</span><span class="sxs-lookup"><span data-stu-id="45e4d-173">Each input argument in the lambda must be implicitly convertible to its corresponding delegate parameter.</span></span>

- <span data-ttu-id="45e4d-174">возвращаемое значение лямбда-выражения (если таковое имеется) должно быть неявно преобразуемым в возвращаемый тип делегата.</span><span class="sxs-lookup"><span data-stu-id="45e4d-174">The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.</span></span>

<span data-ttu-id="45e4d-175">Обратите внимание: лямбда-выражения сами по себе не имеют типа, поскольку в системе общих типов изначально отсутствует понятие "лямбда-выражения".</span><span class="sxs-lookup"><span data-stu-id="45e4d-175">Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of "lambda expression."</span></span> <span data-ttu-id="45e4d-176">Однако иногда бывает удобно оперировать понятием "типа" применительно к лямбда-выражениям.</span><span class="sxs-lookup"><span data-stu-id="45e4d-176">However, it is sometimes convenient to speak informally of the "type" of a lambda expression.</span></span> <span data-ttu-id="45e4d-177">При этом под типом понимается тип делегата или тип <xref:System.Linq.Expressions.Expression> , в который преобразуется лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="45e4d-177">In these cases the type refers to the delegate type or <xref:System.Linq.Expressions.Expression> type to which the lambda expression is converted.</span></span>

## <a name="variable-scope-in-lambda-expressions"></a><span data-ttu-id="45e4d-178">Область действия переменной в лямбда-выражениях</span><span class="sxs-lookup"><span data-stu-id="45e4d-178">Variable Scope in Lambda Expressions</span></span>

<span data-ttu-id="45e4d-179">Лямбда-выражения могут ссылаться на *внешние переменные* (см. раздел [Анонимные методы](programming-guide/statements-expressions-operators/anonymous-methods.md)), находящиеся в области метода, в котором определена лямбда-функция, или в области типа, который содержит лямбда-выражение.</span><span class="sxs-lookup"><span data-stu-id="45e4d-179">Lambdas can refer to *outer variables* (see [Anonymous methods](programming-guide/statements-expressions-operators/anonymous-methods.md)) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression.</span></span> <span data-ttu-id="45e4d-180">Переменные, полученные таким способом, сохраняются для использования в лямбда-выражениях, даже если бы в ином случае они оказались за границами области действия и уничтожились сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="45e4d-180">Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected.</span></span> <span data-ttu-id="45e4d-181">Внешняя переменная должна быть определенным образом присвоена, прежде чем она сможет использоваться в лямбда-выражениях.</span><span class="sxs-lookup"><span data-stu-id="45e4d-181">An outer variable must be definitely assigned before it can be consumed in a lambda expression.</span></span> <span data-ttu-id="45e4d-182">В следующем примере демонстрируются эти правила.</span><span class="sxs-lookup"><span data-stu-id="45e4d-182">The following example demonstrates these rules.</span></span>

[!code-csharp[csSnippets.Lambdas](../../samples/snippets/csharp/concepts/lambda-expressions/scope.cs#1)]

 <span data-ttu-id="45e4d-183">Следующие правила применимы к области действия переменной в лямбда-выражениях.</span><span class="sxs-lookup"><span data-stu-id="45e4d-183">The following rules apply to variable scope in lambda expressions:</span></span>

- <span data-ttu-id="45e4d-184">Захваченная переменная не будет уничтожена сборщиком мусора до тех пор, пока делегат, который на нее ссылается, не перейдет в статус подлежащего уничтожению при сборке мусора.</span><span class="sxs-lookup"><span data-stu-id="45e4d-184">A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.</span></span>

- <span data-ttu-id="45e4d-185">Переменные, вводимые в лямбда-выражении, невидимы во внешнем методе.</span><span class="sxs-lookup"><span data-stu-id="45e4d-185">Variables introduced within a lambda expression are not visible in the outer method.</span></span>

- <span data-ttu-id="45e4d-186">Лямбда-выражение не может непосредственно захватывать параметры `in`, `ref` или `out` из метода, в котором они находятся.</span><span class="sxs-lookup"><span data-stu-id="45e4d-186">A lambda expression cannot directly capture an `in`, `ref`, or `out` parameter from an enclosing method.</span></span>

- <span data-ttu-id="45e4d-187">Оператор return в лямбда-выражении не вызывает возвращение значения внешним методом.</span><span class="sxs-lookup"><span data-stu-id="45e4d-187">A return statement in a lambda expression does not cause the enclosing method to return.</span></span>

- <span data-ttu-id="45e4d-188">Лямбда-выражение не может содержать оператора `goto` , оператора `break` или оператора `continue` внутри лямбда-функции, если целевой объект перехода находится вне блока.</span><span class="sxs-lookup"><span data-stu-id="45e4d-188">A lambda expression cannot contain a `goto` statement, `break` statement, or `continue` statement that is inside the lambda function if the jump statement’s target is outside the block.</span></span> <span data-ttu-id="45e4d-189">Если целевой объект находится внутри блока, то наличие оператора перехода за пределами лямбда-функции также будет ошибкой.</span><span class="sxs-lookup"><span data-stu-id="45e4d-189">It is also an error to have a jump statement outside the lambda function block if the target is inside the block.</span></span>

## <a name="see-also"></a><span data-ttu-id="45e4d-190">См. также</span><span class="sxs-lookup"><span data-stu-id="45e4d-190">See also</span></span>

- [<span data-ttu-id="45e4d-191">Встроенный язык запросов LINQ</span><span class="sxs-lookup"><span data-stu-id="45e4d-191">LINQ (Language-Integrated Query)</span></span>](../standard/using-linq.md)
- [<span data-ttu-id="45e4d-192">Анонимные методы</span><span class="sxs-lookup"><span data-stu-id="45e4d-192">Anonymous methods</span></span>](programming-guide/statements-expressions-operators/anonymous-methods.md)
- [<span data-ttu-id="45e4d-193">Деревья выражений</span><span class="sxs-lookup"><span data-stu-id="45e4d-193">Expression trees</span></span>](expression-trees.md)
