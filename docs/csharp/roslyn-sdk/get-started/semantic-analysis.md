---
title: "Начало работы с семантическим анализом"
description: "В этом учебнике содержатся общие сведения о работе с семантическим анализом с помощью пакета SDK для компилятора .NET."
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="1eff2-103">Начало работы с семантическим анализом</span><span class="sxs-lookup"><span data-stu-id="1eff2-103">Get started with semantic analysis</span></span>

<span data-ttu-id="1eff2-104">В учебнике предполагается, что вы знакомы с синтаксическим API.</span><span class="sxs-lookup"><span data-stu-id="1eff2-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="1eff2-105">Вводные сведения можно найти в статье о [начале работы с синтаксическим анализом](syntax-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="1eff2-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="1eff2-106">В этом учебнике вы изучите **символы** и **API привязки**.</span><span class="sxs-lookup"><span data-stu-id="1eff2-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="1eff2-107">Эти API предоставляют сведения о _семантическом значении_ программы.</span><span class="sxs-lookup"><span data-stu-id="1eff2-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="1eff2-108">Они позволяют задавать вопросы, касающиеся типов, представленных любыми символами в программе, и получать на них ответы.</span><span class="sxs-lookup"><span data-stu-id="1eff2-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="1eff2-109">Общие сведения о компиляциях и символах</span><span class="sxs-lookup"><span data-stu-id="1eff2-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="1eff2-110">В процессе работы с пакетом SDK для компилятора .NET вы узнаете различия между синтаксическим API и семантическим API.</span><span class="sxs-lookup"><span data-stu-id="1eff2-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="1eff2-111">**Синтаксический API** позволяет получить представление о _структуре_ программы.</span><span class="sxs-lookup"><span data-stu-id="1eff2-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="1eff2-112">Однако часто требуются более полные сведения о семантике или _значении_ программы.</span><span class="sxs-lookup"><span data-stu-id="1eff2-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="1eff2-113">Несмотря на то, что синтаксический анализ свободного файла или фрагмента кода VB или C# можно выполнить изолированно, задавать вопросы, к примеру о типе переменной, в отрыве от реальности не имеет смысла.</span><span class="sxs-lookup"><span data-stu-id="1eff2-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="1eff2-114">Значение имени типа может зависеть от ссылок на сборки, операций импорта пространств имен или других файлов кода.</span><span class="sxs-lookup"><span data-stu-id="1eff2-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="1eff2-115">Ответы на эти вопросы можно получить с помощью **семантического API**, в частности класса <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="1eff2-116">Экземпляр <xref:Microsoft.CodeAnalysis.Compilation> является аналогом отдельного проекта с точки зрения компилятора и представляет все необходимое для компиляции программы Visual Basic или C#.</span><span class="sxs-lookup"><span data-stu-id="1eff2-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="1eff2-117">**Компиляция** включает в себя набор исходных файлов, подлежащих компиляции, ссылки на сборки, параметры компилятора.</span><span class="sxs-lookup"><span data-stu-id="1eff2-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="1eff2-118">О значении кода можно рассуждать, используя в этом контексте все остальные сведения.</span><span class="sxs-lookup"><span data-stu-id="1eff2-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="1eff2-119"><xref:Microsoft.CodeAnalysis.Compilation> позволяет находить **символы** — сущности, такие как типы, пространства имен, члены и переменные, на которые указывают имена и другие выражения.</span><span class="sxs-lookup"><span data-stu-id="1eff2-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="1eff2-120">Процесс связывания имен и выражений с **символами** называется **привязкой**.</span><span class="sxs-lookup"><span data-stu-id="1eff2-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="1eff2-121">Как <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> является абстрактным классом с производными, соответствующими конкретному языку.</span><span class="sxs-lookup"><span data-stu-id="1eff2-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="1eff2-122">При создании экземпляра компиляции необходимо вызвать фабричный метод в классе <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (или <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="1eff2-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="1eff2-123">Выполнение запросов к символам</span><span class="sxs-lookup"><span data-stu-id="1eff2-123">Querying symbols</span></span>

<span data-ttu-id="1eff2-124">В этом учебнике мы снова обратимся к программе "Hello, World!".</span><span class="sxs-lookup"><span data-stu-id="1eff2-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="1eff2-125">На этот раз вы будете запрашивать символы в программе, чтобы понять, какие типы они представляют.</span><span class="sxs-lookup"><span data-stu-id="1eff2-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="1eff2-126">Вы будете запрашивать типы в пространстве имен и узнаете, как найти методы, доступные для типа.</span><span class="sxs-lookup"><span data-stu-id="1eff2-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1eff2-127">Для приведенных ниже примеров требуется установить **пакет SDK для компилятора .NET** в составе Visual Studio 2017.</span><span class="sxs-lookup"><span data-stu-id="1eff2-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="1eff2-128">Пакет SDK для компилятора .NET является последним необязательным компонентом, указанным в рабочей нагрузке для **разработки расширения Visual Studio**.</span><span class="sxs-lookup"><span data-stu-id="1eff2-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="1eff2-129">Без этого компонента невозможно установить шаблоны.</span><span class="sxs-lookup"><span data-stu-id="1eff2-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="1eff2-130">Окончательный код этого примера доступен в [репозитории примеров на сайте GitHub](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="1eff2-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="1eff2-131">Типы синтаксического дерева используют наследование для описания различных элементов синтаксиса, которые являются допустимыми в разных местах в программе.</span><span class="sxs-lookup"><span data-stu-id="1eff2-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="1eff2-132">Применение этих API часто означает приведение свойств или элементов коллекции к конкретным производным типам.</span><span class="sxs-lookup"><span data-stu-id="1eff2-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="1eff2-133">В следующих примерах назначения и приведения являются отдельными инструкциями, использующими явно типизированные переменные.</span><span class="sxs-lookup"><span data-stu-id="1eff2-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="1eff2-134">Прочитайте код, чтобы увидеть типы возвращаемых значений API и тип среды выполнения возвращаемых объектов.</span><span class="sxs-lookup"><span data-stu-id="1eff2-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="1eff2-135">На практике более распространено использование неявно типизированных переменных и имен API для описания типа рассматриваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="1eff2-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="1eff2-136">Создайте новый проект C# для **автономного средства анализа кода**:</span><span class="sxs-lookup"><span data-stu-id="1eff2-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="1eff2-137">В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**, чтобы открыть диалоговое окно "Новый проект".</span><span class="sxs-lookup"><span data-stu-id="1eff2-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="1eff2-138">В разделе **Visual C#** > **Расширяемость** выберите **Автономное средство анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="1eff2-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="1eff2-139">Присвойте проекту имя "**SemanticQuickStart**" и нажмите кнопку "ОК".</span><span class="sxs-lookup"><span data-stu-id="1eff2-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="1eff2-140">Вы будете анализировать программу "Hello World!",</span><span class="sxs-lookup"><span data-stu-id="1eff2-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="1eff2-141">показанную ранее.</span><span class="sxs-lookup"><span data-stu-id="1eff2-141">program shown earlier.</span></span>
<span data-ttu-id="1eff2-142">Добавьте текст для программы "Hello World" в качестве константы в класс `Program`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="1eff2-143">Затем добавьте в константу `programText` следующий код для создания дерева синтаксиса для текста кода.</span><span class="sxs-lookup"><span data-stu-id="1eff2-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="1eff2-144">Добавьте следующую строку в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="1eff2-145">Далее постройте <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> из уже созданного дерева.</span><span class="sxs-lookup"><span data-stu-id="1eff2-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="1eff2-146">В примере "Hello World!" используются типы <xref:System.String> и <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="1eff2-147">Необходимо сослаться на сборку, объявляющую эти два типа при компиляции.</span><span class="sxs-lookup"><span data-stu-id="1eff2-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="1eff2-148">Добавьте следующую строку в метод `Main` для создания компиляции дерева синтаксиса, включая ссылку на соответствующую сборку:</span><span class="sxs-lookup"><span data-stu-id="1eff2-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="1eff2-149">Метод <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> добавит ссылки на компиляцию.</span><span class="sxs-lookup"><span data-stu-id="1eff2-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="1eff2-150">Метод <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> загрузит сборку как ссылку.</span><span class="sxs-lookup"><span data-stu-id="1eff2-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="1eff2-151">Выполнение запросов к семантической модели</span><span class="sxs-lookup"><span data-stu-id="1eff2-151">Querying the semantic model</span></span>

<span data-ttu-id="1eff2-152">К существующему объекту <xref:Microsoft.CodeAnalysis.Compilation> можно отправить запрос на класс <xref:Microsoft.CodeAnalysis.SemanticModel> для любого класса <xref:Microsoft.CodeAnalysis.SyntaxTree>, содержащегося в этом объекте <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="1eff2-153">Семантическую модель можно представить как источник всей информации, которая обычно доступна из IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="1eff2-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="1eff2-154">Класс <xref:Microsoft.CodeAnalysis.SemanticModel> помогает получить ответы на такие вопросы, как "Какие имена находятся в области действия в этом расположении?",</span><span class="sxs-lookup"><span data-stu-id="1eff2-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="1eff2-155">"Какие члены доступны из этого метода?",</span><span class="sxs-lookup"><span data-stu-id="1eff2-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="1eff2-156">"Какие переменные используются в этом блоке текста?"</span><span class="sxs-lookup"><span data-stu-id="1eff2-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="1eff2-157">и "На что ссылается это имя или выражение?"</span><span class="sxs-lookup"><span data-stu-id="1eff2-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="1eff2-158">Добавьте этот оператор для создания семантической модели:</span><span class="sxs-lookup"><span data-stu-id="1eff2-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="1eff2-159">Привязка имени</span><span class="sxs-lookup"><span data-stu-id="1eff2-159">Binding a name</span></span>

<span data-ttu-id="1eff2-160"><xref:Microsoft.CodeAnalysis.Compilation> создает <xref:Microsoft.CodeAnalysis.SemanticModel> из <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="1eff2-161">После создания модели можно выполнить запрос на поиск первой директивы `using` и получение сведений о символах для пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="1eff2-162">Добавьте следующие две строки в метод `Main` для создания семантической модели и получения символа для первого оператора using:</span><span class="sxs-lookup"><span data-stu-id="1eff2-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="1eff2-163">В предыдущем коде показано, как получить объект <xref:Microsoft.CodeAnalysis.SemanticModel> для класса <xref:Microsoft.CodeAnalysis.SyntaxTree>HelloWorld.</span><span class="sxs-lookup"><span data-stu-id="1eff2-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="1eff2-164">После получения модели имя первой директивы `using` привязывается для получения <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> для пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="1eff2-165">В предыдущем коде также демонстрируется, что для поиска структуры кода используется **синтаксическая модель**, а для понимания ее значения — **семантическая модель**.</span><span class="sxs-lookup"><span data-stu-id="1eff2-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="1eff2-166">**Синтаксическая модель** находит строку `System` в операторе using.</span><span class="sxs-lookup"><span data-stu-id="1eff2-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="1eff2-167">**Семантическая модель** располагает всеми сведениями о типах, определенных в пространстве имен `System`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="1eff2-168">Из объекта <xref:Microsoft.CodeAnalysis.SymbolInfo> можно получить интерфейс <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> с помощью свойства <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1eff2-169">Это свойство возвращает символ, на который ссылается это выражение.</span><span class="sxs-lookup"><span data-stu-id="1eff2-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="1eff2-170">Для выражений, не ссылающихся ни на какие объекты (например, числовые литералы), это свойство имеет значение `null`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="1eff2-171">Если <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> не задано значение NULL, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> обозначает тип символа.</span><span class="sxs-lookup"><span data-stu-id="1eff2-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="1eff2-172">В этом примере свойству <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> присваивается значение <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1eff2-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1eff2-173">Добавьте приведенный ниже код в метод `Main`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="1eff2-174">Он возвращает символ для пространства имен `System`, а затем отображает все дочерние пространства имен, объявленные в пространстве имен `System`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="1eff2-175">Запустите программу. Вы должны увидеть следующие результаты:</span><span class="sxs-lookup"><span data-stu-id="1eff2-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="1eff2-176">Выходные данные не содержат каждое пространство имен, имеющее дочернее пространство имен от пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="1eff2-177">В них отображается каждое пространство имен, которое присутствует в этой компиляции и ссылается только на сборку, где объявлено `System.String`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="1eff2-178">Этой компиляции неизвестно о пространствах имен, объявленных в других сборках.</span><span class="sxs-lookup"><span data-stu-id="1eff2-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="1eff2-179">Привязка выражения</span><span class="sxs-lookup"><span data-stu-id="1eff2-179">Binding an expression</span></span>

<span data-ttu-id="1eff2-180">В предыдущем коде показано, как найти символ путем привязки к имени.</span><span class="sxs-lookup"><span data-stu-id="1eff2-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="1eff2-181">В программе C# существуют и другие не являющиеся именами выражения, которые можно привязать.</span><span class="sxs-lookup"><span data-stu-id="1eff2-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="1eff2-182">Чтобы продемонстрировать эту возможность, выполним привязку к простому строковому литералу.</span><span class="sxs-lookup"><span data-stu-id="1eff2-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="1eff2-183">Программа "Hello World" содержит класс <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, строку "Hello World",</span><span class="sxs-lookup"><span data-stu-id="1eff2-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="1eff2-184">отображаемую в консоли.</span><span class="sxs-lookup"><span data-stu-id="1eff2-184">string displayed to the console.</span></span>

<span data-ttu-id="1eff2-185">Строку "Hello World"</span><span class="sxs-lookup"><span data-stu-id="1eff2-185">You find the "Hello, World!"</span></span> <span data-ttu-id="1eff2-186">можно найти путем поиска одного строкового литерала в программе.</span><span class="sxs-lookup"><span data-stu-id="1eff2-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="1eff2-187">Затем после обнаружения узла синтаксиса получите сведения о типе для этого узла из семантической модели.</span><span class="sxs-lookup"><span data-stu-id="1eff2-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="1eff2-188">Добавьте приведенный ниже код в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="1eff2-189">Структура <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> содержит свойство <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType>, которое обеспечивает доступ к семантическим сведениям о типе литерала.</span><span class="sxs-lookup"><span data-stu-id="1eff2-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="1eff2-190">В этом примере типом является `string`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="1eff2-191">Добавьте объявление, которое присваивает это свойство локальной переменной:</span><span class="sxs-lookup"><span data-stu-id="1eff2-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="1eff2-192">Чтобы завершить действия в этом учебнике, сформируем запрос LINQ, который создает последовательность всех открытых методов, объявленных в типе `string` и возвращающих `string`.</span><span class="sxs-lookup"><span data-stu-id="1eff2-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="1eff2-193">Поскольку запрос сложный, мы будем создавать его построчно, а затем перестроим в один запрос.</span><span class="sxs-lookup"><span data-stu-id="1eff2-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="1eff2-194">Источником для этого запроса является последовательность всех элементов, объявленных в типе `string`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="1eff2-195">Эта исходная последовательность содержит все элементы, включая свойства и поля, поэтому ее нужно отфильтровать с помощью метода <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType>, чтобы найти элементы, которые являются объектами <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="1eff2-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="1eff2-196">Затем добавьте другой фильтр, чтобы вернуть только открытые методы, возвращающие `string`:</span><span class="sxs-lookup"><span data-stu-id="1eff2-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="1eff2-197">Выберите только свойство имени и только уникальные имена, удаляя все перегрузки:</span><span class="sxs-lookup"><span data-stu-id="1eff2-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="1eff2-198">Можно также создать полный запрос с помощью синтаксиса запросов LINQ и затем отобразить имена всех методов в консоли:</span><span class="sxs-lookup"><span data-stu-id="1eff2-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="1eff2-199">Постройте и запустите программу.</span><span class="sxs-lookup"><span data-stu-id="1eff2-199">Build and run the program.</span></span> <span data-ttu-id="1eff2-200">Должны выводиться следующие данные:</span><span class="sxs-lookup"><span data-stu-id="1eff2-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="1eff2-201">Вы использовали семантический API для поиска и отображения сведений о символах, которые являются частью этой программы.</span><span class="sxs-lookup"><span data-stu-id="1eff2-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
