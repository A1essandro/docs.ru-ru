---
title: Семантика ссылок с типами значений
description: Сведения о функциях языка, которые безопасно минимизируют копирование структур
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: 5bbfe34a9a14e4ccb22367e57b57585c208cf757
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2018
ms.locfileid: "45964708"
---
# <a name="reference-semantics-with-value-types"></a>Семантика ссылок с типами значений

Преимущество использования типов значений заключается в том, что они часто позволяют избежать выделения памяти в кучах.
Недостаток состоит в том, что они копируются по значению. Этот компромисс усложняет оптимизацию алгоритмов, работающих с большими объемами данных. Новые возможности языка в C# 7.2 предоставляют механизмы, позволяющие включать семантику передачи по ссылке с типами значений. При рациональном использовании этих функций можно свести к минимуму число операций выделения и копирования. В этой статье приводится описание этих новых функций.

В большей части примера кода в этой статье демонстрируются функции, добавленные в C# 7.2. Чтобы их использовать, нужно настроить проект для работы с языком C# 7.2 или более поздней версии. Дополнительные сведения об установке версии языка см. в разделе [Настройка языковой версии](language-reference/configure-language-version.md).

## <a name="passing-arguments-by-readonly-reference"></a>Передача аргументов по ссылке, доступной только для чтения

При передаче аргументов по ссылке можно использовать ключевое слово `in`, добавленное в C# 7.2 как дополнение к существующим ключевым словам `ref` и `out`. Ключевое слово `in` указывает, что аргумент передается по ссылке, но вызванный метод не изменяет это значение. 

Это дополнение позволяет полностью выразить намерение разработки. Если в сигнатуре метода не указан ни один из следующих модификаторов, типы значений копируются при передаче в вызываемый метод. Каждый из этих модификаторов указывает, что тип значения передается по ссылке, предотвращая копирование. Каждый модификатор выражает конкретное намерение.

- `out`: этот метод задает значение аргумента, используемого в качестве этого параметра.
- `ref`: этот метод может задавать значение аргумента, используемого в качестве этого параметра.
- `in`: этот метод не изменяет значение аргумента, используемого в качестве этого параметра.

При добавлении модификатора `in` для передачи аргумента по ссылке вы объявляете о своем намерении передавать аргументы по ссылке, чтобы избежать ненужных операций копирования. Вы не собираетесь изменять объект, используемый в качестве этого аргумента. Ниже приведен пример метода, который вычисляет расстояние между двумя точками в трехмерном пространстве. 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

Аргументами являются две структуры, каждая из которых содержит три типа double. double имеет размер 8 байт, поэтому каждый аргумент равен 24 байтам. Указывая модификатор `in`, вы, в зависимости от архитектуры компьютера, передаете этим аргументам 4- или 8-байтовую ссылку. Разница в размере невелика, но она может быстро вырасти, когда приложение вызывает этот метод в непрерывном цикле с помощью множества различных значений.
 
Существуют и другие способы, которыми модификатор `in` дополняет `out` и `ref`. Невозможно создать перегрузки метода, которые отличаются только наличием `in`, `out` или `ref`. Эти новые правила расширяют то же поведение, которое всегда действовало для параметров `out` и `ref`.

Модификатор `in` может применяться к любому члену, который принимает параметры: к методам, делегатам, лямбда-выражениям, локальным функциям, индексаторам, операторам.

В отличие от аргументов `ref` и `out`, аргумент параметра `in` поддерживает литеральные значения или константы. Кроме того, в отличие от параметра `ref` или `out`, не нужно применять модификатор `in` на сайте вызова. В следующем коде показаны два примера вызова метода `CalculateDistance`. В первом используются две локальные переменные, передаваемые по ссылке. Второй содержит временную переменную, созданную в рамках вызова метода. 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

Существует несколько способов, когда компилятор гарантирует, что аргумент `in` доступен только для чтения.  Во-первых, вызванный метод не может быть напрямую назначен параметру `in`. Его невозможно напрямую назначить полю параметра `in`, когда это значение имеет тип `struct`. Кроме того, параметр `in` невозможно передать какому-либо методу, использующему модификатор `ref` или `out`.
Эти правила применяются к любому полю параметра `in` при условии, что данное поле имеет тип `struct` и параметр имеет тип `struct`. На самом деле эти правила применяются к нескольким уровням доступа к членам при условии, что все уровни доступа к членам являются `structs`. Компилятор принудительно указывает, что типы `struct`, передаваемые в качестве аргументов `in`, и их члены `struct` являются переменными, доступными только для чтения, когда используются в качестве аргументов для других методов.

Использование параметров `in` позволяет избежать потенциальных затрат на создание копий. Это не меняет семантику ни одного вызова метода. Таким образом, указывать модификатор `in` в месте вызова не нужно. Однако пропуск модификатора `in` в месте вызова сообщает компилятору, что он может сделать копию аргумента по следующим причинам:

- Выполняется неявное преобразование, но не преобразование удостоверения из типа аргумента в тип параметра.
- Аргумент является выражением, но не имеет известную переменную хранения.
- Существует перегрузка, которая отличается наличием или отсутствием `in`. В этом случае перегрузка по значению подходит лучше.

Эти правила полезны и при обновлении существующего кода для использования аргументов со ссылками, доступными только для чтения. Внутри вызываемого метода можно вызвать любой метод экземпляра, который использует параметры передачи по значению. В этих экземплярах создается копия параметра `in`. Поскольку компилятор может создавать временную переменную для любого параметра `in`, вы можете также указать значения по умолчанию для любого параметра `in`. Следующий код указывает начало координат (точку 0,0) в качестве значения по умолчанию для второй точки:

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

Чтобы велеть компилятору передавать аргументы, доступные только для чтения, по ссылке, укажите модификатор `in` для аргументов в месте вызова, как показано в следующем коде:

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

Это упрощает постепенное внедрение параметров `in` в больших базах кода, где возможен выигрыш по производительности. Сначала нужно добавить модификатор `in` в сигнатуры методов. Затем можно добавить модификатор `in` в местах вызовов и создать типы `readonly struct`, чтобы разрешить компилятору не создавать защитные копии параметров `in` в дополнительных расположениях.

Обозначение параметра `in` также можно использовать со ссылочными типами или числовыми значениями. Однако преимущества в обоих случаях минимальны (если они вообще есть).

## <a name="ref-readonly-returns"></a>Возвращаемые значения `ref readonly`

Может потребоваться возвращать тип значения по ссылке, но при этом запретить вызывающей стороне изменять это значение. Для выражения этого намерения служит модификатор `ref readonly`. Он уведомляет читателей, что выполняется возврат ссылки на существующие данные, но внесение изменений запрещено. 

Компилятор применяет правило, не позволяющее вызывающему объекту изменять ссылку. Попытки назначить значение напрямую вызывают ошибку времени компиляции. Однако компилятору не может быть известно, изменяет ли какой-либо метод члена состояние структуры.
Чтобы защитить объект от изменений, компилятор создает копию и с ее помощью вызывает ссылки на члены. Все изменения будут вноситься в эту защитную копию. 

Скорее всего, библиотека, использующая `Point3D`, будет часто применять точку начала координат во всем коде. Каждый экземпляр создает новый объект в стеке. В этом случае может быть целесообразно создать константу и вернуть ее по ссылке. Однако при возвращении ссылки на внутреннее хранилище может потребоваться применить правило, запрещающее вызывающему объекту изменять указанное хранилище. В следующем коде определяется свойство только для чтения, которое возвращает `readonly ref` для структуры `Point3D`, указывающее начало координат.

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

Создать копию возвращаемого значения ref readonly несложно: просто назначьте его переменной, не объявленной с модификатором `ref readonly`. Компилятор создает код для копирования объекта в рамках назначения. 

При назначении переменной для `ref readonly return` можно указать либо переменную `ref readonly`, либо копию по значению ссылки только для чтения:

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

При первом назначении в предыдущем примере кода создается и назначается копия константы `Origin`. При втором назначается ссылка. Обратите внимание, что модификатор `readonly` должен быть частью объявления переменной. Ссылку, на которую он ссылается, изменить невозможно. В противном случае возникнет ошибка времени компиляции.

## <a name="readonly-struct-type"></a>Тип `readonly struct`

Может быть достаточным применять `ref readonly` в ситуациях высокоинтенсивного использования структуры.
В других случаях может потребоваться создать неизменяемую структуру. Затем можно всегда выполнять передачу по ссылке только для чтения. В этом случае удаляются защитные копии, создаваемые при доступе к методам структуры, используемым в качестве параметра `in`.

Это можно сделать путем создания типа `readonly struct`. Можно добавить модификатор `readonly` в объявление структуры. Компилятор применяет правило, согласно которому все члены экземпляра структуры являются `readonly`; тип `struct` должен быть неизменным.

Существуют другие виды оптимизации для `readonly struct`. Модификатор `in` используется в любом месте, где `readonly struct` выступает в качестве аргумента. Кроме того, модификатор `readonly struct` можно вернуть как `ref return` при возвращении объекта, время существования которого выходит за пределы области действия метода, возвращающего объект.

Наконец, компилятор создает более эффективный код, когда вызываются члены `readonly struct`: параметром `in`, передаваемым по ссылке методу члена, всегда является ссылка `this`, а не копия приемника. Эта оптимизация сохраняет дополнительные операции копирования при использовании `readonly struct`. Для этого изменения отлично подходит `Point3D`. В приведенном ниже коде показана обновленная структура `ReadonlyPoint3D`.

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a>Тип `ref struct`

Еще одной связанной функцией языка является возможность объявлять тип значения, который должен быть размещен в стеке. Другими словами, эти типы никогда не создаются в куче в качестве члена другого класса. Главным стимулом для создания этой функции была структура <xref:System.Span%601> и связанные структуры. <xref:System.Span%601> может содержать управляемый указатель в виде одного из своих членов, а другой — в виде длины диапазона. Это реализуется немного по-другому, так как C# не поддерживает указатели на управляемую память за пределами небезопасного контекста. Все записи, приводящие к изменению указателя и длины, не являются атомарными. Это означает, что структура <xref:System.Span%601> будет подвергаться ошибкам выхода за пределы диапазона или другим нарушениям безопасности, где отсутствует ограничение одним кадром стека. Кроме того, размещение управляемого указателя в куче сборщика мусора обычно приводит к аварийному завершению во время работы JIT-компилятора.

Похожие требования могут иметь место при работе с памятью, созданной с помощью [`stackalloc`](language-reference/keywords/stackalloc.md), или при использовании памяти из API взаимодействия. Для этих задач можно определить собственные типы `ref struct`. В этой статье примеры использования `Span<T>` приведены для упрощения понимания.

Объявление `ref struct` объявляет, что структура этого типа должна находиться в стеке. Безопасное использование этих типов гарантируется правилами языка. В число других типов, объявленных как `ref struct`, входит <xref:System.ReadOnlySpan%601>. 

Необходимость поддержки типа `ref struct` как выделенной в стеке переменной вводит ряд правил, применяемых компилятором ко всем типам `ref struct`.

- `ref struct` не поддерживает упаковку. Тип `ref struct` невозможно присвоить переменной типа `object`, `dynamic` или любому типу интерфейса.
- `ref struct` невозможно объявить как член класса или обычной структуры.
- Невозможно объявить локальные переменные, которые являются типами `ref struct` в асинхронных методах. Их можно объявить в синхронных методах, возвращающих `Task`, `Task<T>` или типах Task.
- Локальные переменные `ref struct` невозможно объявить в итераторах.
- Невозможно захватить переменные `ref struct` в лямбда-выражениях или локальных функциях.

Эти ограничения исключают возможность случайного использования `ref struct` таким образом, который может повысить его уровень до управляемой кучи.

## <a name="readonly-ref-struct-type"></a>Тип `readonly ref struct`

Объявление структуры как `readonly ref` сочетает в себе преимущества и недостатки объявлений `ref struct` и `readonly struct`. 

В следующем примере показано объявление `readonly ref struct`.

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a>Выводы

Эти усовершенствования языка C# предназначены для критических алгоритмов производительности, когда операции выделения памяти могут иметь важное значение для достижения необходимой производительности. Может оказаться, что в создаваемом коде эти функции используются довольно редко. Однако эти усовершенствования были реализованы во многих компонентах .NET Framework. Поскольку с этими функциями работает все больше API-интерфейсов, повышение производительности приложений не останется незаметным.
