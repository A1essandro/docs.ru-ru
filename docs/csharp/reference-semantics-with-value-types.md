---
title: Семантика ссылок с типами значений
description: Сведения о функциях языка, которые безопасно минимизируют копирование структур
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: 3c53a426a6adb37f5091e4ad61835fef6c9f7729
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="ef65c-103">Семантика ссылок с типами значений</span><span class="sxs-lookup"><span data-stu-id="ef65c-103">Reference semantics with value types</span></span>

<span data-ttu-id="ef65c-104">Преимущество использования типов значений заключается в том, что они часто позволяют избежать выделения памяти в кучах.</span><span class="sxs-lookup"><span data-stu-id="ef65c-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="ef65c-105">Недостаток состоит в том, что они копируются по значению.</span><span class="sxs-lookup"><span data-stu-id="ef65c-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="ef65c-106">Этот компромисс усложняет оптимизацию алгоритмов, работающих с большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="ef65c-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="ef65c-107">Новые возможности языка в C# 7.2 предоставляют механизмы, позволяющие включать семантику передачи по ссылке с типами значений.</span><span class="sxs-lookup"><span data-stu-id="ef65c-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="ef65c-108">При рациональном использовании этих функций можно свести к минимуму число операций выделения и копирования.</span><span class="sxs-lookup"><span data-stu-id="ef65c-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="ef65c-109">В этой статье приводится описание этих новых функций.</span><span class="sxs-lookup"><span data-stu-id="ef65c-109">This article explores those new features.</span></span>

<span data-ttu-id="ef65c-110">В большей части примера кода в этой статье демонстрируются функции, добавленные в C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="ef65c-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="ef65c-111">Чтобы их использовать, нужно настроить проект для работы с языком C# 7.2 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="ef65c-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="ef65c-112">Выбор осуществляется с помощью Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="ef65c-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="ef65c-113">Для каждого проекта в меню выберите **Проект**, а затем **Свойства**.</span><span class="sxs-lookup"><span data-stu-id="ef65c-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="ef65c-114">Перейдите на вкладку **Сборка** и нажмите кнопку **Дополнительно**.</span><span class="sxs-lookup"><span data-stu-id="ef65c-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="ef65c-115">Теперь можно настроить версию языка.</span><span class="sxs-lookup"><span data-stu-id="ef65c-115">From there, configure the language version.</span></span> <span data-ttu-id="ef65c-116">Выберите "7.2" или "последняя".</span><span class="sxs-lookup"><span data-stu-id="ef65c-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="ef65c-117">Или можно изменить файл *test-library.csproj* и добавить следующий узел:</span><span class="sxs-lookup"><span data-stu-id="ef65c-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="ef65c-118">В качестве значения укажите "7.2" или "последняя".</span><span class="sxs-lookup"><span data-stu-id="ef65c-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="ef65c-119">Передача аргументов по ссылке, доступной только для чтения</span><span class="sxs-lookup"><span data-stu-id="ef65c-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="ef65c-120">При передаче аргументов по ссылке можно использовать ключевое слово `in`, добавленное в C# 7.2 как дополнение к существующим ключевым словам `ref` и `out`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="ef65c-121">Ключевое слово `in` указывает, что аргумент передается по ссылке, но вызванный метод не изменяет это значение.</span><span class="sxs-lookup"><span data-stu-id="ef65c-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="ef65c-122">Это дополнение позволяет полностью выразить намерение разработки.</span><span class="sxs-lookup"><span data-stu-id="ef65c-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="ef65c-123">Если в сигнатуре метода не указан ни один из следующих модификаторов, типы значений копируются при передаче в вызываемый метод.</span><span class="sxs-lookup"><span data-stu-id="ef65c-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="ef65c-124">Каждый из этих модификаторов указывает, что тип значения передается по ссылке, предотвращая копирование.</span><span class="sxs-lookup"><span data-stu-id="ef65c-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="ef65c-125">Каждый модификатор выражает конкретное намерение.</span><span class="sxs-lookup"><span data-stu-id="ef65c-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="ef65c-126">`out`: этот метод задает значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ef65c-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ef65c-127">`ref`: этот метод может задавать значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ef65c-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ef65c-128">`in`: этот метод не изменяет значение аргумента, используемого в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ef65c-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="ef65c-129">При добавлении модификатора `in` для передачи аргумента по ссылке вы объявляете о своем намерении передавать аргументы по ссылке, чтобы избежать ненужных операций копирования.</span><span class="sxs-lookup"><span data-stu-id="ef65c-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="ef65c-130">Вы не собираетесь изменять объект, используемый в качестве этого аргумента.</span><span class="sxs-lookup"><span data-stu-id="ef65c-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="ef65c-131">Ниже приведен пример метода, который вычисляет расстояние между двумя точками в трехмерном пространстве.</span><span class="sxs-lookup"><span data-stu-id="ef65c-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="ef65c-132">Аргументами являются две структуры, каждая из которых содержит три типа double.</span><span class="sxs-lookup"><span data-stu-id="ef65c-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="ef65c-133">double имеет размер 8 байт, поэтому каждый аргумент равен 24 байтам.</span><span class="sxs-lookup"><span data-stu-id="ef65c-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="ef65c-134">Указывая модификатор `in`, вы, в зависимости от архитектуры компьютера, передаете этим аргументам 4- или 8-байтовую ссылку.</span><span class="sxs-lookup"><span data-stu-id="ef65c-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="ef65c-135">Разница в размере невелика, но она может быстро вырасти, когда приложение вызывает этот метод в непрерывном цикле с помощью множества различных значений.</span><span class="sxs-lookup"><span data-stu-id="ef65c-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="ef65c-136">Существуют и другие способы, которыми модификатор `in` дополняет `out` и `ref`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="ef65c-137">Невозможно создать перегрузки метода, которые отличаются только наличием `in`, `out` или `ref`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="ef65c-138">Эти новые правила расширяют то же поведение, которое всегда действовало для параметров `out` и `ref`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="ef65c-139">Модификатор `in` может применяться к любому члену, который принимает параметры: к методам, делегатам, лямбда-выражениям, локальным функциям, индексаторам, операторам.</span><span class="sxs-lookup"><span data-stu-id="ef65c-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="ef65c-140">В отличие от аргументов `ref` и `out`, аргумент параметра `in` поддерживает литеральные значения или константы.</span><span class="sxs-lookup"><span data-stu-id="ef65c-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="ef65c-141">Кроме того, в отличие от параметра `ref` или `out`, не нужно применять модификатор `in` на сайте вызова.</span><span class="sxs-lookup"><span data-stu-id="ef65c-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="ef65c-142">В следующем коде показаны два примера вызова метода `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="ef65c-143">В первом используются две локальные переменные, передаваемые по ссылке.</span><span class="sxs-lookup"><span data-stu-id="ef65c-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="ef65c-144">Второй содержит временную переменную, созданную в рамках вызова метода.</span><span class="sxs-lookup"><span data-stu-id="ef65c-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="ef65c-145">Существует несколько способов, когда компилятор гарантирует, что аргумент `in` доступен только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ef65c-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="ef65c-146">Во-первых, вызванный метод не может быть напрямую назначен параметру `in`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="ef65c-147">Его невозможно напрямую назначить полю параметра `in`, когда это значение имеет тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="ef65c-148">Кроме того, параметр `in` невозможно передать какому-либо методу, использующему модификатор `ref` или `out`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="ef65c-149">Эти правила применяются к любому полю параметра `in` при условии, что данное поле имеет тип `struct` и параметр имеет тип `struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="ef65c-150">На самом деле эти правила применяются к нескольким уровням доступа к членам при условии, что все уровни доступа к членам являются `structs`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="ef65c-151">Компилятор принудительно указывает, что типы `struct`, передаваемые в качестве аргументов `in`, и их члены `struct` являются переменными, доступными только для чтения, когда используются в качестве аргументов для других методов.</span><span class="sxs-lookup"><span data-stu-id="ef65c-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="ef65c-152">Использование параметров `in` позволяет избежать потенциальных затрат на создание копий.</span><span class="sxs-lookup"><span data-stu-id="ef65c-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="ef65c-153">Это не меняет семантику ни одного вызова метода.</span><span class="sxs-lookup"><span data-stu-id="ef65c-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="ef65c-154">Таким образом, указывать модификатор `in` в месте вызова не нужно.</span><span class="sxs-lookup"><span data-stu-id="ef65c-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="ef65c-155">Однако пропуск модификатора `in` в месте вызова сообщает компилятору, что он может сделать копию аргумента по следующим причинам:</span><span class="sxs-lookup"><span data-stu-id="ef65c-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="ef65c-156">Выполняется неявное преобразование, но не преобразование удостоверения из типа аргумента в тип параметра.</span><span class="sxs-lookup"><span data-stu-id="ef65c-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="ef65c-157">Аргумент является выражением, но не имеет известную переменную хранения.</span><span class="sxs-lookup"><span data-stu-id="ef65c-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="ef65c-158">Существует перегрузка, которая отличается наличием или отсутствием `in`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="ef65c-159">В этом случае перегрузка по значению подходит лучше.</span><span class="sxs-lookup"><span data-stu-id="ef65c-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="ef65c-160">Эти правила полезны и при обновлении существующего кода для использования аргументов со ссылками, доступными только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ef65c-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="ef65c-161">Внутри вызываемого метода можно вызвать любой метод экземпляра, который использует параметры передачи по значению.</span><span class="sxs-lookup"><span data-stu-id="ef65c-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="ef65c-162">В этих экземплярах создается копия параметра `in`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="ef65c-163">Поскольку компилятор может создавать временную переменную для любого параметра `in`, вы можете также указать значения по умолчанию для любого параметра `in`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="ef65c-164">Следующий код указывает начало координат (точку 0,0) в качестве значения по умолчанию для второй точки:</span><span class="sxs-lookup"><span data-stu-id="ef65c-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="ef65c-165">Чтобы велеть компилятору передавать аргументы, доступные только для чтения, по ссылке, укажите модификатор `in` для аргументов в месте вызова, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="ef65c-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="ef65c-166">Это упрощает постепенное внедрение параметров `in` в больших базах кода, где возможен выигрыш по производительности.</span><span class="sxs-lookup"><span data-stu-id="ef65c-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="ef65c-167">Сначала нужно добавить модификатор `in` в сигнатуры методов.</span><span class="sxs-lookup"><span data-stu-id="ef65c-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="ef65c-168">Затем можно добавить модификатор `in` в местах вызовов и создать типы `readonly struct`, чтобы разрешить компилятору не создавать защитные копии параметров `in` в дополнительных расположениях.</span><span class="sxs-lookup"><span data-stu-id="ef65c-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="ef65c-169">Обозначение параметра `in` также можно использовать со ссылочными типами или числовыми значениями.</span><span class="sxs-lookup"><span data-stu-id="ef65c-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="ef65c-170">Однако преимущества в обоих случаях минимальны (если они вообще есть).</span><span class="sxs-lookup"><span data-stu-id="ef65c-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="ef65c-171">Возвращаемые значения `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="ef65c-171">`ref readonly` returns</span></span>

<span data-ttu-id="ef65c-172">Может потребоваться возвращать тип значения по ссылке, но при этом запретить вызывающей стороне изменять это значение.</span><span class="sxs-lookup"><span data-stu-id="ef65c-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="ef65c-173">Для выражения этого намерения служит модификатор `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="ef65c-174">Он уведомляет читателей, что выполняется возврат ссылки на существующие данные, но внесение изменений запрещено.</span><span class="sxs-lookup"><span data-stu-id="ef65c-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="ef65c-175">Компилятор применяет правило, не позволяющее вызывающему объекту изменять ссылку.</span><span class="sxs-lookup"><span data-stu-id="ef65c-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="ef65c-176">Попытки назначить значение напрямую вызывают ошибку времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="ef65c-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="ef65c-177">Однако компилятору не может быть известно, изменяет ли какой-либо метод члена состояние структуры.</span><span class="sxs-lookup"><span data-stu-id="ef65c-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="ef65c-178">Чтобы защитить объект от изменений, компилятор создает копию и с ее помощью вызывает ссылки на члены.</span><span class="sxs-lookup"><span data-stu-id="ef65c-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="ef65c-179">Все изменения будут вноситься в эту защитную копию.</span><span class="sxs-lookup"><span data-stu-id="ef65c-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="ef65c-180">Скорее всего, библиотека, использующая `Point3D`, будет часто применять точку начала координат во всем коде.</span><span class="sxs-lookup"><span data-stu-id="ef65c-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="ef65c-181">Каждый экземпляр создает новый объект в стеке.</span><span class="sxs-lookup"><span data-stu-id="ef65c-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="ef65c-182">В этом случае может быть целесообразно создать константу и вернуть ее по ссылке.</span><span class="sxs-lookup"><span data-stu-id="ef65c-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="ef65c-183">Однако при возвращении ссылки на внутреннее хранилище может потребоваться применить правило, запрещающее вызывающему объекту изменять указанное хранилище.</span><span class="sxs-lookup"><span data-stu-id="ef65c-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="ef65c-184">В следующем коде определяется свойство только для чтения, которое возвращает `readonly ref` для структуры `Point3D`, указывающее начало координат.</span><span class="sxs-lookup"><span data-stu-id="ef65c-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="ef65c-185">Создать копию возвращаемого значения ref readonly несложно: просто назначьте его переменной, не объявленной с модификатором `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="ef65c-186">Компилятор создает код для копирования объекта в рамках назначения.</span><span class="sxs-lookup"><span data-stu-id="ef65c-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="ef65c-187">При назначении переменной для `ref readonly return` можно указать либо переменную `ref readonly`, либо копию по значению ссылки только для чтения:</span><span class="sxs-lookup"><span data-stu-id="ef65c-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="ef65c-188">При первом назначении в предыдущем примере кода создается и назначается копия константы `Origin`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="ef65c-189">При втором назначается ссылка.</span><span class="sxs-lookup"><span data-stu-id="ef65c-189">The second assigns a reference.</span></span> <span data-ttu-id="ef65c-190">Обратите внимание, что модификатор `readonly` должен быть частью объявления переменной.</span><span class="sxs-lookup"><span data-stu-id="ef65c-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="ef65c-191">Ссылку, на которую он ссылается, изменить невозможно.</span><span class="sxs-lookup"><span data-stu-id="ef65c-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="ef65c-192">В противном случае возникнет ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="ef65c-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="ef65c-193">Тип `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="ef65c-193">`readonly struct` type</span></span>

<span data-ttu-id="ef65c-194">Может быть достаточным применять `ref readonly` в ситуациях высокоинтенсивного использования структуры.</span><span class="sxs-lookup"><span data-stu-id="ef65c-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="ef65c-195">В других случаях может потребоваться создать неизменяемую структуру.</span><span class="sxs-lookup"><span data-stu-id="ef65c-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="ef65c-196">Затем можно всегда выполнять передачу по ссылке только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ef65c-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="ef65c-197">В этом случае удаляются защитные копии, создаваемые при доступе к методам структуры, используемым в качестве параметра `in`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="ef65c-198">Это можно сделать путем создания типа `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="ef65c-199">Можно добавить модификатор `readonly` в объявление структуры.</span><span class="sxs-lookup"><span data-stu-id="ef65c-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="ef65c-200">Компилятор применяет правило, согласно которому все члены экземпляра структуры являются `readonly`; тип `struct` должен быть неизменным.</span><span class="sxs-lookup"><span data-stu-id="ef65c-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="ef65c-201">Существуют другие виды оптимизации для `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="ef65c-202">Модификатор `in` используется в любом месте, где `readonly struct` выступает в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="ef65c-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="ef65c-203">Кроме того, модификатор `readonly struct` можно вернуть как `ref return` при возвращении объекта, время существования которого выходит за пределы области действия метода, возвращающего объект.</span><span class="sxs-lookup"><span data-stu-id="ef65c-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="ef65c-204">Наконец, компилятор создает более эффективный код, когда вызываются члены `readonly struct`: параметром `in`, передаваемым по ссылке методу члена, всегда является ссылка `this`, а не копия приемника.</span><span class="sxs-lookup"><span data-stu-id="ef65c-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="ef65c-205">Эта оптимизация сохраняет дополнительные операции копирования при использовании `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="ef65c-206">Для этого изменения отлично подходит `Point3D`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="ef65c-207">В приведенном ниже коде показана обновленная структура `ReadonlyPoint3D`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="ef65c-208">Тип `ref struct`</span><span class="sxs-lookup"><span data-stu-id="ef65c-208">`ref struct` type</span></span>

<span data-ttu-id="ef65c-209">Еще одной связанной функцией языка является возможность объявлять тип значения, который должен быть размещен в стеке.</span><span class="sxs-lookup"><span data-stu-id="ef65c-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="ef65c-210">Другими словами, эти типы никогда не создаются в куче в качестве члена другого класса.</span><span class="sxs-lookup"><span data-stu-id="ef65c-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="ef65c-211">Главным стимулом для создания этой функции была структура <xref:System.Span%601> и связанные структуры.</span><span class="sxs-lookup"><span data-stu-id="ef65c-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="ef65c-212"><xref:System.Span%601> может содержать управляемый указатель в виде одного из своих членов, а другой — в виде длины диапазона.</span><span class="sxs-lookup"><span data-stu-id="ef65c-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="ef65c-213">Это реализуется немного по-другому, так как C# не поддерживает указатели на управляемую память за пределами небезопасного контекста.</span><span class="sxs-lookup"><span data-stu-id="ef65c-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="ef65c-214">Все записи, приводящие к изменению указателя и длины, не являются атомарными.</span><span class="sxs-lookup"><span data-stu-id="ef65c-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="ef65c-215">Это означает, что структура <xref:System.Span%601> будет подвергаться ошибкам выхода за пределы диапазона или другим нарушениям безопасности, где отсутствует ограничение одним кадром стека.</span><span class="sxs-lookup"><span data-stu-id="ef65c-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="ef65c-216">Кроме того, размещение управляемого указателя в куче сборщика мусора обычно приводит к аварийному завершению во время работы JIT-компилятора.</span><span class="sxs-lookup"><span data-stu-id="ef65c-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="ef65c-217">Похожие требования могут иметь место при работе с памятью, созданной с помощью [`stackalloc`](language-reference/keywords/stackalloc.md), или при использовании памяти из API взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="ef65c-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="ef65c-218">Для этих задач можно определить собственные типы `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="ef65c-219">В этой статье примеры использования `Span<T>` приведены для упрощения понимания.</span><span class="sxs-lookup"><span data-stu-id="ef65c-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="ef65c-220">Объявление `ref struct` объявляет, что структура этого типа должна находиться в стеке.</span><span class="sxs-lookup"><span data-stu-id="ef65c-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="ef65c-221">Безопасное использование этих типов гарантируется правилами языка.</span><span class="sxs-lookup"><span data-stu-id="ef65c-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="ef65c-222">В число других типов, объявленных как `ref struct`, входит <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="ef65c-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="ef65c-223">Необходимость поддержки типа `ref struct` как выделенной в стеке переменной вводит ряд правил, применяемых компилятором ко всем типам `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="ef65c-224">`ref struct` не поддерживает упаковку.</span><span class="sxs-lookup"><span data-stu-id="ef65c-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="ef65c-225">Тип `ref struct` невозможно присвоить переменной типа `object`, `dynamic` или любому типу интерфейса.</span><span class="sxs-lookup"><span data-stu-id="ef65c-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="ef65c-226">`ref struct` невозможно объявить как член класса или обычной структуры.</span><span class="sxs-lookup"><span data-stu-id="ef65c-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="ef65c-227">Невозможно объявить локальные переменные, которые являются типами `ref struct` в асинхронных методах.</span><span class="sxs-lookup"><span data-stu-id="ef65c-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="ef65c-228">Их можно объявить в синхронных методах, возвращающих `Task`, `Task<T>` или типах Task.</span><span class="sxs-lookup"><span data-stu-id="ef65c-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="ef65c-229">Локальные переменные `ref struct` невозможно объявить в итераторах.</span><span class="sxs-lookup"><span data-stu-id="ef65c-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="ef65c-230">Невозможно захватить переменные `ref struct` в лямбда-выражениях или локальных функциях.</span><span class="sxs-lookup"><span data-stu-id="ef65c-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="ef65c-231">Эти ограничения исключают возможность случайного использования `ref struct` таким образом, который может повысить его уровень до управляемой кучи.</span><span class="sxs-lookup"><span data-stu-id="ef65c-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="ef65c-232">Тип `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="ef65c-232">`readonly ref struct` type</span></span>

<span data-ttu-id="ef65c-233">Объявление структуры как `readonly ref` сочетает в себе преимущества и недостатки объявлений `ref struct` и `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="ef65c-234">В следующем примере показано объявление `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="ef65c-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="ef65c-235">Выводы</span><span class="sxs-lookup"><span data-stu-id="ef65c-235">Conclusions</span></span>

<span data-ttu-id="ef65c-236">Эти усовершенствования языка C# предназначены для критических алгоритмов производительности, когда операции выделения памяти могут иметь важное значение для достижения необходимой производительности.</span><span class="sxs-lookup"><span data-stu-id="ef65c-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="ef65c-237">Может оказаться, что в создаваемом коде эти функции используются довольно редко.</span><span class="sxs-lookup"><span data-stu-id="ef65c-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="ef65c-238">Однако эти усовершенствования были реализованы во многих компонентах .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ef65c-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="ef65c-239">Поскольку с этими функциями работает все больше API-интерфейсов, повышение производительности приложений не останется незаметным.</span><span class="sxs-lookup"><span data-stu-id="ef65c-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
