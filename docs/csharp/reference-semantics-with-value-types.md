---
title: "Семантика ссылок с типами значений"
description: "Сведения о функциях языка, которые безопасно минимизируют копирование структур"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 0c6e44a3e1a1458f4211b66b6d1ef5b4b30cd7c1
ms.sourcegitcommit: 5177d6ae2e9baf026f07ee0631556700a5a193f7
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2017
---
# <a name="reference-semantics-with-value-types"></a>Семантика ссылок с типами значений

Преимущество использования типов значений заключается в том, что они часто позволяют избежать выделения памяти в кучах.
Соответствующий недостаток состоит в том, что они копируются по значению. Этот компромисс усложняет оптимизацию алгоритмов, работающих с большими объемами данных. Новые возможности языка в C# 7.2 предоставляют механизмы, позволяющие включать семантику передачи по ссылке с типами значений. При рациональном использовании этих функций можно свести к минимуму число операций выделения и копирования. В этой статье приводится описание этих новых функций.

В большей части примера кода в этой статье демонстрируются функции, добавленные в C# 7.2. Чтобы их использовать, необходимо настроить проект для работы с языком C# 7.2 или более поздней версии. Выбор осуществляется с помощью Visual Studio. Для каждого проекта в меню выберите **Проект**, а затем **Свойства**. Перейдите на вкладку **Сборка** и нажмите кнопку **Дополнительно**. Теперь можно настроить версию языка. Выберите "7.2" или "последняя".  Или можно изменить файл *test-library.csproj* и добавить следующий узел:

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

В качестве значения укажите "7.2" или "последняя".

## <a name="specifying-in-parameters"></a>Указание параметров `in`

При создании метода, передающего аргументы по ссылке, используйте добавленное в C# 7.2 ключевое слово `in` как дополнение к существующим ключевым словам `ref` и `out`. Ключевое слово `in` указывает, что параметр передается по ссылке, и вызванный метод не изменяет переданное ему значение. 

Это дополнение позволяет полностью выразить намерение разработки. Если не указан ни один из следующих модификаторов, типы значений копируются при передаче в вызываемый метод. Каждый из этих модификаторов указывает, что тип значения передается по ссылке, предотвращая копирование. Каждый модификатор выражает конкретное намерение.

- `out`: этот метод задает значение аргумента, используемого в качестве этого параметра.
- `ref`: этот метод может задавать значение аргумента, используемого в качестве этого параметра.
- `in`: этот метод не изменяет значение аргумента, используемого в качестве этого параметра.

При добавлении модификатора `in` для передачи аргумента по ссылке вы объявляете о своем намерении передавать аргументы по ссылке, чтобы избежать ненужных операций копирования. Вы не собираетесь изменять объект, используемый в качестве этого аргумента. Ниже приведен пример метода, который вычисляет расстояние между двумя точками в трехмерном пространстве. 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

Аргументами являются две структуры, каждая из которых содержит три типа double. double имеет размер 8 байт, поэтому каждый аргумент равен 24 байтам. Указывая модификатор `in`, вы в зависимости от архитектуры компьютера передаете этим аргументам 4- или 8-байтовую ссылку. Разница в размере невелика, но она может быстро вырасти, когда приложение вызывает этот метод в непрерывном цикле с помощью множества различных значений.
 
Существуют и другие способы, которыми модификатор `in` дополняет `out` и `ref`. Нельзя создать перегрузки метода, которые отличаются только наличием `in`, `out` или `ref`. Эти новые правила расширяют то же поведение, которое всегда действовало для параметров `out` и `ref`.

Модификатор `in` может применяться к любому члену, который принимает параметры: к методам, делегатам, лямбда-выражениям, локальным функциям, индексаторам, операторам.

В отличие от аргументов `ref` и `out`, аргумент параметра `in` поддерживает литеральные значения или константы. Кроме того, в отличие от параметра `ref` или `out`, не нужно применять модификатор `in` на сайте вызова. В следующем коде показаны два примера вызова метода `CalculateDistance`. В первом используются две локальные переменные, передаваемые по ссылке. Второй содержит временную переменную, созданную в рамках вызова метода. 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

Существует несколько способов, когда компилятор гарантирует, что аргумент `in` доступен только для чтения.  Во-первых, вызванный метод не может быть напрямую назначен параметру `in`. Его нельзя напрямую назначить полю параметра `in`. Кроме того, параметр `in` невозможно передать какому-либо методу, требующему модификатор `ref` или `out`.
Компилятор принудительно реализует тот факт, что аргумент `in` является переменной только для чтения. Можно вызвать любой метод экземпляра, который использует семантику передачи по значению. В этих экземплярах создается копия параметра `in`. Поскольку компилятор может создавать временную переменную для любого параметра `in`, вы можете также указать значения по умолчанию для любого параметра `in`. В следующем коде этот параметр указывает начало координат (точку 0,0) в качестве значения по умолчанию для второй точки:

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

Обозначение параметра `in` также используется со ссылочными типами или встроенными числовыми значениями. Однако преимущества в обоих случаях минимальны (если они вообще есть).

## <a name="ref-readonly-returns"></a>Возвращаемые значения `ref readonly`

Может потребоваться возвращать тип значения по ссылке, но при этом запретить вызывающей стороне изменять это значение. Для выражения этого намерения служит модификатор `ref readonly`. Он уведомляет читателей, что выполняется возврат ссылки на существующие данные, но внесение изменений запрещено. 

Компилятор применяет правило, не позволяющее вызывающему объекту изменять ссылку. Попытки назначить значение напрямую вызывают ошибку времени компиляции. Однако компилятору не может быть известно, изменяет ли какой-либо метод члена состояние структуры.
Чтобы защитить объект от изменений, компилятор создает копию и с ее помощью вызывает ссылки на члены. Все изменения будут вноситься в эту защитную копию. 

Скорее всего, библиотека, использующая `Point3D`, будет часто применять точку начала координат во всем коде. Каждый экземпляр создает новый объект в стеке. В этом случае может быть целесообразно создать константу и вернуть ее по ссылке. Однако при возвращении ссылки на внутреннее хранилище может потребоваться применить правило, запрещающее вызывающему объекту изменять указанное хранилище. В следующем коде определяется свойство только для чтения, которое возвращает `readonly ref` для структуры `Point3D`, указывающее начало координат.

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

Создать копию возвращаемого значения ref readonly несложно: просто назначьте его переменной, не объявленной с модификатором `ref readonly`. Компилятор создает код для копирования объекта в рамках назначения. 

При назначении переменной для `ref readonly return` можно указать либо переменную `ref readonly`, либо копию по значению ссылки только для чтения:

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

При первом назначении в предыдущем примере кода создается и назначается копия константы `Origin`. При втором назначается ссылка. Обратите внимание, что модификатор `readonly` должен быть частью объявления переменной. Ссылку, на которую он ссылается, изменить нельзя. В противном случае возникнет ошибка времени компиляции.

## <a name="readonly-struct-type"></a>Тип `readonly struct`

Может быть достаточным применять `ref readonly` в ситуациях высокоинтенсивного использования структуры.
В других случаях может потребоваться создать неизменяемую структуру. Затем можно всегда выполнять передачу по ссылке только для чтения. В этом случае удаляются защитные копии, создаваемые при доступе к методам структуры, используемым в качестве параметра `in`.

Это можно сделать путем создания типа `readonly struct`. Можно добавить модификатор `readonly` в объявление структуры. Компилятор применяет правило, согласно которому все члены экземпляра структуры являются `readonly`; тип `struct` должен быть неизменным.

Существуют другие виды оптимизации для `readonly struct`. Модификатор `in` используется в любом месте, где `readonly struct` выступает в качестве аргумента. Кроме того, модификатор `readonly struct` можно вернуть как `ref return` при возвращении объекта, время существования которого выходит за пределы области действия метода, возвращающего объект.

Наконец, компилятор создает более эффективный код, когда вызываются члены `readonly struct`: параметром `in`, передаваемым по ссылке методу члена, всегда является ссылка `this`, а не копия приемника. Эта оптимизация сохраняет дополнительные операции копирования при использовании `readonly struct`. Для этого изменения отлично подходит `Point3D`. В приведенном ниже коде показана обновленная структура `ReadonlyPoint3D`.

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a>Тип `ref struct`

Еще одной связанной функцией языка является возможность объявлять тип значения, который должен быть размещен в стеке. Другими словами, эти типы никогда не создаются в куче в качестве члена другого класса. Главным стимулом для создания этой функции была структура <xref:System.Span%601> и связанные структуры. <xref:System.Span%601> может содержать управляемый указатель в виде одного из своих членов, а другой — в виде длины диапазона. Фактически она реализуется немного по-другому, так как C# не поддерживает указатели на управляемую память за пределами небезопасного контекста. Все записи, приводящие к изменению указателя и длины, не являются атомарными. Это означает, что структура <xref:System.Span%601> будет подвергаться ошибкам выхода за пределы диапазона или другим нарушениям безопасности, где отсутствует ограничение одним кадром стека. Кроме того, размещение управляемого указателя в куче сборщика мусора обычно приводит к аварийному завершению во время работы JIT-компилятора.

Похожие требования могут иметь место при работе с памятью, созданной с помощью [`stackalloc`](language-reference/keywords/stackalloc.md), или при использовании памяти из API взаимодействия. Для этих задач можно определить собственные типы `ref struct`. В этой статье примеры использования `Span<T>` приведены для упрощения понимания.

Объявление `ref struct` объявляет, что структура этого типа должна находиться в стеке. Безопасное использование этих типов гарантируется правилами языка. В число других типов, объявленных как `ref struct`, входит <xref:System.ReadOnlySpan%601>. 

Необходимость поддержки типа `ref struct` как выделенной в стеке переменной вводит ряд правил, применяемых компилятором ко всем типам `ref struct`.

- `ref struct` не поддерживает упаковку. Тип `ref struct` невозможно присвоить переменной типа `object`, `dynamic` или любому типу интерфейса.
- `ref struct` невозможно объявить как член класса или обычной структуры.
- Невозможно объявить локальные переменные, которые являются типами `ref struct` в асинхронных методах. Их можно объявить в синхронных методах, возвращающих `Task`, `Task<T>` или типах Task.
- Локальные переменные `ref struct` невозможно объявить в итераторах.
- Невозможно захватить переменные `ref struct` в лямбда-выражениях или локальных функциях.

Эти ограничения исключают возможность случайного использования `ref struct` таким образом, который может повысить его уровень до управляемой кучи.

## <a name="conclusions"></a>Выводы

Эти усовершенствования языка C# предназначены для критических алгоритмов производительности, когда операции выделения памяти могут иметь важное значение для достижения необходимой производительности. Может оказаться, что в создаваемом коде эти функции используются довольно редко. Однако эти усовершенствования были реализованы во многих компонентах .NET Framework. Поскольку с этими функциями работает все больше API-интерфейсов, повышение производительности приложений не останется незаметным.
