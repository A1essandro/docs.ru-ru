---
title: "Семантику ссылки с типами значений"
description: "Понять возможности языка, которые сводят к минимуму копирование структуры безопасно"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="ad515-103">Семантику ссылки с типами значений</span><span class="sxs-lookup"><span data-stu-id="ad515-103">Reference semantics with value types</span></span>

<span data-ttu-id="ad515-104">Преимуществом использования типов значений — часто избежать выделений памяти в куче.</span><span class="sxs-lookup"><span data-stu-id="ad515-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="ad515-105">Соответствующий недостаток заключается в том, что они копируются по значению.</span><span class="sxs-lookup"><span data-stu-id="ad515-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="ad515-106">Это компромисс затрудняет для оптимизации алгоритмы, работающие с большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="ad515-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="ad515-107">Новые возможности языка C# 7.2 предоставления механизмов, позволяющих включить семантику передачи по ссылке с типами значений.</span><span class="sxs-lookup"><span data-stu-id="ad515-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="ad515-108">Если вы используете эти функции рационально можно свести к минимуму обоих выделений и операции копирования.</span><span class="sxs-lookup"><span data-stu-id="ad515-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="ad515-109">В этой статье исследуются этих новых функций.</span><span class="sxs-lookup"><span data-stu-id="ad515-109">This article explores those new features.</span></span>

<span data-ttu-id="ad515-110">Большая часть кода примера в этой статье показано, добавленных в C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="ad515-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="ad515-111">Чтобы использовать эти функции, необходимо настроить проект на языке C# 7,2 или более поздней версии в своем проекте.</span><span class="sxs-lookup"><span data-stu-id="ad515-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="ad515-112">Visual Studio можно использовать, чтобы выбрать его.</span><span class="sxs-lookup"><span data-stu-id="ad515-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="ad515-113">Для каждого проекта, выберите **проекта** меню, затем **свойства**.</span><span class="sxs-lookup"><span data-stu-id="ad515-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="ad515-114">Выберите **построения** и нажмите кнопку **Дополнительно**.</span><span class="sxs-lookup"><span data-stu-id="ad515-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="ad515-115">После этого можно настроить на английском языке.</span><span class="sxs-lookup"><span data-stu-id="ad515-115">From there, you can configure the language version.</span></span> <span data-ttu-id="ad515-116">Выберите «7.2» или «последние».</span><span class="sxs-lookup"><span data-stu-id="ad515-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="ad515-117">Или же можно изменить *csproj* и добавьте следующий узел:</span><span class="sxs-lookup"><span data-stu-id="ad515-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="ad515-118">«7,2» или «последние» можно использовать для значения.</span><span class="sxs-lookup"><span data-stu-id="ad515-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="ad515-119">Указание `in` параметров</span><span class="sxs-lookup"><span data-stu-id="ad515-119">Specifying `in` parameters</span></span>

<span data-ttu-id="ad515-120">7.2 C# добавляет `in` ключевое слово в дополнение к существующий `ref` и `out` ключевые слова, если необходимо написать метод, который передает аргументы по ссылке.</span><span class="sxs-lookup"><span data-stu-id="ad515-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="ad515-121">`in` Ключевое слово указывает, что параметр передаются по ссылке, и вызванный метод не изменяет значение, переданное параметру.</span><span class="sxs-lookup"><span data-stu-id="ad515-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="ad515-122">Это дополнение предоставляет полный словаря для выражения намерениям конструктора.</span><span class="sxs-lookup"><span data-stu-id="ad515-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="ad515-123">Типы значений, копируются при передаче в вызываемый метод, если не указать один из следующих модификаторов.</span><span class="sxs-lookup"><span data-stu-id="ad515-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="ad515-124">Каждый из этих модификаторов указать, что тип значения передается по ссылке, как избежать копирования.</span><span class="sxs-lookup"><span data-stu-id="ad515-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="ad515-125">Каждый модификатор выражает вопроса:</span><span class="sxs-lookup"><span data-stu-id="ad515-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="ad515-126">`out`: Этот метод задает значение аргумента, используемое в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ad515-127">`ref`: Этот метод может задать значение аргумента, используемое в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="ad515-128">`in`: Этот метод не изменяет значение аргумента, используемое в качестве этого параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="ad515-129">При добавлении `in` модификатор для передачи аргумента по ссылке, объявите намерениям разработки аргументы передаются по ссылке, чтобы избежать ненужных копирования.</span><span class="sxs-lookup"><span data-stu-id="ad515-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="ad515-130">Не требуется изменить объект, который используется в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="ad515-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="ad515-131">Ниже приведен пример метода, которая вычисляет расстояние между двумя точками в трехмерном пространстве.</span><span class="sxs-lookup"><span data-stu-id="ad515-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="ad515-132">Аргументы являются две структуры, которые в них содержатся три тип Double.</span><span class="sxs-lookup"><span data-stu-id="ad515-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="ad515-133">Значение типа double — 8 байт, поэтому каждый аргумент является 24 байта.</span><span class="sxs-lookup"><span data-stu-id="ad515-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="ad515-134">Указав `in` модификатор, передайте байт 4 или 8 байт ссылку для этих аргументов, в зависимости от архитектуры компьютера.</span><span class="sxs-lookup"><span data-stu-id="ad515-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="ad515-135">Разница в размере небольшое, однако его можно быстро сложить когда приложение вызывает этот метод в непрерывном цикле с помощью большого количества различных значений.</span><span class="sxs-lookup"><span data-stu-id="ad515-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="ad515-136">`in` Дополняет модификатор `out` и `ref` также другие способы.</span><span class="sxs-lookup"><span data-stu-id="ad515-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="ad515-137">Не удается создать перегрузки метода, которые отличаются только в за присутствии из `in`, `out` или `ref`.</span><span class="sxs-lookup"><span data-stu-id="ad515-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="ad515-138">Эти новые правила поведения же, всегда определен для `out` и `ref` параметров.</span><span class="sxs-lookup"><span data-stu-id="ad515-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="ad515-139">`in` Модификатор может применяться к любому элементу, который принимает параметры: методы, делегаты, лямбда-выражения, локальные функции, индексаторы, операторы.</span><span class="sxs-lookup"><span data-stu-id="ad515-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="ad515-140">В отличие от `ref` и `out` аргументов, может использовать литералы или константы аргумент `in` параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="ad515-141">Кроме того, в отличие от `ref` или `out` параметр, не нужно применять `in` модификатор на сайте вызова.</span><span class="sxs-lookup"><span data-stu-id="ad515-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="ad515-142">В следующем коде показано два примера вызова `CalculateDistance` метод.</span><span class="sxs-lookup"><span data-stu-id="ad515-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="ad515-143">Первый использует двух локальных переменных, передаваемый по ссылке.</span><span class="sxs-lookup"><span data-stu-id="ad515-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="ad515-144">Второй включает временной переменной, которая создана как часть вызова метода.</span><span class="sxs-lookup"><span data-stu-id="ad515-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="ad515-145">Существует несколько способов, в которых компилятор гарантирует, только для чтения характер `in` обеспечивается аргумент.</span><span class="sxs-lookup"><span data-stu-id="ad515-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="ad515-146">Во-первых, вызванный метод не может быть назначена непосредственно `in` параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="ad515-147">Невозможно присвоить непосредственно к любому полю `in` параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="ad515-148">Кроме того, невозможно передать `in` параметр для любого метода, где это требуется `ref` или `out` модификатор.</span><span class="sxs-lookup"><span data-stu-id="ad515-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="ad515-149">Компилятор принудительно применяет `in` аргумент является переменной только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ad515-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="ad515-150">Можно вызвать любой метод экземпляра, который использует семантику передачи по значению.</span><span class="sxs-lookup"><span data-stu-id="ad515-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="ad515-151">В этих случаях копию `in` создается параметр.</span><span class="sxs-lookup"><span data-stu-id="ad515-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="ad515-152">Поскольку компилятор может создать временную переменную для любого `in` параметр, можно также указать значения по умолчанию для любого `in` параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="ad515-153">Следующий код использует, чтобы указать в качестве значения по умолчанию для второй точки начала координат (точки 0,0):</span><span class="sxs-lookup"><span data-stu-id="ad515-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="ad515-154">`in` Обозначение параметр можно также использовать со ссылочными типами или встроенных числовых значений.</span><span class="sxs-lookup"><span data-stu-id="ad515-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="ad515-155">Тем не менее преимущества в обоих случаях минимальны, если таковые имеются.</span><span class="sxs-lookup"><span data-stu-id="ad515-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="ad515-156">`ref readonly`Возвращает</span><span class="sxs-lookup"><span data-stu-id="ad515-156">`ref readonly` returns</span></span>

<span data-ttu-id="ad515-157">Можно также возвращать тип значения по ссылке, но запретить вызывающей стороне из изменение этого значения.</span><span class="sxs-lookup"><span data-stu-id="ad515-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="ad515-158">Используйте `ref readonly` модификатор express этой цели проекта.</span><span class="sxs-lookup"><span data-stu-id="ad515-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="ad515-159">Он уведомляет читатели производится возврат ссылки к существующим данным, а также не позволяет изменять.</span><span class="sxs-lookup"><span data-stu-id="ad515-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="ad515-160">Поэтому компилятор применяет, что вызывающий объект не удается изменить ссылку.</span><span class="sxs-lookup"><span data-stu-id="ad515-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="ad515-161">Предпринимается попытка назначить значение напрямую вызывают ошибку компиляции.</span><span class="sxs-lookup"><span data-stu-id="ad515-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="ad515-162">Однако компилятор не знает, если любой член метод изменяет состояние структуры.</span><span class="sxs-lookup"><span data-stu-id="ad515-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="ad515-163">Чтобы убедиться, что объект не изменяется, компилятор создает копию и вызывает член ссылки с помощью этой копии.</span><span class="sxs-lookup"><span data-stu-id="ad515-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="ad515-164">Все изменения будут к этой копии защитного.</span><span class="sxs-lookup"><span data-stu-id="ad515-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="ad515-165">Скорее всего, в библиотеке с использованием `Point3D` часто используется начало координат по всему коду.</span><span class="sxs-lookup"><span data-stu-id="ad515-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="ad515-166">Каждый экземпляр создает новый объект в стеке.</span><span class="sxs-lookup"><span data-stu-id="ad515-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="ad515-167">Может оказаться целесообразным создать константу и вернуть его по ссылке.</span><span class="sxs-lookup"><span data-stu-id="ad515-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="ad515-168">Но если вы получите ссылку на внутреннее хранилище, можно обеспечить, что вызывающий объект не удается изменить хранилища, на которую указывает ссылка.</span><span class="sxs-lookup"><span data-stu-id="ad515-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="ad515-169">В следующем коде определяется только для чтения свойство, возвращающее `readonly ref` для `Point3D` , указывающий начало координат.</span><span class="sxs-lookup"><span data-stu-id="ad515-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="ad515-170">Создать копию ref readonly возвращаемого несложно: просто присвоить его переменной, не объявлен со `ref readonly` модификатор.</span><span class="sxs-lookup"><span data-stu-id="ad515-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="ad515-171">Компилятор создает код для копирования объекта, в рамках назначения.</span><span class="sxs-lookup"><span data-stu-id="ad515-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="ad515-172">При назначении переменной для `ref readonly return`, можно указать либо `ref readonly` переменной или по значению копии ссылки только для чтения:</span><span class="sxs-lookup"><span data-stu-id="ad515-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="ad515-173">Первое присваивание в предыдущем примере кода создается копия `Origin` константы и назначит, предназначенных для копирования.</span><span class="sxs-lookup"><span data-stu-id="ad515-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="ad515-174">Второй назначает ссылку.</span><span class="sxs-lookup"><span data-stu-id="ad515-174">The second assigns a reference.</span></span> <span data-ttu-id="ad515-175">Обратите внимание, что `readonly` модификатор должен быть частью объявления переменной.</span><span class="sxs-lookup"><span data-stu-id="ad515-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="ad515-176">Невозможно изменить ссылку, на который она ссылается.</span><span class="sxs-lookup"><span data-stu-id="ad515-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="ad515-177">Попытки сделать это привести к ошибке во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="ad515-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="ad515-178">Тип `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="ad515-178">`readonly struct` type</span></span>

<span data-ttu-id="ad515-179">Применение `ref readonly` пользователям с высоким трафиком структуры может быть достаточно.</span><span class="sxs-lookup"><span data-stu-id="ad515-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="ad515-180">В других случаях может потребоваться создать неизменяемый структуры.</span><span class="sxs-lookup"><span data-stu-id="ad515-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="ad515-181">Затем всегда можно передавать по ссылке только для чтения.</span><span class="sxs-lookup"><span data-stu-id="ad515-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="ad515-182">Удаляет, рекомендуется защитного копирует которые происходят, когда к методам структуры используется в качестве `in` параметра.</span><span class="sxs-lookup"><span data-stu-id="ad515-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="ad515-183">Это можно сделать путем создания `readonly struct` типа.</span><span class="sxs-lookup"><span data-stu-id="ad515-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="ad515-184">Можно добавить `readonly` модификатор в объявлении структуры.</span><span class="sxs-lookup"><span data-stu-id="ad515-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="ad515-185">Поэтому компилятор применяет все члены структуры, `readonly`; `struct` должны быть неизменными.</span><span class="sxs-lookup"><span data-stu-id="ad515-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="ad515-186">Существуют другие виды оптимизации для `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ad515-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="ad515-187">Можно использовать `in` модификатор в любом месте где `readonly struct` выступает в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="ad515-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="ad515-188">Кроме того, можно вернуть `readonly struct` как `ref return` при возвращении объекта, время существования которых выходит за пределы области действия метода возврат объекта.</span><span class="sxs-lookup"><span data-stu-id="ad515-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="ad515-189">Наконец, компилятор создает более эффективный код, когда вызов членов из `readonly struct`: `this` ссылку вместо копирования приемника, всегда является `in` параметра, передаваемого по ссылке метод члена.</span><span class="sxs-lookup"><span data-stu-id="ad515-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="ad515-190">Эта оптимизация сохраняет копирования при использовании `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="ad515-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="ad515-191">`Point3D` Отлично подходит для этого изменения.</span><span class="sxs-lookup"><span data-stu-id="ad515-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="ad515-192">В следующем коде показано обновленное `ReadonlyPoint3D` структуры:</span><span class="sxs-lookup"><span data-stu-id="ad515-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="ad515-193">Тип `ref struct`</span><span class="sxs-lookup"><span data-stu-id="ad515-193">`ref struct` type</span></span>

<span data-ttu-id="ad515-194">Другой функцией, относящиеся к нему является возможность объявлять тип значения, который должен быть выделен стек.</span><span class="sxs-lookup"><span data-stu-id="ad515-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="ad515-195">Другими словами эти типы никогда не создаются в куче является членом другого класса.</span><span class="sxs-lookup"><span data-stu-id="ad515-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="ad515-196">Главной целью этот компонент был <xref:System.Span%601> и связанными структурами.</span><span class="sxs-lookup"><span data-stu-id="ad515-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="ad515-197"><xref:System.Span%601>может содержать управляемый указатель как один из его элементов, другое — длина диапазона.</span><span class="sxs-lookup"><span data-stu-id="ad515-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="ad515-198">Он фактически реализуется немного по-разному C# поддерживает указатели на управляемой памяти за пределами небезопасном контексте.</span><span class="sxs-lookup"><span data-stu-id="ad515-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="ad515-199">Все записи, изменения указателя и длины не является атомарной.</span><span class="sxs-lookup"><span data-stu-id="ad515-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="ad515-200">Это означает <xref:System.Span%601> будет подвергаться на вне допустимого диапазона ошибки или другие нарушения безопасности типов были не ограничен один стек.</span><span class="sxs-lookup"><span data-stu-id="ad515-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="ad515-201">Кроме того размещение управляемый указатель на кучу сборщика Мусора обычно аварийно завершает работу во время JIT-компилятора.</span><span class="sxs-lookup"><span data-stu-id="ad515-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="ad515-202">Могут иметь похожие требования, работа с памятью, созданные с помощью [ `stackalloc` ](language-reference/keywords/stackalloc.md) или при использовании памяти из API взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="ad515-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="ad515-203">Можно определить собственные `ref struct` типов для этих задач.</span><span class="sxs-lookup"><span data-stu-id="ad515-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="ad515-204">В этой статье вы видите примеры использования `Span<T>` для простоты.</span><span class="sxs-lookup"><span data-stu-id="ad515-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="ad515-205">`ref struct` Объявление объявляет, что структура этого типа должен быть в стеке.</span><span class="sxs-lookup"><span data-stu-id="ad515-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="ad515-206">Язык правила гарантируют безопасность использования этих типов.</span><span class="sxs-lookup"><span data-stu-id="ad515-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="ad515-207">Другие типы, объявленные как `ref struct` включают <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="ad515-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="ad515-208">Целью поддержания `ref struct` введите как переменная, выделенному стеком представлены несколько правил, которые компилятор применяет для всех `ref struct` типов.</span><span class="sxs-lookup"><span data-stu-id="ad515-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="ad515-209">Не поддерживает упаковку `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="ad515-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="ad515-210">Невозможно присвоить `ref struct` тип переменной типа `object`, `dynamic`, или любой другой тип интерфейса.</span><span class="sxs-lookup"><span data-stu-id="ad515-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="ad515-211">Нельзя объявлять `ref struct` как член класса или структуры обычного.</span><span class="sxs-lookup"><span data-stu-id="ad515-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="ad515-212">Нельзя объявлять локальные переменные, которые являются `ref struct` типов в асинхронных методах.</span><span class="sxs-lookup"><span data-stu-id="ad515-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="ad515-213">Их можно объявить в синхронных методов, возвращающих `Task`, `Task<T>` или типов задач.</span><span class="sxs-lookup"><span data-stu-id="ad515-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="ad515-214">Нельзя объявлять `ref struct` локальных переменных в итераторах.</span><span class="sxs-lookup"><span data-stu-id="ad515-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="ad515-215">Вы не можете получить `ref struct` переменных в лямбда-выражения или локальные функции.</span><span class="sxs-lookup"><span data-stu-id="ad515-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="ad515-216">Эти ограничения убедитесь, что вы не используете случайно `ref struct` таким образом, можно превратить в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="ad515-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="ad515-217">Выводы</span><span class="sxs-lookup"><span data-stu-id="ad515-217">Conclusions</span></span>

<span data-ttu-id="ad515-218">Эти усовершенствования для языка C# предназначены для критических алгоритмов производительности, где может быть вызвана для достижения необходимую производительность операций выделения памяти.</span><span class="sxs-lookup"><span data-stu-id="ad515-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="ad515-219">Вы можете обнаружить, что не часто используют эти функции в написании кода.</span><span class="sxs-lookup"><span data-stu-id="ad515-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="ad515-220">Однако эти усовершенствования были приняты во множестве расположений в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ad515-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="ad515-221">API-интерфейсы по мере внесения использовать эти функции, вы увидите повысить производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="ad515-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
