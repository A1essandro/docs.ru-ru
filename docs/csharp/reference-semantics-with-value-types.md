---
title: "Семантику ссылки с типами значений"
description: "Понять возможности языка, которые сводят к минимуму копирование структуры безопасно"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a>Семантику ссылки с типами значений

Преимуществом использования типов значений — часто избежать выделений памяти в куче.
Соответствующий недостаток заключается в том, что они копируются по значению. Это компромисс затрудняет для оптимизации алгоритмы, работающие с большими объемами данных. Новые возможности языка C# 7.2 предоставления механизмов, позволяющих включить семантику передачи по ссылке с типами значений. Если вы используете эти функции рационально можно свести к минимуму обоих выделений и операции копирования. В этой статье исследуются этих новых функций.

Большая часть кода примера в этой статье показано, добавленных в C# 7.2. Чтобы использовать эти функции, необходимо настроить проект на языке C# 7,2 или более поздней версии в своем проекте. Visual Studio можно использовать, чтобы выбрать его. Для каждого проекта, выберите **проекта** меню, затем **свойства**. Выберите **построения** и нажмите кнопку **Дополнительно**. После этого можно настроить на английском языке. Выберите «7.2» или «последние».  Или же можно изменить *csproj* и добавьте следующий узел:

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

«7,2» или «последние» можно использовать для значения.

## <a name="specifying-in-parameters"></a>Указание `in` параметров

7.2 C# добавляет `in` ключевое слово в дополнение к существующий `ref` и `out` ключевые слова, если необходимо написать метод, который передает аргументы по ссылке. `in` Ключевое слово указывает, что параметр передаются по ссылке, и вызванный метод не изменяет значение, переданное параметру. 

Это дополнение предоставляет полный словаря для выражения намерениям конструктора. Типы значений, копируются при передаче в вызываемый метод, если не указать один из следующих модификаторов. Каждый из этих модификаторов указать, что тип значения передается по ссылке, как избежать копирования. Каждый модификатор выражает вопроса:

- `out`: Этот метод задает значение аргумента, используемое в качестве этого параметра.
- `ref`: Этот метод может задать значение аргумента, используемое в качестве этого параметра.
- `in`: Этот метод не изменяет значение аргумента, используемое в качестве этого параметра.

При добавлении `in` модификатор для передачи аргумента по ссылке, объявите намерениям разработки аргументы передаются по ссылке, чтобы избежать ненужных копирования. Не требуется изменить объект, который используется в качестве аргумента. Ниже приведен пример метода, которая вычисляет расстояние между двумя точками в трехмерном пространстве. 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

Аргументы являются две структуры, которые в них содержатся три тип Double. Значение типа double — 8 байт, поэтому каждый аргумент является 24 байта. Указав `in` модификатор, передайте байт 4 или 8 байт ссылку для этих аргументов, в зависимости от архитектуры компьютера. Разница в размере небольшое, однако его можно быстро сложить когда приложение вызывает этот метод в непрерывном цикле с помощью большого количества различных значений.
 
`in` Дополняет модификатор `out` и `ref` также другие способы. Не удается создать перегрузки метода, которые отличаются только в за присутствии из `in`, `out` или `ref`. Эти новые правила поведения же, всегда определен для `out` и `ref` параметров.

`in` Модификатор может применяться к любому элементу, который принимает параметры: методы, делегаты, лямбда-выражения, локальные функции, индексаторы, операторы.

В отличие от `ref` и `out` аргументов, может использовать литералы или константы аргумент `in` параметра. Кроме того, в отличие от `ref` или `out` параметр, не нужно применять `in` модификатор на сайте вызова. В следующем коде показано два примера вызова `CalculateDistance` метод. Первый использует двух локальных переменных, передаваемый по ссылке. Второй включает временной переменной, которая создана как часть вызова метода. 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

Существует несколько способов, в которых компилятор гарантирует, только для чтения характер `in` обеспечивается аргумент.  Во-первых, вызванный метод не может быть назначена непосредственно `in` параметра. Невозможно присвоить непосредственно к любому полю `in` параметра. Кроме того, невозможно передать `in` параметр для любого метода, где это требуется `ref` или `out` модификатор.
Компилятор принудительно применяет `in` аргумент является переменной только для чтения. Можно вызвать любой метод экземпляра, который использует семантику передачи по значению. В этих случаях копию `in` создается параметр. Поскольку компилятор может создать временную переменную для любого `in` параметр, можно также указать значения по умолчанию для любого `in` параметра. Следующий код использует, чтобы указать в качестве значения по умолчанию для второй точки начала координат (точки 0,0):

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

`in` Обозначение параметр можно также использовать со ссылочными типами или встроенных числовых значений. Тем не менее преимущества в обоих случаях минимальны, если таковые имеются.

## <a name="ref-readonly-returns"></a>`ref readonly`Возвращает

Можно также возвращать тип значения по ссылке, но запретить вызывающей стороне из изменение этого значения. Используйте `ref readonly` модификатор express этой цели проекта. Он уведомляет читатели производится возврат ссылки к существующим данным, а также не позволяет изменять. 

Поэтому компилятор применяет, что вызывающий объект не удается изменить ссылку. Предпринимается попытка назначить значение напрямую вызывают ошибку компиляции. Однако компилятор не знает, если любой член метод изменяет состояние структуры.
Чтобы убедиться, что объект не изменяется, компилятор создает копию и вызывает член ссылки с помощью этой копии. Все изменения будут к этой копии защитного. 

Скорее всего, в библиотеке с использованием `Point3D` часто используется начало координат по всему коду. Каждый экземпляр создает новый объект в стеке. Может оказаться целесообразным создать константу и вернуть его по ссылке. Но если вы получите ссылку на внутреннее хранилище, можно обеспечить, что вызывающий объект не удается изменить хранилища, на которую указывает ссылка. В следующем коде определяется только для чтения свойство, возвращающее `readonly ref` для `Point3D` , указывающий начало координат.

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

Создать копию ref readonly возвращаемого несложно: просто присвоить его переменной, не объявлен со `ref readonly` модификатор. Компилятор создает код для копирования объекта, в рамках назначения. 

При назначении переменной для `ref readonly return`, можно указать либо `ref readonly` переменной или по значению копии ссылки только для чтения:

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

Первое присваивание в предыдущем примере кода создается копия `Origin` константы и назначит, предназначенных для копирования. Второй назначает ссылку. Обратите внимание, что `readonly` модификатор должен быть частью объявления переменной. Невозможно изменить ссылку, на который она ссылается. Попытки сделать это привести к ошибке во время компиляции.

## <a name="readonly-struct-type"></a>Тип `readonly struct`

Применение `ref readonly` пользователям с высоким трафиком структуры может быть достаточно.
В других случаях может потребоваться создать неизменяемый структуры. Затем всегда можно передавать по ссылке только для чтения. Удаляет, рекомендуется защитного копирует которые происходят, когда к методам структуры используется в качестве `in` параметра.

Это можно сделать путем создания `readonly struct` типа. Можно добавить `readonly` модификатор в объявлении структуры. Поэтому компилятор применяет все члены структуры, `readonly`; `struct` должны быть неизменными.

Существуют другие виды оптимизации для `readonly struct`. Можно использовать `in` модификатор в любом месте где `readonly struct` выступает в качестве аргумента. Кроме того, можно вернуть `readonly struct` как `ref return` при возвращении объекта, время существования которых выходит за пределы области действия метода возврат объекта.

Наконец, компилятор создает более эффективный код, когда вызов членов из `readonly struct`: `this` ссылку вместо копирования приемника, всегда является `in` параметра, передаваемого по ссылке метод члена. Эта оптимизация сохраняет копирования при использовании `readonly struct`. `Point3D` Отлично подходит для этого изменения. В следующем коде показано обновленное `ReadonlyPoint3D` структуры:

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a>Тип `ref struct`

Другой функцией, относящиеся к нему является возможность объявлять тип значения, который должен быть выделен стек. Другими словами эти типы никогда не создаются в куче является членом другого класса. Главной целью этот компонент был <xref:System.Span%601> и связанными структурами. <xref:System.Span%601>может содержать управляемый указатель как один из его элементов, другое — длина диапазона. Он фактически реализуется немного по-разному C# поддерживает указатели на управляемой памяти за пределами небезопасном контексте. Все записи, изменения указателя и длины не является атомарной. Это означает <xref:System.Span%601> будет подвергаться на вне допустимого диапазона ошибки или другие нарушения безопасности типов были не ограничен один стек. Кроме того размещение управляемый указатель на кучу сборщика Мусора обычно аварийно завершает работу во время JIT-компилятора.

Могут иметь похожие требования, работа с памятью, созданные с помощью [ `stackalloc` ](language-reference/keywords/stackalloc.md) или при использовании памяти из API взаимодействия. Можно определить собственные `ref struct` типов для этих задач. В этой статье вы видите примеры использования `Span<T>` для простоты.

`ref struct` Объявление объявляет, что структура этого типа должен быть в стеке. Язык правила гарантируют безопасность использования этих типов. Другие типы, объявленные как `ref struct` включают <xref:System.ReadOnlySpan%601>. 

Целью поддержания `ref struct` введите как переменная, выделенному стеком представлены несколько правил, которые компилятор применяет для всех `ref struct` типов.

- Не поддерживает упаковку `ref struct`. Невозможно присвоить `ref struct` тип переменной типа `object`, `dynamic`, или любой другой тип интерфейса.
- Нельзя объявлять `ref struct` как член класса или структуры обычного.
- Нельзя объявлять локальные переменные, которые являются `ref struct` типов в асинхронных методах. Их можно объявить в синхронных методов, возвращающих `Task`, `Task<T>` или типов задач.
- Нельзя объявлять `ref struct` локальных переменных в итераторах.
- Вы не можете получить `ref struct` переменных в лямбда-выражения или локальные функции.

Эти ограничения убедитесь, что вы не используете случайно `ref struct` таким образом, можно превратить в управляемой куче.

## <a name="conclusions"></a>Выводы

Эти усовершенствования для языка C# предназначены для критических алгоритмов производительности, где может быть вызвана для достижения необходимую производительность операций выделения памяти. Вы можете обнаружить, что не часто используют эти функции в написании кода. Однако эти усовершенствования были приняты во множестве расположений в .NET Framework. API-интерфейсы по мере внесения использовать эти функции, вы увидите повысить производительность приложения.
