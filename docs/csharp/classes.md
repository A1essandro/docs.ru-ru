---
title: "Классы | Руководство по C#"
description: "Сведения о типах классов и их создании"
keywords: .NET, .NET Core, C#
author: BillWagner
ms.author: wiwagn
ms.date: 10/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 13cbd3a5b53ea9b0f1acb22684b6a28639d00751
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="classes"></a>Классы
*Класс* — это конструкция, которая позволяет создавать собственные настраиваемые типы путем группирования переменных других типов, методов и событий. Класс похож на проект. Он определяет данные и поведение типа. Если класс не объявлен как статический, клиентский код может использовать его, создавая *объекты* или *экземпляры*, назначенные переменной. Переменная остается в памяти до тех пор, пока все ссылки на нее не выйдут из области. В этот момент среда CLR помечает ее пригодной для сборки мусора. Если класс объявляется как [статический](language-reference/keywords/static.md), то в памяти существует только одна копия, и клиентский код может получать к ней доступ только через сам класс, а не *переменную экземпляра*. Дополнительные сведения см. в разделе [Статические классы и члены статических классов](programming-guide/classes-and-structs/static-classes-and-static-class-members.md).  

## <a name="reference-types"></a>Ссылочные типы  
Тип, который определен как [класс](language-reference/keywords/class.md), является *ссылочным типом*. Во время выполнения при объявлении переменной ссылочного типа переменная содержит значение [NULL](language-reference/keywords/null.md) до тех пор, пока вы явным образом не создадите экземпляр объекта с помощью оператора [new](language-reference/keywords/new.md), или назначите его объекту, который был создан в другом месте, используя [new](language-reference/keywords/new.md), как показано в следующем примере:  

[!code-csharp[Reference Types](../../samples/snippets/csharp/concepts/classes/reference-type.cs)]
  
При создании объекта выделяется память в управляемой куче, и переменная хранит только ссылку на расположение объекта. Для типов в управляемой куче требуются временные затраты как при их выделении, так и удалении с помощью функции автоматического управления памятью в среде CLR, которая называется *сборкой мусора*. Сборка мусора является высоко оптимизированным процессом и в большинстве случаев не приводит к возникновению проблем производительности. Дополнительные сведения о сборке мусора см. в разделе [Автоматическое управление памятью и сборка мусора](../standard/garbage-collection/gc.md).  
  
Ссылочные типа полностью поддерживают *наследование*, фундаментальную характеристику объектно ориентированного программирования. При создании класса его можно наследовать от любого другого интерфейса или класса, который не определен как [запечатанный](language-reference/keywords/sealed.md), а другие классы могут наследоваться от этого класса и переопределять виртуальные методы. Дополнительные сведения см. в разделе [Наследование](programming-guide/classes-and-structs/inheritance.md).

## <a name="declaring-classes"></a>Объявление классов  
Классы объявляются с помощью ключевого слова [class](language-reference/keywords/class.md), как показано в следующем примере:  
  
[!code-csharp[Declaring Classes](../../samples/snippets/csharp/concepts/classes/declaring-classes.cs)]  
  
Ключевому слову **class** предшествует модификатор доступа. Поскольку в этом случае используется открытый класс ([public](language-reference/keywords/public.md)), любой пользователь может создавать объекты из этого класса. Имя класса указывается после ключевого слова **class**. Оставшаяся часть определения — это тело класса, в котором задаются данные и поведение. Поля, свойства, методы и события в классе собирательно называются *членами класса*.  
  
## <a name="creating-objects"></a>Создание объектов  
Класс определяет тип объекта, но не является объектом. Объект — это конкретная сущность, основанная на классе, которую иногда называют экземпляром класса.  
  
Объекты можно создавать с помощью ключевого слова [new](language-reference/keywords/new.md), за которым следует имя класса, на котором будет основан объект, например следующим образом:  
  
[!code-csharp[Creating Objects](../../samples/snippets/csharp/concepts/classes/creating-objects.cs)]   
  
При создании экземпляра класса ссылка на объект передается программисту. В предыдущем примере `object1` представляет собой ссылку на объект, который основан на `Customer`. Эта ссылка указывает на новый объект, но не содержит данные этого объекта. Фактически, можно создать ссылку на объект без создания собственно объекта:  
  
[!code-csharp[Creating Objects](../../samples/snippets/csharp/concepts/classes/creating-objects2.cs)]  
  
Создание таких ссылок, которые не указывают на объект, не рекомендуется, так как попытка доступа к объекту по такой ссылке приведет к сбою во время выполнения. Однако такую ссылку можно сделать указывающей на объект, создав новый объект или назначив ее существующему объекту, как показано далее:  
  
[!code-csharp[Creating Objects](../../samples/snippets/csharp/concepts/classes/creating-objects3.cs)]  
  
В этом коде создаются две ссылки на объект, которые указывают на один и тот же объект. Таким образом, любые изменения объекта, выполненные посредством `object3`, будут отражены при последующем использовании `object4`. Поскольку на объекты, основанные на классах, указывают ссылки, классы называют ссылочными типами.  
  
## <a name="class-inheritance"></a>Наследование классов  
При наследовании создается *производный* класс, то есть класс объявляется с помощью *базового класса*, от которого он наследует данные и поведение. Базовый класс задается добавлением после имени производного класса двоеточия и имени базового класса, как показано далее:  
  
[!code-csharp[Inheritance](../../samples/snippets/csharp/concepts/classes/inheritance.cs)]  
  
Когда класс объявляет базовый класс, он наследует все члены базового класса, за исключением конструкторов.  
  
В отличие от C++, класс в C# может только напрямую наследовать от одного базового класса. Тем не менее, поскольку базовый класс может сам наследовать от другого класса, класс может косвенно наследовать от нескольких базовых классов. Кроме того, класс может напрямую реализовать несколько интерфейсов. Дополнительные сведения см. в разделе [Интерфейсы](programming-guide/interfaces/index.md).  
  
Класс может быть объявлен [абстрактным](language-reference/keywords/abstract.md). Абстрактный класс содержит абстрактные методы, которые имеют определение сигнатуры, но не имеют реализации. Нельзя создавать экземпляры абстрактных классов. Они могут использоваться только через производные классы, реализующие абстрактные методы. И наоборот, [запечатанный](language-reference/keywords/sealed.md) класс не позволяет другим классам быть от него производными. Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
Определения классов можно разделить между различными исходными файлами. Дополнительные сведения см. в разделе [Определения разделяемого класса](programming-guide/classes-and-structs/partial-classes-and-methods.md).  
  
 
## <a name="example"></a>Пример
В следующем примере определяется открытый класс, содержащий одно поле, метод и специальный метод, вызывающий конструктор. Дополнительные сведения см. в разделе [Конструкторы](programming-guide/classes-and-structs/constructors.md). Затем создается экземпляр этого класса с помощью ключевого слова **new**.

[!code-csharp[Class Example](../../samples/snippets/csharp/concepts/classes/class-example.cs)]  
  
## <a name="c-language-specification"></a>Спецификация языка C#  
Дополнительные сведения см. в [спецификации языка C#](language-reference/language-specification/index.md). Спецификация языка является предписывающим источником информации о синтаксисе и использовании языка C#.
  
## <a name="see-also"></a>См. также  
[Руководство по программированию на C#](programming-guide/index.md)   
[Полиморфизм](programming-guide/classes-and-structs/polymorphism.md)   
[Члены класса и структуры](programming-guide/classes-and-structs/members.md)   
[Методы класса и структуры](programming-guide/classes-and-structs/methods.md)   
[Конструкторы](programming-guide/classes-and-structs/constructors.md)   
[Методы завершения](programming-guide/classes-and-structs/destructors.md)   
[Объекты](programming-guide/classes-and-structs/objects.md)

