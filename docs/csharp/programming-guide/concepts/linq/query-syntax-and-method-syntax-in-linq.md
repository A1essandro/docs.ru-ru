---
title: "Синтаксис запросов и синтаксис методов в LINQ (C#) | Документы Майкрософт"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- LINQ [C#], query syntax vs. method syntax
- queries [LINQ in C#], syntax comparisons
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
caps.latest.revision: 30
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 687741ed357fd13424c4e2f9eeda3d2b531fd129
ms.lasthandoff: 03/13/2017

---
# <a name="query-syntax-and-method-syntax-in-linq-c"></a>Синтаксис запросов и синтаксис методов в LINQ (C#)
Большинство запросов в вводной документации к LINQ ([!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]) написано с использованием декларативного синтаксиса запросов LINQ. Однако синтаксис запроса должен быть преобразован в вызовы методов для среды CLR .NET, когда код компилируется. Эти вызовы метода вызывают стандартные операторы запросов, которые имеют такие имена, как `Where`, `Select`, `GroupBy`, `Join`, `Max` и `Average`. Вместо синтаксиса запросов для их вызова можно использовать синтаксис методов.  
  
 Синтаксис запросов и синтаксис методов семантически идентичны, но многие пользователи найдут синтаксис запросов более простым и более удобным для чтения. Некоторые запросы должны быть выражены как вызовы методов. Например, необходимо использовать вызов метода для выражения запроса, который возвращает число элементов, соответствующих указанным критериям. Вызов метода также необходимо использовать для запроса, который получает элемент с максимальным значением в исходной последовательности. В справочной документации по стандартным операторам запросов в пространствах имен <xref:System.Linq> обычно применяется синтаксис методов. В связи с этим даже на начальном этапе работы с запросами [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)] полезно иметь представление о том, как использовать синтаксис методов в самих запросах и выражениях запросов.  
  
## <a name="standard-query-operator-extension-methods"></a>Методы расширения стандартных операторов запросов  
 В следующем примере показано простое *выражение запроса* и семантически эквивалентный ему запрос, написанный как *запрос, основанный на методе*.  
  
 [!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/CSharp/query-syntax-and-method-syntax-in-linq_1.cs)]  
  
 Оба примера дают одинаковый результат. Видно, что тип переменной запроса в обеих формах одинаковый: <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Чтобы разобраться в запросе, основанном на методе, изучим его более подробно. Обратите внимание на то, что в правой части выражения предложение `where` теперь выражается как метод экземпляра в объекта `numbers`, который, как вы, наверное, помните, имеет тип `IEnumerable<int>`. Если вы знакомы с универсальным интерфейсом <xref:System.Collections.Generic.IEnumerable%601>, то знаете, что в нем отсутствует метод `Where`. При этом, вызвав список завершения IntelliSense в Visual Studio IDE, вы увидите не только метод `Where`, но и многие другие методы, такие как `Select`, `SelectMany`, `Join` и `Orderby`. Все это — стандартные операторы запросов.  
  
 ![Стандартные операторы запросов в Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")  
  
 Может показаться, что класс <xref:System.Collections.Generic.IEnumerable%601> был переопределен и включает дополнительные методы, однако это не так. Стандартные операторы запросов реализуются как новый тип метода, который называется *методы расширения*. Эти методы "расширяют" существующий тип и могут вызываться так, как если бы они являлись методами экземпляра для этого типа. Стандартные операторы запросов расширяют <xref:System.Collections.Generic.IEnumerable%601>, что позволяет написать `numbers.Where(...)`.  
  
 Чтобы приступить к использованию [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)], о методах расширения достаточно знать только то, как ввести их в область действия в приложении, используя директивы `using`. С точки зрения приложения метод расширения и обычные методы экземпляров одинаковы.  
  
 Дополнительные сведения о методах расширения см. в разделе [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md). Дополнительные сведения о стандартных операторах запросов см. в разделе [Общие сведения о стандартных операторах запроса (C#)](../../../../csharp/programming-guide/concepts/linq/standard-query-operators-overview.md). Некоторые поставщики [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)], такие как [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq_md.md)] и [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)], помимо <xref:System.Collections.Generic.IEnumerable%601> реализуют собственные стандартные операторы запросов и дополнительные методы расширения для других типов.  
  
## <a name="lambda-expressions"></a>Лямбда-выражения  
 В предыдущем примере обратите внимание на то, что условное выражение (`num % 2 == 0`) передается в метод `Where` как встроенный аргумент: `Where(num => num % 2 == 0).`. Это встроенное выражение называется лямбда-выражением. Это удобный способ написания кода, который иначе пришлось бы записывать более громоздко: как анонимный метод, универсальный метод-делегат или дерево выражения. В C# `=>` представляет собой лямбда-оператор, который читается как "переходит в". `num` слева от оператора — входная переменная, которая соответствует переменной `num` в выражении запроса. Компилятор может получить тип `num`, поскольку знает, что `numbers` представляет собой универсальный тип <xref:System.Collections.Generic.IEnumerable%601>. Тело лямбда-выражения — точно такое же, как выражение в синтаксисе запроса или в любом другом выражении или операторе C#, и может включать вызовы метода и другие сложные логические выражения. "Возвращаемое значение" — результат выражения.  
  
 Чтобы приступить к использованию [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)], активно использовать лямбда-выражения необязательно. При этом одни запросы могут быть выражены с помощью синтаксиса запроса, в то время как другие требуют лямбда-выражений. После знакомства с лямбда-выражениями станет понятно, что они являются мощными и гибкими элементами в арсенале элементов [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq_md.md)]. Дополнительные сведения см. в разделе [Лямбда-выражения](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).  
  
## <a name="composability-of-queries"></a>Совместимость запросов  
 Обратите внимание на то, что в представленном выше примере кода метод `OrderBy` вызывается с помощью оператора точки при вызове `Where`. `Where` создает отфильтрованную последовательность, а затем `Orderby` ее сортирует. Поскольку запросы возвращают `IEnumerable`, объедините их в синтаксис метода, собрав вызовы методов в цепочку. Компилятор выполняет это действие в фоновом режиме, когда вы пишете запросы, используя синтаксис запросов. А поскольку в переменной запроса результаты запроса не сохраняются, его можно в любое время изменить или использовать как базу для нового запроса даже после выполнения.  
  
## <a name="see-also"></a>См. также  
 [Приступая к работе с LINQ в C#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)
