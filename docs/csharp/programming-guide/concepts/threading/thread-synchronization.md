---
title: "Синхронизация потоков (C#) | Документы Майкрософт"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
ms.assetid: e42b1be6-c93c-479f-a148-be0759f1a4e1
caps.latest.revision: 3
author: BillWagner
ms.author: wiwagn
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 31b206eb01d778b67acc1a25d3c69e2e1dfd553d
ms.lasthandoff: 03/13/2017

---
# <a name="thread-synchronization-c"></a>Синхронизация потоков (C#)
В следующих разделах описаны функции и классы, которые можно использовать для синхронизации доступа к ресурсам в многопоточных приложениях.  
  
 Одним из преимуществ использования нескольких потоков в приложении является асинхронное выполнение каждого потока. В приложениях Windows это позволяет выполнять длительные задачи в фоновом режиме, при этом окно приложения и элементы управления остаются активными. Для серверных приложений многопоточность обеспечивает возможность обработки каждого входящего запроса в отдельном потоке. В противном случае ни один новый запрос не будет обработан, пока не завершена обработка предыдущего запроса.  
  
 Однако вследствие того, что потоки асинхронные, доступ к ресурсам, таким как дескрипторы файлов, сетевые подключения и память, должен быть скоординирован. Иначе два или более потоков могут получить доступ к одному и тому же ресурсу одновременно, причем один поток не будет учитывать действия другого. В результате данные могут быть повреждены непредсказуемым образом.  
  
 Для простых операций над числовыми типами данных синхронизация потоков выполняется с помощью членов класса <xref:System.Threading.Interlocked>. Для прочих типов данных и других ресурсов, не являющихся потокобезопасными, многопоточность можно применять только с помощью структур, описываемых в этом разделе.  
  
 Дополнительные сведения о многопоточном программировании см. в разделах:  
  
-   [Основы управляемых потоков](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [Использование потоков и работа с потоками](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [Рекомендации по работе с потоками](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-keyword"></a>Ключевое слово lock  
 Оператор C# `lock` используется для того, чтобы выполнение блока кода не прерывалось кодом, выполняемым в других потоках. Для этого нужно получить взаимоисключающую блокировку для данного объекта на время длительности блока кода.  
  
 Оператор `lock`получает объект в качестве аргумента, и за ним следует блок кода, который должен выполняться одновременно только в одном потоке. Пример:  
  
```csharp  
public class TestThreading  
{  
    private System.Object lockThis = new System.Object();  
  
    public void Process()  
    {  
  
        lock (lockThis)  
        {  
            // Access thread-sensitive resources.  
        }  
    }  
  
}  
```  
  
 Аргумент, предоставляемый ключевому слову `lock`, должен быть объектом на основе ссылочного типа; он используется для определения области блокировки. В приведенном выше примере область блокировки ограничена этой функцией, поскольку не существует ссылок на объект `lockThis` вне функции. Если бы такая ссылка существовала, область блокировки включала бы этот объект. Строго говоря, предоставляемый объект используется только для того, чтобы уникальным образом определить ресурс, к которому предоставляется доступ для различных потоков, поэтому это может быть произвольный экземпляр класса. В действительности этот объект обычно представляет ресурс, для которого требуется синхронизация потоков. Например, если объект контейнера должен использоваться в нескольких потоках, то контейнер можно передать блокировке, а блок синхронизированного кода после блокировки должен получить доступ к контейнеру. Если другие потоки блокируются для того же контейнера перед доступом к нему, обеспечивается безопасная синхронизация доступа к объекту.  
  
 Как правило, рекомендуется избегать блокировки типа `public` или экземпляров объектов, которыми не управляет код вашего приложения. Например, использование `lock(this)` может привести к неполадкам, если к экземпляру разрешен открытый доступ, поскольку внешний код также может блокировать объект. Это может привести к созданию ситуаций взаимной блокировки, когда два или несколько потоков будут ожидать высвобождения одного и того же объекта. По этой же причине блокировка открытого типа данных (в отличие от объектов) может привести к неполадкам. Блокировка строковых литералов наиболее опасна, поскольку строковые литералы *интернируются* средой CLR. Это означает, что если во всей программе есть один экземпляр любого строкового литерала, точно такой же объект будет представлять литерал во всех запущенных доменах приложения и во всех потоках. В результате блокировка, включенная для строки с одинаковым содержимым во всем приложении, блокирует все экземпляры этой строки в приложении. По этой причине лучше использовать блокировку закрытых или защищенных членов, для которых интернирование не применяется. В некоторых классах есть члены, специально предназначенные для блокировки. Например, в типе <xref:System.Array> есть <xref:System.Array.SyncRoot%2A>. Во многих типах коллекций есть член `SyncRoot`.  
  
 Дополнительные сведения об операторе `lock` см. в следующих разделах.  
  
-   [Оператор lock](../../../../csharp/language-reference/keywords/lock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a>Мониторы  
 Как и ключевое слово `lock`, мониторы не допускают одновременное выполнение несколькими потоками одних и тех же блоков кода. Метод <xref:System.Threading.Monitor.Enter%2A> позволяет только одному потоку переходить к последующим операторам, все прочие потоки заблокированы, пока выполняемый поток не вызовет <xref:System.Threading.Monitor.Exit%2A>. Это аналогично использованию ключевого слова `lock`. Пример:  
  
```csharp  
lock (x)  
{  
    DoSomething();  
}  
```  
  
 Это соответствует следующей записи:  
  
```csharp  
System.Object obj = (System.Object)x;  
System.Threading.Monitor.Enter(obj);  
try  
{  
    DoSomething();  
}  
finally  
{  
    System.Threading.Monitor.Exit(obj);  
}  
```  
  
 Использование ключевого слова `lock` предпочтительнее прямого использования класса <xref:System.Threading.Monitor>, так как ключевое слово `lock`, а также слово `lock` обеспечивает разблокировку основного монитора даже в том случае, если защищенный код вызывает исключение. Для этого применяется ключевое слово `finally`, которые выполняет свой блок кода вне зависимости от наличия исключений.  
  
## <a name="synchronization-events-and-wait-handles"></a>События синхронизации и дескрипторы ожидания  
 Использование блокировки или монитора полезно для предотвращения одновременного выполнения блоков кода, но эти структуры не позволяют одному потоку передавать события в другой. Для этого требуются *события синхронизации* — объекты, обладающие одним из двух состояний (с сигналом или без сигнала), применяющиеся для активации и приостановки потоков. Потоки можно приостанавливать, заставляя их ожидать события синхронизации без сигнала, и активировать, меняя состояние события на состояние с сигналом. Если поток попытается ожидать события, для которого уже есть сигнал, то выполнение потока продолжится без задержки.  
  
 Существует два типа событий синхронизации: <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>. Отличие только одно: <xref:System.Threading.AutoResetEvent> автоматически изменяется с состояния с сигналом на состояние без сигнала всегда при активации потока. В отличие от него, <xref:System.Threading.ManualResetEvent> позволяет активировать состоянием с сигналом любое количество потоков, и вернется в состояние без сигнала только при вызове своего метода <xref:System.Threading.EventWaitHandle.Reset%2A>.  
  
 Потоки можно заставить дожидаться определенных событий, вызвав один из методов ожидания, например <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> или <xref:System.Threading.WaitHandle.WaitAll%2A>. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> приводит к ожиданию потока до тех пор, пока единственное событие не становится сигнализирующим, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> блокирует поток до тех пор, пока одно или несколько указанных событий не становятся сигнализирующими, и <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> блокирует поток до тех пор, пока все указанные события не становятся сигнализирующими. Событие выдает сигнал при вызове метода <xref:System.Threading.EventWaitHandle.Set%2A> этого события.  
  
 В следующем примере поток создается и запускается функцией `Main`. Новый поток ожидает события с помощью метода <xref:System.Threading.WaitHandle.WaitOne%2A>. Выполнение потока приостанавливается до получения сигнала от события основным потоком, выполняющим функцию `Main`. После получения сигнала возвращается дополнительный поток. В этом случае, поскольку событие используется только для активации одного потока, можно использовать классы <xref:System.Threading.AutoResetEvent> или <xref:System.Threading.ManualResetEvent>.  
  
```csharp  
using System;  
using System.Threading;  
  
class ThreadingExample  
{  
    static AutoResetEvent autoEvent;  
  
    static void DoWork()  
    {  
        Console.WriteLine("   worker thread started, now waiting on event...");  
        autoEvent.WaitOne();  
        Console.WriteLine("   worker thread reactivated, now exiting...");  
    }  
  
    static void Main()  
    {  
        autoEvent = new AutoResetEvent(false);  
  
        Console.WriteLine("main thread starting worker thread...");  
        Thread t = new Thread(DoWork);  
        t.Start();  
  
        Console.WriteLine("main thread sleeping for 1 second...");  
        Thread.Sleep(1000);  
  
        Console.WriteLine("main thread signaling worker thread...");  
        autoEvent.Set();  
    }  
}  
```  
  
## <a name="mutex-object"></a>Мьютексные объекты  
 *Мьютекс* аналогичен монитору, он не допускает одновременного выполнения блока кода более чем из одного потока. Название "мьютекс" — сокращенная форма слова "взаимоисключающий" ("mutually exclusive" на английском языке). Впрочем, в отличие от мониторов мьютексы можно использовать для синхронизации потоков по процессам. Мьютекс представляется классом <xref:System.Threading.Mutex>.  
  
 При использовании для синхронизации между процессами мьютекс называется *именованным мьютексом*, поскольку он должен использоваться в другом приложении и к нему нельзя предоставить общий доступ с помощью глобальной или статической переменной. Ему нужно назначить имя, чтобы оба приложения могли получить доступ к одному и тому же объекту мьютекса.  
  
 Несмотря на то, что для синхронизации потоков внутри процесса можно использовать мьютекс, рекомендуется использовать <xref:System.Threading.Monitor>, поскольку мониторы были созданы специально для .NET Framework и более эффективно используют ресурсы. Напротив, класс <xref:System.Threading.Mutex> является оболочкой для структуры Win32. Мьютекс мощнее монитора, но для мьютекса требуются переходы взаимодействия, на которые затрачивается больше вычислительных ресурсов, чем на обработку класса <xref:System.Threading.Monitor>. Пример использования мьютекса см. в разделе [Объекты Mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).  
  
## <a name="interlocked-class"></a>Класс Interlocked  
 Методы класса <xref:System.Threading.Interlocked> можно использовать для предотвращения проблем, возникающих при одновременной попытке нескольких потоков обновить или сравнить некоторое значение. Методы этого класса позволяют безопасно увеличивать, уменьшать, заменять и сравнивать значения переменных из любого потока.  
  
## <a name="readerwriter-locks"></a>Блокировки чтения и записи  
 В некоторых случаях может понадобиться блокировать ресурс только для записи данных и разрешить нескольким клиентам одновременно считывать данные, когда они не обновляются. Класс <xref:System.Threading.ReaderWriterLock> обеспечивает монопольный доступ к ресурсу на то время, в течение которого поток изменяет ресурс, но разрешает одновременно выполнять несколько операций чтения. Блокировки чтения и записи являются удобной альтернативой монопольным блокировкам, которые заставляют другие потоки находиться в состоянии ожидания, даже когда им не нужно обновлять данные.  
  
## <a name="deadlocks"></a>Взаимоблокировки  
 В многопоточных приложениях не обойтись без синхронизации потоков, однако всегда существует опасность создания `deadlock`, когда несколько потоков ожидают друг друга, и приложение зависает. Взаимоблокировка аналогична ситуации, в которой автомобили останавливаются на перекрестке и каждый водитель ожидает, пока проедет другой. Важно исключить возможность взаимоблокировок путем тщательного планирования. Взаимоблокировки часто можно предвидеть еще до написания кода, построив диаграмму многопотокового приложения.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Threading.Thread>   
 <xref:System.Threading.WaitHandle.WaitOne%2A>   
 <xref:System.Threading.WaitHandle.WaitAny%2A>   
 <xref:System.Threading.WaitHandle.WaitAll%2A>   
 <xref:System.Threading.Thread.Join%2A>   
 <xref:System.Threading.Thread.Start%2A>   
 <xref:System.Threading.Thread.Sleep%2A>   
 <xref:System.Threading.Monitor>   
 <xref:System.Threading.Mutex>   
 <xref:System.Threading.AutoResetEvent>   
 <xref:System.Threading.ManualResetEvent>   
 <xref:System.Threading.Interlocked>   
 <xref:System.Threading.WaitHandle>   
 <xref:System.Threading.EventWaitHandle>   
 <xref:System.Threading>   
 <xref:System.Threading.EventWaitHandle.Set%2A>   
 [Многопоточные приложения(C#)](../../../../csharp/programming-guide/concepts/threading/multithreaded-applications.md)   
 [Оператор lock](../../../../csharp/language-reference/keywords/lock-statement.md)   
 [Объекты Mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2)   
 @System.Threading.Monitor   
 [Блокируемые операции](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b)   
 [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18)   
 [Синхронизация данных для многопоточности](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)
