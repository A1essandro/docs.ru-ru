---
title: "Синхронизация потоков (C#)"
ms.custom: 
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: devlang-csharp
ms.topic: article
ms.assetid: e42b1be6-c93c-479f-a148-be0759f1a4e1
caps.latest.revision: "3"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 2b51775eac5221ec8c723d89323d1f4f542d2453
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="thread-synchronization-c"></a>Синхронизация потоков (C#)
В следующих разделах описаны функции и классы, которые можно использовать для синхронизации доступа к ресурсам в многопоточных приложениях.  
  
 Одним из преимуществ использования нескольких потоков в приложении является асинхронное выполнение каждого потока. В приложениях Windows это позволяет выполнять длительные задачи в фоновом режиме, при этом окно приложения и элементы управления остаются активными. Для серверных приложений многопоточность обеспечивает возможность обработки каждого входящего запроса в отдельном потоке. В противном случае ни один новый запрос не будет обработан, пока не завершена обработка предыдущего запроса.  
  
 Однако вследствие того, что потоки асинхронные, доступ к ресурсам, таким как дескрипторы файлов, сетевые подключения и память, должен быть скоординирован. Иначе два или более потоков могут получить доступ к одному и тому же ресурсу одновременно, причем один поток не будет учитывать действия другого. В результате данные могут быть повреждены непредсказуемым образом.  
  
 Для простых операций над числовыми типами данных синхронизация потоков выполняется с помощью членов класса <xref:System.Threading.Interlocked>. Для прочих типов данных и других ресурсов, не являющихся потокобезопасными, многопоточность можно применять только с помощью структур, описываемых в этом разделе.  
  
 Дополнительные сведения о многопоточном программировании см. в разделах:  
  
-   [Основы управляемых потоков](../../../../standard/threading/managed-threading-basics.md)  
  
-   [Использование потоков и работа с потоками](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [Рекомендации по работе с потоками](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-keyword"></a>Ключевое слово lock  
 Оператор C# `lock` используется для того, чтобы выполнение блока кода не прерывалось кодом, выполняемым в других потоках. Для этого нужно получить взаимоисключающую блокировку для данного объекта на время длительности блока кода.  
  
 Оператор `lock`получает объект в качестве аргумента, и за ним следует блок кода, который должен выполняться одновременно только в одном потоке. Пример:  
  
```csharp  
public class TestThreading  
{  
    private System.Object lockThis = new System.Object();  
  
    public void Process()  
    {  
  
        lock (lockThis)  
        {  
            // Access thread-sensitive resources.  
        }  
    }  
  
}  
```  
  
 Аргумент, предоставляемый ключевому слову `lock`, должен быть объектом на основе ссылочного типа; он используется для определения области блокировки. В приведенном выше примере область блокировки ограничена этой функцией, поскольку не существует ссылок на объект `lockThis` вне функции. Если бы такая ссылка существовала, область блокировки включала бы этот объект. Строго говоря, предоставляемый объект используется только для того, чтобы уникальным образом определить ресурс, к которому предоставляется доступ для различных потоков, поэтому это может быть произвольный экземпляр класса. В действительности этот объект обычно представляет ресурс, для которого требуется синхронизация потоков. Например, если объект контейнера должен использоваться в нескольких потоках, то контейнер можно передать блокировке, а блок синхронизированного кода после блокировки должен получить доступ к контейнеру. Если другие потоки блокируются для того же контейнера перед доступом к нему, обеспечивается безопасная синхронизация доступа к объекту.  
  
 Как правило, рекомендуется избегать блокировки типа `public` или экземпляров объектов, которыми не управляет код вашего приложения. Например, использование `lock(this)` может привести к неполадкам, если к экземпляру разрешен открытый доступ, поскольку внешний код также может блокировать объект. Это может привести к созданию ситуаций взаимной блокировки, когда два или несколько потоков будут ожидать высвобождения одного и того же объекта. По этой же причине блокировка открытого типа данных (в отличие от объектов) может привести к неполадкам. Блокировка строковых литералов наиболее опасна, поскольку строковые литералы *интернируются* средой CLR. Это означает, что если во всей программе есть один экземпляр любого строкового литерала, точно такой же объект будет представлять литерал во всех запущенных доменах приложения и во всех потоках. В результате блокировка, включенная для строки с одинаковым содержимым во всем приложении, блокирует все экземпляры этой строки в приложении. По этой причине лучше использовать блокировку закрытых или защищенных членов, для которых интернирование не применяется. В некоторых классах есть члены, специально предназначенные для блокировки. Например, тип <xref:System.Array> предоставляет <xref:System.Array.SyncRoot%2A>. Во многих типах коллекций есть член `SyncRoot`.  
  
 Дополнительные сведения об операторе `lock` см. в следующих разделах.  
  
-   [Оператор lock](../../../../csharp/language-reference/keywords/lock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a>Мониторы  
 Как и ключевое слово `lock`, мониторы не допускают одновременное выполнение несколькими потоками одних и тех же блоков кода. Метод <xref:System.Threading.Monitor.Enter%2A> позволяет переходить к последующим операторам только одному потоку; все прочие потоки будут заблокированы, пока выполняемый поток не вызовет <xref:System.Threading.Monitor.Exit%2A>. Это аналогично использованию ключевого слова `lock`. Пример:  
  
```csharp  
lock (x)  
{  
    DoSomething();  
}  
```  
  
 Это соответствует следующей записи:  
  
```csharp  
System.Object obj = (System.Object)x;  
System.Threading.Monitor.Enter(obj);  
try  
{  
    DoSomething();  
}  
finally  
{  
    System.Threading.Monitor.Exit(obj);  
}  
```  
  
 Использование ключевого слова `lock` предпочтительнее прямого использования класса <xref:System.Threading.Monitor>, поскольку `lock` лаконичнее, а также потому, что `lock` обеспечивает разблокировку основного монитора даже в том случае, если защищенный код вызывает исключение. Для этого применяется ключевое слово `finally`, которые выполняет свой блок кода вне зависимости от наличия исключений.  
  
## <a name="synchronization-events-and-wait-handles"></a>События синхронизации и дескрипторы ожидания  
 Использование блокировки или монитора полезно для предотвращения одновременного выполнения блоков кода, но эти структуры не позволяют одному потоку передавать события в другой. Для этого требуются *события синхронизации* — объекты, обладающие одним из двух состояний (с сигналом или без сигнала), применяющиеся для активации и приостановки потоков. Потоки можно приостанавливать, заставляя их ожидать события синхронизации без сигнала, и активировать, меняя состояние события на состояние с сигналом. Если поток попытается ожидать события, для которого уже есть сигнал, то выполнение потока продолжится без задержки.  
  
 События синхронизации делятся на два типа: <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>. Отличие только одно: при каждой активации потока <xref:System.Threading.AutoResetEvent> автоматически переходит из состояния с сигналом в состояние без сигнала. <xref:System.Threading.ManualResetEvent>, наоборот, допускает активацию любого количества потоков при переходе в состояние с сигналом и возвращается в состояние без сигнала только при вызове метода <xref:System.Threading.EventWaitHandle.Reset%2A>.  
  
 Для того чтобы потоки ожидали событий, можно вызвать один из методов ожидания, таких как <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> или <xref:System.Threading.WaitHandle.WaitAll%2A>. Метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> заставляет поток дожидаться сигнала о единичном событии, метод <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> блокирует поток до получения сигналов об одном или нескольких указанных событиях, а метод <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> блокирует поток до тех пор, пока не будут получены сигналы обо всех указанных событиях. Сигнал о событии подается, когда вызывается его метод <xref:System.Threading.EventWaitHandle.Set%2A>.  
  
 В следующем примере поток создается и запускается функцией `Main`. Новый поток ожидает события за счет метода <xref:System.Threading.WaitHandle.WaitOne%2A>. Выполнение потока приостанавливается до получения сигнала от события основным потоком, выполняющим функцию `Main`. После получения сигнала возвращается дополнительный поток. Поскольку в этом случае событие используется для активации только одного потока, можно использовать либо класс <xref:System.Threading.AutoResetEvent>, либо класс <xref:System.Threading.ManualResetEvent>.  
  
```csharp  
using System;  
using System.Threading;  
  
class ThreadingExample  
{  
    static AutoResetEvent autoEvent;  
  
    static void DoWork()  
    {  
        Console.WriteLine("   worker thread started, now waiting on event...");  
        autoEvent.WaitOne();  
        Console.WriteLine("   worker thread reactivated, now exiting...");  
    }  
  
    static void Main()  
    {  
        autoEvent = new AutoResetEvent(false);  
  
        Console.WriteLine("main thread starting worker thread...");  
        Thread t = new Thread(DoWork);  
        t.Start();  
  
        Console.WriteLine("main thread sleeping for 1 second...");  
        Thread.Sleep(1000);  
  
        Console.WriteLine("main thread signaling worker thread...");  
        autoEvent.Set();  
    }  
}  
```  
  
## <a name="mutex-object"></a>Мьютексные объекты  
 *Мьютекс* аналогичен монитору, он не допускает одновременного выполнения блока кода более чем из одного потока. Название "мьютекс" — сокращенная форма слова "взаимоисключающий" ("mutually exclusive" на английском языке). Впрочем, в отличие от мониторов мьютексы можно использовать для синхронизации потоков по процессам. Мьютексы представляет класс <xref:System.Threading.Mutex>.  
  
 При использовании для синхронизации между процессами мьютекс называется *именованным мьютексом*, поскольку он должен использоваться в другом приложении и к нему нельзя предоставить общий доступ с помощью глобальной или статической переменной. Ему нужно назначить имя, чтобы оба приложения могли получить доступ к одному и тому же объекту мьютекса.  
  
 Несмотря на то, что для синхронизации потоков внутри процесса можно использовать мьютекс, рекомендуется использовать <xref:System.Threading.Monitor>, поскольку мониторы были созданы специально для .NET Framework и более эффективно используют ресурсы. Напротив, класс <xref:System.Threading.Mutex> является оболочкой для структуры Win32. Мьютекс мощнее монитора, но для мьютекса требуются переходы взаимодействия, на которые затрачивается больше вычислительных ресурсов, чем на обработку класса <xref:System.Threading.Monitor>. Пример использования мьютекса см. в разделе [Объекты Mutex](../../../../standard/threading/mutexes.md).  
  
## <a name="interlocked-class"></a>Класс Interlocked  
 Методы класса <xref:System.Threading.Interlocked> можно использовать для предотвращения проблем, возникающих, когда несколько потоков пытаются обновить или сравнить какое-то значение одновременно. Методы этого класса позволяют безопасно увеличивать, уменьшать, заменять и сравнивать значения переменных из любого потока.  
  
## <a name="readerwriter-locks"></a>Блокировки чтения и записи  
 В некоторых случаях может понадобиться блокировать ресурс только для записи данных и разрешить нескольким клиентам одновременно считывать данные, когда они не обновляются. Класс <xref:System.Threading.ReaderWriterLock> обеспечивает монопольный доступ к ресурсу на то время, в течение которого поток изменяет ресурс, но разрешает одновременно выполнять несколько операций чтения. Блокировки чтения и записи являются удобной альтернативой монопольным блокировкам, которые заставляют другие потоки находиться в состоянии ожидания, даже когда им не нужно обновлять данные.  
  
## <a name="deadlocks"></a>Взаимоблокировки  
 В многопоточных приложениях не обойтись без синхронизации потоков, однако всегда существует опасность создания `deadlock`, когда несколько потоков ожидают друг друга, и приложение зависает. Взаимоблокировка аналогична ситуации, в которой автомобили останавливаются на перекрестке и каждый водитель ожидает, пока проедет другой. Важно исключить возможность взаимоблокировок путем тщательного планирования. Взаимоблокировки часто можно предвидеть еще до написания кода, построив диаграмму многопотокового приложения.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [Многопоточные приложения(C#)](../../../../csharp/programming-guide/concepts/threading/multithreaded-applications.md)  
 [Оператор lock](../../../../csharp/language-reference/keywords/lock-statement.md)  
 [Мьютексы](../../../../standard/threading/mutexes.md)  
 [Блокируемые операции](../../../../standard/threading/interlocked-operations.md)  
 [AutoResetEvent](../../../../standard/threading/autoresetevent.md)  
 [Синхронизация данных для многопоточности](../../../../standard/threading/synchronizing-data-for-multithreading.md)
