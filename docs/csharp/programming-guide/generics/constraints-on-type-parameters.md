---
title: "Ограничения параметров типа (Руководство по программированию на C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a>Ограничения параметров типа (Руководство по программированию на C#)
При определении универсального класса можно применить ограничения на типы, которые могут использоваться в клиентском коде для аргументов типа при создании экземпляра класса. Если в клиентском коде для создания экземпляра класса используется недопустимый тип, возникает ошибка времени компиляции. Таким образом, устанавливаются ограничения. Ограничения задаются с помощью контекстного ключевого слова `where`. В следующей таблице описываются шесть типов ограничений:  
  
|Ограничение|Описание|  
|----------------|-----------------|  
|where T: struct|Аргумент типа должен быть типом значения. Допускается задание любого типа значения, кроме <xref:System.Nullable>. Дополнительные сведения см. в разделе [Использование допускающих значение NULL типов](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).|  
|where T : class|Аргумент типа должен быть ссылочным типом; это также касается любого типа массива, класса, интерфейса или делегата.|  
|where T : new()|Аргумент типа должен иметь общий конструктор без параметров. При одновременном использовании нескольких ограничений последним должно указываться ограничение `new()`.|  
|where T : \<имя базового класса>|Аргумент типа должен иметь базовый класс или производный от него класс.|  
|where T : \<имя интерфейса>|Аргумент типа должен являться заданным интерфейсом или реализовывать его. Можно указать несколько ограничений интерфейса. Заданный в ограничении интерфейс также может быть универсальным.|  
|where T : U|Аргумент типа, указанный для T, должен быть аргументом, указанным для U, или производным от него.|  
  
## <a name="why-use-constraints"></a>Зачем использовать ограничения  
 Чтобы проверить допустимость элемента универсального списка или сравнить его с каким-либо другим элементом, компилятору нужны гарантии того, что вызываемый для этого оператор или метод будет поддерживаться любым аргументом типа, который может быть указан в клиентском коде. Это достигается путем применения одного или нескольких ограничений к определению универсального класса. Например, на основе ограничения базового класса компилятор определяет, что в качестве аргументов типа будут использоваться только объекты указанного типа или производных от него. Имея такую гарантию, компилятор может вызывать методы указанного типа в универсальном классе. Ограничения задаются с помощью контекстного ключевого слова `where`. В следующем примере кода показаны функциональные возможности, которые можно добавить в класс `GenericList<T>` (см. раздел [Введение в универсальные шаблоны](../../../csharp/programming-guide/generics/introduction-to-generics.md)), применив ограничения базового класса.  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 Это ограничение позволяет универсальному классу использовать свойство `Employee.Name`, поскольку все элементы типа T гарантированно будут являться объектами `Employee` или объектами, унаследованными от `Employee`.  
  
 К одному параметру типа можно применять несколько ограничений, которые сами по себе могут быть универсальными типами, как показано ниже:  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 Ограничивая параметр типа, вы расширяете выбор разрешенных операций и вызовов метода до поддерживаемых ограничивающим типом и всеми типами в его иерархии наследования. Таким образом, если при разработке универсальных классов или методов планируется выполнение любых других операций с универсальными элементами, помимо простого присвоения или вызова методов, не поддерживаемых `System.Object`, вам необходимо применить ограничения к параметру типа.  
  
 При применении ограничения `where T : class` не рекомендуется использовать операторы `==` и `!=` для параметра типа, поскольку в этом случае будет проверяться только удостоверение ссылки, а не равенство значений. Такое поведение будет наблюдаться даже в том случае, если эти операторы будут перегружены в типе, используемом в качестве аргумента. Эта особенность показана в следующем коде, который будет возвращать значение false даже в том случае, если класс <xref:System.String> перегружает оператор `==`.  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 Такое поведение обусловлено тем, что во время компиляции компилятору известно только то, что тип T является ссылочным, и он вынужден использовать операторы по умолчанию, которые действительны для всех ссылочных типов. Чтобы проверить равенство значений, рекомендуется применить ограничение `where T : IComparable<T>` и реализовать соответствующий интерфейс в любом классе, который будет использоваться для создания универсального класса.  
  
## <a name="constraining-multiple-parameters"></a>Ограничение нескольких параметров  
 Ограничения можно применить к нескольким параметрам. Кроме того, к одному параметру можно применять несколько ограничений, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a>Несвязанные параметры типа  
 Не имеющие ограничений параметры типа (например, T в общем классе `SampleClass<T>{}`) называются несвязанными. В отношении несвязанных параметров типа применяются следующие правила:  
  
-   Не допускается использование операторов `!=` и `==`, поскольку нет гарантии, что они будут поддерживаться конкретным типом аргумента.  
  
-   Их можно преобразовать в `System.Object` или явно преобразовать в любой тип интерфейса.  
  
-   Можно выполнять сравнение с [null](../../../csharp/language-reference/keywords/null.md). При сравнении несвязанного параметра с `null` для аргументов типа, являющихся типами значений, всегда возвращается значение false.  
  
## <a name="type-parameters-as-constraints"></a>Параметры типа в качестве ограничений  
 Использование параметров универсального типа в качестве ограничений применимо, когда функция-член со своим параметром типа должна ограничивать этот параметр параметром содержащего типа, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 В предыдущем примере `T` является ограничением типа в контексте метода `Add` и несвязанным параметром типа в контексте класса `List`.  
  
 Параметры типа также можно использовать в определениях универсальных классов. Обратите внимание, что параметр типа необходимо объявлять в угловых скобках вместе с любыми другими параметрами типа:  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 Применение параметров типа в качестве ограничений для универсальных классов ограничено, поскольку в отношении таких параметров типа компилятор может предполагать только то, что они являются производными от `System.Object`. Параметры типа в качестве ограничений следует использовать в универсальных классах в тех случаях, когда необходимо обеспечить отношение наследования между двумя параметрами типа.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Collections.Generic>  
 [Руководство по программированию на C#](../../../csharp/programming-guide/index.md)  
 [Введение в универсальные шаблоны](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [Универсальные классы](../../../csharp/programming-guide/generics/generic-classes.md)  
 [Ограничение new](../../../csharp/language-reference/keywords/new-constraint.md)
