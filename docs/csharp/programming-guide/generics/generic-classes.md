---
title: "Универсальные классы (Руководство по программированию на C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "C# - язык, универсальные классы"
  - "универсальные шаблоны [C#], классы"
ms.assetid: 27d6f256-cd61-41e3-bc6e-b990a53b0224
caps.latest.revision: 30
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 30
---
# Универсальные классы (Руководство по программированию на C#)
Универсальные классы инкапсулируют операции, не относящиеся к какому\-либо определенному типу данных.  Чаще всего универсальные классы используются с коллекциями, такими как связанные списки, хэш\-таблицы, очереди, стеки, деревья и т.п.  Такие операции как добавление элементов в коллекцию или их удаление осуществляются одинаково вне зависимости от типа хранящихся данных.  
  
 Для большей части сценариев, в которых требуются классы коллекций, рекомендуется использовать классы, входящие в библиотеку классов платформы .NET Framework.  Дополнительные сведения об использовании этих классов см. в разделе [Универсальные шаблоны в библиотеке классов платформы .NET Framework](../../../csharp/programming-guide/generics/generics-in-the-net-framework-class-library.md).  
  
 Как правило, создания универсальных классов начинается с запуска существующего класса и изменения типов на параметры типов по одному до тех пор, пока не будет достигнуто оптимальное соотношение между универсальностью и удобством.  При создании собственных универсальных классов следует учитывать следующее:  
  
-   Какие типы преобразовывать в параметры.  
  
     Как правило, чем больше типов преобразовано в параметры, тем более гибким становится программный код.  Однако излишняя универсальность использование ключевого слова может сделать код более трудным для понимания другими разработчиками.  
  
-   Какие ограничения применяются к параметрам типов \(см. [Ограничения параметров типа](../../../csharp/programming-guide/generics/constraints-on-type-parameters.md)\).  
  
     Рекомендуется применять наибольшее возможное число ограничений, при котором обеспечивается обработка нужных типов.  Например, если известно, что универсальных класс нужен только для ссылочных типов, можно применить ограничение класса.  Это предотвратит использования класса с типами значений и позволит использовать оператор `as` для `T` и проверять нулевые значения.  
  
-   Следует ли разделять поведение универсального класса на базовые классы и подклассы.  
  
     Универсальные классы могут служить базовыми классами, поэтому при их создании следует учитывать такие же обстоятельства, как при создании классов, не являющихся универсальными.  См. правила наследования от универсальных базовых классов далее в этом разделе.  
  
-   Следует ли реализовывать один или несколько универсальных интерфейсов.  
  
     Например, при создании класса, который будет использован для создания элементов в универсальной коллекции, может понадобиться реализовать интерфейс, подобный <xref:System.IComparable%601>, где `T` — тип вашего класса.  
  
 Пример простого универсального класса см. в разделе [Введение в универсальные шаблоны](../../../csharp/programming-guide/generics/introduction-to-generics.md).  
  
 В правилах, действующих для параметров типов и ограничений, действует несколько неявных принципов поведения универсальных классов, особенно в отношении наследования и доступа к членам.  Перед тем, как продолжить, следует уяснить некоторые моменты.  Для универсального класса `Node<T>,` клиентский код может ссылаться на класс путем указания аргумента типа, чтобы создать закрытый тип \(`Node<int>`\).  Также можно не указывать параметр типа, чтобы создать открытый тип \(`Node<T>`\).  Универсальные классы могут быть унаследованы от конкретных закрытых или открытых базовых классов.  
  
 [!code-cs[csProgGuideGenerics#16](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_1.cs)]  
  
 Классы, не являющиеся универсальными, то есть конкретные классы, могут быть унаследованы от закрытых базовых классов, но не от открытых базовых классов и от параметров типов, поскольку во время выполнения клиентский код не может предоставить аргумент типа, необходимый для создания экземпляра базового класса.  
  
 [!code-cs[csProgGuideGenerics#17](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_2.cs)]  
  
 Универсальные классы, унаследованные от открытых базовых классов, должны предоставлять аргументы типа для всех параметров типа базового класса, к которым нет доступа у наследующего класса, как показано в следующем примере кода.  
  
 [!code-cs[csProgGuideGenerics#18](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_3.cs)]  
  
 Универсальные классы, унаследованные от открытых базовых классов, должны указывать ограничения, которые соответствуют ограничениям базового типа или являются более строгими.  
  
 [!code-cs[csProgGuideGenerics#19](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_4.cs)]  
  
 Универсальные типы могут использовать несколько параметров типа и ограничений.  
  
 [!code-cs[csProgGuideGenerics#20](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_5.cs)]  
  
 Открытые и закрытые типы можно использовать в качестве параметров методов.  
  
 [!code-cs[csProgGuideGenerics#21](../../../csharp/programming-guide/generics/codesnippet/CSharp/generic-classes_6.cs)]  
  
 Если универсальных класс реализует интерфейс, все экземпляры этого класса могут быть приведены к этому интерфейсу.  
  
 Универсальные классы инвариантны.  Другими словами, если входной параметр указывает `List<BaseClass>`, при попытке предоставить `List<DerivedClass>` возникнет ошибка компиляции.  
  
## См. также  
 <xref:System.Collections.Generic>   
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Универсальные шаблоны](../../../csharp/programming-guide/generics/index.md)   
 [Saving the State of Enumerators](http://go.microsoft.com/fwlink/?LinkId=112390)   
 [An Inheritance Puzzle, Part One](http://go.microsoft.com/fwlink/?LinkId=112380)