---
title: "Практическое руководство. Перебор дерева папок (Руководство по программированию на C#)"
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
caps.latest.revision: 10
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 562431f525cc58b5d630671c9015e30a14ea06ee
ms.contentlocale: ru-ru
ms.lasthandoff: 07/28/2017

---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="6e0e0-102">Практическое руководство. Перебор дерева папок (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="6e0e0-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="6e0e0-103">Под фразой "итерация дерева каталога" подразумевается доступ к каждому файлу в каждом вложенном подкаталоге в заданной корневой папке на любую глубину.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="6e0e0-104">Необязательно открывать каждый файл.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="6e0e0-105">Можно просто извлечь имя файла или подкаталога в виде значения `string` или получить дополнительную информацию в форме объекта <xref:System.IO.FileInfo?displayProperty=fullName> или <xref:System.IO.DirectoryInfo?displayProperty=fullName>.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=fullName> or <xref:System.IO.DirectoryInfo?displayProperty=fullName> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e0e0-106">В Windows термины "каталог" и "папка" являются взаимозаменяемыми.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="6e0e0-107">В большинстве документации и в текстах пользовательского интерфейса используется термин "папка", но в библиотеке классов [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] используется термин "каталог".</span><span class="sxs-lookup"><span data-stu-id="6e0e0-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="6e0e0-108">В простейшем случае, когда точно известно, что имеются права доступа ко всем каталогам в указанном корне, можно использовать флаг `System.IO.SearchOption.AllDirectories`.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="6e0e0-109">Этот флаг возвращает все вложенные подкаталоги, соответствующие заданному шаблону.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="6e0e0-110">В приведенном ниже примере показано, как использовать этот флаг.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="6e0e0-111">Слабая сторона такого подхода заключается в том, что если какой-либо из подкаталогов в указанном корне вызовет <xref:System.IO.DirectoryNotFoundException> или <xref:System.UnauthorizedAccessException>, то весь метод не будет выполнен и каталоги не будут возвращены.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="6e0e0-112">Это же относится и к использованию метода <xref:System.IO.DirectoryInfo.GetFiles%2A>.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="6e0e0-113">Если необходимо обработать эти исключения в определенных вложенных папках, необходимо вручную пройти по дереву каталога, как показано в приведенных ниже примерах.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="6e0e0-114">При проходе вручную по дереву каталога можно обработать сначала подкаталоги (*обход в прямом порядке*) или файлы (*обход в обратном порядке*).</span><span class="sxs-lookup"><span data-stu-id="6e0e0-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="6e0e0-115">При выполнении обхода в прямом порядке проходится все дерево в текущей папке перед итерацией файлов, которые находятся в самой папке.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="6e0e0-116">В приведенных ниже примерах выполняется обход в обратном порядке, но его можно легко изменить на обход в прямом порядке.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="6e0e0-117">Еще одним параметром является использование рекурсии или обхода на основе стека.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="6e0e0-118">В приведенных ниже примерах показаны оба подхода.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="6e0e0-119">Если необходимо выполнить различные операции с файлами и папками, то можно смоделировать эти примеры путем рефакторинга операции на отдельные функции, которые можно вызвать с помощью одного делегата.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6e0e0-120">Файловые системы NTFS могут содержать *точки повторного анализа* в форме *точек соединения*, *символических ссылок* и *жестких связей*.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="6e0e0-121">Методы платформы .NET Framework, такие как <xref:System.IO.DirectoryInfo.GetFiles%2A> и <xref:System.IO.DirectoryInfo.GetDirectories%2A>, не возвращают подкаталоги ниже точки повторного анализа.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="6e0e0-122">Такое поведение предотвращает риск входа в бесконечный цикл, когда две точки повторного анализа ссылаются друг на друга.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="6e0e0-123">Как правило, следует быть предельно осторожными при работе с точками повторного анализа, чтобы избежать случайного изменения или удаления файлов.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="6e0e0-124">Если требуется строгий контроль над точками повторного анализа, используйте вызов неуправляемого кода или машинный код для прямого вызова подходящих методов файловой системы Win32.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="6e0e0-125">Пример</span><span class="sxs-lookup"><span data-stu-id="6e0e0-125">Example</span></span>  
 <span data-ttu-id="6e0e0-126">В приведенном ниже примере показан проход по дереву каталога с помощью рекурсии.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="6e0e0-127">Рекурсивный подход является элегантным, но он потенциально может вызвать исключение переполнения стека, если дерево каталога большое и имеет большой уровень вложения.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="6e0e0-128">Обрабатываемые исключения и действия, выполняемые с каждым файлом или папкой, предоставляются только в качестве примеров.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="6e0e0-129">Этот код следует изменить в соответствии с конкретными требованиями.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="6e0e0-130">Дополнительные сведения см. в комментариях в коде.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-130">See the comments in the code for more information.</span></span>  
  
 <span data-ttu-id="6e0e0-131">[!code-cs[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="6e0e0-131">[!code-cs[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]</span></span>  
  
## <a name="example"></a><span data-ttu-id="6e0e0-132">Пример</span><span class="sxs-lookup"><span data-stu-id="6e0e0-132">Example</span></span>  
 <span data-ttu-id="6e0e0-133">В приведенном ниже примере показана итерация файлов и папок в дереве каталога без использования рекурсии.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-133">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="6e0e0-134">Этот метод использует универсальный тип коллекции <xref:System.Collections.Generic.Stack%601>, который представляет стек типа "последним пришел — первым вышел" (LIFO).</span><span class="sxs-lookup"><span data-stu-id="6e0e0-134">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="6e0e0-135">Обрабатываемые исключения и действия, выполняемые с каждым файлом или папкой, предоставляются только в качестве примеров.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-135">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="6e0e0-136">Этот код следует изменить в соответствии с конкретными требованиями.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-136">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="6e0e0-137">Дополнительные сведения см. в комментариях в коде.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-137">See the comments in the code for more information.</span></span>  
  
 <span data-ttu-id="6e0e0-138">[!code-cs[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="6e0e0-138">[!code-cs[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]</span></span>  
  
 <span data-ttu-id="6e0e0-139">Обычно проверка каждой папки на наличие у приложения разрешений на ее открытие занимает слишком много времени.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-139">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="6e0e0-140">Поэтому в примере кода эта часть операции просто включена в блок `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-140">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="6e0e0-141">Блок `catch` можно изменить так, чтобы при отказе в доступе к папке предпринималась попытка повысить права, а затем повторная попытка получить доступ.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-141">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="6e0e0-142">Как правило, следует перехватывать только те исключения, которые можно обработать, не оставляя приложение в неопределенном состоянии.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-142">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="6e0e0-143">Если необходимо сохранить содержимое дерева каталога либо в памяти, либо на диске, наилучшим вариантом будет сохранение только свойства <xref:System.IO.FileSystemInfo.FullName%2A> (типа `string`) для каждого файла.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-143">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="6e0e0-144">Затем можно использовать эту строку для создания объекта <xref:System.IO.FileInfo> или <xref:System.IO.DirectoryInfo> по мере необходимости или открыть любой файл, для которого требуется дополнительная обработка.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-144">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="6e0e0-145">Отказоустойчивость</span><span class="sxs-lookup"><span data-stu-id="6e0e0-145">Robust Programming</span></span>  
 <span data-ttu-id="6e0e0-146">Надежный код итерации файлов должен учитывать сложности файловой системы.</span><span class="sxs-lookup"><span data-stu-id="6e0e0-146">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="6e0e0-147">Дополнительные сведения см. в разделе [техническом справочнике по NTFS](http://go.microsoft.com/fwlink/?LinkId=79488).</span><span class="sxs-lookup"><span data-stu-id="6e0e0-147">For more information, see [NTFS Technical Reference](http://go.microsoft.com/fwlink/?LinkId=79488).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6e0e0-148">См. также</span><span class="sxs-lookup"><span data-stu-id="6e0e0-148">See Also</span></span>  
 <span data-ttu-id="6e0e0-149"><xref:System.IO></span><span class="sxs-lookup"><span data-stu-id="6e0e0-149"><xref:System.IO></span></span>   
 <span data-ttu-id="6e0e0-150">[LINQ и каталоги файлов](http://msdn.microsoft.com/library/5a5d516c-0279-4a84-ac84-b87f54caa808) </span><span class="sxs-lookup"><span data-stu-id="6e0e0-150">[LINQ and File Directories](http://msdn.microsoft.com/library/5a5d516c-0279-4a84-ac84-b87f54caa808) </span></span>  
 [<span data-ttu-id="6e0e0-151">Файловая система и реестр (руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="6e0e0-151">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)

