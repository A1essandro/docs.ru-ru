---
title: "Перенос устаревших монолитных приложений .NET Framework в контейнеры Windows"
description: "Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Перенос устаревших монолитных приложений .NET Framework в контейнеры Windows"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 3bce714d517615bdd56473a8c74acde424d2d5a7
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="migrating-legacy-monolithic-net-framework-applications-to-windows-containers"></a>Перенос устаревших монолитных приложений .NET Framework в контейнеры Windows

*С помощью контейнеров Windows можно улучшить возможности сред разработки и тестовых сред, а также развертывать приложения на основе устаревших технологий .NET Framework, таких как веб*-*формы. Такое использование контейнеров для устаревших приложений называется сценарием переноса без изменения.*

В предыдущих разделах рассматривались преимущества архитектуры микрослужб, которая предусматривает распределение бизнес-приложений между разными контейнерами, в каждом из которых выполняется небольшая узконаправленная служба. Такой подход настоятельно рекомендуется при разработке новых приложений. Преимущества для критически важных корпоративных приложений также достаточно велики, чтобы оправдать затраты на переработку архитектуры и повторное внедрение.

Но эти затраты оправданны не для каждого приложения. Это не означает, что для таких приложений использовать контейнеры невозможно.

В этом разделе мы рассмотрим приложение для компании eShopOnContainers, показанное на рис. 7-1. Оно будет использовать сотрудниками eShopOnContainers enterprise для просмотра и изменения каталога товаров.

![](./media/image1.png)

**Рис. 7-1**. Приложение веб-форм ASP.NET (устаревшая технология) в контейнере Windows

Это приложение веб-форм, которое служит для просмотра и изменения записей каталога. Из-за зависимости от веб-форм приложение не будет выполняться в .NET Core, если его не переделать так, чтобы вместо веб-форм использовался шаблон MVC ASP.NET Core. Вы узнаете, как можно запускать подобные приложения в контейнерах без изменения. Вы также узнаете, как с минимальными изменениями обеспечить работу в гибридном режиме, в котором некоторые функциональные возможности перенесены в отдельную микрослужбу, но большинство оставлены в монолитном приложении.

## <a name="benefits-of-containerizing-a-monolithic-application"></a>Преимущества помещения монолитного приложения в контейнер

Приложение Catalog.WebForms доступно в репозитории GitHub eShopOnContainers (<https://github.com/dotnet/eShopOnContainers>). Оно представляет собой автономное веб-приложение, обращающееся к хранилищу данных высокой доступности. Даже с учетом этого выполнение приложения в контейнере имеет свои преимущества. Вы создаете образ для приложения. В дальнейшем каждое развертывание будет производиться в одной и той же среде. Каждый контейнер использует одну и ту же версию ОС, в нем установлены одни и те же версии зависимостей, используется одна и та же платформа, и для сборки применяется один и тот же процесс. Приложение, загруженное в Visual Studio 2017, показано на рис. 7-2.

![](./media/image2.png)

**Рис. 7-2**. Приложение веб-формы для управления каталогом в Visual Studio 2017

Кроме того, все разработчики могут запускать приложение в единообразной среде. Проблемы, возникающие в определенных версиях, выявляются на этапе разработки, а не в промежуточной или рабочей среде. Когда приложения выполняются в контейнерах, различия между средами разработки, используемыми разными группами разработчиков, не так важны.

Наконец, упакованные в контейнеры приложения имеют более плоскую кривую горизонтального масштабирования. Вы уже знаете, как можно создавать дополнительные контейнеры с приложениями в виртуальной машине или на физическом компьютере. Таким образом достигается более высокая плотность размещения и требуется меньше ресурсов.

По этим причинам рекомендуется запускать уже имеющиеся монолитные приложения в контейнерах Docker с применением переноса без изменения. Процедура переноса без изменения заключается в следующем: вы *берете* приложение с физического компьютера или из виртуальной машины и *перемещаете* его в контейнер. В идеальной ситуации, чтобы приложение работало в контейнере, в его код не нужно вносить никаких изменений.

## <a name="possible-migration-paths"></a>Возможные способы переноса

Так как веб-приложение Catalog.Webforms является монолитным, оно содержит весь код, включая библиотеки доступа к данным. База данных размещается на отдельном компьютере с высоким уровнем доступности. Эта конфигурация моделируется в образце кода с помощью макета службы каталога: для имитации переноса без изменения приложение Catalog.WebForms можно использовать с фиктивными данными. Этот пример демонстрирует простейший способ переноса, при котором существующие ресурсы переносятся в контейнер без внесения каких-либо изменений в код. Такой способ подходит для полнофункциональных приложений, которые отличаются минимальным взаимодействием с функциональными возможностями, переносимыми в микрослужбы.

Но веб-сайт eShopOnContainers уже обращается к хранилищу данных с помощью микрослужб в различных целях. Чтобы использовать микрослужбу каталога вместо прямого доступа к хранилищу данных, можно внести небольшие изменения в редактор каталога.

Эти изменения демонстрируют пространство возможностей для ваших собственных приложений. Вы можете сделать что угодно: перенести приложение в контейнеры без изменений, внести небольшие изменения, позволяющие существующему приложению обращаться к некоторым новым микрослужбам, или полностью переписать приложение, чтобы интегрировать его в новую архитектуру на основе микрослужб. Правильный подход зависит от стоимости миграции и предоставляемых ею преимуществ.

## <a name="application-tour"></a>Обзор приложения

Вы можете загрузить решение Catalog.WebForms и запустить его как автономное приложение. В этой конфигурации приложение возвращает данные не из постоянного хранилища в виде базы данных, а из фиктивной службы. Приложение использует Autofac (<https://autofac.org/>) в качестве контейнера с инверсией управления (IOC). С помощью внедрения зависимостей (DI) можно настроить приложение так, чтобы оно использовало фиктивные данные или активную службу данных каталога. (Подробнее о внедрении зависимостей мы поговорим позднее.) Код запуска считывает параметр useFake из файлов web.config и настраивает контейнер Autofac для внедрения фиктивной службы данных или активной службы каталога. Если при запуске приложения параметр useFake в файле web.config имеет значение false, в приложении Web Forms отображаются данные каталога.

Большинство методов, используемых в этом приложении, должно быть хорошо знакомо тем, кто имеет опыт работы с Web Forms. Но в микрослужбе каталога представлены два механизма, которые могут оказаться новыми: внедрение зависимостей, которое упоминалось ранее, и работа с асинхронными хранилищами данных в Web Forms.

Внедрение зависимостей преобразует стандартный объектно-ориентированный подход к написанию классов, при котором для классов выделяются все необходимые ресурсы. Вместо этого классы запрашивают зависимости из контейнера службы. Преимущество внедрения зависимостей заключается в том, что вы можете заменять внешние службы на заглушки (макеты) для тестирования или в иных целях.

Контейнер с внедрением зависимостей использует конфигурацию appSettings в файле web.config для определения того, следует ли использовать фиктивные данные каталога или реальные данные из работающей службы. Приложение регистрирует объект HttpModule, который создает контейнер и регистрирует предварительный обработчик для внедрения зависимостей. Код можно просмотреть в файле Modules/AutoFacHttpModule.cs. Выглядит он так.

```cs
private static IContainer CreateContainer()
{
  // Configure AutoFac:
  // Register Containers:

  var settings = WebConfigurationManager.AppSettings;
  var useFake = settings["usefake"];
  bool fake = useFake == "true";
  var builder = new ContainerBuilder();

  if (fake)
  {
    builder.RegisterType<CatalogMockService>()
    .As<ICatalogService>();
  }
  else
  {
    builder.RegisterType<CatalogService>()
    .As<ICatalogService>();
    builder.RegisterType<RequestProvider>()
    .As<IRequestProvider>();
  }

  var container = builder.Build();
  return container;
}

private void InjectDependencies()
{
  if (HttpContext.Current.CurrentHandler is Page page)
  {
    // Get the code-behind class that we may have written
    var pageType = page.GetType().BaseType;

    // Determine if there is a constructor to inject, and grab it
    var ctor = (from c in pageType.GetConstructors()
                where c.GetParameters().Length > 0
                select c).FirstOrDefault();

    if (ctor != null)
    {
      // Resolve the parameters for the constructor
      var args = (from parm in ctor.GetParameters()
                  select Container.Resolve(parm.ParameterType))
                  .ToArray();

      // Execute the constructor method with the arguments resolved
      ctor.Invoke(page, args);
    }

    // Use the Autofac method to inject any
    // properties that can be filled by Autofac
    Container.InjectProperties(page);
  }
}
```

Страницы приложения (Default.aspx.cs и EditPage.aspx.cs) определяют конструкторы, принимающие эти зависимости. Обратите внимание на то, что конструктор по умолчанию по-прежнему доступен. Инфраструктуре требуется приведенный ниже код.

```cs
protected _Default() { }

public _Default(ICatalogService catalog) => this.catalog = catalog;
```

Все интерфейсы API представляют собой асинхронные методы. Web Forms теперь поддерживают их для всех элементов управления данными. Приложение Catalog.WebForms использует привязку модели для страниц списка и редактирования. В элементах управления на этих страницах определены свойства SelectMethod, UpdateMethod, InsertMethod и DeleteMethod, с помощью которых создается задача, возвращающая асинхронные операции. Элементы управления Web Forms могут определять, когда привязанные к ним методы являются асинхронными. Единственным ограничением при работе с асинхронными методами выбора является отсутствие поддержки разбивки на страницы. Сигнатура разбивки на страницы требует выходного параметра, но асинхронные методы не могут иметь таких параметров. Аналогичный подход применяется и на других страницах, которым требуются данные из службы каталога.

В конфигурации по умолчанию для приложения каталога на основе Web Forms используется макет службы catalog.api. В этом макете используется жестко заданный набор данных, что упрощает ряд задач благодаря устранению зависимости от службы catalog.api в средах разработки.

## <a name="lifting-and-shifting"></a>Перенос без изменения

Visual Studio обеспечивает эффективную поддержку упаковки приложений в контейнеры. Щелкните узел проекта правой кнопкой мыши и выберите пункт **Добавить**, а затем пункт **Поддержка Docker**. Шаблон проекта Docker добавляет в решение новый проект **docker-compose**. Этот проект содержит ресурсы Docker, которые компонуют (или создают) необходимые образы и запускают необходимые контейнеры, как показано на рис. 7-3.

В простейшем сценарии переноса без изменения приложение представляет собой одиночную службу для приложения Web Forms. Шаблон также меняет запускаемый проект на **docker-compose**. Если нажать клавиши CTRL+F5 или F5, теперь создается образ Docker и запускается контейнер Docker.

![](./media/image3.png)

**Рис. 7-3**. Проект **docker-compose** в решении Web Forms

Перед запуском решения необходимо убедиться в том, что Docker настроен для использования контейнеров Windows. Для этого щелкните значок Docker на панели задач Windows правой кнопкой мыши и выберите пункт **Switch to Windows Containers** (Переключиться на контейнеры Windows), как показано на рис. 7-4.

![](./media/image4.png)

**Рис. 7-4**. Переключение на контейнеры Windows с помощью значка Docker на панели задач в Windows

Если вместо этого в меню имеется пункт **Switch to Linux containers** (Переключиться на контейнеры Linux), в Docker уже используются контейнеры Windows.

При запуске решения узел Docker перезапускается. При сборке решения выполняется сборка приложения и образа Docker для проекта Web Forms. В первый раз это занимает немало времени. Причина в том, что процесс сборки получает базовый образ Windows Server и дополнительный образ для ASP.NET. Последующие циклы сборки и запуска происходят гораздо быстрее.

Давайте подробнее рассмотрим файлы, добавляемые шаблоном проекта Docker. Он автоматически создал несколько файлов. Visual Studio использует их для создания образа Docker и запуска контейнера. Эти же файлы можно использовать в интерфейсе командной строки для выполнения команд Docker вручную.

В приведенном ниже примере файла Dockerfile показаны основные параметры для сборки образа Docker на основе образа Windows ASP.NET, в котором выполняется сайт ASP.NET.

```
FROM microsoft/aspnet

ARG source

WORKDIR /inetpub/wwwroot

COPY ${source:-obj/Docker/publish} .
```

Этот файл Dockerfile очень похож на те, которые создаются для выполнения приложений ASP.NET Core в контейнерах Linux. Но есть некоторые существенные отличия. Самое важное из них заключается в том, что базовым образом является microsoft/aspnet. Это текущий образ Windows Server, включающий в себя платформу .NET Framework. Кроме того, из исходного каталога копируются другие каталоги.

Остальные файлы в проекте **docker-compose** представляют собой ресурсы Docker, необходимые для сборки и настройки контейнеров. Visual Studio помещает различные файлы docker-compose.yml в один узел, чтобы показать, как они используются. Основной файл docker-compose содержит директивы, общие для всех конфигураций. Файл docker-compose.override.yml содержит переменные среды и связанные с ними переопределения для конфигурации разработки. Варианты с расширениями .vs.debug и .vs.release предоставляют параметры среды, которые позволяют Visual Studio подключаться к работающему контейнеру и управлять им.

Хотя при добавлении поддержки Docker в решение осуществляется интеграция с Visual Studio, вы также можете выполнять сборку и запуск из командной строки с помощью команды docker-compose up, как было показано в предыдущих разделах.

## <a name="getting-data-from-the-existing-catalog-net-core-microservice"></a>Получение данных из существующей микрослужбы каталога .NET Core

Приложение Web Forms можно настроить так, чтобы оно получало не фиктивные данные, а данные из микрослужбы каталога eShopOnContainers. Для этого нужно изменить файл web.config и присвоить параметру useFake значение false. Контейнер с внедрением зависимостей будет использовать класс, обращающийся к активной микрослужбе каталога, а не класс, возвращающий жестко заданные данные. Вносить другие изменения в код не требуется.

Для обращения к активной службе каталога требуется изменить проект **docker-compose** так, чтобы он выполнял сборку образа службы каталога и запускал контейнер службы каталога. Docker CE для Windows поддерживает как контейнеры Linux, так и контейнеры Windows, но не одновременно. Чтобы запустить микрослужбу каталога, нужно выполнить сборку образа для запуска микрослужбы каталога на основе контейнера Windows. При таком подходе для проекта микрослужб требуется файл Dockerfile, отличный от того, который был представлен в предыдущих разделах. Файл Dockerfile.windows содержит параметры конфигурации для сборки образа контейнера API каталога, выполняющегося в контейнере Windows, например образа Docker Windows Nano.

Микрослужба каталога использует базу данных SQL Server. Поэтому также требуется использовать образ Docker SQL Server на основе Windows.

После внесения этих изменений проект docker-compose выполняет дополнительные действия при запуске приложения. Теперь он запускает SQL Server с помощью образа SQL Server на основе Windows. Он запускает микрослужбу каталога в контейнере Windows. Кроме того, он запускает контейнер редактора каталога Web Forms также в контейнере Windows. Если какие-либо из этих образов требуют сборки, они сначала создаются.

## <a name="development-and-production-environments"></a>Среда разработки и рабочая среда

Между конфигурацией для развертывания и рабочей конфигурацией есть ряд отличий. В среде разработки приложение Web Forms, микрослужба каталога и SQL Server запускаются в контейнерах Windows в одном узле Docker. В предыдущих разделах упоминались образы SQL Server, развертываемые в том же узле Docker на основе Linux, что и другие службы .NET Core. Преимущество выполнения нескольких микрослужб в одном узле Docker (или кластере) заключается в том, что уменьшается объем сетевого трафика и взаимодействие между контейнерами происходит с меньшими задержками.

В среде разработки все контейнеры должны выполняться в одной операционной системе. Docker CE для Windows не поддерживает одновременное выполнение контейнеров на основе Windows и Linux. В рабочей среде можно решить, должна ли микрослужба каталога выполняться в контейнере Windows в одном узле (или кластере) Docker вместе с приложением либо приложение Web Forms должно взаимодействовать с экземпляром микрослужбы каталога, выполняющимся в контейнере Linux в другом узле Docker. Зависит это от требований к сетевой задержке. В большинстве случаев микрослужбы, от которых зависит приложение, желательно размещать в том же узле (или кластере) Docker, что позволяет упростить развертывание и сократить задержки при обмене данными. В такой конфигурации значительные ресурсы сети расходуются только на взаимодействие между экземплярами микрослужб и серверами высокой доступности, на которых размещается постоянное хранилище данных.

>[!div class="step-by-step"]
[Назад] (../net-core-single-containers-linux-windows-server-hosts/index.md) [Далее] (../multi-container-microservice-net-applications/index.md)
