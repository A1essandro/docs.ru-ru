---
title: "Проектирование микрослужбу, ориентированных на DDD"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Проектирование микрослужбу, ориентированных на DDD"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a>Проектирование микрослужбу, ориентированных на DDD

Проектирование на основе домена (DDD) представляет моделирования, в зависимости от реальности бизнес-как относящиеся к сценариям использования. В контексте создания приложений DDD рассказывает о проблемах как домены. Описывает независимых проблемных областей, как ограниченных контекстах (каждый контекст ограниченных соответствующее микрослужбу), подчеркиваются общий язык говорить о таких проблем. В нем также рассматриваются многие технические концепции и шаблоны, подобно сущностям домена с форматированным моделями (не [anemic доменной модели](https://martinfowler.com/bliki/AnemicDomainModel.html)), значение объектов, агрегаты и статистические корень (или корневой объект) правил для поддержки внутренней реализации. В этом разделе представлены на проектирование и реализацию этих внутренних шаблонов.

Иногда эти DDD технические правила и закономерности считается препятствия, имеющих некоторого обучения для реализации подхода ддд. Однако важно не шаблоны сами себя, но организации кода, поэтому она выравнивается по бизнес-проблемы и с помощью одной бизнес-термины (единый язык). Кроме того подходов DDD должны применяться только в том случае, если вы реализуете сложных микрослужбами с значительные бизнес-правила. Проще обязанности, таких как службы CRUD, можно управлять с простым подходов.

Где рисовать границы является основной задачей при разработке и определении микрослужбы. DDD шаблоны помогают понять сложности в домене. Для модели домена для каждого контекста ограниченных идентификации и определения сущностей, значение объектов и статистические функции, которые моделируют вашего домена. Постройте и детализации модели домена, содержащийся в границу, которая определяет контекст. И это явным образом в виде микрослужбы. Компоненты в пределах этих границ помещаться выполняется вашей микрослужбами, несмотря на то что в некоторых случаях a BC или микрослужбами бизнеса могут состоять из нескольких физических служб. DDD посвящена границы, а следовательно, являются микрослужбами.

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a>Сохранить микрослужбу границ контекста относительно небольшой

Определение поместить границы между контекстами ограниченных сальдо два конкурирующих задач. Во-первых необходимо первоначально создать наименьшее возможных микрослужбами, несмотря на то, что не должно быть основной драйвера. следует создать границу вещей, которые требуется связности. Во-вторых вы хотите избежать «многословных» обмена данными между микрослужбами. Эти цели могут противоречить друг с другом. Вы должны сбалансировать по разбиение столько небольшой микрослужбами можно, пока не увидите быстро растет с каждой дополнительной попытки разделения новый контекст ограниченных границы связи в системе. Связности является ключом, в рамках одного контекста ограниченной.

Это похоже на [недопустимо тесные отношения кода Запах](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) при реализации классов. Если два микрослужбами нужно совместно работать намного друг с другом, они, скорее всего, должны быть же микрослужбы.

Другим способом, это является автономность. Если микрослужбу должно полагаться на другую службу для обслуживания запроса напрямую, не полностью автономной.

## <a name="layers-in-ddd-microservices"></a>Слои в DDD микрослужбами

Большинство приложений предприятия с значительные бизнеса и сложности: определяются несколько слоев. Слои являются артефакт логического и не относятся к развертыванию службы. Они существуют, чтобы помочь разработчикам управлять сложным процессом, в коде. Различные уровни (например, уровень модели домена и уровень представления данных, т. д.) может иметь разные типы, которого требует преобразования между этими типами.

Например сущность может быть загружен из базы данных. Затем эти сведения, и объединенные данные, включая дополнительные данные из других сущностей, могут отправляться клиенту пользовательский Интерфейс в веб-API REST. Суть в том что сущность домена содержится в слой модели домена и не должны распространяться на других областей, которые он не принадлежит, как уровень представления данных.

Кроме того, необходимо иметь всегда действует сущностей (см. [проектирование проверок в уровне модели домена](#designing-validations-in-the-domain-model-layer) раздел) контролируются статистические корни (корневой сущности). Таким образом сущностей не были привязаны к представлениям клиента, так как на уровне ИП некоторые данные могут по-прежнему не удается проверить. Это ViewModel возможности. ViewModel — это модель данных исключительно для потребности слой представления. Сущности домена не принадлежат непосредственно ViewModel. Вместо этого необходимо перевести между сущностями ViewModels и домена и наоборот.

При работе над сложности, очень важно модель домена управляется статистические корни (углубляться в это более подробно далее), убедитесь, что все инварианты и правила, связанные с этой группы сущностей (статистических) выполняются через одну запись точка или шлюзом, статистические корневой.

Рис. 9-5 показано реализации многоуровневая архитектура eShopOnContainers приложения.

![](./media/image6.png)

**Рис. 9-5**. Слои DDD упорядочивания микрослужбу в eShopOnContainers

Необходимо разработать систему, чтобы каждый уровень взаимодействует только с некоторых других слоев. Что может быть проще принудительно, если слои реализованы в виде библиотеки другого класса, так как вы четко определить, какие зависимости устанавливаются между библиотеками. Например, уровень модели домена не должен принимать зависимости на любом другом слое (классы модели домена должны быть обычные старые объекты CLR или [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), классы). Как показано на рисунке 9-6, **Ordering.Domain** библиотеки слоя имеет зависимости только в библиотеках .NET Core, но не на любой другой пользовательской библиотеки (библиотека данных, сохранения в библиотеке, и т. д.).

![](./media/image7.PNG)

**Рис. 9-6**. Слои, реализован в виде библиотеки позволяют лучше управлять зависимостей между слоями

### <a name="the-domain-model-layer"></a>Уровень модели домена

Отлично книги Eric Evans [Domain Driven Design](http://domainlanguage.com/ddd/) говорит следующие о уровень модели домена и на уровне приложения.

**Уровень модели домена**: ответственность для представления понятия бизнеса, сведения о ситуации и бизнес-правил. Состояние, которое отражает состояние дел контролироваться и использовать здесь, несмотря на то, что технические детали запоминался, делегируются в инфраструктуре. Этот уровень является сердцем платформы бизнес-программ.

Уровень модели домена — где выражены бизнеса. При реализации слой модели домена микрослужбу в .NET, что слой будет закодировано как библиотеки классов с сущности домена, которые моделируют данных, а также возможности (методы с логикой).

Следующая [сохраняемости](http://deviq.com/persistence-ignorance/) и [пропуск инфраструктуры](https://ayende.com/blog/3137/infrastructure-ignorance) принципы, этот уровень полностью должен игнорировать детали сохраняемости данных. Эти задачи сохранения следует выполнять на уровне инфраструктуры. Таким образом, этот уровень не должен принимать прямых зависимостей на инфраструктуру, это означает, что правило, ваши классы сущностей модели домена должно быть [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.

На любой платформе инфраструктуры данных access как Entity Framework и NHibernate для сущности домена не должен прямой зависимости (например, для создания класса, производного от базового класса). В идеальном случае сущностей домена не следует наследовать или реализации любого типа, определенного в любую платформу инфраструктуры.

Большинство современных ORM платформ, таких как Entity Framework Core разрешить этот подход, чтобы ваши классы модели домена не привязаны к инфраструктуре. Однако наличие сущности POCO не всегда возможно при использовании определенных базах данных NoSQL и платформы, например, субъектами и надежного коллекций в Azure Service Fabric.

Даже в том случае, когда важно следуйте принципу сохраняемости для модели домена, не следует пропускать проблемы сохраняемости. По-прежнему очень важно для понимания модели физических данных и как он сопоставляется объектной модели сущности. В противном случае можно создать макеты невозможно.

Кроме того это не означает, можно воспользоваться моделью, разработанной для реляционной базы данных и непосредственно переместить NoSQL или базы данных с учетом документа. В некоторых моделях сущности подойдут модели, но обычно нет. Все еще существуют ограничения, должен соответствовать модели сущности, основанная на технологии хранения и технологией ORM.

### <a name="the-application-layer"></a>Уровень приложения

Переход к уровень приложения мы снова можно упоминаются Eric Evans книги [Domain Driven Design](http://domainlanguage.com/ddd/):

**Уровень приложения:** определяет задания, предусмотренных для программного обеспечения с указанием объекты выразительный домена для работы проблем с. Задачи, за которые отвечает этим слоем, может применяться для бизнеса или необходимые для взаимодействия с уровней приложения из других систем. Этот уровень хранится тонкой. Он не содержит бизнес-правила или набора знаний, но только задачи координаты и делегаты работать на совместную работу объектов домена в следующий уровень вниз. Состояние, отражая состояние дел не существует, но он может иметь состояние, которое отражает ход выполнения задачи для пользователя или программы.

Часто микрослужбу уровня приложения .NET закодирован как проект веб-API ASP.NET Core. Проект реализует микрослужбу взаимодействия, удаленный доступ к сети и внешних веб-API, используемый из пользовательского интерфейса или клиентских приложений. Запросы включает в том случае, если с помощью CQRS подход команд, принимаемое микрослужбу и даже событиями связи между микрослужбами (события интеграции). Веб-API ASP.NET Core, представляющее уровень приложения не должны содержать бизнес-правила или набора знаний домена (особенно правила домена для обновления или транзакции); Эти должен принадлежать библиотеки классов модели домена. Только координату должен слой приложения задач и не должно хранения или определить состояние любого домена (модель домена). Он делегирует выполнение бизнес-правила для домена модели сами классы (статистические корни и сущностями домена), что в конечном итоге приведет к обновлению данных в этих сущностей домена.

По сути логика приложения — где реализовать все случаи использования, которые зависят от данного интерфейса. Например реализация, относящиеся к службе веб-API.

Целью является доменную логику в слой модели домена, его инварианты, модели данных и связанных бизнес-правил необходимо полностью независим от уровни представления и приложения. Чаще всего уровень модели домена не должен зависеть непосредственно любую платформу инфраструктуры.

### <a name="the-infrastructure-layer"></a>Уровень инфраструктуры

Уровень инфраструктуры — это способ сохранения в базах данных или другое постоянное хранилище данных, изначально содержатся в сущности домена (в памяти). Пример использует Entity Framework Core код для реализации классов шаблон репозитория, использование класса DBContext для сохранения данных в реляционной базе данных.

В соответствии с ранее упомянутых [сохраняемости](http://deviq.com/persistence-ignorance/) и [пропуск инфраструктуры](https://ayende.com/blog/3137/infrastructure-ignorance) принципы уровня инфраструктуры должен не «повлиять» уровень модели домена. Независимость от классов для модели сущности домена необходимо предотвратить инфраструктуру, которая используется для хранения данных (EF или любой другой структуре), не выполнив жестких зависимостей из платформ. Библиотека классов слой модели домена должен иметь только ваш код домена, просто [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) сущности классы, реализующие лежит в основе программного обеспечения и полностью отделен от технологий инфраструктуры.

Таким образом, слои или библиотек классов и проекты должны в конечном счете зависят от уровня модели домена (библиотека), наоборот, как показано на рисунке 9-7.

![](./media/image8.png)

**Рис. 9-7**. Зависимости между слоями DDD

Такая структура слой должен быть независимым для каждого микрослужбы. Как отмечалось ранее, вы можете реализовать самые сложные микрослужбами следующие шаблоны DDD при реализации более простой управляемой данными микрослужбами (простой CRUD в одном слое) проще.

#### <a name="additional-resources"></a>Дополнительные ресурсы

-   **DevIQ. Принцип пропуск сохраняемости**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)

-   **Oren Eini. Пропуск инфраструктуры**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)

-   **Angel Lopez. Многоуровневая архитектура в разработки на основе домена**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)


>[!div class="step-by-step"]
[Предыдущие] (cqrs микрослужбу reads.md) [Далее] (model.md микрослужбу домена)
