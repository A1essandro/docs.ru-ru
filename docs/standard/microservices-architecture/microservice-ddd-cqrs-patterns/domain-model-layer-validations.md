---
title: "Проектирование проверок в уровне модели домена"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Проектирование проверок в уровне модели домена"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f4870d0568c3539f296bcb3f577291cb0250cfca
ms.sourcegitcommit: 62d3e3e74c1b7ffa927590012c0b9f87de1b0848
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/27/2017
---
# <a name="designing-validations-in-the-domain-model-layer"></a>Проектирование проверок в уровне модели домена

В ддд правила проверки можно рассматривать как инварианты. Главной задачей статистической обработки является принудительное инварианты через изменения состояния для всех сущностей внутри сводные данные.

Сущности домена всегда должно быть допустимым сущностей. Существует несколько вариантов для объекта, который всегда должен иметь значение true. Например объект элемента заказа всегда должен иметь количество, которое должно быть положительным целым числом, а также имя статьи и price. Таким образом применение инварианты несет ответственность за сущностями домена (особенно для статистических root) и объект сущности не сможете использовать, не являются допустимыми. Инвариантные правила просто выражаются в виде контрактов и исключения или уведомления о возникающим, когда они нарушены.

Причины, обуславливающие это то, что множество ошибок выполнен, поскольку объекты находятся в состояние, в котором они никогда не должно было в. Ниже приведен подробно объясняется из Янг Грег в [дискуссионные](http://jeffreypalermo.com/blog/the-fallacy-of-the-always-valid-entity/):

Давайте предложить, теперь у нас есть SendUserCreationEmailService, принимающий UserProfile... как можно мы рационализации в этой службе, что имя не является null? Мы устанавливайте его еще раз? Или более вероятно... вы просто не использоваться для проверки и «надеемся, что для обеспечения оптимальной» — надеемся, что кто-то утруждать для его проверки перед отправкой его можно. Конечно с помощью управляемой тестами разработки один первый тестов, которые мы Пишите: Если отправить клиенту с нулевым значением, он должен вызывать ошибку. Но когда мы начинаем записи этих типов тестов снова и снова помните, мы... «ожидания, если мы никогда не может быть имя, чтобы стать null бы не было все эти тесты»

## <a name="implementing-validations-in-the-domain-model-layer"></a>Реализация проверок в уровне модели домена

Проверки обычно реализуются в конструкторах сущности домена или в методах, которые можно обновлять сущность. Существует несколько способов реализации проверки, такие как проверка данных и создание исключений, если проверка завершается с ошибкой. Существуют более сложные шаблоны, например с помощью шаблона спецификации для проверки, а также шаблон уведомления для возврата коллекции ошибок вместо возвращения исключения для каждой проверки возникающем совпадении.

### <a name="validating-conditions-and-throwing-exceptions"></a>Проверка условия и создание исключений

В следующем примере кода показан простой подход к проверке в сущности домена, вызывая исключение. В таблице ссылок в конце этого раздела можно просмотреть ссылки на более сложные реализации на основе шаблонов, которые мы обсуждали ранее.

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

Лучше пример продемонстрирует требуется убедиться в внутреннего состояния не был изменен или превышение все гарантированного для метода. Например следующая реализация объект будет оставаться в недопустимом состоянии:

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shipingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

Если недопустимое значение состояния, первая строка адреса и города уже были изменены. Что может сделать недействительными адрес.

Аналогичный подход можно использовать в конструкторе сущности, вызывает исключение, чтобы убедиться в том, что сущность является недопустимым после его создания.

### <a name="using-validation-attributes-in-the-model-based-on-data-annotations"></a>С помощью проверки атрибутов в модели, основанной на данных заметок

Другой подход заключается в использовании проверки атрибутов на основании заметок к данным. Атрибуты проверки предоставляют способ настроить проверку модели, которая по существу аналогично проверки для полей в таблицах базы данных. Сюда входят ограничения, такие как назначение типов данных или обязательных полей. Другие виды проверки включают применение шаблонов данных для применения бизнес-правил, таких как номер кредитной карты, номер телефона или адрес электронной почты. Атрибуты проверки упрощают для применения требований.

Тем не менее как показано в следующем коде, этот подход возможно слишком вмешивается в модели ддд, она примет зависимость ModelState.IsValid из Microsoft.AspNetCore.Mvc.ModelState, который должен вызывать контроллеров MVC. Проверка модели происходит до каждого вызываемого действия контроллера, и метод контроллера ответственность за проверить результат вызова ModelState.IsValid и реагировать соответствующим образом. Решение для его использования зависит от как тесно связаны требуется модель с ИТ-инфраструктуры.

```csharp
using System.ComponentModel.DataAnnotations;
// Other using statements ...
// Entity is a custom base class which has the ID
public class Product : Entity
{
    [Required]
    [StringLength(100)]
    public string Title { get; private set; }

    [Required]
    [Range(0, 999.99)]
    public decimal Price { get; private set; }

    [Required]
    [VintageProduct(1970)]
    [DataType(DataType.Date)]
    public DateTime ReleaseDate { get; private set; }

    [Required]
    [StringLength(1000)]
    public string Description { get; private set; }

    // Constructor...
    // Additional methods for entity logic and constructor...
}
```

Тем не менее, с точки зрения DDD модель домена лучше всего хранятся бережливого с использованием исключений в методах поведение к сущности, либо путем реализации шаблонов спецификации и уведомления для принудительного выполнения правил проверки. Проверки платформ, таких как заметок к данным в ASP.NET Core или какие-либо другие проверки платформы, как FluentValidation выполнение требований для вызова платформы приложений. Например при вызове метода ModelState.IsValid в заметок к данным, необходимо вызвать контроллеры ASP.NET.

Имеет смысл использовать заметок к данным на уровне приложения в классах ViewModel (а не сущностями домена), которые будет принимать входные данные для проверки модели на уровне пользовательского интерфейса. Тем не менее это должно выполняться не на исключения проверки в модели домена.

### <a name="validating-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a>Проверка сущностей путем реализации спецификации и шаблонов уведомлений

Наконец более сложный подход к реализации проверки в модели домена — посредством реализации шаблона спецификации в сочетании с шаблон уведомления, как описано в некоторых дополнительных ресурсов, перечислены ниже.

Следует отметить, что может использоваться только один из этих шаблонов — например, проверка вручную с помощью операторов управления, но с помощью шаблона уведомления для стека и возвращают список ошибок проверки.

### <a name="using-deferred-validation-in-the-domain"></a>Использование отложенной проверки в домене

Существуют различные подходы для обработки отложенного проверок в домене. В своей книге [Implementing Domain-Driven разработки](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vernon Вон обсуждается в разделе о проверке.

### <a name="two-step-validation"></a>Двухшаговая проверка

Также рассмотрите двухшаговой проверки. Используйте проверки уровня полей на объекты передачи команды данных (DTO) и проверки на уровне домена внутри сущностей. Это можно сделать путем возвращения результирующего объекта вместо этого исключения для упрощения работы с ошибками проверки.

Проверка полей с помощью заметок к данным, например, вы не дублируют проверка определение. Выполнение, однако, может быть серверных и клиентских данных в случае DTO (команды и ViewModels, например).

## <a name="additional-resources"></a>Дополнительные ресурсы

-   **Рэйчел Аппель. Общие сведения о проверке модели в ASP.NET Core MVC**
    [*https://docs.microsoft.com/aspnet/core/mvc/models/validation*](https://docs.microsoft.com/aspnet/core/mvc/models/validation)

-   **Рик Андерсон (Rick Anderson). Добавление проверки**
    [*https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation*](https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation)

-   **Мартин Фоулер (Martin Fowler). Замена создание исключений с уведомлением при проверке**
    [*https://martinfowler.com/articles/replaceThrowWithNotification.html*](https://martinfowler.com/articles/replaceThrowWithNotification.html)

-   **Спецификация и шаблоны уведомлений**
    [*https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns*](https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns)

-   **Gorodinski лев. Проверка в разработки на основе домена (DDD)**
    [*http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/*](http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/)

-   **Colin гнездо. Проверка модели домена**
    [*http://colinjack.blogspot.com/2008/03/domain-model-validation.html*](http://colinjack.blogspot.com/2008/03/domain-model-validation.html)

-   **Джимми Богард (Jimmy Bogard). Проверка данных в мире DDD**
    [*https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/*](https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/)


>[!div class="step-by-step"]
[Предыдущие] (перечисление классы over-enum-types.md) [Далее] (validation.md клиента стороне)
