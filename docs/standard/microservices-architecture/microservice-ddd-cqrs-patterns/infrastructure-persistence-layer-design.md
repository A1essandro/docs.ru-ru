---
title: "Проектирование инфраструктуры уровне сохраняемости"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Проектирование инфраструктуры уровне сохраняемости"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="0623a-104">Проектирование инфраструктуры уровне сохраняемости</span><span class="sxs-lookup"><span data-stu-id="0623a-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="0623a-105">Компоненты сохраняемости данных предоставляют доступ к данным, размещенным в пределах микрослужбу (то есть база данных микрослужбу).</span><span class="sxs-lookup"><span data-stu-id="0623a-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="0623a-106">Они содержат фактической реализации компонентов, таких как репозиториев и [единица работы](http://martinfowler.com/eaaCatalog/unitOfWork.html) классов, например пользовательские EF DBContexts.</span><span class="sxs-lookup"><span data-stu-id="0623a-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="0623a-107">Шаблон репозитория</span><span class="sxs-lookup"><span data-stu-id="0623a-107">The Repository pattern</span></span>

<span data-ttu-id="0623a-108">Репозитории, классы или компоненты, которые инкапсулируют логику, необходимую для доступа к источникам данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="0623a-109">Они централизовать общие функции доступа к данным, предоставляя последующего сопровождения и отделение инфраструктуры или технология, используемая для доступа к базам данных с уровнем модели домена.</span><span class="sxs-lookup"><span data-stu-id="0623a-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="0623a-110">Если вы используете ORM как Entity Framework, код, который должен быть реализован упрощено благодаря LINQ и строгую типизацию.</span><span class="sxs-lookup"><span data-stu-id="0623a-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="0623a-111">Это позволяет сосредоточиться на логику сохраняемости данных, а не на данных, доступ к коммуникации.</span><span class="sxs-lookup"><span data-stu-id="0623a-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="0623a-112">Шаблон репозитория хорошо документированы способ работы с источником данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="0623a-113">В книге [шаблоны of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler описывает репозиторий следующим образом:</span><span class="sxs-lookup"><span data-stu-id="0623a-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="0623a-114">Репозиторий выполняет задачи в роли посредника между слои модели домена и сопоставление данных действующего аналогичным образом набор доменных объектов в памяти.</span><span class="sxs-lookup"><span data-stu-id="0623a-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="0623a-115">Клиентские объекты декларативно создавать запросы и отправить их в репозитории для ответов.</span><span class="sxs-lookup"><span data-stu-id="0623a-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="0623a-116">По существу репозиторий инкапсулирует набор объектов, хранящихся в базе данных и операции, которые можно выполнить с ними, предоставляя способом, который ближе к уровень сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="0623a-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="0623a-117">Репозитории, кроме того, поддерживает назначение разделения, четко и в одном направлении, зависимости между работы домена и размещения данных или сопоставления.</span><span class="sxs-lookup"><span data-stu-id="0623a-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="0623a-118">Определение одного репозитория на статистическое выражение</span><span class="sxs-lookup"><span data-stu-id="0623a-118">Define one repository per aggregate</span></span>

<span data-ttu-id="0623a-119">Для каждого корня агрегатной функции или агрегатные необходимо создать один класс репозитория.</span><span class="sxs-lookup"><span data-stu-id="0623a-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="0623a-120">В микрослужбу на основе шаблонов разработки на основе домена это единственный канал, который следует использовать для обновления базы данных должны быть репозиториях.</span><span class="sxs-lookup"><span data-stu-id="0623a-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="0623a-121">Это так, как они имеют однозначное соответствие статистические корень, который управляет инварианты статистическое выражение и согласованность транзакций.</span><span class="sxs-lookup"><span data-stu-id="0623a-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="0623a-122">Допустимо для запроса к базе данных через другие каналы (как это можно сделать следующий подход CQRS), так как запросы не изменяют состояние базы данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="0623a-123">Тем не менее области транзакций — обновления, всегда должны управляться с репозиториев и статистические корней.</span><span class="sxs-lookup"><span data-stu-id="0623a-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="0623a-124">По сути репозиторий позволяет заполнять данные в памяти, поступающие из базы данных в виде сущности домена.</span><span class="sxs-lookup"><span data-stu-id="0623a-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="0623a-125">Как только что сущности находятся в памяти, они могут быть изменены и затем сохраняются в базе данных с помощью транзакций.</span><span class="sxs-lookup"><span data-stu-id="0623a-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="0623a-126">Как уже отмечалось, если вы используете шаблон архитектуры CQS/CQRS, начальных запросов выполненных запросов со стороны из модели домена, выполненных с помощью Dapper простой инструкции SQL.</span><span class="sxs-lookup"><span data-stu-id="0623a-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="0623a-127">Этот подход является более гибким, чем репозиториев так, как можно запрашивать и соединение таблиц необходима, и эти запросы не ограничивается правилами из агрегатов.</span><span class="sxs-lookup"><span data-stu-id="0623a-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="0623a-128">Эти данные переместится в презентации слоя или клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="0623a-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="0623a-129">Внесение изменений, обновление данных будет поступать на уровне приложения или презентацию клиента на уровне приложения (например, веб-API службы).</span><span class="sxs-lookup"><span data-stu-id="0623a-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="0623a-130">Получив команду (с данными) является допустимым обработчиком команд, репозиториев позволяет получить данные, которые необходимо выполнить обновление из базы данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="0623a-131">Обновить ее в памяти с данные, переданные с помощью команд, а затем добавьте или обновите данные (объектами) в базе данных с помощью транзакции.</span><span class="sxs-lookup"><span data-stu-id="0623a-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="0623a-132">Нам необходимо выделить еще раз, как показано на рисунке 9-17 для каждого статистические корневого должен быть определен только одного репозитория.</span><span class="sxs-lookup"><span data-stu-id="0623a-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="0623a-133">Для достижения цели статистические корня для поддержания транзакционной согласованности между объектами в агрегатной функции, не следует создавать репозиторий для каждой таблицы в базе данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="0623a-134">**На рис. 9-17**.</span><span class="sxs-lookup"><span data-stu-id="0623a-134">**Figure 9-17**.</span></span> <span data-ttu-id="0623a-135">Связь между репозиториев, статистические и таблицы базы данных</span><span class="sxs-lookup"><span data-stu-id="0623a-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="0623a-136">Применение одной агрегатной корневой в репозиторий</span><span class="sxs-lookup"><span data-stu-id="0623a-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="0623a-137">Он может пригодиться для реализации макета репозитория таким образом, тем самым правило, наличие только агрегатные корни репозиториев.</span><span class="sxs-lookup"><span data-stu-id="0623a-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="0623a-138">Можно создать репозитории универсального или базовый тип, который ограничивает тип сущности, которые она работает с, чтобы убедиться, что они имеют интерфейс IAggregateRoot разметки.</span><span class="sxs-lookup"><span data-stu-id="0623a-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="0623a-139">Таким образом каждый класс репозитория, реализации на уровне инфраструктуры реализует собственный контракт или интерфейс, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="0623a-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="0623a-140">Каждой определенный репозиторий интерфейс реализует универсальный интерфейс IRepository:</span><span class="sxs-lookup"><span data-stu-id="0623a-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="0623a-141">Однако лучше иметь код перед применять соглашение, каждого репозитория должен быть связан с одной статистической функции, можно реализовать тип универсального репозитория, он является явным, что вы используете хранилище для определенного агрегата.</span><span class="sxs-lookup"><span data-stu-id="0623a-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="0623a-142">Можно легко сделать путем реализации этого универсального в IRepository базовый интерфейс, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="0623a-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="0623a-143">Шаблон репозитория упрощает тестирование логики приложения</span><span class="sxs-lookup"><span data-stu-id="0623a-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="0623a-144">Использование шаблона репозитория дает возможность легко протестировать приложение с помощью модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="0623a-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="0623a-145">Помните, что модульные тесты тестировать только код, не инфраструктуры, эти абстракции репозитория упростить для достижения этой цели.</span><span class="sxs-lookup"><span data-stu-id="0623a-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="0623a-146">Как отмечалось в предыдущем разделе, рекомендуется определить и поместите интерфейсы репозитория в уровне модели домена, на уровне приложения (например, для вашего веб-API микрослужбу) не зависит от слоя инфраструктуры при наличии реализации классов фактическое репозитория.</span><span class="sxs-lookup"><span data-stu-id="0623a-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="0623a-147">С помощью внедрения зависимости контроллеров веб-API и таким образом, вы можете реализовать репозитории макетов, которые возвращают фальшивых данных, а не данные из базы данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="0623a-148">Что подхода со слабой взаимосвязью позволяет создавать и запускать модульные тесты, можно проверить логику приложения не требует подключения к базе данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="0623a-149">Может произойти сбой подключения к базам данных и что более важно, запущенного сотни тестов для базы данных — плохо по двум причинам.</span><span class="sxs-lookup"><span data-stu-id="0623a-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="0623a-150">Во-первых из-за большого количества тестов может занять много времени.</span><span class="sxs-lookup"><span data-stu-id="0623a-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="0623a-151">Во-вторых записей базы данных может изменить и повлиять на результаты тестов, так что они могут быть не согласованы.</span><span class="sxs-lookup"><span data-stu-id="0623a-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="0623a-152">В базе данных нет тестирования модульные тесты, но интеграции тестов.</span><span class="sxs-lookup"><span data-stu-id="0623a-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="0623a-153">Должен иметь много модульные тесты, выполнение быстрого, но меньше интеграции тестов для баз данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="0623a-154">С точки зрения разделения проблем для модульных тестов логика работает с объектами в памяти.</span><span class="sxs-lookup"><span data-stu-id="0623a-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="0623a-155">Предполагается, что класс репозитория их доставке.</span><span class="sxs-lookup"><span data-stu-id="0623a-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="0623a-156">После логику изменяет сущности домена, предполагается, что класс репозитория хранения их правильно.</span><span class="sxs-lookup"><span data-stu-id="0623a-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="0623a-157">Важно, для создания модульных тестов от модели домена и логику домена.</span><span class="sxs-lookup"><span data-stu-id="0623a-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="0623a-158">Агрегатные корни являются границами основного согласованности в ддд.</span><span class="sxs-lookup"><span data-stu-id="0623a-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="0623a-159">Разница между репозитория и устаревших шаблонов доступа к данным (DAL) класса</span><span class="sxs-lookup"><span data-stu-id="0623a-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="0623a-160">Объект доступа к данным непосредственно выполняет операции доступа и сохранения данных в службу хранилища.</span><span class="sxs-lookup"><span data-stu-id="0623a-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="0623a-161">Помечает репозитория данных с помощью операции, которые требуется выполнить в памяти, единицы работы объекта (как EF при использовании DbContext), но эти обновления не выполняются немедленно.</span><span class="sxs-lookup"><span data-stu-id="0623a-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="0623a-162">Единица работы, упоминается как одна транзакция, использующая несколько insert, update или delete операций.</span><span class="sxs-lookup"><span data-stu-id="0623a-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="0623a-163">Проще говоря это означает, что действия конкретного пользователя (например, регистрация на веб-сайте), insert, update и delete транзакции обрабатываются в рамках одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="0623a-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="0623a-164">Это более эффективно, чем обрабатывать несколько транзакций базы данных в виде chattier.</span><span class="sxs-lookup"><span data-stu-id="0623a-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="0623a-165">Эти несколько сохраняемости операции выполняются более поздней версии в рамках одной операции при команд кода с уровня приложения.</span><span class="sxs-lookup"><span data-stu-id="0623a-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="0623a-166">Решение о применении изменения в памяти для хранения базы данных обычно зависит от [шаблон единица работы](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="0623a-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="0623a-167">В EF шаблон единица работы реализуется как класс DBContext.</span><span class="sxs-lookup"><span data-stu-id="0623a-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="0623a-168">Во многих случаях этот шаблон или способ применения операций с хранилищами, можно повысить производительность приложения, чтобы снизить риск возникновения несоответствий.</span><span class="sxs-lookup"><span data-stu-id="0623a-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="0623a-169">Кроме того он уменьшает транзакции блокируются в таблицах базы данных, потому, что все нужные операции фиксируются как часть одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="0623a-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="0623a-170">Это более эффективно по сравнению с выполнение многих изолированные операции в базе данных.</span><span class="sxs-lookup"><span data-stu-id="0623a-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="0623a-171">Таким образом будет может оптимизировать выполнение в базе данных с помощью группирования несколько действий обновления в той же транзакции, в отличие от многих небольших и отдельные транзакции выполнений выбранного ORM.</span><span class="sxs-lookup"><span data-stu-id="0623a-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="0623a-172">Репозитории не должно быть обязательным</span><span class="sxs-lookup"><span data-stu-id="0623a-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="0623a-173">Пользовательские репозитории можно по причинам, указанным выше, а именно такой подход для упорядочивания микрослужбу в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="0623a-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="0623a-174">Однако это не essential шаблон, который требуется реализовать в структуре DDD или даже вообще разработка в .NET.</span><span class="sxs-lookup"><span data-stu-id="0623a-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="0623a-175">Например Джимми Богард, при предоставлении обратной связи в этом руководстве ответил следующее:</span><span class="sxs-lookup"><span data-stu-id="0623a-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="0623a-176">Это, скорее всего, будете крупнейших отзывом.</span><span class="sxs-lookup"><span data-stu-id="0623a-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="0623a-177">Я действительно не вентилятор репозиториев, главным образом, так как они скрыть важные сведения базового механизма сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="0623a-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="0623a-178">Он является почему найти MediatR для команд, слишком.</span><span class="sxs-lookup"><span data-stu-id="0623a-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="0623a-179">Я могу использовать всю мощь уровень сохраняемости и принудительной отправки, поведение домена в моей статистические корней.</span><span class="sxs-lookup"><span data-stu-id="0623a-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="0623a-180">Я не хочу обычно макета my репозиториев — по-прежнему нужно иметь, интеграцию теста с подлинные.</span><span class="sxs-lookup"><span data-stu-id="0623a-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="0623a-181">Перейдя CQRS предполагается, что нас не было действительно потребность в репозитории больше.</span><span class="sxs-lookup"><span data-stu-id="0623a-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="0623a-182">Мы пригодиться репозиториев, но мы подтверждаю, что они не являются значимыми для вашего ддд, тем, что статистические шаблон и широкие возможности доменной модели.</span><span class="sxs-lookup"><span data-stu-id="0623a-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="0623a-183">Таким образом использовать шаблон репозитория или нет, как можно увидеть размеру.</span><span class="sxs-lookup"><span data-stu-id="0623a-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="0623a-184">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="0623a-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="0623a-185">Шаблон репозитория</span><span class="sxs-lookup"><span data-stu-id="0623a-185">The Repository pattern</span></span>

-   <span data-ttu-id="0623a-186">**Эдвард Hieatt и Роба me. Шаблон репозитория. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="0623a-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="0623a-187">**Шаблон репозитория**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="0623a-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="0623a-188">**Шаблон репозитория: Сохраняемости уровень абстракции данных**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="0623a-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="0623a-189">**Эрик Эванс (Eric Evans). Проектирование на основе домена: Выполняемой сложность лежит в основе программного обеспечения.**</span><span class="sxs-lookup"><span data-stu-id="0623a-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="0623a-190">(Книга; включает в себя обсуждение шаблон репозитория) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="0623a-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="0623a-191">Единица работы шаблон</span><span class="sxs-lookup"><span data-stu-id="0623a-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="0623a-192">**Мартин Фоулер (Martin Fowler). Единица работы шаблон. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="0623a-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="0623a-193">**Реализация репозитория и единицы шаблонов рабочих элементов в приложении ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-Repository-and-Unit-of-work-Patterns-in-an-ASP-NET-MVC-Application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="0623a-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0623a-194">[Предыдущие] (домен события конструктора implementation.md) [Далее] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="0623a-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
