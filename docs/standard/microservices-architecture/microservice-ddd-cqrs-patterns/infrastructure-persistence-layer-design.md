---
title: "Проектирование инфраструктуры уровне сохраняемости"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Проектирование инфраструктуры уровне сохраняемости"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a>Проектирование инфраструктуры уровне сохраняемости

Компоненты сохраняемости данных предоставляют доступ к данным, размещенным в пределах микрослужбу (то есть база данных микрослужбу). Они содержат фактической реализации компонентов, таких как репозиториев и [единица работы](http://martinfowler.com/eaaCatalog/unitOfWork.html) классов, например пользовательские EF DBContexts.

## <a name="the-repository-pattern"></a>Шаблон репозитория

Репозитории, классы или компоненты, которые инкапсулируют логику, необходимую для доступа к источникам данных. Они централизовать общие функции доступа к данным, предоставляя последующего сопровождения и отделение инфраструктуры или технология, используемая для доступа к базам данных с уровнем модели домена. Если вы используете ORM как Entity Framework, код, который должен быть реализован упрощено благодаря LINQ и строгую типизацию. Это позволяет сосредоточиться на логику сохраняемости данных, а не на данных, доступ к коммуникации.

Шаблон репозитория хорошо документированы способ работы с источником данных. В книге [шаблоны of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler описывает репозиторий следующим образом:

Репозиторий выполняет задачи в роли посредника между слои модели домена и сопоставление данных действующего аналогичным образом набор доменных объектов в памяти. Клиентские объекты декларативно создавать запросы и отправить их в репозитории для ответов. По существу репозиторий инкапсулирует набор объектов, хранящихся в базе данных и операции, которые можно выполнить с ними, предоставляя способом, который ближе к уровень сохраняемости. Репозитории, кроме того, поддерживает назначение разделения, четко и в одном направлении, зависимости между работы домена и размещения данных или сопоставления.

### <a name="define-one-repository-per-aggregate"></a>Определение одного репозитория на статистическое выражение

Для каждого корня агрегатной функции или агрегатные необходимо создать один класс репозитория. В микрослужбу на основе шаблонов разработки на основе домена это единственный канал, который следует использовать для обновления базы данных должны быть репозиториях. Это так, как они имеют однозначное соответствие статистические корень, который управляет инварианты статистическое выражение и согласованность транзакций. Допустимо для запроса к базе данных через другие каналы (как это можно сделать следующий подход CQRS), так как запросы не изменяют состояние базы данных. Тем не менее области транзакций — обновления, всегда должны управляться с репозиториев и статистические корней.

По сути репозиторий позволяет заполнять данные в памяти, поступающие из базы данных в виде сущности домена. Как только что сущности находятся в памяти, они могут быть изменены и затем сохраняются в базе данных с помощью транзакций.

Как уже отмечалось, если вы используете шаблон архитектуры CQS/CQRS, начальных запросов выполненных запросов со стороны из модели домена, выполненных с помощью Dapper простой инструкции SQL. Этот подход является более гибким, чем репозиториев так, как можно запрашивать и соединение таблиц необходима, и эти запросы не ограничивается правилами из агрегатов. Эти данные переместится в презентации слоя или клиентского приложения.

Внесение изменений, обновление данных будет поступать на уровне приложения или презентацию клиента на уровне приложения (например, веб-API службы). Получив команду (с данными) является допустимым обработчиком команд, репозиториев позволяет получить данные, которые необходимо выполнить обновление из базы данных. Обновить ее в памяти с данные, переданные с помощью команд, а затем добавьте или обновите данные (объектами) в базе данных с помощью транзакции.

Нам необходимо выделить еще раз, как показано на рисунке 9-17 для каждого статистические корневого должен быть определен только одного репозитория. Для достижения цели статистические корня для поддержания транзакционной согласованности между объектами в агрегатной функции, не следует создавать репозиторий для каждой таблицы в базе данных.

![](./media/image18.png)

**На рис. 9-17**. Связь между репозиториев, статистические и таблицы базы данных

### <a name="enforcing-one-aggregate-root-per-repository"></a>Применение одной агрегатной корневой в репозиторий

Он может пригодиться для реализации макета репозитория таким образом, тем самым правило, наличие только агрегатные корни репозиториев. Можно создать репозитории универсального или базовый тип, который ограничивает тип сущности, которые она работает с, чтобы убедиться, что они имеют интерфейс IAggregateRoot разметки.

Таким образом каждый класс репозитория, реализации на уровне инфраструктуры реализует собственный контракт или интерфейс, как показано в следующем коде:

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

Каждой определенный репозиторий интерфейс реализует универсальный интерфейс IRepository:

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

Однако лучше иметь код перед применять соглашение, каждого репозитория должен быть связан с одной статистической функции, можно реализовать тип универсального репозитория, он является явным, что вы используете хранилище для определенного агрегата. Можно легко сделать путем реализации этого универсального в IRepository базовый интерфейс, как показано в следующем коде:

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a>Шаблон репозитория упрощает тестирование логики приложения

Использование шаблона репозитория дает возможность легко протестировать приложение с помощью модульных тестов. Помните, что модульные тесты тестировать только код, не инфраструктуры, эти абстракции репозитория упростить для достижения этой цели.

Как отмечалось в предыдущем разделе, рекомендуется определить и поместите интерфейсы репозитория в уровне модели домена, на уровне приложения (например, для вашего веб-API микрослужбу) не зависит от слоя инфраструктуры при наличии реализации классов фактическое репозитория. С помощью внедрения зависимости контроллеров веб-API и таким образом, вы можете реализовать репозитории макетов, которые возвращают фальшивых данных, а не данные из базы данных. Что подхода со слабой взаимосвязью позволяет создавать и запускать модульные тесты, можно проверить логику приложения не требует подключения к базе данных.

Может произойти сбой подключения к базам данных и что более важно, запущенного сотни тестов для базы данных — плохо по двум причинам. Во-первых из-за большого количества тестов может занять много времени. Во-вторых записей базы данных может изменить и повлиять на результаты тестов, так что они могут быть не согласованы. В базе данных нет тестирования модульные тесты, но интеграции тестов. Должен иметь много модульные тесты, выполнение быстрого, но меньше интеграции тестов для баз данных.

С точки зрения разделения проблем для модульных тестов логика работает с объектами в памяти. Предполагается, что класс репозитория их доставке. После логику изменяет сущности домена, предполагается, что класс репозитория хранения их правильно. Важно, для создания модульных тестов от модели домена и логику домена. Агрегатные корни являются границами основного согласованности в ддд.

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a>Разница между репозитория и устаревших шаблонов доступа к данным (DAL) класса

Объект доступа к данным непосредственно выполняет операции доступа и сохранения данных в службу хранилища. Помечает репозитория данных с помощью операции, которые требуется выполнить в памяти, единицы работы объекта (как EF при использовании DbContext), но эти обновления не выполняются немедленно.

Единица работы, упоминается как одна транзакция, использующая несколько insert, update или delete операций. Проще говоря это означает, что действия конкретного пользователя (например, регистрация на веб-сайте), insert, update и delete транзакции обрабатываются в рамках одной транзакции. Это более эффективно, чем обрабатывать несколько транзакций базы данных в виде chattier.

Эти несколько сохраняемости операции выполняются более поздней версии в рамках одной операции при команд кода с уровня приложения. Решение о применении изменения в памяти для хранения базы данных обычно зависит от [шаблон единица работы](http://martinfowler.com/eaaCatalog/unitOfWork.html). В EF шаблон единица работы реализуется как класс DBContext.

Во многих случаях этот шаблон или способ применения операций с хранилищами, можно повысить производительность приложения, чтобы снизить риск возникновения несоответствий. Кроме того он уменьшает транзакции блокируются в таблицах базы данных, потому, что все нужные операции фиксируются как часть одной транзакции. Это более эффективно по сравнению с выполнение многих изолированные операции в базе данных. Таким образом будет может оптимизировать выполнение в базе данных с помощью группирования несколько действий обновления в той же транзакции, в отличие от многих небольших и отдельные транзакции выполнений выбранного ORM.

### <a name="repositories-should-not-be-mandatory"></a>Репозитории не должно быть обязательным

Пользовательские репозитории можно по причинам, указанным выше, а именно такой подход для упорядочивания микрослужбу в eShopOnContainers. Однако это не essential шаблон, который требуется реализовать в структуре DDD или даже вообще разработка в .NET.

Например Джимми Богард, при предоставлении обратной связи в этом руководстве ответил следующее:

Это, скорее всего, будете крупнейших отзывом. Я действительно не вентилятор репозиториев, главным образом, так как они скрыть важные сведения базового механизма сохраняемости. Он является почему найти MediatR для команд, слишком. Я могу использовать всю мощь уровень сохраняемости и принудительной отправки, поведение домена в моей статистические корней. Я не хочу обычно макета my репозиториев — по-прежнему нужно иметь, интеграцию теста с подлинные. Перейдя CQRS предполагается, что нас не было действительно потребность в репозитории больше.

Мы пригодиться репозиториев, но мы подтверждаю, что они не являются значимыми для вашего ддд, тем, что статистические шаблон и широкие возможности доменной модели. Таким образом использовать шаблон репозитория или нет, как можно увидеть размеру.

#### <a name="additional-resources"></a>Дополнительные ресурсы

##### <a name="the-repository-pattern"></a>Шаблон репозитория

-   **Эдвард Hieatt и Роба me. Шаблон репозитория. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)

-   **Шаблон репозитория**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)

-   **Шаблон репозитория: Сохраняемости уровень абстракции данных**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)

-   **Эрик Эванс (Eric Evans). Проектирование на основе домена: Выполняемой сложность лежит в основе программного обеспечения.** (Книга; включает в себя обсуждение шаблон репозитория) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)

##### <a name="unit-of-work-pattern"></a>Единица работы шаблон

-   **Мартин Фоулер (Martin Fowler). Единица работы шаблон. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)

<!-- -->

-   **Реализация репозитория и единицы шаблонов рабочих элементов в приложении ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-Repository-and-Unit-of-work-Patterns-in-an-ASP-NET-MVC-Application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)


>[!div class="step-by-step"]
[Предыдущие] (домен события конструктора implementation.md) [Далее] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)
