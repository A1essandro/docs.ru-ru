---
title: "Проектирование уровня сохраняемости инфраструктуры"
description: "Архитектура микрослужб .NET для контейнерных приложений .NET | Проектирование уровня сохраняемости инфраструктуры"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 76db5388c75d4eb3b5cc23c1e57cc391a15f2934
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/19/2018
---
# <a name="designing-the-infrastructure-persistence-layer"></a>Проектирование уровня сохраняемости инфраструктуры

Компоненты сохраняемости данных предоставляют доступ к данным, размещенным в границах микрослужбы (то есть в границах базы данных микрослужбы). Они содержат фактическую реализацию компонентов, таких как репозитории и классы [единиц работы](http://martinfowler.com/eaaCatalog/unitOfWork.html), например пользовательские контексты EF DBContexts.

## <a name="the-repository-pattern"></a>Шаблон репозитория

Репозитории — это классы или компоненты, которые содержат логику, необходимую для доступа к источникам данных. Репозитории предоставляют централизованные функции для доступа к данным, позволяя улучшить управление и отделить инфраструктуру или технологию, используемую для доступа к данным, от модели предметной области. Если вы используете ORM, например Entity Framework, код, который необходимо реализовать, упрощается благодаря LINQ и строгой типизации. Это позволяет сосредоточиться на логике сохраняемости данных, а не на вспомогательных функциях для доступа к данным.

Шаблон репозитория представляет собой хорошо задокументированный способ работы с источниками данных. В книге [Шаблоны архитектуры корпоративных приложений](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/) Мартин Фаулер описывает репозиторий следующим образом.

Репозиторий выполняет задачи в роли посредника между уровнями модели предметной области и сопоставлением данных и действует похожим образом для набора объектов предметной области в памяти. Клиентские объекты декларативно создают запросы и отправляют их в репозитории для получения ответов. По существу, репозиторий инкапсулирует набор объектов, хранящихся в базе данных, и операции, которые можно выполнить над этими объектами, и предоставляет уровень, который находится ближе к уровню сохраняемости. Кроме того, репозитории поддерживают четкое и однонаправленное разделение между рабочей предметной областью и распределением или сопоставлением данных.

### <a name="define-one-repository-per-aggregate"></a>Определение одного репозитория для каждого агрегата

Для каждого агрегата или корня агрегации следует создать только один класс репозитория. В микрослужбе на основе шаблонов предметно-ориентированного проектирования единственный канал, который следует использовать для обновления базы данных, — репозитории. Это вызвано тем, что у репозитория есть связь "один к одному" с корнем агрегации, который управляет инвариантностью агрегата и согласованностью транзакций. Отправлять запросы к базе данных также можно через другие каналы (например, с использованием подхода CQRS), так как запросы не изменяют состояния базы данных. Однако область транзакций (обновления) всегда должна контролироваться репозиториями и корнями агрегации.

По сути, репозиторий позволяет заполнять данные в памяти, которые поступают из базы данных в форме объектов предметной области. После того как объекты оказываются в памяти, их можно изменить и затем сохранить обратно в базе данных с помощью транзакций.

Как уже отмечалось, если вы используете шаблон архитектуры CQS/CQRS, то начальные запросы будут выполнены с помощью сторонних запросов модели предметной области, которые выполняются с помощью простых инструкций SQL с помощью Dapper. Этот подход является гораздо более гибким по сравнению с репозиториями, так как вы можете отправлять запросы к любым необходимым таблицам и объединять эти таблицы, и эти запросы не ограничены правилами агрегатов. Эти данные перейдут на уровень представления или в клиентское приложение.

Если пользователь вносит изменения, то данные для обновления поступают из клиентского приложения или с уровня представления на уровень приложения (например, в службу веб-API). При получении команды (с данными) в обработчике команд вы получаете данные, которые хотите обновить, из базы данных с помощью репозитория. Вы обновляете эти данные в памяти, используя информацию, переданную с командами, а затем добавляете или обновляете данные (объекты предметной области) в базе данных с помощью транзакций.

Помните, что для одного корня агрегации нужно определить только один репозиторий, как показано на рис. 9-17. Чтобы корень агрегации поддерживал транзакционную согласованность между всеми объектами в агрегате, не следует создавать репозиторий для каждой таблицы в базе данных.

![](./media/image18.png)

**Рис. 9-17**. Связь между репозиториями, агрегатами и таблицами базы данных

### <a name="enforcing-one-aggregate-root-per-repository"></a>Использование только одного корня агрегации для одного репозитория

При создании архитектуры репозитория может оказаться полезным правило, которое позволяет создать только один репозиторий для одного корня агрегации. Вы можете создать универсальный или базовый репозиторий, который ограничивает типы объектов, с которым он работает, интерфейсом метки IAggregateRoot.

Таким образом, в каждом классе репозитория, реализованном на уровне инфраструктуры, реализуется собственный контракт или интерфейс, как показано в следующем коде:

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

Каждый интерфейс репозитория реализует общий интерфейс IRepository:

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

Однако для реализации правила, по которому один репозиторий должен быть связан с одним корнем агрегации, в коде лучше реализовать общий тип репозитория, из которого будет ясно, что для него используется определенный агрегат. Это можно сделать, реализовав общий репозиторий в базовом интерфейсе IRepository, как показано в следующем коде:

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a>Шаблон репозитория упрощает тестирование логики приложения

Шаблон репозитория дает возможность легко протестировать приложение с помощью модульных тестов. Помните, что модульные тесты проверяют только код, а не инфраструктуру, поэтому для проверки инфраструктуры лучше использовать абстракции репозитория.

Как отмечалось в предыдущем разделе, рекомендуется определить и разместить интерфейсы репозитория на уровне модели предметной области, чтобы уровень приложения (например, микрослужба веб-API) напрямую не зависел от уровня инфраструктуры, на котором реализованы фактические классы репозитория. Сделав это и используя внедрение зависимостей в контроллерах веб-API, вы можете реализовать макеты репозиториев, которые возвращают псевдоданные вместо данных из базы данных. Этот подход с разделением позволяет создавать и запускать модульные тесты, которые проверяют только логику приложения и не требуют подключения к базе данных.

Подключение к базе данных может завершиться неудачно, а главное — выполнение нескольких сотен тестов для базы данных не рекомендуется по двум причинам. Во-первых, это может занять много времени из-за большого количества тестов. Во-вторых, записи в базе данных могут измениться и повлиять на результаты тестов, поэтому они могут быть несогласованными. Тесты, которые выполняются над базой данных, — это не модульные тесты, а тесты интеграции. У вас должно быть много модульных тестов, которые быстро выполняются, и меньшее количество тестов интеграции, которые выполняются над базами данных.

С точки зрения проблемы разделения для модульных тестов, ваша логика работает над объектами предметной области в памяти. Предполагается, что класс репозитория доставил эти объекты. После того как логика изменяет объекты предметной области, предполагается, что класс репозитория правильно сохраняет их. Важно создавать модульные тесты для модели предметной области и ее логики. Корни агрегации представляют собой главные границы согласованности в предметно-ориентированном проектировании.

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a>Разница между шаблоном репозитория и устаревшим шаблоном класса для доступа к данным

Объект доступа к данным осуществляет доступ к данным и операции сохраняемости в хранилище. Репозиторий отмечает данные операциями, которые вы хотите выполнить в памяти, для объекта единицы работы (как в EF при использовании DbContext), но эти обновления не выполняются немедленно.

Единица работы — это одна транзакция, которая включает несколько операций вставки, обновления или удаления. Проще говоря, это означает, что все действия по вставке, обновлению и удалению данных для конкретного действия пользователя (например, регистрация на веб-сайте) обрабатываются в рамках одной транзакции. Это более эффективно, чем использовать несколько транзакций базы данных, которые выполняются поочередно.

Эти несколько операций сохраняемости выполняются позднее в одном действии, когда из кода на уровне приложения поступает команда на их выполнение. Решение о применении изменений в памяти к фактическому хранилищу базы данных обычно основано на [шаблоне единицы работы](http://martinfowler.com/eaaCatalog/unitOfWork.html). В EF шаблон единицы работы реализуется как DBContext.

Во многих случаях этот шаблон, или способ применения операций к хранилищам, может повысить производительность приложения и снизить риск возникновения несоответствий. Кроме того, он снижает блокировку транзакций в таблицах базы данных, потому что все необходимые операции фиксируются как часть одной транзакции. Это более эффективно по сравнению с выполнением многих изолированных операций в базе данных. Таким образом, в выбранных ORM можно оптимизировать выполнение запросов к базам данных путем группирования нескольких действий обновления в одной и той же транзакции в отличие от выполнения нескольких отдельных мелких транзакций.

### <a name="repositories-should-not-be-mandatory"></a>Репозитории не должны быть обязательными

Пользовательские репозитории удобны по перечисленным выше причинам, и именно: этот подход используется для упорядочивания микрослужб в eShopOnContainers. Однако этот подход необязателен в предметно-ориентированном проектировании и даже при разработке в .NET в целом.

Например, Джимми Богард в качестве прямого отзыва на это руководство отметил следующее:

Пожалуй, это мой самый большой отзыв. Я не большой поклонник репозиториев, главным образом, потому, что они скрывают важные детали механизма сохраняемости. Именно поэтому я пользуюсь MediatR для команд. Я могу использовать все возможности уровня сохраняемости и отправить все это поведение предметной области в корни агрегации. Обычно я не хочу создавать макеты репозиториев, так как этот тест интеграции нужно проводить на реальной системе. Переход на CQRS означал, что у нас действительно больше не было потребности в репозиториях.

Мы считаем, что репозитории удобны, но отмечаем, что они не так важны для предметно-ориентированного проектирования, как шаблон агрегирования и обширная модель предметной области. Поэтому вы сами должны решить, стоит ли использовать шаблон репозитория в каждом конкретном случае.

## <a name="the-specification-pattern"></a>Шаблон спецификации

Шаблон спецификации (полностью — шаблон спецификации запроса) — это шаблон предметно-ориентированного проектирования, представляющий собой место, в котором можно разместить определение запроса с дополнительной логикой сортировки и разбиения на страницы.

Шаблон спецификации определяет запрос в объекте. Например, чтобы инкапсулировать страничный запрос, который выполняет поиск некоторых продуктов, вы можете создать спецификацию PagedProduct, которая принимает необходимые входные параметры (номер страницы, размер страницы, фильтр и т. д.). Затем в любом методе репозитория (обычно в перегрузке List()) вы можете принять ISpecification и запустить ожидаемый запрос на основе этой спецификации.

Этот подход имеет несколько преимуществ:

* У спецификации есть имя (в отличие от нескольких выражений LINQ), которое можно обсудить.

* Для спецификации можно выполнить изолированное модульное тестирование, чтобы проверить ее корректность. Ее также можно использовать повторно, если необходимо реализовать аналогичное поведение. Например, в действии представления MVC или действии веб-API, а также в различных службах.

* Спецификацию также можно использовать для описания формы возвращаемых данных, поэтому эти запросы могут возвращать только необходимые данные. Это устраняет потребность в отложенной загрузке в веб-приложениях (использовать которую обычно не рекомендуется), а также позволяет избежать заполнения реализаций репозитория ненужными деталями.

Пример универсального интерфейса спецификации приведен в следующем коде из [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

В следующих разделах описано, как реализовать шаблон спецификации в Entity Framework Core 2.0 и как использовать его из класса репозитория.

**Важное замечание:** шаблон спецификации — это старый шаблон, который может быть реализован различными способами, как показано в следующих дополнительных материалах. С более старыми подходами полезно ознакомиться в качестве шаблона или идеи. Но не стоит использовать старые реализации, в которых не используются возможности современных языков, таких как Linq, и выражения.

## <a name="additional-resources"></a>Дополнительные ресурсы

### <a name="the-repository-pattern"></a>Шаблон репозитория

-   **Эдвард Хиятт и Роб Ми (Edward Hieatt и Rob Mee). Шаблон репозитория.**
    [*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)

-   **Шаблон репозитория**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)

-   **Шаблон репозитория: абстракция для сохраняемости данных**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)

-   **Эрик Эванс (Eric Evans). Предметно-ориентированное проектирование (DDD). Структуризация сложных программных систем.** (Книга содержит обсуждение шаблона репозитория) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)

### <a name="unit-of-work-pattern"></a>Шаблон единицы работы

-   **Мартин Фоулер (Martin Fowler). Шаблон единицы работы.**
    [*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)

<!-- -->

-   **Реализация шаблонов репозиториев и единиц работы в приложении MVC ASP.NET**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)

### <a name="the-specification-pattern"></a>Шаблон спецификации

-   **Шаблон спецификации.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)

-   **Эрик Эванс (2004). Предметно-ориентированное проектирование. Addison-Wesley. стр. 224.**

-   **Спецификации. Мартин Фаулер**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)

>[!div class="step-by-step"]
[Назад] (domain-events-design-implementation.md) [Далее] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)
