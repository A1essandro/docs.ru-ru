---
title: Проектирование уровня сохраняемости инфраструктуры
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Проектирование уровня сохраняемости инфраструктуры
keywords: Docker, микрослужбы, ASP.NET, контейнер
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/08/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 76db5388c75d4eb3b5cc23c1e57cc391a15f2934
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/26/2018
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="7e1a5-104">Проектирование уровня сохраняемости инфраструктуры</span><span class="sxs-lookup"><span data-stu-id="7e1a5-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="7e1a5-105">Компоненты сохраняемости данных предоставляют доступ к данным, размещенным в границах микрослужбы (то есть в границах базы данных микрослужбы).</span><span class="sxs-lookup"><span data-stu-id="7e1a5-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="7e1a5-106">Они содержат фактическую реализацию компонентов, таких как репозитории и классы [единиц работы](http://martinfowler.com/eaaCatalog/unitOfWork.html), например пользовательские контексты EF DBContexts.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="7e1a5-107">Шаблон репозитория</span><span class="sxs-lookup"><span data-stu-id="7e1a5-107">The Repository pattern</span></span>

<span data-ttu-id="7e1a5-108">Репозитории — это классы или компоненты, которые содержат логику, необходимую для доступа к источникам данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="7e1a5-109">Репозитории предоставляют централизованные функции для доступа к данным, позволяя улучшить управление и отделить инфраструктуру или технологию, используемую для доступа к данным, от модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="7e1a5-110">Если вы используете ORM, например Entity Framework, код, который необходимо реализовать, упрощается благодаря LINQ и строгой типизации.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="7e1a5-111">Это позволяет сосредоточиться на логике сохраняемости данных, а не на вспомогательных функциях для доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="7e1a5-112">Шаблон репозитория представляет собой хорошо задокументированный способ работы с источниками данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="7e1a5-113">В книге [Шаблоны архитектуры корпоративных приложений](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/) Мартин Фаулер описывает репозиторий следующим образом.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="7e1a5-114">Репозиторий выполняет задачи в роли посредника между уровнями модели предметной области и сопоставлением данных и действует похожим образом для набора объектов предметной области в памяти.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="7e1a5-115">Клиентские объекты декларативно создают запросы и отправляют их в репозитории для получения ответов.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="7e1a5-116">По существу, репозиторий инкапсулирует набор объектов, хранящихся в базе данных, и операции, которые можно выполнить над этими объектами, и предоставляет уровень, который находится ближе к уровню сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="7e1a5-117">Кроме того, репозитории поддерживают четкое и однонаправленное разделение между рабочей предметной областью и распределением или сопоставлением данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="7e1a5-118">Определение одного репозитория для каждого агрегата</span><span class="sxs-lookup"><span data-stu-id="7e1a5-118">Define one repository per aggregate</span></span>

<span data-ttu-id="7e1a5-119">Для каждого агрегата или корня агрегации следует создать только один класс репозитория.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="7e1a5-120">В микрослужбе на основе шаблонов предметно-ориентированного проектирования единственный канал, который следует использовать для обновления базы данных, — репозитории.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="7e1a5-121">Это вызвано тем, что у репозитория есть связь "один к одному" с корнем агрегации, который управляет инвариантностью агрегата и согласованностью транзакций.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="7e1a5-122">Отправлять запросы к базе данных также можно через другие каналы (например, с использованием подхода CQRS), так как запросы не изменяют состояния базы данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="7e1a5-123">Однако область транзакций (обновления) всегда должна контролироваться репозиториями и корнями агрегации.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="7e1a5-124">По сути, репозиторий позволяет заполнять данные в памяти, которые поступают из базы данных в форме объектов предметной области.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="7e1a5-125">После того как объекты оказываются в памяти, их можно изменить и затем сохранить обратно в базе данных с помощью транзакций.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="7e1a5-126">Как уже отмечалось, если вы используете шаблон архитектуры CQS/CQRS, то начальные запросы будут выполнены с помощью сторонних запросов модели предметной области, которые выполняются с помощью простых инструкций SQL с помощью Dapper.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="7e1a5-127">Этот подход является гораздо более гибким по сравнению с репозиториями, так как вы можете отправлять запросы к любым необходимым таблицам и объединять эти таблицы, и эти запросы не ограничены правилами агрегатов.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="7e1a5-128">Эти данные перейдут на уровень представления или в клиентское приложение.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="7e1a5-129">Если пользователь вносит изменения, то данные для обновления поступают из клиентского приложения или с уровня представления на уровень приложения (например, в службу веб-API).</span><span class="sxs-lookup"><span data-stu-id="7e1a5-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="7e1a5-130">При получении команды (с данными) в обработчике команд вы получаете данные, которые хотите обновить, из базы данных с помощью репозитория.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="7e1a5-131">Вы обновляете эти данные в памяти, используя информацию, переданную с командами, а затем добавляете или обновляете данные (объекты предметной области) в базе данных с помощью транзакций.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="7e1a5-132">Помните, что для одного корня агрегации нужно определить только один репозиторий, как показано на рис. 9-17.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-132">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="7e1a5-133">Чтобы корень агрегации поддерживал транзакционную согласованность между всеми объектами в агрегате, не следует создавать репозиторий для каждой таблицы в базе данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="7e1a5-134">**Рис. 9-17**.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-134">**Figure 9-17**.</span></span> <span data-ttu-id="7e1a5-135">Связь между репозиториями, агрегатами и таблицами базы данных</span><span class="sxs-lookup"><span data-stu-id="7e1a5-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="7e1a5-136">Использование только одного корня агрегации для одного репозитория</span><span class="sxs-lookup"><span data-stu-id="7e1a5-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="7e1a5-137">При создании архитектуры репозитория может оказаться полезным правило, которое позволяет создать только один репозиторий для одного корня агрегации.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="7e1a5-138">Вы можете создать универсальный или базовый репозиторий, который ограничивает типы объектов, с которым он работает, интерфейсом метки IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="7e1a5-139">Таким образом, в каждом классе репозитория, реализованном на уровне инфраструктуры, реализуется собственный контракт или интерфейс, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="7e1a5-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="7e1a5-140">Каждый интерфейс репозитория реализует общий интерфейс IRepository:</span><span class="sxs-lookup"><span data-stu-id="7e1a5-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="7e1a5-141">Однако для реализации правила, по которому один репозиторий должен быть связан с одним корнем агрегации, в коде лучше реализовать общий тип репозитория, из которого будет ясно, что для него используется определенный агрегат.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="7e1a5-142">Это можно сделать, реализовав общий репозиторий в базовом интерфейсе IRepository, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="7e1a5-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="7e1a5-143">Шаблон репозитория упрощает тестирование логики приложения</span><span class="sxs-lookup"><span data-stu-id="7e1a5-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="7e1a5-144">Шаблон репозитория дает возможность легко протестировать приложение с помощью модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="7e1a5-145">Помните, что модульные тесты проверяют только код, а не инфраструктуру, поэтому для проверки инфраструктуры лучше использовать абстракции репозитория.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="7e1a5-146">Как отмечалось в предыдущем разделе, рекомендуется определить и разместить интерфейсы репозитория на уровне модели предметной области, чтобы уровень приложения (например, микрослужба веб-API) напрямую не зависел от уровня инфраструктуры, на котором реализованы фактические классы репозитория.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="7e1a5-147">Сделав это и используя внедрение зависимостей в контроллерах веб-API, вы можете реализовать макеты репозиториев, которые возвращают псевдоданные вместо данных из базы данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="7e1a5-148">Этот подход с разделением позволяет создавать и запускать модульные тесты, которые проверяют только логику приложения и не требуют подключения к базе данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="7e1a5-149">Подключение к базе данных может завершиться неудачно, а главное — выполнение нескольких сотен тестов для базы данных не рекомендуется по двум причинам.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="7e1a5-150">Во-первых, это может занять много времени из-за большого количества тестов.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="7e1a5-151">Во-вторых, записи в базе данных могут измениться и повлиять на результаты тестов, поэтому они могут быть несогласованными.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="7e1a5-152">Тесты, которые выполняются над базой данных, — это не модульные тесты, а тесты интеграции.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="7e1a5-153">У вас должно быть много модульных тестов, которые быстро выполняются, и меньшее количество тестов интеграции, которые выполняются над базами данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="7e1a5-154">С точки зрения проблемы разделения для модульных тестов, ваша логика работает над объектами предметной области в памяти.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="7e1a5-155">Предполагается, что класс репозитория доставил эти объекты.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="7e1a5-156">После того как логика изменяет объекты предметной области, предполагается, что класс репозитория правильно сохраняет их.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="7e1a5-157">Важно создавать модульные тесты для модели предметной области и ее логики.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="7e1a5-158">Корни агрегации представляют собой главные границы согласованности в предметно-ориентированном проектировании.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="7e1a5-159">Разница между шаблоном репозитория и устаревшим шаблоном класса для доступа к данным</span><span class="sxs-lookup"><span data-stu-id="7e1a5-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="7e1a5-160">Объект доступа к данным осуществляет доступ к данным и операции сохраняемости в хранилище.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="7e1a5-161">Репозиторий отмечает данные операциями, которые вы хотите выполнить в памяти, для объекта единицы работы (как в EF при использовании DbContext), но эти обновления не выполняются немедленно.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="7e1a5-162">Единица работы — это одна транзакция, которая включает несколько операций вставки, обновления или удаления.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="7e1a5-163">Проще говоря, это означает, что все действия по вставке, обновлению и удалению данных для конкретного действия пользователя (например, регистрация на веб-сайте) обрабатываются в рамках одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="7e1a5-164">Это более эффективно, чем использовать несколько транзакций базы данных, которые выполняются поочередно.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="7e1a5-165">Эти несколько операций сохраняемости выполняются позднее в одном действии, когда из кода на уровне приложения поступает команда на их выполнение.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-165">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="7e1a5-166">Решение о применении изменений в памяти к фактическому хранилищу базы данных обычно основано на [шаблоне единицы работы](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="7e1a5-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="7e1a5-167">В EF шаблон единицы работы реализуется как DBContext.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="7e1a5-168">Во многих случаях этот шаблон, или способ применения операций к хранилищам, может повысить производительность приложения и снизить риск возникновения несоответствий.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="7e1a5-169">Кроме того, он снижает блокировку транзакций в таблицах базы данных, потому что все необходимые операции фиксируются как часть одной транзакции.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="7e1a5-170">Это более эффективно по сравнению с выполнением многих изолированных операций в базе данных.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="7e1a5-171">Таким образом, в выбранных ORM можно оптимизировать выполнение запросов к базам данных путем группирования нескольких действий обновления в одной и той же транзакции в отличие от выполнения нескольких отдельных мелких транзакций.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-171">Therefore, the selected ORM is able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="7e1a5-172">Репозитории не должны быть обязательными</span><span class="sxs-lookup"><span data-stu-id="7e1a5-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="7e1a5-173">Пользовательские репозитории удобны по перечисленным выше причинам, и именно: этот подход используется для упорядочивания микрослужб в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="7e1a5-174">Однако этот подход необязателен в предметно-ориентированном проектировании и даже при разработке в .NET в целом.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="7e1a5-175">Например, Джимми Богард в качестве прямого отзыва на это руководство отметил следующее:</span><span class="sxs-lookup"><span data-stu-id="7e1a5-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="7e1a5-176">Пожалуй, это мой самый большой отзыв.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="7e1a5-177">Я не большой поклонник репозиториев, главным образом, потому, что они скрывают важные детали механизма сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="7e1a5-178">Именно поэтому я пользуюсь MediatR для команд.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="7e1a5-179">Я могу использовать все возможности уровня сохраняемости и отправить все это поведение предметной области в корни агрегации.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="7e1a5-180">Обычно я не хочу создавать макеты репозиториев, так как этот тест интеграции нужно проводить на реальной системе.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="7e1a5-181">Переход на CQRS означал, что у нас действительно больше не было потребности в репозиториях.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="7e1a5-182">Мы считаем, что репозитории удобны, но отмечаем, что они не так важны для предметно-ориентированного проектирования, как шаблон агрегирования и обширная модель предметной области.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="7e1a5-183">Поэтому вы сами должны решить, стоит ли использовать шаблон репозитория в каждом конкретном случае.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="7e1a5-184">Шаблон спецификации</span><span class="sxs-lookup"><span data-stu-id="7e1a5-184">The Specification pattern</span></span>

<span data-ttu-id="7e1a5-185">Шаблон спецификации (полностью — шаблон спецификации запроса) — это шаблон предметно-ориентированного проектирования, представляющий собой место, в котором можно разместить определение запроса с дополнительной логикой сортировки и разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-185">The Specification pattern (its full name would be Query-specification pattern) is a Domain-Driven Design pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="7e1a5-186">Шаблон спецификации определяет запрос в объекте.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-186">The Specification pattern defines a query in an object.</span></span> <span data-ttu-id="7e1a5-187">Например, чтобы инкапсулировать страничный запрос, который выполняет поиск некоторых продуктов, вы можете создать спецификацию PagedProduct, которая принимает необходимые входные параметры (номер страницы, размер страницы, фильтр и т. д.).</span><span class="sxs-lookup"><span data-stu-id="7e1a5-187">For example, in order to encapsulate a paged query that searches for some products, you can create a PagedProduct specification that takes the necessary input parameters (pageNumber, pageSize, filter, etc.).</span></span> <span data-ttu-id="7e1a5-188">Затем в любом методе репозитория (обычно в перегрузке List()) вы можете принять ISpecification и запустить ожидаемый запрос на основе этой спецификации.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-188">Then, within any Repository method (usually a List() overload) it would accept an ISpecification and run the expected query based on that specification.</span></span>

<span data-ttu-id="7e1a5-189">Этот подход имеет несколько преимуществ:</span><span class="sxs-lookup"><span data-stu-id="7e1a5-189">There are several benefits to this approach:</span></span>

* <span data-ttu-id="7e1a5-190">У спецификации есть имя (в отличие от нескольких выражений LINQ), которое можно обсудить.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-190">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

* <span data-ttu-id="7e1a5-191">Для спецификации можно выполнить изолированное модульное тестирование, чтобы проверить ее корректность.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-191">The specification can be unit tested in isolation to ensure it is right.</span></span> <span data-ttu-id="7e1a5-192">Ее также можно использовать повторно, если необходимо реализовать аналогичное поведение.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-192">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="7e1a5-193">Например, в действии представления MVC или действии веб-API, а также в различных службах.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-193">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

* <span data-ttu-id="7e1a5-194">Спецификацию также можно использовать для описания формы возвращаемых данных, поэтому эти запросы могут возвращать только необходимые данные.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-194">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="7e1a5-195">Это устраняет потребность в отложенной загрузке в веб-приложениях (использовать которую обычно не рекомендуется), а также позволяет избежать заполнения реализаций репозитория ненужными деталями.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-195">This eliminates the need for lazy loading in web applications (which is usually not a good idea) and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="7e1a5-196">Пример универсального интерфейса спецификации приведен в следующем коде из [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span><span class="sxs-lookup"><span data-stu-id="7e1a5-196">An example of a generic Specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb ).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb 
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="7e1a5-197">В следующих разделах описано, как реализовать шаблон спецификации в Entity Framework Core 2.0 и как использовать его из класса репозитория.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-197">In the upcoming sections, it is explained how to implement the Specification pattern with Entity Framework Core 2.0 and how to use it from any Repository class.</span></span>

<span data-ttu-id="7e1a5-198">**Важное замечание:** шаблон спецификации — это старый шаблон, который может быть реализован различными способами, как показано в следующих дополнительных материалах.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-198">**Important note:** The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="7e1a5-199">С более старыми подходами полезно ознакомиться в качестве шаблона или идеи. Но не стоит использовать старые реализации, в которых не используются возможности современных языков, таких как Linq, и выражения.</span><span class="sxs-lookup"><span data-stu-id="7e1a5-199">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="7e1a5-200">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="7e1a5-200">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="7e1a5-201">Шаблон репозитория</span><span class="sxs-lookup"><span data-stu-id="7e1a5-201">The Repository pattern</span></span>

-   <span data-ttu-id="7e1a5-202">**Эдвард Хиятт и Роб Ми (Edward Hieatt и Rob Mee). Шаблон репозитория.**
    [*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-202">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="7e1a5-203">**Шаблон репозитория**
    [*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-203">**The Repository pattern**
[*https://msdn.microsoft.com/library/ff649690.aspx*](https://msdn.microsoft.com/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="7e1a5-204">**Шаблон репозитория: Сохраняемости уровень абстракции данных**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-204">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="7e1a5-205">**Эрик Эванс (Eric Evans). Предметно-ориентированное проектирование (DDD). Структуризация сложных программных систем.**</span><span class="sxs-lookup"><span data-stu-id="7e1a5-205">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="7e1a5-206">(Книга; включает в себя обсуждение шаблон репозитория) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-206">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="7e1a5-207">Шаблон единицы работы</span><span class="sxs-lookup"><span data-stu-id="7e1a5-207">Unit of Work pattern</span></span>

-   <span data-ttu-id="7e1a5-208">**Мартин Фоулер (Martin Fowler). Единица работы шаблон.**
    [*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-208">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="7e1a5-209">**Реализация шаблонов репозитория и единиц работы в приложении ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-209">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="7e1a5-210">Шаблон спецификации</span><span class="sxs-lookup"><span data-stu-id="7e1a5-210">The Specification pattern</span></span>

-   <span data-ttu-id="7e1a5-211">**Шаблон спецификации.**
    [*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-211">**The Specification pattern.**
[*http://deviq.com/specification-pattern/*](http://deviq.com/specification-pattern/)</span></span>

-   <span data-ttu-id="7e1a5-212">**Эрик Эванс (2004). Предметно-ориентированное проектирование. Addison-Wesley. стр. 224.**</span><span class="sxs-lookup"><span data-stu-id="7e1a5-212">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

-   <span data-ttu-id="7e1a5-213">**Спецификации. Martin Fowler**
    [*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-213">**Specifications. Martin Fowler**
[*https://www.martinfowler.com/apsupp/spec.pdf/*](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="7e1a5-214">[Назад] (domain-events-design-implementation.md) [Далее] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="7e1a5-214">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
