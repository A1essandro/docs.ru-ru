---
title: "Реализация операции чтения и запросы в микрослужбу CQRS"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Реализация операции чтения и запросы в микрослужбу CQRS"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: e017aaaa701d8033110be8d6244d3e1120fc4fd9
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="implementing-readsqueries-in-a-cqrs-microservice"></a>Реализация операции чтения и запросы в микрослужбу CQRS

Для операций чтения и запросы упорядочивания микрослужбу из приложения ссылку eShopOnContainers реализует запросы независимо от модели DDD и область транзакций. Это было сделано потому, что требования для запросов и транзакций, значительно отличаются. Записывает выполнение операций, которые должны быть совместимыми с логикой домена. Запросы, с другой стороны, являются идемпотентными и могут быть выделены из правил домена.

Этот подход является простым, как показано на рисунке 9-3. API-интерфейса реализуется контроллеров веб-API, с помощью любой инфраструктуры (например, micro ORM, например Dapper) и возврат динамического ViewModels в зависимости от потребностей приложения пользовательского интерфейса.

![](./media/image3.png)

**Рис. 9-3**. Самый простой способ для запросов в микрослужбу CQRS

Это простейший возможный подход для запросов. Определения запросов запроса к базе данных и возвращают динамические ViewModel построен в режиме реального времени для каждого запроса. Поскольку запросы должны быть идемпотентными, они не изменит данные независимо от того, сколько раз выполнить запрос. Таким образом необходимо ограничить шаблоном ддд, используемые на стороне транзакций, например статистические функции и другие шаблоны, и поэтому запросы отделены от области транзакций. Вы просто запрашивают данные, необходимые для пользовательского интерфейса в базе данных и возвращают динамические ViewModel, не должен быть статически, определенных в любом месте (без классы ViewModels) за исключением в сами инструкции SQL.

Так как это простой подход, требуется код на стороне запросов (например, код, с помощью micro, ORM, например [Dapper](https://github.com/StackExchange/Dapper)) можно реализовать [в том же проекте веб-API](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.API/Application/Queries/OrderQueries.cs). Это показано на рис. 9-4. Определенные запросы в **Ordering.API** микрослужбу проекта в решение eShopOnContainers.

![](./media/image4.png)

**Рис. 9-4**. Запросы в микрослужбу упорядочения элементов в eShopOnContainers

## <a name="using-viewmodels-specifically-made-for-client-apps-independent-from-domain-model-constraints"></a>С помощью ViewModels специально создана для клиентских приложений, независимо от ограничений модели домена

Поскольку запросы выполняются для получения данных, необходимых клиентских приложений, возвращаемый тип может быть специально создана для клиентов, на основе данных, возвращенных запросами. Эти модели или объекты передачи данных (DTO), называются ViewModels.

Возвращаемые данные (ViewModel) может быть результатом объединения данных из нескольких сущностей или таблиц в базе данных или даже через несколько агрегатные функции, определенные в модели предметной области транзакций. Таким образом так как вы создаете запросы независимо от модели домена, статистические выражения границ и ограничения полностью игнорируются, и можно запрашивать любую таблицу и столбец, который может потребоваться. Такой подход обеспечивает большую гибкость и производительность для разработчиков, создание или обновление запросов.

ViewModels может быть статические типы, определенные в классах. Или они могут создаваться динамически на основании запросы, выполняемые (как реализована в микрослужбу порядка сортировки), который является очень гибкой для разработчиков.

## <a name="using-dapper-as-a-micro-orm-to-perform-queries"></a>С помощью Dapper как micro ORM для выполнения запросов 

Можно использовать любой микро-ORM, Entity Framework Core или даже простой ADO.NET для выполнения запросов. В примере приложения мы выбрали Dapper для упорядочивания микрослужбу в eShopOnContainers как хороший пример популярных micro ORM. Его можно запустить простой SQL-запросы с высокую производительность, так как это очень простой framework. С помощью Dapper, можно написать SQL-запроса, можно открыть и соединения нескольких таблиц.

Dapper проекта с открытым кодом (original созданные Сэм Сэффрон), который частью стандартных блоков, используемых в [переполнения стека](https://stackoverflow.com/). Чтобы использовать Dapper, вам следует установить его через [пакет Dapper NuGet](https://www.nuget.org/packages/Dapper), как показано на следующем рисунке.

![](./media/image5.png)

Также необходимо добавить с помощью инструкции, поэтому код имеет доступ к методам Dapper расширения.

При использовании Dapper в коде непосредственно используют класс SqlClient, доступны в пространстве имен System.Data.SqlClient. Через метод QueryAsync и другие методы расширения, которые расширяют класс SqlClient можно просто запустить запросы в простой и эффективный способ.

## <a name="dynamic-and-static-viewmodels"></a>Динамических и статических ViewModels

Как показано в следующем коде из упорядочивания микрослужбу большинство ViewModels, возвращенных запросами, реализуются как *динамическое*. Это означает, что к подмножеству атрибутов должны быть возвращены зависит от самого запроса. При добавлении нового столбца на запрос или соединение, возвращенный ViewModel динамически добавляется этих данных. Этот подход уменьшает необходимость изменения запросов в ответ на обновления для базовой модели данных, что этот подход более гибкими и нечувствительного к ошибкам будущих изменений.

```csharp
using Dapper;
using Microsoft.Extensions.Configuration;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Dynamic;
using System.Collections.Generic;

public class OrderQueries : IOrderQueries
{
    public async Task<IEnumerable<dynamic>> GetOrdersAsync()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Open();
            return await connection.QueryAsync<dynamic>(
@"SELECT o.[Id] as ordernumber,
o.[OrderDate] as [date],os.[Name] as [status],
SUM(oi.units*oi.unitprice) as total
FROM [ordering].[Orders] o
LEFT JOIN[ordering].[orderitems] oi ON o.Id = oi.orderid
LEFT JOIN[ordering].[orderstatus] os on o.OrderStatusId = os.Id
GROUP BY o.[Id], o.[OrderDate], os.[Name]");
        }
  }
}
```

Важно то, что с помощью динамический тип, возвращаемый набор данных будет динамически собирать как ViewModel.

Для большинства запросов не нужно предварительно определять класс DTO или ViewModel, который упрощает написание кода, их проще и продуктивным. Тем не менее можно заранее определить ViewModels (например, стандартные DTO), если вы хотите иметь ViewModels с определением больше ограничений, как контракты.

#### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Dapper**
    [*https://github.com/StackExchange/dapper-dot-net*](https://github.com/StackExchange/dapper-dot-net)

-   **Джули Лерман. Точки данных — Dapper, Entity Framework и гибридные приложения (статья MSDN Mag.)**

    *https://MSDN.Microsoft.com/en-US/Magazine/mt703432.aspx*


>[!div class="step-by-step"]
[Предыдущие] (eshoponcontainers-cqrs ддд microservice.md) [Далее] (ddd ориентированного microservice.md)
