---
title: "События домена. Проектирование и реализация"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | События домена, проектирования и реализации"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 2d98b302be4ee72d8225526944fc3e41cbadcb5f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="6168f-105">События домена: проектирование и реализация</span><span class="sxs-lookup"><span data-stu-id="6168f-105">Domain events: design and implementation</span></span>

<span data-ttu-id="6168f-106">События домена используйте явно реализовать побочные эффекты изменений в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="6168f-107">В другие слова и с помощью терминологии ддд домена события можно используйте чтобы явно реализовать побочные эффекты в несколько статистических выражений.</span><span class="sxs-lookup"><span data-stu-id="6168f-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="6168f-108">При необходимости для повышения масштабируемости и менее без влияния на блокировок базы данных используйте окончательной согласованности между статистические выражения в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="6168f-109">Что такое событие домена?</span><span class="sxs-lookup"><span data-stu-id="6168f-109">What is a domain event?</span></span>

<span data-ttu-id="6168f-110">Событие — это то, что произошло в прошлом.</span><span class="sxs-lookup"><span data-stu-id="6168f-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="6168f-111">События домена, логически, то, что произошло в определенном домене, и что-то предполагается домену (внутрипроцессный) следует учитывать и потенциально реагирования на другие части.</span><span class="sxs-lookup"><span data-stu-id="6168f-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="6168f-112">Важное преимущество событий домена — что побочные эффекты после что-то произошло в домене можно выразить явно вместо неявно.</span><span class="sxs-lookup"><span data-stu-id="6168f-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="6168f-113">Эти эффекты должны быть согласованы, либо все связанные с бизнес-задачи выполняются операции на стороне, или ни один из них.</span><span class="sxs-lookup"><span data-stu-id="6168f-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="6168f-114">Кроме того события домена включить лучшего разделения областей ответственности между классами в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="6168f-115">Например если используется только просто Entity Framework и сущности или даже статистических выражений, если должно быть в варианте использования вызывает побочные эффекты, те будет реализован в качестве неявного понятием в связанной кода после произошла ошибка.</span><span class="sxs-lookup"><span data-stu-id="6168f-115">For example, if you are just using just Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="6168f-116">Но видны только этот код может быть неизвестно, если этот код (побочным эффектом) является частью основной операции или если это побочный эффект.</span><span class="sxs-lookup"><span data-stu-id="6168f-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="6168f-117">С другой стороны использование события домена делает концепции явного и частью единый язык.</span><span class="sxs-lookup"><span data-stu-id="6168f-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="6168f-118">Например в приложении eShopOnContainers Создание заказа не практически порядке; он обновляет или создает статистические покупателя, на основе исходного пользователя, поскольку пользователь не является покупателем, до момента заказа.</span><span class="sxs-lookup"><span data-stu-id="6168f-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="6168f-119">При использовании события домена можно выразить явно, правило домена в единый язык, предоставляемые специалистами в предметной области.</span><span class="sxs-lookup"><span data-stu-id="6168f-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="6168f-120">События домена чем-то похожи на события стиле сообщений, с одним важным отличием.</span><span class="sxs-lookup"><span data-stu-id="6168f-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="6168f-121">С реальными обмена сообщениями, очереди сообщений, посредникам или service bus с помощью AMPQ сообщение всегда асинхронной рассылки и передается между процессами и компьютеров.</span><span class="sxs-lookup"><span data-stu-id="6168f-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="6168f-122">Это полезно для интеграции нескольких ограниченных контекстах, микрослужбами или даже в разных приложениях.</span><span class="sxs-lookup"><span data-stu-id="6168f-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="6168f-123">С событиями домена, необходимо вызвать событие операция домена, которым в данный момент работает, однако требуется никаких побочных эффектов, в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="6168f-124">События домена и их побочные эффекты (действия после этого запускается под управлением обработчики событий) должно выполняться почти мгновенно, обычно в процессе и в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="6168f-125">Таким образом события домена могут быть синхронными или асинхронными.</span><span class="sxs-lookup"><span data-stu-id="6168f-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="6168f-126">События интеграции, тем не менее, должно всегда выполняться асинхронно.</span><span class="sxs-lookup"><span data-stu-id="6168f-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="6168f-127">События домена и события интеграции</span><span class="sxs-lookup"><span data-stu-id="6168f-127">Domain events versus integration events</span></span>

<span data-ttu-id="6168f-128">Семантически, домена и интеграцию события — это то же самое: уведомления о том, произошедшего.</span><span class="sxs-lookup"><span data-stu-id="6168f-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="6168f-129">Тем не менее их реализации должны быть разными.</span><span class="sxs-lookup"><span data-stu-id="6168f-129">However, their implementation must be different.</span></span> <span data-ttu-id="6168f-130">События домена — это просто сообщений, отправленных на диспетчер событий домена, который может быть реализован как посредника в памяти, на основе контейнер IoC или любой другой метод.</span><span class="sxs-lookup"><span data-stu-id="6168f-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="6168f-131">С другой стороны события интеграции предназначено для распространения зафиксированных транзакций и обновления для дополнительных подсистем, вне зависимости от их других микрослужбами, ограниченных контекстах или даже внешними приложениями.</span><span class="sxs-lookup"><span data-stu-id="6168f-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="6168f-132">Следовательно, их следует выполнять, только если сущность успешно сохранен, так как во многих сценариях в случае сбоя всей операции эффективно никогда не происходило.</span><span class="sxs-lookup"><span data-stu-id="6168f-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="6168f-133">Дополнительно и как сказано выше, интеграция события должны быть основаны на асинхронное взаимодействие между несколькими микрослужбами (других ограниченных контекстах) или внешних систем и приложений.</span><span class="sxs-lookup"><span data-stu-id="6168f-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="6168f-134">Таким образом интерфейс шины событий должен некоторые инфраструктуры, которая позволяет процессу между и распределенных обмен данными между потенциально удаленной службы.</span><span class="sxs-lookup"><span data-stu-id="6168f-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="6168f-135">Он может основываться на коммерческих служебной шины, очереди, общей базы данных, используемый в качестве почтового ящика или любой другой распределенных и в идеале Push-уведомлений системы обмена сообщениями на основе.</span><span class="sxs-lookup"><span data-stu-id="6168f-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="6168f-136">События домена как предпочтительный способ запуска побочные эффекты в несколько агрегатов в том же домене</span><span class="sxs-lookup"><span data-stu-id="6168f-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="6168f-137">Если при выполнении команды, связанной с одного экземпляра агрегатной функции требует дополнительного домена правил для выполнения на один или несколько дополнительных статистических выражений, следует проектировании и реализации этих побочные эффекты, которое будет вызвано события домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="6168f-138">Как показано на рисунке 9-14 и как один из наиболее важные варианты использования, событие домена следует использовать для распространения изменений состояния в несколько агрегатов в одной модели домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="6168f-139">**Рис. 9-14**.</span><span class="sxs-lookup"><span data-stu-id="6168f-139">**Figure 9-14**.</span></span> <span data-ttu-id="6168f-140">События домена для обеспечения согласованности между несколько статистических выражений в том же домене</span><span class="sxs-lookup"><span data-stu-id="6168f-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="6168f-141">На рисунке когда пользователь инициирует заказ, событие OrderStarted домена запускает создание объекта покупателей в упорядочивания микрослужбу, на основе исходные сведения о пользователе из удостоверения микрослужбу (сведения о командой CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="6168f-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="6168f-142">Событие домена формируется с помощью агрегирования заказа при его создании в первую очередь.</span><span class="sxs-lookup"><span data-stu-id="6168f-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="6168f-143">Кроме того можно иметь статистические корневой подписан на события, вызванные члены его агрегатов (дочерние объекты).</span><span class="sxs-lookup"><span data-stu-id="6168f-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="6168f-144">Для экземпляра каждой дочерней сущности OrderItem может вызвать событие, когда цена товара превышает определенный промежуток или сумма продукта элементов слишком велико.</span><span class="sxs-lookup"><span data-stu-id="6168f-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="6168f-145">Агрегатные корневой можно получать эти события и выполнить расчет глобальных или статистической обработки.</span><span class="sxs-lookup"><span data-stu-id="6168f-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="6168f-146">Важно понимать, что это взаимодействие на основе событий не реализован непосредственно в статистические функции; необходимо реализовать обработчики событий для домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="6168f-147">Обработка событий домена является аспектом приложения.</span><span class="sxs-lookup"><span data-stu-id="6168f-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="6168f-148">Уровень модели домена должна быть направлена только на доменную логику — факторов расценит эксперта, не инфраструктуры приложений как обработчики и действий сохраняемости побочных эффектов, с помощью репозиториев.</span><span class="sxs-lookup"><span data-stu-id="6168f-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="6168f-149">Таким образом приложения слоя будет представлять уровень которой должны выглядеть домена обработчики событий, запускающего действия при возникновении события домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="6168f-150">События домена может также использоваться для запуска любого числа действий приложения и что является более важным, должен быть открытым, чтобы увеличить это число в будущем несвязанной способом.</span><span class="sxs-lookup"><span data-stu-id="6168f-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="6168f-151">Для экземпляра при его запуске, можно опубликовать событие домена для распространения, info или другими статистическими выражениями или даже для вызова действий приложения, таких как уведомления.</span><span class="sxs-lookup"><span data-stu-id="6168f-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="6168f-152">Основная задача — открыть количество действий для выполнения при возникновении события домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="6168f-153">Со временем действия и правила в домене и приложение будет увеличиваться.</span><span class="sxs-lookup"><span data-stu-id="6168f-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="6168f-154">Сложность или количество побочным эффектом действия, когда происходит событие будет увеличиваться, но если код были вместе с «связующего» (то есть просто создание экземпляров объектов с помощью нового ключевого слова в C\#), то каждый раз, вам необходимо, чтобы добавить новое действие необходимо для Изменение исходного кода.</span><span class="sxs-lookup"><span data-stu-id="6168f-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="6168f-155">Это может привести к новые ошибки, так как с каждой новое требование может потребоваться изменить исходный поток кода.</span><span class="sxs-lookup"><span data-stu-id="6168f-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="6168f-156">Это противоречит [Open или Closed принцип](https://en.wikipedia.org/wiki/Open/closed_principle) из [СПЛОШНОЙ](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="6168f-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="6168f-157">Это не единственная, исходный класс, оркестрация операции будет иметь, а, которая противоречит [один принцип ответственности (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="6168f-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="6168f-158">С другой стороны при использовании события домена можно создать точного и несвязанной реализация по возможности размещая обязанности, используя этот подход:</span><span class="sxs-lookup"><span data-stu-id="6168f-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="6168f-159">Отправьте команду (например, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="6168f-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="6168f-160">Получать команды в обработчике команды.</span><span class="sxs-lookup"><span data-stu-id="6168f-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="6168f-161">Выполните транзакцию одного статистического выражения.</span><span class="sxs-lookup"><span data-stu-id="6168f-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="6168f-162">(Необязательно) Вызов событий домена для побочные эффекты (например, OrderStartedDomainDvent).</span><span class="sxs-lookup"><span data-stu-id="6168f-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="6168f-163">Дескриптор домена события (в текущий процесс) thast выполнит откройте число побочные эффекты в нескольких статистических выражений или действий приложения.</span><span class="sxs-lookup"><span data-stu-id="6168f-163">Handle domain events (within the current process) thast will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="6168f-164">Пример:</span><span class="sxs-lookup"><span data-stu-id="6168f-164">For example:</span></span>
    -   <span data-ttu-id="6168f-165">Проверьте или создать метод Покупатель "и" Оплата ".</span><span class="sxs-lookup"><span data-stu-id="6168f-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="6168f-166">Создание и отправка событий связанных интеграции шину событий выходят за микрослужбами или триггера внешних действий Отправка сообщения электронной почты покупателю состояний.</span><span class="sxs-lookup"><span data-stu-id="6168f-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="6168f-167">Обрабатывать никаких побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="6168f-167">Handle other side effects.</span></span>

<span data-ttu-id="6168f-168">Как показано на рисунке 9-15, начиная с того же домена события, можно обрабатывать несколько действий, связанных с другими статистическими функциями в домене или дополнительное приложение действия, необходимые для выполнения между микрослужбами соединение с помощью интеграции событий и событий шины.</span><span class="sxs-lookup"><span data-stu-id="6168f-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="6168f-169">**Рис. 9-15**.</span><span class="sxs-lookup"><span data-stu-id="6168f-169">**Figure 9-15**.</span></span> <span data-ttu-id="6168f-170">Обработка нескольких действий в домене</span><span class="sxs-lookup"><span data-stu-id="6168f-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="6168f-171">Обработчики событий обычно являются на уровне приложения, так как объекты инфраструктуры, такие как репозиториев или API, приложение будет использовать для микрослужбу поведения.</span><span class="sxs-lookup"><span data-stu-id="6168f-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="6168f-172">В этом смысле обработчики событий аналогичны обработчики команд, поэтому оба являются частью на уровне приложения.</span><span class="sxs-lookup"><span data-stu-id="6168f-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="6168f-173">Важное отличие заключается в том, что команды должны обрабатываться только один раз.</span><span class="sxs-lookup"><span data-stu-id="6168f-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="6168f-174">Событие домена может быть обработано ноль или  *n*  время ожидания, поскольку если могут быть получены нескольких получателей или обработчики событий с целью разных для каждого обработчика.</span><span class="sxs-lookup"><span data-stu-id="6168f-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="6168f-175">Возможность открыть количество обработчиков на событие домена позволяет добавлять множество дополнительных правил домена без влияния на текущий код.</span><span class="sxs-lookup"><span data-stu-id="6168f-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="6168f-176">Например реализации следующих бизнес-правила, не произошло справа после события может быть так же легко, как добавить несколько обработчиков событий (или хотя бы один):</span><span class="sxs-lookup"><span data-stu-id="6168f-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="6168f-177">Общая сумма, приобретенных клиентом в хранилище через любое количество заказов, превышает 6000, применяются 10% от скидки каждый новый заказ и уведомление клиента с адресом электронной почты об этой скидки для заказов в будущем.</span><span class="sxs-lookup"><span data-stu-id="6168f-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="6168f-178">Реализация событий в домене</span><span class="sxs-lookup"><span data-stu-id="6168f-178">Implementing domain events</span></span>

<span data-ttu-id="6168f-179">В C# событие домена является просто хранения данных структуры или класса, например DTO, со всеми сведениями, связанные с произошедшее в домене, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="6168f-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : IAsyncNotification
{
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
        int cardTypeId, string cardNumber,
        string cardSecurityNumber, string cardHolderName,
        DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="6168f-180">Это по сути класс, содержащий все данные, относящиеся к событию OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="6168f-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="6168f-181">С точки зрения единый язык домена так как событие является то, что произошло в прошлом, имя класса события должны быть представлены как команда прошедшем времени, например OrderStartedDomainEvent или OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="6168f-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="6168f-182">Это реализации упорядочивания микрослужбу в eShopOnContainers событие домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="6168f-183">Как мы отмечали важной характеристикой событий является, так как событие является то, что произошло в прошлом, не следует изменять.</span><span class="sxs-lookup"><span data-stu-id="6168f-183">As we have noted, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="6168f-184">Поэтому он должен являться неизменяемого класса.</span><span class="sxs-lookup"><span data-stu-id="6168f-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="6168f-185">Вы увидите в приведенном выше коде, что свойства доступны только для чтения вне объекта.</span><span class="sxs-lookup"><span data-stu-id="6168f-185">You can see in the preceding code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="6168f-186">Единственный способ обновления объекта — через конструктор при создании объекта события.</span><span class="sxs-lookup"><span data-stu-id="6168f-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="6168f-187">Создание домена событий</span><span class="sxs-lookup"><span data-stu-id="6168f-187">Raising domain events</span></span>

<span data-ttu-id="6168f-188">Следующий вопрос заключается в том, как инициировать событие домена, поэтому достигнет соответствующих обработчиков событий, связанных.</span><span class="sxs-lookup"><span data-stu-id="6168f-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="6168f-189">Можно использовать несколько подходов.</span><span class="sxs-lookup"><span data-stu-id="6168f-189">You can use multiple approaches.</span></span>

<span data-ttu-id="6168f-190">Ранее было предложено UDI Dahan (например, в нескольких связанных записей, такие как [события домена — требует 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) с помощью статического класса для управления и вызов событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="6168f-191">Сюда могут относиться статический класс с именем DomainEvents, приведет к возникновению событий домена немедленно в том случае, когда он вызывается с помощью синтаксиса, подобного DomainEvents.Raise (событие myEvent).</span><span class="sxs-lookup"><span data-stu-id="6168f-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="6168f-192">Джимми Богард производили запись в блоге ([повышению уровня домена: события домена](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)), корпорация Майкрософт рекомендует подобный подход.</span><span class="sxs-lookup"><span data-stu-id="6168f-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="6168f-193">Тем не менее если класс событий домена является статическим, он также отправляет обработчикам немедленно.</span><span class="sxs-lookup"><span data-stu-id="6168f-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="6168f-194">Это усложняет тестирование и отладка, поскольку обработчики событий с логикой побочные эффекты выполняются сразу же после события.</span><span class="sxs-lookup"><span data-stu-id="6168f-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="6168f-195">Тестирование и отладка необходимо сосредоточиться на и только что происходит в текущей статистической классов. не требуется внезапно перенаправляться на другие обработчики для побочные эффекты, связанные с другими статистические функции или логику приложения.</span><span class="sxs-lookup"><span data-stu-id="6168f-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="6168f-196">Именно поэтому других подходов, отражающих развитие, как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="6168f-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="6168f-197">Отложенное подход для вызова и диспетчеризации событий</span><span class="sxs-lookup"><span data-stu-id="6168f-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="6168f-198">Вместо немедленно диспетчеризации с обработчиком событий домена, лучшим подходом является добавление событий в коллекцию и последующей отправки этих событий домена *прямо перед* или *правой*  *После* фиксации транзакции (как при использовании SaveChanges в EF).</span><span class="sxs-lookup"><span data-stu-id="6168f-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="6168f-199">(Джимми Богард описанного этот подход в этой записи [лучше шаблон события домена](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="6168f-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="6168f-200">Выбор при отправке события домена до или правом сразу после фиксации транзакции важна, так как он определяет, включаются ли в рамках одной транзакции или в разных транзакциях побочные эффекты.</span><span class="sxs-lookup"><span data-stu-id="6168f-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="6168f-201">В последнем случае необходимо работать с окончательной согласованности между несколько статистических выражений.</span><span class="sxs-lookup"><span data-stu-id="6168f-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="6168f-202">В этом разделе рассматривается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="6168f-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="6168f-203">Отложенное подход заключается в какой eShopOnContainers используется.</span><span class="sxs-lookup"><span data-stu-id="6168f-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="6168f-204">Сначала добавьте событиях, происходящих в сущностях в коллекцию или список событий по сущности.</span><span class="sxs-lookup"><span data-stu-id="6168f-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="6168f-205">Этот список должно быть частью объекта сущности или даже лучше, частью базовой сущности класса, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="6168f-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example:</span></span>

```csharp
public abstract class Entity
{
    private List<IAsyncNotification> _domainEvents;

    public List<IAsyncNotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(IAsyncNotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<IAsyncNotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(IAsyncNotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="6168f-206">При необходимости создайте событие, нужно просто добавить его в коллекцию событий для размещения в методе статистические сущности, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="6168f-206">When you want to raise an event, you just add it to the event collection to be placed within an aggregate entity method, as the following code shows:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
    cardTypeId,
    cardNumber,
    cardSecurityNumber,
    cardHolderName,
    cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="6168f-207">Обратите внимание, что единственное, что делает AddDomainEvent метод добавления события в список.</span><span class="sxs-lookup"><span data-stu-id="6168f-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="6168f-208">Событие не возникает еще и нет обработчика вызывается еще.</span><span class="sxs-lookup"><span data-stu-id="6168f-208">No event is raised yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="6168f-209">Фактически вы хотите позже на диспетчеризации событий при фиксации транзакции в базу данных.</span><span class="sxs-lookup"><span data-stu-id="6168f-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="6168f-210">При использовании Entity Framework Core, то есть в метод SaveChanges вашей EF DbContext, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="6168f-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<int> SaveEntitiesAsync()
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);
        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="6168f-211">Этот код отправляют события объектов в их обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="6168f-212">Общий результат является, что вы лишается вызова события домена (простого добавления в список в памяти) распределения его в обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="6168f-213">Кроме того в зависимости от того, какого рода dispatcher используется, может отправлять события синхронно или асинхронно.</span><span class="sxs-lookup"><span data-stu-id="6168f-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="6168f-214">Имейте в виду здесь воспроизвести границы транзакций, следует учитывать значительные.</span><span class="sxs-lookup"><span data-stu-id="6168f-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="6168f-215">Если единиц работы и транзакция может охватывать более одного агрегата (как при использовании EF Core и реляционной базы данных), это может работать хорошо.</span><span class="sxs-lookup"><span data-stu-id="6168f-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="6168f-216">Но если транзакция не может включать статистические выражения, например при использовании баз данных NoSQL, таких как Azure DocumentDB необходимо реализовывать дополнительные шаги для поддержания согласованности.</span><span class="sxs-lookup"><span data-stu-id="6168f-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="6168f-217">Это еще одна причина, почему сохраняемости не является универсальной; Это зависит от используемой системы хранения.</span><span class="sxs-lookup"><span data-stu-id="6168f-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="6168f-218">Одной транзакции между статистические выражения и окончательной согласованности между статистические функции</span><span class="sxs-lookup"><span data-stu-id="6168f-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="6168f-219">Вопрос, следует ли выполнять одной транзакции между статистические выражения и полагаться на окончательной согласованности между этими статистические выражения является противоречивым.</span><span class="sxs-lookup"><span data-stu-id="6168f-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="6168f-220">DDD инструкция SQL, как Eric Evans и Vernon Вон представление правило, одна транзакция = одного агрегата и поэтому аргументы в пользу окончательной согласованности между статистических выражений.</span><span class="sxs-lookup"><span data-stu-id="6168f-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="6168f-221">Например, в своей книге *сей разработки*, Eric Evans указано следующее:</span><span class="sxs-lookup"><span data-stu-id="6168f-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="6168f-222">Любое правило, охватывающий статистические выражения, не следует ожидать будут обновленными в любое время.</span><span class="sxs-lookup"><span data-stu-id="6168f-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="6168f-223">Посредством обработки события, пакетная обработка или другие механизмы обновления другие зависимости, могут быть устранены в некоторых определенное время.</span><span class="sxs-lookup"><span data-stu-id="6168f-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="6168f-224">(стр.</span><span class="sxs-lookup"><span data-stu-id="6168f-224">(pg.</span></span> <span data-ttu-id="6168f-225">128)</span><span class="sxs-lookup"><span data-stu-id="6168f-225">128)</span></span>

<span data-ttu-id="6168f-226">Vernon Вон говорится в следующие [эффективной статистической схемы. Часть II: Создание агрегирует рабочих вместе](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="6168f-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="6168f-227">Таким образом, если выполнение команды для одного экземпляра агрегатной функции требует, что дополнительные бизнес-правила выполнения на один или несколько статистических выражений, используйте окончательной согласованности \[...\] Нет удобным способом для поддержки окончательной согласованности в модели ддд.</span><span class="sxs-lookup"><span data-stu-id="6168f-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="6168f-228">Статистический метод публикует домена событие, которое времени для одного или нескольких подписчиков асинхронной.</span><span class="sxs-lookup"><span data-stu-id="6168f-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="6168f-229">Является основой на принятие детально транзакции вместо транзакциях, объединяющих несколько статистических выражений или сущности.</span><span class="sxs-lookup"><span data-stu-id="6168f-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="6168f-230">Идея заключается во втором случае числа блокировок базы данных будет значительной в больших приложениях с высокой масштабируемостью.</span><span class="sxs-lookup"><span data-stu-id="6168f-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="6168f-231">Тот факт, что высокий масштабируемых приложений должны использоваться мгновенных транзакционную согласованность между несколькими статистические выражения в рамках помогает принимать концепцию окончательной согласованности.</span><span class="sxs-lookup"><span data-stu-id="6168f-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="6168f-232">Указанные изменения часто не нужны бизнес и отвечает в любом случае экспертов домена можно сказать, необходимы ли определенных операций атомарные транзакции.</span><span class="sxs-lookup"><span data-stu-id="6168f-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="6168f-233">Если операция всегда должен атомарной транзакции между несколькими статистические выражения, может запросить ли ваш статистическое выражение должно быть больше или не был правильно разработанный.</span><span class="sxs-lookup"><span data-stu-id="6168f-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="6168f-234">Тем не менее, другие разработчики и архитекторы, как Джимми Богард не затронуты охват одной транзакции через несколько статистических выражений, но только если эти дополнительные статистические выражения относятся к побочные эффекты для одной и той же исходной команды.</span><span class="sxs-lookup"><span data-stu-id="6168f-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="6168f-235">Например, в [лучше шаблон события домена](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Богард указано следующее:</span><span class="sxs-lookup"><span data-stu-id="6168f-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="6168f-236">Как правило, требуется побочные эффекты домена события происходят в одной и той же логической транзакции, но не в той же области домена события \[...\] Непосредственно перед мы зафиксировать наш транзакцию, мы перенаправления нашей их соответствующих обработчиков событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="6168f-237">Если диспетчеризации событий право домена *перед* фиксации исходной транзакции, это означает, что вы хотите побочные эффекты этих событий, которые будут включены в той же транзакции.</span><span class="sxs-lookup"><span data-stu-id="6168f-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="6168f-238">Например при сбое метода EF DbContext SaveChanges, будет произведен откат транзакции все изменения, включая результат операций побочный эффект, реализуемый обработчики событий связанных доменах.</span><span class="sxs-lookup"><span data-stu-id="6168f-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="6168f-239">Это имеет поскольку область DbContext жизни по умолчанию определяется как «область.»</span><span class="sxs-lookup"><span data-stu-id="6168f-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="6168f-240">Таким образом объект DbContext распределяется между несколькими объектами репозитория, создание экземпляров в пределах одной области или в граф объекта.</span><span class="sxs-lookup"><span data-stu-id="6168f-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="6168f-241">Совпадает с областью HttpRequest при разработке веб-API или MVC-приложений.</span><span class="sxs-lookup"><span data-stu-id="6168f-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="6168f-242">На самом деле оба подхода (одной атомарной транзакции и окончательной согласованности) может быть справа.</span><span class="sxs-lookup"><span data-stu-id="6168f-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="6168f-243">Это зависит домена или бизнес-требований и что специалистами в предметной области сообщить.</span><span class="sxs-lookup"><span data-stu-id="6168f-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="6168f-244">Он также зависит от как масштабируемой необходима служба быть (более детального транзакции не нарушать по отношению к базе данных блокировки).</span><span class="sxs-lookup"><span data-stu-id="6168f-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="6168f-245">И он зависит от того, какой объем инвестиций вы готовы внести в код, поскольку для окончательной согласованности требуется более сложный код для обнаружения несогласованности между статистические выражения и необходимость реализации Компенсационный выходной действия.</span><span class="sxs-lookup"><span data-stu-id="6168f-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="6168f-246">Принять во внимание, что при фиксации изменений для исходной статистических вычислений, и после этого при событиях доставляются, имеется ли проблема и обработчики событий не удается зафиксировать их побочные эффекты, будет иметь несоответствия между статистические выражения.</span><span class="sxs-lookup"><span data-stu-id="6168f-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="6168f-247">Способ предоставления Компенсационный выходной действия будет хранить события домена в таблицах дополнительную базу данных, чтобы они могли быть частью исходной транзакции.</span><span class="sxs-lookup"><span data-stu-id="6168f-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="6168f-248">После этого можно создать пакетную обработку, которая обнаруживает несогласованности и выполняет Компенсационный выходной действия путем сравнения список событий с текущим состоянием статистические выражения.</span><span class="sxs-lookup"><span data-stu-id="6168f-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="6168f-249">Компенсационный выходной действия являются частью сложная тема, требующей глубокий анализ с вашей стороны, включая обсуждали ее с бизнес-пользователь и специалистами в предметной области.</span><span class="sxs-lookup"><span data-stu-id="6168f-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="6168f-250">В любом случае можно выбрать подход, что нужно.</span><span class="sxs-lookup"><span data-stu-id="6168f-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="6168f-251">Но первоначального отложенное подход — вызов событий перед фиксацией, чтобы использовать одну транзакцию — наиболее простой подход, при использовании EF Core и реляционной базе данных.</span><span class="sxs-lookup"><span data-stu-id="6168f-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="6168f-252">Это проще реализовать и допустимым во многих случаях бизнеса.</span><span class="sxs-lookup"><span data-stu-id="6168f-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="6168f-253">Это также этот подход используется в упорядочивания микрослужбу в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="6168f-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="6168f-254">Но, как вы фактически отправляют эти события в их обработчики событий?</span><span class="sxs-lookup"><span data-stu-id="6168f-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="6168f-255">Что такое \_объект посредником, содержатся в предыдущем примере?</span><span class="sxs-lookup"><span data-stu-id="6168f-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="6168f-256">Его методы и артефакты, которые можно использовать для сопоставления событий и их обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="6168f-257">Диспетчер событий домена: сопоставление из журналов событий для обработчиков событий</span><span class="sxs-lookup"><span data-stu-id="6168f-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="6168f-258">После возможность перенаправлять или публикация событий, необходимо каким-либо артефакта, который будет публиковать события, чтобы каждый связанный обработчик может получить его, и процесс побочные эффекты на основе этого события.</span><span class="sxs-lookup"><span data-stu-id="6168f-258">Once you are able to dispatch or publish the events, you need some kind of artifact that will publish the event so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="6168f-259">Один из подходов заключается в системе real обмена сообщениями или даже события, возможно на основе шины на служебной шины, в отличие от событий в памяти.</span><span class="sxs-lookup"><span data-stu-id="6168f-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="6168f-260">Однако в случае первого реальный обмен сообщениями бы чрезмерными для обработки события домена, поскольку необходимо обработать эти события в одном процессе (то есть, в том же слое домена и приложения).</span><span class="sxs-lookup"><span data-stu-id="6168f-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="6168f-261">Другой способ сопоставить события нескольких обработчиков событий — с помощью регистрации типов в контейнер IoC, чтобы могут динамически определять место для отправки событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="6168f-262">Другими словами необходимо знать, какие обработчики событий необходимо получить определенное событие.</span><span class="sxs-lookup"><span data-stu-id="6168f-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="6168f-263">Упрощенный подход, показаны на рис. 9-16.</span><span class="sxs-lookup"><span data-stu-id="6168f-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="6168f-264">**На рисунке 9 – 16**.</span><span class="sxs-lookup"><span data-stu-id="6168f-264">**Figure 9-16**.</span></span> <span data-ttu-id="6168f-265">Диспетчер событий домена с помощью IoC</span><span class="sxs-lookup"><span data-stu-id="6168f-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="6168f-266">Можно построить коммуникации и артефакты для реализации такого подхода самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="6168f-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="6168f-267">Тем не менее, можно использовать доступных библиотек как [MediatR](https://github.com/jbogard/MediatR), в системе использующий IoT контейнера.</span><span class="sxs-lookup"><span data-stu-id="6168f-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="6168f-268">Может поэтому напрямую использовать стандартные интерфейсы и методы объекта посредником публикации диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="6168f-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="6168f-269">В коде необходимо сначала зарегистрировать типы обработчиков событий в контейнер IoC, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="6168f-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example:</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement
        // IAsyncNotificationHandler<>) in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(
            typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
            .GetTypeInfo().Assembly)
            .Where(t => t.IsClosedTypeOf(typeof(IAsyncNotificationHandler<>)))
            .AsImplementedInterfaces();
        // Other registrations ...
    }
}
```

<span data-ttu-id="6168f-270">Код сначала идентифицирует сборку, которая содержит обработчики событий домена, найдя сборку, которая содержит все обработчики (с помощью typeof(ValidateOrAddBuyerAggregateWhenXxxx), но можно выбрать другой обработчик событий для обнаружения сборки).</span><span class="sxs-lookup"><span data-stu-id="6168f-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="6168f-271">Поскольку все обработчики событий реализует интерфейс IAsyncNotificationHandler, код, а затем просто ищет те типы и регистрирует все обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="6168f-272">Как подписаться на события домена</span><span class="sxs-lookup"><span data-stu-id="6168f-272">How to subscribe to domain events</span></span>

<span data-ttu-id="6168f-273">При использовании MediatR каждый обработчик событий, необходимо использовать тип событий, который предоставляется на универсальный параметр IAsyncNotificationHandler интерфейса, как видно в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="6168f-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the IAsyncNotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="6168f-274">На основе связи между событием и обработчик событий, который может считаться подписки, артефакта MediatR может обнаружить все обработчики событий для каждого события и запустить каждый из этих обработчиков событий.</span><span class="sxs-lookup"><span data-stu-id="6168f-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="6168f-275">Способ обработки событий домена</span><span class="sxs-lookup"><span data-stu-id="6168f-275">How to handle domain events</span></span>

<span data-ttu-id="6168f-276">Наконец обработчик события обычно реализует приложения слой кода, использующего репозиториев инфраструктуры для получения необходимых дополнительных агрегатов и для выполнения логики домена побочных эффектов.</span><span class="sxs-lookup"><span data-stu-id="6168f-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="6168f-277">Вот пример кода:</span><span class="sxs-lookup"><span data-stu-id="6168f-277">The following code shows an example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
    : IAsyncNotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;
    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // Parameter validations
        //...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ?
            orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;
        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }
        buyer.VerifyOrAddPaymentMethod(cardTypeId,
            $"Payment Method on {DateTime.UtcNow}",
            orderStartedEvent.CardNumber,
            orderStartedEvent.CardSecurityNumber,
            orderStartedEvent.CardHolderName,
            orderStartedEvent.CardExpiration,
            orderStartedEvent.Order.Id);
        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) :
        _buyerRepository.Add(buyer);
        await _buyerRepository.UnitOfWork.SaveEntitiesAsync();
        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="6168f-278">Этот код обработчика событий считается код уровня приложения так, как она использует инфраструктуру репозиториев, как описано в следующем разделе на уровне инфраструктуры сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="6168f-278">This event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="6168f-279">Обработчики событий также можно использовать другие компоненты инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="6168f-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="6168f-280">События домена может создавать события интеграции для публикации вне границ микрослужбу</span><span class="sxs-lookup"><span data-stu-id="6168f-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="6168f-281">Наконец важно говоря о том, что иногда может потребоваться распространяется на несколько микрослужбами события.</span><span class="sxs-lookup"><span data-stu-id="6168f-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="6168f-282">Считается интеграции события и может быть опубликован через шину событий из любого обработчика событий для конкретного домена.</span><span class="sxs-lookup"><span data-stu-id="6168f-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="6168f-283">Выводы о событиях домена</span><span class="sxs-lookup"><span data-stu-id="6168f-283">Conclusions on domain events</span></span> 

<span data-ttu-id="6168f-284">Как уже говорилось, используйте события домена явно реализовать побочные эффекты изменений в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="6168f-285">Чтобы использовать DDD терминология, домена события можно используйте для явно реализовать побочные эффекты в один или несколько статистических выражений.</span><span class="sxs-lookup"><span data-stu-id="6168f-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="6168f-286">Кроме того и для повышения масштабируемости и меньше влияет на блокировки базы данных используйте окончательной согласованности между статистические выражения в том же домене.</span><span class="sxs-lookup"><span data-stu-id="6168f-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="6168f-287">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="6168f-287">Additional resources</span></span>

-   <span data-ttu-id="6168f-288">**Грег Янг. Что такое событие домена? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="6168f-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="6168f-289">**Stenberg января. События домена и окончательной согласованности**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="6168f-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="6168f-290">**Джимми Богард (Jimmy Bogard). Шаблон события лучше домена**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="6168f-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="6168f-291">**Вон Вернон (Vaughn Vernon). Эффективных статистических конструктора, часть II: Внесения рабочих статистические выражения вместе**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_статьи или Vernon\_2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="6168f-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="6168f-292">**Джимми Богард (Jimmy Bogard). Усиление домена: события домена**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="6168f-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="6168f-293">**Tony Truong. События домена шаблона пример**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="6168f-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="6168f-294">**UDI Dahan. Как создать полностью инкапсулирован моделей домена**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="6168f-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="6168f-295">**UDI Dahan. События домена — требует 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="6168f-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="6168f-296">**UDI Dahan. События домена — дать**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="6168f-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="6168f-297">**Kronquist января. Не публиковать события домена, возвращают их! ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="6168f-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="6168f-298">**Сезар де ла Торре (Cesar de la Torre). Vs событий домена. События интеграции в архитектурах ддд и микрослужбами**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="6168f-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="6168f-299">[Предыдущие] (клиент стороны validation.md) [Далее] (инфраструктуры сохраняемости слоя design.md)</span><span class="sxs-lookup"><span data-stu-id="6168f-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
