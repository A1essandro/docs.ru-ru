---
title: Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: f429bc0c6e76c2be2e4f491768a15ab36ecb0d34
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33591098"
---
# <a name="deploying-single-container-based-net-core-web-applications-on-linux-or-windows-nano-server-hosts"></a><span data-ttu-id="0e194-103">Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server</span><span class="sxs-lookup"><span data-stu-id="0e194-103">Deploying Single-Container-Based .NET Core Web Applications on Linux or Windows Nano Server Hosts</span></span>

<span data-ttu-id="0e194-104">*Контейнеры Docker можно использовать для монолитного развертывания простых веб-приложений. Это позволяет оптимизировать процессы непрерывной интеграции и непрерывного развертывания, а также добиться успешного развертывания в рабочей среде. Вам больше не придется гадать, почему решение, работающее на вашем компьютере, не работает в рабочей среде?*</span><span class="sxs-lookup"><span data-stu-id="0e194-104">*You can use Docker containers for monolithic deployment of simpler web applications. This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success. No more “It works in my machine, why does not work in production?”*</span></span>

<span data-ttu-id="0e194-105">Архитектура на основе микрослужб имеет много преимуществ, но обратной стороной является повышение сложности.</span><span class="sxs-lookup"><span data-stu-id="0e194-105">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="0e194-106">В некоторых случаях затраты перевешивают преимущества и лучше прибегнуть к монолитному развертыванию приложения в одном контейнере или буквально нескольких.</span><span class="sxs-lookup"><span data-stu-id="0e194-106">In some cases, the costs outweigh the benefits, and you will be better served with a monolithic deployment application running in a single container or in just a few containers.</span></span> 

<span data-ttu-id="0e194-107">Монолитное приложение может быть непросто разделить на отдельные микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="0e194-107">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="0e194-108">Вы уже знаете, что разделение должно производиться на основе функций: микрослужбы должны работать независимо друг от друга для повышения отказоустойчивости приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-108">You have learned that these should be partitioned by function: microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="0e194-109">Если приложение невозможно разложить на функциональные составляющие, то его разделение лишь увеличит сложность.</span><span class="sxs-lookup"><span data-stu-id="0e194-109">If you cannot deliver feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="0e194-110">Приложению пока может не требоваться независимое масштабирование компонентов.</span><span class="sxs-lookup"><span data-stu-id="0e194-110">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="0e194-111">Предположим, что на ранних этапах объем трафика приложения eShopOnContainers, которые мы используем в качестве примера, не оправдывал разнесения функций по отдельным микрослужбам.</span><span class="sxs-lookup"><span data-stu-id="0e194-111">Let’s suppose that early in the life of our eShopOnContainers reference application, the traffic did not justify separating features into different microservices.</span></span> <span data-ttu-id="0e194-112">Объем трафика был достаточно невелик, поэтому добавление ресурсов в одну службу обычно означало их добавление для всех служб.</span><span class="sxs-lookup"><span data-stu-id="0e194-112">Traffic was small enough that adding resources to one service typically meant adding resources to all services.</span></span> <span data-ttu-id="0e194-113">Разделение приложения на отдельные службы требовало дополнительных усилий, но давало минимальные преимущества.</span><span class="sxs-lookup"><span data-stu-id="0e194-113">The additional work to separate the application into discrete services provided minimal benefit.</span></span>

<span data-ttu-id="0e194-114">Кроме того, на ранних этапах развертывания приложения может отсутствовать ясное представление о том, где пролегают границы между функциональными областями.</span><span class="sxs-lookup"><span data-stu-id="0e194-114">Also, early in the development of an application you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="0e194-115">В процессе разработки продукта, обладающего минимальным необходимым набором возможностей, его естественное разделение на части может быть не очевидным.</span><span class="sxs-lookup"><span data-stu-id="0e194-115">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span>

<span data-ttu-id="0e194-116">Некоторые из этих условий могут быть временными.</span><span class="sxs-lookup"><span data-stu-id="0e194-116">Some of these conditions might be temporary.</span></span> <span data-ttu-id="0e194-117">Вы можете сначала создать монолитное приложение, а в дальнейшем отделить некоторые компоненты для разработки и развертывания в качестве микрослужб.</span><span class="sxs-lookup"><span data-stu-id="0e194-117">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="0e194-118">Другие условия могут быть неотъемлемыми особенностями приложения. Это означает, что приложение в принципе невозможно разделить на несколько микрослужб.</span><span class="sxs-lookup"><span data-stu-id="0e194-118">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="0e194-119">Разделение приложения на множество отдельных процессов также приводит к накладным расходам.</span><span class="sxs-lookup"><span data-stu-id="0e194-119">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="0e194-120">При разделении компонента на несколько процессов повышается сложность.</span><span class="sxs-lookup"><span data-stu-id="0e194-120">There is more complexity in separating features into different processes.</span></span> <span data-ttu-id="0e194-121">Усложняются протоколы обмена данными.</span><span class="sxs-lookup"><span data-stu-id="0e194-121">The communication protocols become more complex.</span></span> <span data-ttu-id="0e194-122">Вместо вызовов методов необходимо использовать асинхронное взаимодействие между службами.</span><span class="sxs-lookup"><span data-stu-id="0e194-122">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="0e194-123">При переходе на архитектуру микрослужб необходимо добавить множество стандартных блоков, реализованных в версии приложения eShopOnContainers на основе микрослужб: обработку шины событий, отказоустойчивость и повторную отправку сообщений, итоговую согласованность и многое другое.</span><span class="sxs-lookup"><span data-stu-id="0e194-123">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="0e194-124">Гораздо более простая версия приложения eShopOnContainers (которая называется [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) и находится в том же репозитории GitHub) работает как монолитное приложение MVC. Как было сказано только что, такой подход имеет свои преимущества.</span><span class="sxs-lookup"><span data-stu-id="0e194-124">A much-simplified version of eShopOnContainers (named [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) and included in the same GitHub repo) runs as a monolithic MVC application, and as just described, there are advantages offered by that design choice.</span></span> <span data-ttu-id="0e194-125">Вы можете скачать исходный код этого приложения из GitHub и запустить его в локальной системе.</span><span class="sxs-lookup"><span data-stu-id="0e194-125">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="0e194-126">Даже такое монолитное приложение выигрывает от развертывания в контейнерной среде.</span><span class="sxs-lookup"><span data-stu-id="0e194-126">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="0e194-127">Во-первых, контейнерное развертывание означает, что каждый экземпляр приложения выполняется в одной и той же среде.</span><span class="sxs-lookup"><span data-stu-id="0e194-127">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="0e194-128">Это относится и к среде разработки, в которой проводятся начальные этапы тестирования и разработки.</span><span class="sxs-lookup"><span data-stu-id="0e194-128">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="0e194-129">Команда разработчиков может запускать приложение в контейнерной среде, которая аналогична рабочей.</span><span class="sxs-lookup"><span data-stu-id="0e194-129">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="0e194-130">Кроме того, контейнерные приложения обеспечивают более экономичное горизонтальное масштабирование.</span><span class="sxs-lookup"><span data-stu-id="0e194-130">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="0e194-131">Как вы уже видели, контейнерная среда позволяет эффективнее организовывать совместное использование ресурсов, чем традиционные среды виртуальных машин.</span><span class="sxs-lookup"><span data-stu-id="0e194-131">As you saw earlier, the container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="0e194-132">Наконец, помещая приложение в контейнеры, вы разделяете бизнес-логику и сервер хранилища.</span><span class="sxs-lookup"><span data-stu-id="0e194-132">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="0e194-133">По мере масштабирования приложения все контейнеры будут использовать один физический носитель данных.</span><span class="sxs-lookup"><span data-stu-id="0e194-133">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="0e194-134">Как правило, это сервер высокой доступности с базой данных SQL Server.</span><span class="sxs-lookup"><span data-stu-id="0e194-134">This would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="application-tour"></a><span data-ttu-id="0e194-135">Обзор приложения</span><span class="sxs-lookup"><span data-stu-id="0e194-135">Application tour</span></span>

<span data-ttu-id="0e194-136">Приложение [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) реализует некоторые возможности приложения eShopOnContainers, но работает как монолитное приложение MVC ASP.NET Core на основе .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0e194-136">The [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) application represents some of the eShopOnContainers application running as a monolithic application—an ASP.NET Core MVC based application running on .NET Core.</span></span> <span data-ttu-id="0e194-137">В основном оно предоставляет возможности просмотра каталога, которые описывались в предыдущих разделах.</span><span class="sxs-lookup"><span data-stu-id="0e194-137">It mainly provides the catalog browsing capabilities that we described in earlier sections.</span></span>

<span data-ttu-id="0e194-138">Для хранения каталога приложение использует базу данных SQL Server.</span><span class="sxs-lookup"><span data-stu-id="0e194-138">The application uses a SQL Server database for the catalog storage.</span></span> <span data-ttu-id="0e194-139">В развертываниях на основе контейнеров это монолитное приложение имеет доступ к тому же хранилищу данных, что и приложение на основе микрослужб.</span><span class="sxs-lookup"><span data-stu-id="0e194-139">In container-based deployments, this monolithic application can access the same data store as the microservices-based application.</span></span> <span data-ttu-id="0e194-140">Приложение настроено так, что параллельно с ним выполняется контейнер с сервером SQL Server.</span><span class="sxs-lookup"><span data-stu-id="0e194-140">The application is configured to run SQL Server in a container alongside the monolithic application.</span></span> <span data-ttu-id="0e194-141">В рабочей среде сервер SQL Server будет выполняться на компьютере с высоким уровнем доступности не на узле Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-141">In a production environment, SQL Server would run on a high-availability machine, outside of the Docker host.</span></span> <span data-ttu-id="0e194-142">Для удобства в среде разработки или тестовой среде рекомендуется запускать SQL Server в собственном контейнере.</span><span class="sxs-lookup"><span data-stu-id="0e194-142">For convenience in a dev or test environment, we recommend running SQL Server in its own container.</span></span>

<span data-ttu-id="0e194-143">Исходный набор возможностей включает в себя только просмотр каталога.</span><span class="sxs-lookup"><span data-stu-id="0e194-143">The initial feature set only enables browsing the catalog.</span></span> <span data-ttu-id="0e194-144">Посредством обновлений обеспечивается весь набор возможностей контейнерного приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-144">Updates would enable the full feature set of the containerized application.</span></span> <span data-ttu-id="0e194-145">Более сложная архитектура монолитного веб-приложения описывается в электронной книге [Методы проектирования архитектуры веб-приложений ASP.NET](https://aka.ms/webappebook), с которой связан [образец приложения eShopOnWeb](http://aka.ms/WebAppArchitecture). Но в этом случае приложение работает не в контейнерах Docker, так как книга посвящена обычной веб-разработке с помощью ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="0e194-145">A more advanced monolithic web application architecture is described in the [ASP.NET Web Application architecture practices](https://aka.ms/webappebook) e-book and related [eShopOnWeb sample application](http://aka.ms/WebAppArchitecture), although in that case it is not running on Docker containers because that scenario focuses on plain web development with ASP.NET Core.</span></span>

<span data-ttu-id="0e194-146">Тем не менее упрощенная версия приложения eShopOnContainers (eShopWeb) работает в контейнере Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-146">However, the simplified version available in eShopOnContainers (eShopWeb) runs in a Docker container.</span></span>

## <a name="docker-support"></a><span data-ttu-id="0e194-147">Поддержка Docker</span><span class="sxs-lookup"><span data-stu-id="0e194-147">Docker support</span></span>

<span data-ttu-id="0e194-148">Проект eShopOnWeb работает в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="0e194-148">The eShopOnWeb project runs on .NET Core.</span></span> <span data-ttu-id="0e194-149">Поэтому его можно запускать как в контейнерах Linux, так и в контейнерах Windows.</span><span class="sxs-lookup"><span data-stu-id="0e194-149">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="0e194-150">Обратите внимание на то, что для развертывания Docker необходимо использовать тот же тип узла для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="0e194-150">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="0e194-151">Контейнеры на основе Linux требуют меньше ресурсов и более предпочтительны.</span><span class="sxs-lookup"><span data-stu-id="0e194-151">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="0e194-152">В Visual Studio имеется шаблон проекта, добавляющий в решение поддержку Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-152">Visual Studio provides a project template that adds support for Docker to a solution.</span></span> <span data-ttu-id="0e194-153">Щелкните проект правой кнопкой мыши, выберите пункт **Добавить**, а затем пункт **Поддержка Docker**.</span><span class="sxs-lookup"><span data-stu-id="0e194-153">You right-click the project, click **Add** followed by **Docker Support**.</span></span> <span data-ttu-id="0e194-154">Шаблон добавляет в проект файл Dockerfile и новый проект **docker-compose**, который предоставляет начальный файл docker-compose.yml.</span><span class="sxs-lookup"><span data-stu-id="0e194-154">The template adds a Dockerfile to your project, and a new **docker-compose** project that provides a starter docker-compose.yml file.</span></span> <span data-ttu-id="0e194-155">В проекте eShopOnWeb, который можно скачать из GitHub, это действие уже выполнено.</span><span class="sxs-lookup"><span data-stu-id="0e194-155">This step has already been done in the eShopOnWeb project downloaded from GitHub.</span></span> <span data-ttu-id="0e194-156">Вы увидите, что решение содержит проект **eShopOnWeb** и проект **docker-compose**, как показано на рис. 6-1.</span><span class="sxs-lookup"><span data-stu-id="0e194-156">You will see that the solution contains the **eShopOnWeb** project and the **docker-compose** project as shown in Figure 6-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="0e194-157">**Рис. 6-1**.</span><span class="sxs-lookup"><span data-stu-id="0e194-157">**Figure 6-1**.</span></span> <span data-ttu-id="0e194-158">Проект **docker-compose** в одноконтейнерном веб-приложении</span><span class="sxs-lookup"><span data-stu-id="0e194-158">The **docker-compose** project in a single-container web application</span></span>

<span data-ttu-id="0e194-159">Эти файлы являются стандартными файлами docker-compose, которые совместимы с любым проектом Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-159">These files are standard docker-compose files, consistent with any Docker project.</span></span> <span data-ttu-id="0e194-160">Их можно использовать в Visual Studio или из командной строки.</span><span class="sxs-lookup"><span data-stu-id="0e194-160">You can use them with Visual Studio or from the command line.</span></span> <span data-ttu-id="0e194-161">Приложение работает на основе .NET Core и использует контейнеры Linux, так что написание, сборку и запуск кода можно также производить на компьютере Mac или Linux.</span><span class="sxs-lookup"><span data-stu-id="0e194-161">This application runs on .NET Core and uses Linux containers, so you can also code, build, and run on a Mac or on a Linux machine.</span></span>

<span data-ttu-id="0e194-162">Файл docker-compose.yml содержит сведения о том, какие образы необходимо создать и какие контейнеры запустить.</span><span class="sxs-lookup"><span data-stu-id="0e194-162">The docker-compose.yml file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="0e194-163">Шаблоны определяют способ сборки образа eshopweb и запуска контейнеров приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-163">The templates specify how to build the eshopweb image and launch the application’s containers.</span></span> <span data-ttu-id="0e194-164">Вам необходимо добавить зависимость от SQL Server, включив соответствующий образ (например, mssql-server-linux), а также добавить службу для образа sql.data для Docker с целью сборки и запуска этого контейнера.</span><span class="sxs-lookup"><span data-stu-id="0e194-164">You need to add the dependency on SQL Server by including an image for it (for example, mssql-server-linux), and a service for the sql.data image for Docker to build and launch that container.</span></span> <span data-ttu-id="0e194-165">Эти параметры показаны в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="0e194-165">These settings are shown in the following example:</span></span>

```yml
version: '2'

services:
  eshopweb:
    image: eshop/web
    build:
    context: ./eShopWeb
    dockerfile: Dockerfile
    depends_on:
      - sql.data

  sql.data:
    image: microsoft/mssql-server-linux
```

<span data-ttu-id="0e194-166">Директива depends\_on сообщает Docker, что образ eShopWeb зависит от образа sql.data.</span><span class="sxs-lookup"><span data-stu-id="0e194-166">The depends\_on directive tells Docker that the eShopWeb image depends on the sql.data image.</span></span> <span data-ttu-id="0e194-167">Строки ниже представляют собой инструкции по сборке образа, помеченного как sql.data, с помощью образа microsoft/mssql-server-linux.</span><span class="sxs-lookup"><span data-stu-id="0e194-167">Lines below that are the instructions to build an image tagged sql.data using the microsoft/mssql-server-linux image.</span></span>

<span data-ttu-id="0e194-168">В проекте **docker-compose** в главном узле docker-compose.yml приводятся другие файлы docker-compose, чтобы было ясно, что эти файлы связаны.</span><span class="sxs-lookup"><span data-stu-id="0e194-168">The **docker-compose** project displays the other docker-compose files under the main docker-compose.yml node to provide a visual indication that these files are related.</span></span> <span data-ttu-id="0e194-169">Файл docker-compose-override.yml содержит параметры обеих служб, такие как строки подключения и другие параметры приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-169">The docker-compose-override.yml file contains settings for both services, such as connection strings and other application settings.</span></span>

<span data-ttu-id="0e194-170">В приведенном ниже примере показан файл docker-compose.vs.debug.yml, который содержит параметры, используемые для отладки в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="0e194-170">The following example shows the docker-compose.vs.debug.yml file, which contains settings used for debugging in Visual Studio.</span></span> <span data-ttu-id="0e194-171">В этом файле к образу eshopweb добавлен тег dev.</span><span class="sxs-lookup"><span data-stu-id="0e194-171">In that file, the eshopweb image has the dev tag appended to it.</span></span> <span data-ttu-id="0e194-172">Это позволяет различать отладочные образы и образы выпуска, чтобы случайно не развернуть отладочные сведения в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="0e194-172">That helps separate debug from release images so that you do not accidentally deploy the debug information to a production environment:</span></span>

```yml
version: '2'
  
services:
  eshopweb:
    image: eshop/web:dev
    build:
    args:
    source: ${DOCKER_BUILD_SOURCE}
    environment:
      - DOTNET_USE_POLLING_FILE_WATCHER=1
    volumes:
      - ./eShopWeb:/app
      - ~/.nuget/packages:/root/.nuget/packages:ro
      - ~/clrdbg:/clrdbg:ro
    entrypoint: tail -f /dev/null
    labels:
      - "com.microsoft.visualstudio.targetoperatingsystem=linux"
```

<span data-ttu-id="0e194-173">Последний добавляемый файл — docker-compose.ci.build.yml.</span><span class="sxs-lookup"><span data-stu-id="0e194-173">The last file added is docker-compose.ci.build.yml.</span></span> <span data-ttu-id="0e194-174">Он будет использоваться из командной строки для сборки проекта с сервера непрерывной интеграции.</span><span class="sxs-lookup"><span data-stu-id="0e194-174">This would be used from the command line to build the project from a CI server.</span></span> <span data-ttu-id="0e194-175">Этот файл Compose запускает контейнер Docker, который выполняет сборку образов, необходимых для приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-175">This compose file starts a Docker container that builds the images needed for your application.</span></span> <span data-ttu-id="0e194-176">В приведенном ниже примере показано содержимое файла docker-compose.ci.build.yml.</span><span class="sxs-lookup"><span data-stu-id="0e194-176">The following example shows the contents of the docker-compose.ci.build.yml file.</span></span>

```yml
version: '2'
  
services:
  ci-build:
    image: microsoft/aspnetcore-build:latest
    volumes:
      - .:/src
    working_dir: /src
  command: /bin/bash -c "dotnet restore ./eShopWeb.sln && dotnet publish  ./eShopWeb.sln -c Release -o ./obj/Docker/publish"
```

<span data-ttu-id="0e194-177">**Примечание**. Начиная с .NET 2.0, команда dotnet restore автоматически выполняется при выполнении команды dotnet publish.</span><span class="sxs-lookup"><span data-stu-id="0e194-177">**Note**: Starting with .NET Core 2.0, the dotnet restore command executes automatically when dotnet publish is executed.</span></span>

<span data-ttu-id="0e194-178">Обратите внимание на то, что образ представляет собой образ сборки ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="0e194-178">Notice that the image is an ASP.NET Core build image.</span></span> <span data-ttu-id="0e194-179">Он включает в себя пакет SDK и средства, требуемые для сборки приложения и создания необходимых образов.</span><span class="sxs-lookup"><span data-stu-id="0e194-179">That image includes the SDK and build tools to build your application and create the required images.</span></span> <span data-ttu-id="0e194-180">Если запустить проект **docker-compose** с помощью этого файла, будет запущен контейнер сборки из образа, а затем в этом контейнере будет выполнена сборка образа приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-180">Running the **docker-compose** project using this file starts the build container from the image, then builds your application’s image in that container.</span></span> <span data-ttu-id="0e194-181">Для сборки приложения в контейнере Docker и его последующего запуска нужно указать файл docker-compose в командной строке.</span><span class="sxs-lookup"><span data-stu-id="0e194-181">You specify that docker-compose file as part of the command line to build your application in a Docker container, then launch it.</span></span>

<span data-ttu-id="0e194-182">Для запуска приложения в контейнерах Docker в Visual Studio можно выбрать проект **docker-compose** в качестве запускаемого проекта, а затем нажать клавиши CTRL+F5 (F5 для отладки), как и для любого другого приложения.</span><span class="sxs-lookup"><span data-stu-id="0e194-182">In Visual Studio, you can run your application in Docker containers by selecting the **docker-compose** project as the startup project, and then pressing Ctrl+F5 (F5 to debug), as you can with any other application.</span></span> <span data-ttu-id="0e194-183">При запуске проекта **docker-compose** Visual Studio использует для **docker-compose** файл docker-compose.yml, файл docker-compose.override.yml и один из файлов docker-compose.vs.\*</span><span class="sxs-lookup"><span data-stu-id="0e194-183">When you start the **docker-compose** project, Visual Studio runs **docker-compose** using the docker-compose.yml file, the docker-compose.override.yml file, and one of the docker-compose.vs.\* files.</span></span> <span data-ttu-id="0e194-184">После запуска приложения Visual Studio открывает браузер.</span><span class="sxs-lookup"><span data-stu-id="0e194-184">Once the application has started, Visual Studio launches the browser for you.</span></span>

<span data-ttu-id="0e194-185">Если приложение запускается в отладчике, Visual Studio подключается к работающему приложению в Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-185">If you launch the application in the debugger, Visual Studio will attach to the running application in Docker.</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="0e194-186">Устранение неполадок</span><span class="sxs-lookup"><span data-stu-id="0e194-186">Troubleshooting</span></span>

<span data-ttu-id="0e194-187">В этом разделе описывается ряд проблем, которые могут возникать при локальном запуске контейнеров, и предлагаются их решения.</span><span class="sxs-lookup"><span data-stu-id="0e194-187">This section describes a few issues that might arise when your run containers locally and suggests some fixes.</span></span>

### <a name="stopping-docker-containers"></a><span data-ttu-id="0e194-188">Остановка контейнеров Docker</span><span class="sxs-lookup"><span data-stu-id="0e194-188">Stopping Docker containers</span></span> 

<span data-ttu-id="0e194-189">После запуска контейнерного приложения контейнеры продолжают выполняться даже после того, как вы остановили отладку.</span><span class="sxs-lookup"><span data-stu-id="0e194-189">After you launch the containerized application, the containers continue to run, even after you have stopped debugging.</span></span> <span data-ttu-id="0e194-190">Чтобы узнать, какие контейнеры выполняются, можно выполнить в командной строке команду docker ps.</span><span class="sxs-lookup"><span data-stu-id="0e194-190">You can run the docker ps command from the command line to see which containers are running.</span></span> <span data-ttu-id="0e194-191">Команда docker stop останавливает выполняющийся контейнер, как показано на рис. 6-2.</span><span class="sxs-lookup"><span data-stu-id="0e194-191">The docker stop command stops a running container, as shown in Figure 6-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="0e194-192">**Рис. 6-2**.</span><span class="sxs-lookup"><span data-stu-id="0e194-192">**Figure 6-2**.</span></span> <span data-ttu-id="0e194-193">Получение списка контейнеров и их остановка с помощью команд CLI docker ps и docker stop</span><span class="sxs-lookup"><span data-stu-id="0e194-193">Listing and stopping containers with the docker ps and docker stop CLI commands</span></span>

<span data-ttu-id="0e194-194">При переключении между конфигурациями может потребоваться остановить запущенные процессы.</span><span class="sxs-lookup"><span data-stu-id="0e194-194">You might need to stop running processes when you switch between different configurations.</span></span> <span data-ttu-id="0e194-195">В противном случае контейнер, в котором работает веб-приложение, будет использовать порт вашего приложения (5106 в этом примере).</span><span class="sxs-lookup"><span data-stu-id="0e194-195">Otherwise, the container that is running the web application is using the port for your application (5106 in this example).</span></span>

### <a name="adding-docker-to-your-projects"></a><span data-ttu-id="0e194-196">Добавление Docker в проекты</span><span class="sxs-lookup"><span data-stu-id="0e194-196">Adding Docker to your projects</span></span>

<span data-ttu-id="0e194-197">Мастер добавления поддержки Docker взаимодействует с выполняющимся процессом Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-197">The wizard that adds Docker support communicates with the running Docker process.</span></span> <span data-ttu-id="0e194-198">Если при запуске мастера средство Docker не выполняется, мастер будет работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="0e194-198">The wizard will not run correctly if Docker is not running when you start the wizard.</span></span> <span data-ttu-id="0e194-199">Кроме того, мастер проверяет выбранные контейнеры, чтобы правильно реализовать поддержку Docker.</span><span class="sxs-lookup"><span data-stu-id="0e194-199">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="0e194-200">Чтобы добавить поддержку контейнеров Windows, при запуске мастера должно выполняться средство Docker с настроенными контейнерами Windows.</span><span class="sxs-lookup"><span data-stu-id="0e194-200">If you want to add support for Windows Containers, you need to run the wizard while you have Docker running with Windows Containers configured.</span></span> <span data-ttu-id="0e194-201">Чтобы добавить поддержку контейнеров Linux, при запуске мастера должно выполняться средство Docker с настроенными контейнерами Linux.</span><span class="sxs-lookup"><span data-stu-id="0e194-201">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0e194-202">[Назад] (../docker-application-development-process/docker-app-development-workflow.md) [Далее] (../containerize-net-framework-applications/index.md)</span><span class="sxs-lookup"><span data-stu-id="0e194-202">[Previous] (../docker-application-development-process/docker-app-development-workflow.md) [Next] (../containerize-net-framework-applications/index.md)</span></span>
