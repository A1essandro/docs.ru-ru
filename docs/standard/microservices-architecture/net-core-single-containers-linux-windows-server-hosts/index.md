---
title: Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/27/2018
ms.openlocfilehash: 45be99a86a52ed450b795ca5f91c01ab82c7da47
ms.sourcegitcommit: 3c1c3ba79895335ff3737934e39372555ca7d6d0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2018
ms.locfileid: "43778007"
---
# <a name="deploying-single-container-based-net-core-web-applications-on-linux-or-windows-nano-server-hosts"></a>Развертывание одноконтейнерных веб-приложений .NET Core на узлах Linux или Windows Nano Server

_Контейнеры Docker можно использовать для монолитного развертывания простых веб-приложений. Это позволяет оптимизировать процессы непрерывной интеграции и непрерывного развертывания, а также добиться успешного развертывания в рабочей среде. Вам больше не придется гадать, почему решение, работающее на вашем компьютере, не работает в рабочей среде._

Архитектура на основе микрослужб имеет много преимуществ, но обратной стороной является повышение сложности. В некоторых случаях затраты перевешивают преимущества и лучше прибегнуть к монолитному развертыванию приложения в одном или нескольких контейнерах.

Монолитное приложение может быть непросто разделить на отдельные микрослужбы. Вы уже знаете, что разделение микрослужб должно производиться на основе функций: они должны работать независимо друг от друга для повышения отказоустойчивости приложения. Если приложение невозможно разложить на функциональные составляющие, то его разделение лишь увеличит сложность.

Приложению пока может не требоваться независимое масштабирование компонентов. Предположим, что на ранних этапах объем трафика приложения `eShopOnContainers`, которое мы используем в качестве примера, не оправдывал разнесения функций по отдельным микрослужбам. Объем трафика был достаточно невелик, поэтому добавление ресурсов в одну службу обычно означало их добавление для всех служб. Разделение приложения на отдельные службы требовало дополнительных усилий, но давало минимальные преимущества.

Кроме того, на ранних этапах развертывания приложения может отсутствовать ясное представление о том, где пролегают границы между функциональными областями. В процессе разработки продукта, обладающего минимальным необходимым набором возможностей, его естественное разделение на части может быть не очевидным.

Некоторые из этих условий могут быть временными. Вы можете сначала создать монолитное приложение, а в дальнейшем отделить некоторые компоненты для разработки и развертывания в качестве микрослужб. Другие условия могут быть неотъемлемыми особенностями приложения. Это означает, что приложение в принципе невозможно разделить на несколько микрослужб.

Разделение приложения на множество отдельных процессов также приводит к накладным расходам. При разделении компонента на несколько процессов повышается сложность. Усложняются протоколы обмена данными. Вместо вызовов методов необходимо использовать асинхронное взаимодействие между службами. При переходе на архитектуру микрослужб необходимо добавить множество строительных блоков, реализованных в версии приложения `eShopOnContainers` на основе микрослужб: обработку шины событий, отказоустойчивость и повторную отправку сообщений, итоговую согласованность и многое другое.

Гораздо более простая версия приложения eShopOnContainers (которая называется [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) и находится в том же репозитории GitHub) работает как монолитное приложение MVC. Как уже было сказано, такой подход имеет свои преимущества. Вы можете скачать исходный код этого приложения из GitHub и запустить его в локальной системе. Даже такое монолитное приложение выигрывает от развертывания в контейнерной среде.

Во-первых, контейнерное развертывание означает, что каждый экземпляр приложения выполняется в одной и той же среде. Это относится и к среде разработки, в которой проводятся начальные этапы тестирования и разработки. Команда разработчиков может запускать приложение в контейнерной среде, которая аналогична рабочей.

Кроме того, контейнерные приложения обеспечивают более экономичное горизонтальное масштабирование. Как вы уже видели, контейнерная среда позволяет эффективнее организовывать совместное использование ресурсов, чем традиционные среды виртуальных машин.

Наконец, помещая приложение в контейнеры, вы разделяете бизнес-логику и сервер хранилища. По мере масштабирования приложения все контейнеры будут использовать одно физическое хранилище. Как правило, это сервер высокой доступности с базой данных SQL Server.

## <a name="application-tour"></a>Обзор приложения

Приложение [eShopWeb](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Web/WebMonolithic) реализует некоторые возможности приложения eShopOnContainers, но работает как монолитное приложение MVC ASP.NET Core на основе .NET Core. В основном оно предоставляет возможности просмотра каталога, которые описывались в предыдущих разделах.

Для хранения каталога приложение использует базу данных SQL Server. В развертываниях на основе контейнеров это монолитное приложение имеет доступ к тому же хранилищу данных, что и приложение на основе микрослужб. Приложение настроено так, что параллельно с ним выполняется контейнер с сервером SQL Server. В рабочей среде сервер SQL Server будет выполняться на компьютере с высоким уровнем доступности не на узле Docker. Для удобства в среде разработки или тестовой среде рекомендуется запускать SQL Server в собственном контейнере.

Исходный набор возможностей включает в себя только просмотр каталога. Посредством обновлений обеспечивается весь набор возможностей контейнерного приложения. Более сложная архитектура монолитного веб-приложения описывается в электронной книге [Рекомендации по архитектуре веб-приложений ASP.NET](https://aka.ms/webappebook) и в [примере приложения eShopOnWeb](https://aka.ms/WebAppArchitecture).

## <a name="docker-support"></a>Поддержка Docker

Проект eShopOnWeb работает в .NET Core. Поэтому его можно запускать как в контейнерах Linux, так и в контейнерах Windows. Обратите внимание на то, что для развертывания Docker необходимо использовать тот же тип узла для SQL Server. Контейнеры на основе Linux требуют меньше ресурсов и более предпочтительны.

В Visual Studio имеется шаблон проекта, добавляющий в решение поддержку Docker. Щелкните проект правой кнопкой мыши, выберите пункт **Добавить**, а затем пункт **Поддержка Docker**. Шаблон добавляет в проект файл Dockerfile и новый проект **docker-compose**, который предоставляет начальный файл *docker-compose.yml*. В проекте eShopOnWeb, который можно скачать из GitHub, это действие уже выполнено. Вы видите, что решение содержит проект **eShopOnWeb** и проект **docker-compose**, как показано на рис. 6-1.

![](./media/image1.png)

**Рис. 6-1**. Проект **docker-compose** в одноконтейнерном веб-приложении

Эти файлы являются стандартными файлами docker-compose, которые совместимы с любым проектом Docker. Их можно использовать в Visual Studio или из командной строки. Это приложение запускается на .NET Core и использует контейнеры Linux. Таким образом, вы можете писать, собирать и запускать его на компьютере Mac или Linux.

Файл *docker-compose.yml* содержит сведения о том, какие образы необходимо создать и какие контейнеры запустить. Шаблоны определяют способ сборки образа `eshopweb` и запуска контейнеров приложения. Вам необходимо добавить зависимость от SQL Server, включив соответствующий образ (например, `mssql-server-linux`), а также добавить службу для образа sql.data для Docker с целью сборки и запуска этого контейнера. Эти параметры показаны в следующем примере.

```yml
version: '2'

services:
  eshopweb:
    image: eshop/web
    build:
    context: ./eShopWeb
    dockerfile: Dockerfile
    depends_on:
      - sql.data

  sql.data:
    image: microsoft/mssql-server-linux
```

Директива `depends_on` сообщает Docker, что образ eShopWeb зависит от образа sql.data. Приведенные ниже строки `depends_on` — это инструкции для сборки образа с тегом `sql.data` с помощью образа `microsoft/mssql-server-linux`.

В проекте **docker-compose** в главном узле *docker-compose.yml* приводятся другие файлы docker-compose, чтобы было ясно, что эти файлы связаны. Файл *docker-compose-override.yml* содержит параметры обеих служб, такие как строки подключения и другие параметры приложения.

В приведенном ниже примере показан файл *docker-compose.vs.debug.yml*, который содержит параметры, используемые для отладки в Visual Studio. В этом файле к образу eshopweb добавлен тег dev. Это позволяет различать отладочные образы и образы выпуска, чтобы случайно не развернуть отладочные сведения в рабочей среде.

```yml
version: '2'

services:
  eshopweb:
    image: eshop/web:dev
    build:
    args:
    source: ${DOCKER_BUILD_SOURCE}
    environment:
      - DOTNET_USE_POLLING_FILE_WATCHER=1
    volumes:
      - ./eShopWeb:/app
      - ~/.nuget/packages:/root/.nuget/packages:ro
      - ~/clrdbg:/clrdbg:ro
    entrypoint: tail -f /dev/null
    labels:
      - "com.microsoft.visualstudio.targetoperatingsystem=linux"
```

Последний добавляемый файл — *docker-compose.ci.build.yml*. Этот файл будет указываться в командной строке для сборки проекта с сервера непрерывной интеграции. Этот файл Compose запускает контейнер Docker, который выполняет сборку образов, необходимых для приложения. В приведенном ниже примере показано содержимое файла *docker-compose.ci.build.yml*:

```yml
version: '2'

services:
  ci-build:
    image: microsoft/aspnetcore-build:latest
    volumes:
      - .:/src
    working_dir: /src
  command: /bin/bash -c "dotnet restore ./eShopWeb.sln && dotnet publish  ./eShopWeb.sln -c Release -o ./obj/Docker/publish"
```

> [!NOTE]
> Начиная с пакета SDK для .NET Core 2.0 команда [dotnet restore](../../../core/tools/dotnet-restore.md) автоматически выполняется при выполнении команды [dotnet publish](../../../core/tools/dotnet-publish.md).

Обратите внимание на то, что образ представляет собой образ сборки ASP.NET Core. Он включает в себя пакет SDK и средства, требуемые для сборки приложения и создания необходимых образов. Если запустить проект **docker-compose** с помощью этого файла, будет запущен контейнер сборки из образа, а затем в этом контейнере будет выполнена сборка образа приложения. Для сборки приложения в контейнере Docker и его последующего запуска нужно указать файл *docker-compose* в командной строке.

Для запуска приложения в контейнерах Docker в Visual Studio можно выбрать проект **docker-compose** в качестве запускаемого проекта, а затем нажать клавиши CTRL+F5 (F5 для отладки), как и для любого другого приложения. При запуске проекта **docker-compose** Visual Studio использует для **docker-compose** файл *docker-compose.yml*, файл *docker-compose.override.yml* и один из файлов docker-compose.vs\*. После запуска приложения Visual Studio открывает браузер.

Если приложение запускается в отладчике, Visual Studio подключается к работающему приложению в Docker.

## <a name="troubleshooting"></a>Устранение неполадок

В этом разделе описывается ряд проблем, которые могут возникать при локальном запуске контейнеров, и предлагаются их решения.

### <a name="stop-docker-containers"></a>Остановка контейнеров Docker

После запуска контейнерного приложения контейнеры продолжают выполняться даже после того, как вы остановили отладку. Чтобы узнать, какие контейнеры выполняются, можно выполнить в командной строке команду `docker ps`. Команда `docker stop` останавливает выполняющийся контейнер, как показано на рис. 6-2.

![](./media/image2.png)

**Рис. 6-2**. Получение списка контейнеров и их остановка с помощью команд CLI docker ps и docker stop

При переключении между конфигурациями может потребоваться остановить запущенные процессы. В противном случае контейнер, в котором работает веб-приложение, будет использовать порт вашего приложения (5106 в этом примере).

### <a name="add-docker-to-your-projects"></a>Добавление Docker в проекты

Мастер добавления поддержки Docker взаимодействует с выполняющимся процессом Docker. Если при запуске мастера средство Docker не выполняется, мастер будет работать неправильно. Мастер проверяет выбранные контейнеры, чтобы правильно реализовать поддержку Docker. Чтобы добавить поддержку контейнеров Windows, при запуске мастера должно выполняться средство Docker с настроенными контейнерами Windows. Чтобы добавить поддержку контейнеров Linux, при запуске мастера должно выполняться средство Docker с настроенными контейнерами Linux.

>[!div class="step-by-step"]
[Назад](../docker-application-development-process/docker-app-development-workflow.md)
[Вперед](../containerize-net-framework-applications/index.md)
