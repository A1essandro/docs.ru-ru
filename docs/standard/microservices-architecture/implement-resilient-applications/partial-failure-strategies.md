---
title: "Стратегии для обработки частичный сбой"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Стратегии для обработки частичный сбой"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ff3bed530b13a9b1822c7cccf5a4d47df6fc6239
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="strategies-for-handling-partial-failure"></a>Стратегии для обработки частичный сбой

Ниже перечислены стратегии работы с частичных сбоев.

**Использование асинхронного взаимодействия (например, связь на основе сообщений) через внутренний микрослужбами**. Настоятельно рекомендуется не, для создания длинных цепочек синхронные вызовы HTTP через внутренний микрослужбами, так как этой неверные структуры в конечном итоге станет основной причиной сбоев неправильный. Напротив, за исключением переднего плана обмена данными между клиентскими приложениями и первый уровень микрослужбами и детально шлюзами API, рекомендуется использовать асинхронные (на основе сообщений) подключения только один раз за первоначальный запрос / Цикл ответа между внутренней микрослужбами. Итоговая согласованность и событиями архитектуры позволит свести к минимуму влияние ripple. Эти подходы обеспечить более высокий уровень микрослужбу автономность и таким образом предотвратить проблему, указанную ниже.

**Использовать повторные попытки с экспоненциально растущим**. Это помогает предотвратить и временные сбои, выполнив вызов повторяет определенное число раз, в случае, если служба не был доступен только в течение некоторого времени. Это может произойти из-за периодических неполадок сети или при перемещении на другой узел в кластере микрослужбу или контейнера. Тем не менее, если эти повторные попытки не предусмотрена правильно с выключатели, его можно к ухудшению эффекты колебаний в конце концов может даже вызвать [отказ в обслуживании (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).

**Обходной путь таймаутов сети**. Как правило клиенты должны разрабатываться блокировку в течение неограниченного времени и всегда использовать тайм-ауты при ожидании ответа. Использование времен ожидания гарантирует, что ресурсы никогда не, привязаны бесконечно.

**Использовать шаблон, Размыкатель цепи**. При таком подходе клиентского процесса отслеживает количество неудачных запросов. Если частота ошибок превышает установленный предел, обработки «Размыкатель цепи», чтобы дальнейшие попытки немедленно завершить с ошибкой. (Если не удается большое количество запросов, содержащее служба недоступна, и что отправки запросов не имеет смысла.) После периода времени ожидания клиент должен повторить попытку и, если новые запросы выполняются успешно, закройте Размыкатель цепи.

**Укажите в случае ошибки**. При таком подходе клиентский процесс выполняет резервную логику при неудачном запросе, например возвращают кэшированные данные, или значение по умолчанию. — Это подход, подходящих для запросов, а более сложен для обновления или команд.

**Максимальное число запросов в очереди**. Клиенты должны также накладывают верхний предел на количество ожидающих запросов, отправляемых клиентом микрослужбу для конкретной службы. Если был достигнут предел имеет смысла, возможно, дополнительные запросы и попытками следует немедленно завершить с ошибкой. С точки зрения реализации, Polly [изоляции блочный](https://github.com/App-vNext/Polly/wiki/Bulkhead) политика может использоваться для выполнения этого требования. Этот подход является по сути регулирования параллелизации с [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) с реализацией. Он также позволяет службе «очередь» за пределами блочный. Заранее, может пролить избыточную нагрузку еще до выполнения (например, поскольку емкость считается полный). Это делает его ответ на определенных сценариях сбоя быстрее, чем бы Размыкатель цепи, поскольку Размыкатель цепи ожидает сбои. Объект BulkheadPolicy в Polly предоставляет степень заполнения блочный и очереди, и предложения события в случае переполнения таким образом может также использоваться для диска автоматических горизонтальное масштабирование.

## <a name="additional-resources"></a>Дополнительные ресурсы

-   **Шаблоны гибкости**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)

-   **Добавление устойчивости и оптимизация производительности**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)

-   **Блочный.** В репозитории GitHub. Реализация с политикой Polly. \
    [*https://github.com/App-vNext/Polly/Wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   **Проектирование устойчивым приложений для Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)

-   **Обработка временных сбоев**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults>


>[!div class="step-by-step"]
[Предыдущие] (дескриптор partial-failure.md) [Далее] (реализуйте попыток экспоненциальное backoff.md)
