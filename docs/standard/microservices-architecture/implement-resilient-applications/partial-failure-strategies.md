---
title: "Стратегии для обработки частичный сбой"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Стратегии для обработки частичный сбой"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ff3bed530b13a9b1822c7cccf5a4d47df6fc6239
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="367cd-104">Стратегии для обработки частичный сбой</span><span class="sxs-lookup"><span data-stu-id="367cd-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="367cd-105">Ниже перечислены стратегии работы с частичных сбоев.</span><span class="sxs-lookup"><span data-stu-id="367cd-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="367cd-106">**Использование асинхронного взаимодействия (например, связь на основе сообщений) через внутренний микрослужбами**.</span><span class="sxs-lookup"><span data-stu-id="367cd-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="367cd-107">Настоятельно рекомендуется не, для создания длинных цепочек синхронные вызовы HTTP через внутренний микрослужбами, так как этой неверные структуры в конечном итоге станет основной причиной сбоев неправильный.</span><span class="sxs-lookup"><span data-stu-id="367cd-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="367cd-108">Напротив, за исключением переднего плана обмена данными между клиентскими приложениями и первый уровень микрослужбами и детально шлюзами API, рекомендуется использовать асинхронные (на основе сообщений) подключения только один раз за первоначальный запрос / Цикл ответа между внутренней микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="367cd-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="367cd-109">Итоговая согласованность и событиями архитектуры позволит свести к минимуму влияние ripple.</span><span class="sxs-lookup"><span data-stu-id="367cd-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="367cd-110">Эти подходы обеспечить более высокий уровень микрослужбу автономность и таким образом предотвратить проблему, указанную ниже.</span><span class="sxs-lookup"><span data-stu-id="367cd-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="367cd-111">**Использовать повторные попытки с экспоненциально растущим**.</span><span class="sxs-lookup"><span data-stu-id="367cd-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="367cd-112">Это помогает предотвратить и временные сбои, выполнив вызов повторяет определенное число раз, в случае, если служба не был доступен только в течение некоторого времени.</span><span class="sxs-lookup"><span data-stu-id="367cd-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="367cd-113">Это может произойти из-за периодических неполадок сети или при перемещении на другой узел в кластере микрослужбу или контейнера.</span><span class="sxs-lookup"><span data-stu-id="367cd-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="367cd-114">Тем не менее, если эти повторные попытки не предусмотрена правильно с выключатели, его можно к ухудшению эффекты колебаний в конце концов может даже вызвать [отказ в обслуживании (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="367cd-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="367cd-115">**Обходной путь таймаутов сети**.</span><span class="sxs-lookup"><span data-stu-id="367cd-115">**Work around network timeouts**.</span></span> <span data-ttu-id="367cd-116">Как правило клиенты должны разрабатываться блокировку в течение неограниченного времени и всегда использовать тайм-ауты при ожидании ответа.</span><span class="sxs-lookup"><span data-stu-id="367cd-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="367cd-117">Использование времен ожидания гарантирует, что ресурсы никогда не, привязаны бесконечно.</span><span class="sxs-lookup"><span data-stu-id="367cd-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="367cd-118">**Использовать шаблон, Размыкатель цепи**.</span><span class="sxs-lookup"><span data-stu-id="367cd-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="367cd-119">При таком подходе клиентского процесса отслеживает количество неудачных запросов.</span><span class="sxs-lookup"><span data-stu-id="367cd-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="367cd-120">Если частота ошибок превышает установленный предел, обработки «Размыкатель цепи», чтобы дальнейшие попытки немедленно завершить с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="367cd-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="367cd-121">(Если не удается большое количество запросов, содержащее служба недоступна, и что отправки запросов не имеет смысла.) После периода времени ожидания клиент должен повторить попытку и, если новые запросы выполняются успешно, закройте Размыкатель цепи.</span><span class="sxs-lookup"><span data-stu-id="367cd-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="367cd-122">**Укажите в случае ошибки**.</span><span class="sxs-lookup"><span data-stu-id="367cd-122">**Provide fallbacks**.</span></span> <span data-ttu-id="367cd-123">При таком подходе клиентский процесс выполняет резервную логику при неудачном запросе, например возвращают кэшированные данные, или значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="367cd-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="367cd-124">— Это подход, подходящих для запросов, а более сложен для обновления или команд.</span><span class="sxs-lookup"><span data-stu-id="367cd-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="367cd-125">**Максимальное число запросов в очереди**.</span><span class="sxs-lookup"><span data-stu-id="367cd-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="367cd-126">Клиенты должны также накладывают верхний предел на количество ожидающих запросов, отправляемых клиентом микрослужбу для конкретной службы.</span><span class="sxs-lookup"><span data-stu-id="367cd-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="367cd-127">Если был достигнут предел имеет смысла, возможно, дополнительные запросы и попытками следует немедленно завершить с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="367cd-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="367cd-128">С точки зрения реализации, Polly [изоляции блочный](https://github.com/App-vNext/Polly/wiki/Bulkhead) политика может использоваться для выполнения этого требования.</span><span class="sxs-lookup"><span data-stu-id="367cd-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="367cd-129">Этот подход является по сути регулирования параллелизации с [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) с реализацией.</span><span class="sxs-lookup"><span data-stu-id="367cd-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="367cd-130">Он также позволяет службе «очередь» за пределами блочный.</span><span class="sxs-lookup"><span data-stu-id="367cd-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="367cd-131">Заранее, может пролить избыточную нагрузку еще до выполнения (например, поскольку емкость считается полный).</span><span class="sxs-lookup"><span data-stu-id="367cd-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="367cd-132">Это делает его ответ на определенных сценариях сбоя быстрее, чем бы Размыкатель цепи, поскольку Размыкатель цепи ожидает сбои.</span><span class="sxs-lookup"><span data-stu-id="367cd-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="367cd-133">Объект BulkheadPolicy в Polly предоставляет степень заполнения блочный и очереди, и предложения события в случае переполнения таким образом может также использоваться для диска автоматических горизонтальное масштабирование.</span><span class="sxs-lookup"><span data-stu-id="367cd-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="367cd-134">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="367cd-134">Additional resources</span></span>

-   <span data-ttu-id="367cd-135">**Шаблоны гибкости**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="367cd-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="367cd-136">**Добавление устойчивости и оптимизация производительности**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="367cd-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="367cd-137">**Блочный.**</span><span class="sxs-lookup"><span data-stu-id="367cd-137">**Bulkhead.**</span></span> <span data-ttu-id="367cd-138">В репозитории GitHub.</span><span class="sxs-lookup"><span data-stu-id="367cd-138">GitHub repo.</span></span> <span data-ttu-id="367cd-139">Реализация с политикой Polly. \\</span><span class="sxs-lookup"><span data-stu-id="367cd-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="367cd-140">*https://github.com/App-vNext/Polly/Wiki/Bulkhead*</span><span class="sxs-lookup"><span data-stu-id="367cd-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="367cd-141">**Проектирование устойчивым приложений для Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="367cd-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="367cd-142">**Обработка временных сбоев**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="367cd-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="367cd-143">[Предыдущие] (дескриптор partial-failure.md) [Далее] (реализуйте попыток экспоненциальное backoff.md)</span><span class="sxs-lookup"><span data-stu-id="367cd-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
