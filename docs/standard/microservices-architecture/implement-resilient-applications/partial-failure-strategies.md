---
title: Стратегии для обработки частичного сбоя
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Стратегии для обработки частичного сбоя
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/08/2018
ms.openlocfilehash: ac82f6d506213614c7a4079e0f55f798f26a6550
ms.sourcegitcommit: 59b51cd7c95c75be85bd6ef715e9ef8c85720bac
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/06/2018
ms.locfileid: "37874407"
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="04ec4-103">Стратегии для обработки частичного сбоя</span><span class="sxs-lookup"><span data-stu-id="04ec4-103">Strategies for handling partial failure</span></span>

<span data-ttu-id="04ec4-104">Ниже приведены стратегии для обработки частичных сбоев.</span><span class="sxs-lookup"><span data-stu-id="04ec4-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="04ec4-105">**Использование асинхронного взаимодействия (например, взаимодействия на основе сообщений) между внутренними микрослужбами**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="04ec4-106">Настоятельно рекомендуется не создавать длинные цепочки синхронных HTTP-вызовов между внутренними микрослужбами, так как подобная неправильная конструкция в конечном счете станет основной причиной сбоев.</span><span class="sxs-lookup"><span data-stu-id="04ec4-106">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="04ec4-107">Напротив, асинхронный (на основе сообщений) обмен данными следует использовать только после первоначального цикла запрос-ответ между внутренними микрослужбами. Исключение составляет интерфейсное взаимодействие между клиентскими приложениями и первым уровнем микрослужб или детально настроенными шлюзами API.</span><span class="sxs-lookup"><span data-stu-id="04ec4-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="04ec4-108">Итоговая согласованность и управляемые событиями архитектуры помогут свести к минимуму волновой эффект.</span><span class="sxs-lookup"><span data-stu-id="04ec4-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="04ec4-109">Эти подходы обеспечивают более высокий уровень автономности микрослужбы и, таким образом, позволяют избежать возникновения указанной здесь проблемы.</span><span class="sxs-lookup"><span data-stu-id="04ec4-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="04ec4-110">**Использование повторных попыток с экспоненциальной выдержкой**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="04ec4-111">Этот метод помогает не допускать короткие и временные сбои, выполняя многократные повторные попытки вызова в случае, если служба была недоступна в течение небольшого промежутка времени.</span><span class="sxs-lookup"><span data-stu-id="04ec4-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="04ec4-112">Такая проблема может возникать из-за периодических неполадок сети или при перемещении микрослужбы или контейнера на другой узел в кластере.</span><span class="sxs-lookup"><span data-stu-id="04ec4-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="04ec4-113">Однако, если эти повторные попытки неправильно настроены с размыкателями цепи, волновой эффект может усилиться, что в конечном итоге не исключает даже [отказ в обслуживании (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="04ec4-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="04ec4-114">**Обход времени ожидания сети**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-114">**Work around network timeouts**.</span></span> <span data-ttu-id="04ec4-115">Как правило, клиенты должны разрабатываться так, чтобы не переходить в состояние блокировки на неопределенное время и всегда использовать таймауты при ожидании ответа.</span><span class="sxs-lookup"><span data-stu-id="04ec4-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="04ec4-116">Время ожидания исключает постоянную занятость ресурсов.</span><span class="sxs-lookup"><span data-stu-id="04ec4-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="04ec4-117">**Использование шаблона размыкателя цепи**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="04ec4-118">В этом случае клиентский процесс отслеживает количество неудачных запросов.</span><span class="sxs-lookup"><span data-stu-id="04ec4-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="04ec4-119">Если частота ошибок превышает установленный предел, размыкатель цепи отключается, поэтому дальнейшие попытки немедленно завершаются сбоем.</span><span class="sxs-lookup"><span data-stu-id="04ec4-119">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="04ec4-120">(Если количество невыполненных запросов слишком велико, это говорит о том, что служба недоступна и отправка запросов не имеет смысла.) По истечении времени ожидания клиент должен повторить попытку и, если новые запросы выполняются успешно, закрыть размыкатель цепи.</span><span class="sxs-lookup"><span data-stu-id="04ec4-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="04ec4-121">**Предоставление резервных механизмов**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-121">**Provide fallbacks**.</span></span> <span data-ttu-id="04ec4-122">При использовании этого подхода клиентский процесс в случае сбоя запроса реализует резервную логику, например возвращает кэшированные данные или значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="04ec4-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="04ec4-123">Этот вариант подходит для запросов, но несколько сложен для обновлений или команд.</span><span class="sxs-lookup"><span data-stu-id="04ec4-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="04ec4-124">**Ограничение на максимальное количество запросов в очереди**.</span><span class="sxs-lookup"><span data-stu-id="04ec4-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="04ec4-125">Клиенты должны также устанавливать верхний предел на количество ожидающих запросов, отправляемых клиентской микрослужбой в конкретную службу.</span><span class="sxs-lookup"><span data-stu-id="04ec4-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="04ec4-126">Если предел был достигнут, вероятно, нет никакого смысла выполнять дополнительные запросы, так как эти попытки сразу же завершатся ошибкой.</span><span class="sxs-lookup"><span data-stu-id="04ec4-126">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="04ec4-127">С точки зрения реализации для выполнения этого требования можно использовать политику [изоляции отсеков](https://github.com/App-vNext/Polly/wiki/Bulkhead) Polly.</span><span class="sxs-lookup"><span data-stu-id="04ec4-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="04ec4-128">По сути, этот подход представляет собой регулирование распараллеливания с использованием <xref:System.Threading.SemaphoreSlim> в качестве реализации.</span><span class="sxs-lookup"><span data-stu-id="04ec4-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="04ec4-129">Он также позволяет формировать очередь вне переборки.</span><span class="sxs-lookup"><span data-stu-id="04ec4-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="04ec4-130">Избыточную нагрузку можно распределить заранее — еще до выполнения (например, если считается, что достигнута полная мощность).</span><span class="sxs-lookup"><span data-stu-id="04ec4-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="04ec4-131">В результате он реагирует на определенные сценарии сбоя быстрее, чем это сделал бы размыкатель цепи, поскольку размыкатель цепи ждет возникновения сбоев.</span><span class="sxs-lookup"><span data-stu-id="04ec4-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="04ec4-132">Объект BulkheadPolicy в Polly отображает степень заполнения переборки и очереди и предлагает события на случай переполнения, поэтому его также можно использовать для выполнения автоматического горизонтального масштабирования.</span><span class="sxs-lookup"><span data-stu-id="04ec4-132">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="04ec4-133">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="04ec4-133">Additional resources</span></span>

-   <span data-ttu-id="04ec4-134">**Шаблоны устойчивости**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="04ec4-134">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="04ec4-135">**Повышение устойчивости и оптимизация производительности**
    [*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="04ec4-135">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/library/jj591574.aspx*](https://msdn.microsoft.com/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="04ec4-136">**Переборка.**</span><span class="sxs-lookup"><span data-stu-id="04ec4-136">**Bulkhead.**</span></span> <span data-ttu-id="04ec4-137">Репозиторий GitHub.</span><span class="sxs-lookup"><span data-stu-id="04ec4-137">GitHub repo.</span></span> <span data-ttu-id="04ec4-138">Реализация с помощью политики Polly.</span><span class="sxs-lookup"><span data-stu-id="04ec4-138">Implementation with Polly policy.\\</span></span>
    [*https://github.com/App-vNext/Polly/wiki/Bulkhead*](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="04ec4-139">**Проектирование устойчивых приложений для Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="04ec4-139">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="04ec4-140">**Обработка временных сбоев**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="04ec4-140">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="04ec4-141">[Назад](handle-partial-failure.md)
[Вперед](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="04ec4-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
