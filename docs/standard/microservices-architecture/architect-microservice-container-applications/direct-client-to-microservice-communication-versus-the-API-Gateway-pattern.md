---
title: "Прямое взаимодействие клиента и микрослужбы по сравнению с использованием шаблона службы API"
description: "Архитектура микрослужб .NET для контейнерных приложений .NET | Прямое взаимодействие клиента и микрослужбы по сравнению с использованием шаблона службы API"
keywords: "Docker, микрослужбы, ASP.NET, контейнер, шлюз API"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 96a02958ef5750aec7a92ff0dd145edc15a5953a
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/23/2017
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a>Прямое взаимодействие клиента и микрослужбы по сравнению с использованием шаблона службы API

В архитектуре микрослужб каждая микрослужба обычно предоставляет набор специализированных конечных точек. Этот факт может повлиять на взаимодействие между клиентом и микрослужбой, как описано в этом разделе.

## <a name="direct-client-to-microservice-communication"></a>Прямое взаимодействие между клиентом и микрослужбой

Возможный подход — использование архитектуры с прямым взаимодействием между клиентом и микрослужбой. При таком подходе клиентские приложения могут отправлять запросы к некоторым микрослужбам напрямую, как показано на рис. 4-12.

![](./media/image12.png)

**Рис. 4-12**. Использование архитектуры с прямым взаимодействием клиента и микрослужбы

При использовании этого подхода у каждой микрослужбы есть общедоступная конечная точка, иногда с отдельным портом TCP для каждой микрослужбы. Например, определенная служба может иметь следующий URL-адрес в Azure:

<http://eshoponcontainers.westus.cloudapp.azure.com:88/>

В рабочей среде на основе кластера этот URL-адрес будет указывать на подсистему балансировки нагрузки кластера, которая, в свою очередь, распределяет запросы между микрослужбами. В производственной среде можно использовать контроллер доставки приложений, например [шлюз приложения Azure](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) между вашими микрослужбами и Интернетом. Он выступает как прозрачный уровень, который не только выполняет балансировку нагрузки, но и защищает службы благодаря завершению SSL-запросов. Это уменьшает нагрузку на узлах за счет разгрузки завершения SSL-запросов и других задач, активно использующих ЦП, в шлюз приложений Azure. В любом случае подсистема балансировки нагрузки и контроллер доставки приложений прозрачны с точки зрения логической архитектуры приложения.

Архитектура прямого взаимодействия клиента и микрослужбы достаточно хорошо подходит для небольших приложений на основе микрослужб, особенно если клиентское приложение представляет собой веб-приложение на стороне сервера, например приложение MVC ASP.NET. Однако при создании больших и сложных приложений на основе микрослужб (например, при обработке десятков типов микрослужб) и особенно в том случае, если клиентские приложения представляют собой удаленные мобильные приложения или одностраничные веб-приложения, этот подход приводит к появлению нескольких проблем.

При разработке крупного приложения на основе микрослужб ответьте на следующие вопросы:

-   *Как клиентские приложения могут свести к минимуму число запросов к серверной части и уменьшить частоту обмена данными с несколькими микрослужбами?*

Взаимодействие с несколькими микрослужбами для создания пользовательского интерфейса одного окна увеличивает количество обращений через Интернет. Это увеличивает задержку и сложности на стороне пользовательского интерфейса. В идеальном случае ответы должны эффективно агрегироваться на стороне сервера — это сокращает задержки, так как можно возвращать несколько фрагментов данных в параллельном режиме, и в некоторых пользовательских интерфейсах данные можно отобразить сразу же после их появления.

-   *Как вы можете обрабатывать сквозную функциональность, например проверку подлинности, преобразование данных и динамическую диспетчеризацию запросов?*

Реализация вопросов безопасности и сквозной функциональности, например реализация безопасности и проверки подлинности на каждой микрослужбе, может потребовать значительных усилий. Один из возможных подходов состоит в том, чтобы разместить эти службы на узле Docker или во внутреннем кластере, чтобы предотвратить прямой доступ к ним извне и реализовать сквозную функциональность в централизованном месте, например в шлюзе API.

-   *Как клиентские приложения взаимодействуют со службами, использующими не поддерживаемые в Интернете протоколы?*

Протоколы, используемые на стороне сервера (например, AMQP или двоичные протоколы), обычно не поддерживаются в клиентских приложениях. Поэтому запросы необходимо выполнять через такие протоколы, как HTTP или HTTPS, а затем преобразовывать в другие протоколы. Подход *человек посередине* может помочь в этой ситуации.

-   *Как создать интерфейс, специально предназначенный для мобильных приложений?*

API нескольких микрослужб может быть не слишком хорошо приспособлено для удовлетворения потребностей различных клиентских приложений. Например, потребности мобильного приложения могут отличаться от потребностей веб-приложения. Для мобильных приложений может потребоваться дополнительная оптимизация, чтобы повысить эффективность данных ответов. Это можно сделать, агрегировав данные из нескольких микрослужб и возвращая один набор данных. Также иногда можно исключить из ответа все данные, которые не требуются мобильному приложению. И, конечно же, эти данные можно сжать. Опять же, можно предусмотреть удобный интерфейс или API между микрослужбами и мобильным приложением для этого сценария.

## <a name="using-an-api-gateway"></a>Использование шлюза API

При проектировании и разработке крупных или сложных приложений на основе микрослужб с несколькими клиентскими приложениями рекомендуется использовать [шлюз API](http://microservices.io/patterns/apigateway.html). Это служба, предоставляющая единую точку входа для определенных групп микрослужб. Эта служба похожа на [шаблон интерфейса](https://en.wikipedia.org/wiki/Facade_pattern) из объектно-ориентированного проектирования, но в этом случае она является частью распределенной системы. Шаблон шлюза API также иногда называют "серверной частью для клиентской части" [(BFF)](http://samnewman.io/patterns/architectural/bff/), так как она создается с учетом потребностей клиентского приложения.

На рисунке 4-13 показано, как пользовательский шлюз API можно использовать в архитектуре на основе микрослужб.
Важно отметить, что на этой схеме вы использовали бы одну пользовательскую службу шлюза API, взаимодействующую с несколькими и различными клиентскими приложениями. Этот факт может привести к заметному риску, так как служба шлюза API будет расти и развиваться на основе множества различных требований от клиентских приложений. Со временем служба шлюза API окажется перегруженной из-за различных требований и по сути окажется похожей на монолитное приложение или монолитную службу. Поэтому настоятельно рекомендуется разделять шлюз API между различными службами или между более мелкими шлюзами API, например по одному шлюзу для каждого типа форм-фактора.

![](./media/image13.png)

**Рис. 4-13**. Использование шлюза API, реализованного как пользовательская служба веб-API

В этом примере шлюз API будет реализован в виде пользовательской службы веб-API, запущенной в виде контейнера.

Как уже упоминалось, следует реализовать несколько шлюзов API, чтобы у каждого из них был отдельный интерфейс для удовлетворения потребностей каждого клиентского приложения. Каждый шлюз API может предоставлять различное API с учетом потребностей каждого клиентского приложения, возможно, даже на основе форм-фактора клиента с помощью реализации специального кода адаптера, который вызывает несколько внутренних микрослужб.

Так как пользовательский шлюз API обычно представляет собой агрегатор данных, будьте внимательны при работе с ним. Обычно не рекомендуется иметь один шлюз API, который агрегирует все внутренние микрослужбы вашего приложения. Такой шлюз выступает в качестве монолитного агрегатора или оркестратора и нарушает автономность микрослужб, связывая все микрослужбы друг с другом. Поэтому шлюзы API должны быть разделены на основе бизнес-границ и не должны выступать в качестве агрегатора для всего приложения.

Иногда специализированный API шлюза также может представлять собой микрослужбу и даже иметь домен или бизнес-имя и соответствующие данные. Наличие границ шлюза API, определяемых бизнес-требованиями или доменом, поможет лучше спроектировать шлюз.

Степень детализации для уровня шлюза API может быть особенно удобной для более сложных приложений с составным пользовательским интерфейсом на основе микрослужб, так как концепция детализированного шлюза API похожа на службу с составным пользовательским интерфейсом. Этот вопрос будет рассмотрен позже в разделе [Создание составного пользовательского интерфейса на основе микрослужб](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).

Таким образом, для многих средних и крупных приложений пользовательский API шлюза обычно является хорошим решением, но не в качестве единого монолитного агрегатора или уникального централизованного пользовательского шлюза API.

Другой вариант — использовать такой продукт как [Управление API Azure](https://azure.microsoft.com/services/api-management/), как показано на рис. 4-14. Такой подход не только позволяет удовлетворить потребности шлюза API, но и предоставляет такие функции, как сбор аналитических данных с ваших интерфейсов API. Если вы используете решение для управления API, шлюз API является только компонентом в рамках полного решения по управлению API.

![](./media/image14.png)

**Рис. 4-14**. Использование управления API Azure для шлюза API

В этом случае при использовании такого продукта, как управление API Azure, наличие одного шлюза API не так рискованно, так как такие виды шлюзов API "тоньше". Это означает, что вы не сможете реализовать пользовательский код C#, который сможет развиваться в сторону монолитного компонента. 

Такой продукт, скорее, выступает в роли обратного прокси для приема данных, при котором также можно фильтровать API от внутренних микрослужб, а также применять авторизацию к опубликованным API на этом уровне.

Аналитические сведения, доступные из системы управления API, помогут вам понять, как используются ваши API и насколько эффективно они работают. Для этого вы можете просматривать отчеты практически в режиме реального времени и выявлять тенденции, которые могут повлиять на ваш бизнес. Кроме того, вы можете вести журналы запросов и ответов как для интерактивного, так и для автономного анализа.

С помощью управления API Azure вы можете защитить свои интерфейсы API с помощью ключей, маркеров и фильтрации IP-адресов. Эти возможности позволяют обеспечить гибкие и точные квоты и ограничения скорости, изменить форму и поведение ваших API с помощью политик и улучшить производительность с помощью кэширования ответов.

В этом руководстве и в примере приложения (eShopOnContainers) мы ограничиваем архитектуру до более простой пользовательской контейнерной архитектуры, чтобы сосредоточиться только на контейнерах без использования продуктов PaaS, таких как управление API Azure. Однако для крупных приложений на основе микрослужб, развернутых в Microsoft Azure, мы рекомендуем изучить и адаптировать API управления Azure в качестве основы для шлюзов API.

## <a name="drawbacks-of-the-api-gateway-pattern"></a>Недостатки шаблона шлюза API

-   Наиболее важный недостаток заключается в том, что при реализации шлюза API вы связываете этот уровень с внутренними микрослужбами. Такое связывание может привести к серьезным проблемам для вашего приложения. Клеменс Вастер, архитектор команды по разработке служебной шины Azure, называет эту потенциальную трудность "новой служебной шиной предприятия (ESB)" в своем выступлении "[Обмен сообщениями и микрослужбы](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" на GOTO 2016.

-   Использование шлюза API микрослужб создает возможную дополнительную единую точку отказа.

-   Шлюз API может привести к увеличению времени ответа из-за дополнительного сетевого вызова. Однако этот дополнительный вызов обычно оказывает меньшее влияние, чем целый клиентский интерфейс, который постоянно взаимодействует с внутренними микрослужбами.

-   При отсутствии должного масштабирования шлюз API может стать узким местом.

-   Шлюз API требует дополнительных затрат на разработку и последующее обслуживание, если он включает пользовательскую логику и агрегирование данных. Чтобы предоставить конечные точки каждой микрослужбы, разработчикам необходимо обновить шлюз API. Кроме того, изменения в реализации внутренних микрослужб могут вызвать изменения кода на уровне API шлюза. Тем не менее, если в шлюзе API просто применяется безопасность, ведение журналов и управление версиями (как при использовании управления API Azure), эти затраты на разработку могут отсутствовать.

-   Если шлюз API разрабатывается одной командой, это может быть узким местом разработки. Это еще одна причина, по которой лучше использовать несколько специализированных шлюзов API, которые реализуют различные потребности клиента. Также можно внутренне разделить шлюз API на несколько областей или уровней, которые принадлежат другим командам, работающим над внутренними микрослужбами.

## <a name="additional-resources"></a>Дополнительные ресурсы

-   **Чарльз Ричардсон (Charles Richardson). Шаблон: шлюз API / серверная часть для клиентской части**
    [*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)

-   **Управление API Azure**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)

-   **Уди Дахан (Udi Dahan). Объединение на основе служб**\
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   **Клеменс Вастерс (Clemens Vasters). Обмен сообщениями и микрослужбы на GOTO 2016** (видео) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)


>[!div class="step-by-step"]
[Назад] (identify-microservice-domain-model-boundaries.md) [Далее] (communication-in-microservice-architecture.md)
