---
title: "Обмен данными в архитектуре микрослужбу"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Обмен данными в архитектурах микрослужбу архитектуры"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="6130b-104">Обмен данными в архитектуре микрослужбу</span><span class="sxs-lookup"><span data-stu-id="6130b-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="6130b-105">Монолитные приложения, работающего в одном процессе компоненты вызывать друг с другом с помощью метода уровня языка или вызовы функций.</span><span class="sxs-lookup"><span data-stu-id="6130b-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="6130b-106">Это может быть тесно связаны при создании объектов с кодом (например, `new ClassName()`), или можно вызывать несвязанной образом с помощью внедрения зависимости, ссылаясь на абстрактные классы, а не конкретный объект экземпляров.</span><span class="sxs-lookup"><span data-stu-id="6130b-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="6130b-107">В любом случае объекты выполняются в одном процессе.</span><span class="sxs-lookup"><span data-stu-id="6130b-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="6130b-108">Самая сложная задача при изменении монолитные приложения для приложения на основе микрослужбами заключается в изменении механизм обмена данными.</span><span class="sxs-lookup"><span data-stu-id="6130b-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="6130b-109">Прямое преобразование из вызовов методов в процессе в вызовы RPC службы приведет к «многословных» и не эффективного взаимодействия, которая не будет выполняться в распределенных средах.</span><span class="sxs-lookup"><span data-stu-id="6130b-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="6130b-110">Трудностей при проектировании распределенной системе должным образом достаточно хорошо известны это даже canon, известный как [fallacies распределенных вычислений](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) , в которой перечислены предположений, которые разработчики часто при переходе от монолитные для распределенных разработок.</span><span class="sxs-lookup"><span data-stu-id="6130b-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="6130b-111">Нет, не одно из решений, но некоторые.</span><span class="sxs-lookup"><span data-stu-id="6130b-111">There is not one solution, but several.</span></span> <span data-ttu-id="6130b-112">Одно решение включает в себя изоляция максимально микрослужбами бизнеса.</span><span class="sxs-lookup"><span data-stu-id="6130b-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="6130b-113">Затем используйте асинхронную связь между внутренней микрослужбами и замените детально взаимодействие, обычно внутри процесса связи между объектами, имеющими крупногранулированную связи.</span><span class="sxs-lookup"><span data-stu-id="6130b-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="6130b-114">Это можно сделать, группируя вызовов и возвращая данные, объединяет результаты нескольких внутренних вызовов клиенту.</span><span class="sxs-lookup"><span data-stu-id="6130b-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="6130b-115">Приложения на основе микрослужбами является распределенных систем, работающих на несколько процессов или служб, обычно даже между несколькими серверами или узлов.</span><span class="sxs-lookup"><span data-stu-id="6130b-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="6130b-116">Как правило, каждый экземпляр службы — это процесс.</span><span class="sxs-lookup"><span data-stu-id="6130b-116">Each service instance is typically a process.</span></span> <span data-ttu-id="6130b-117">Таким образом службы должны взаимодействовать по протоколу межпроцессного взаимодействия, например, HTTP, AMQP или двоичный протокол, такой как TCP, в зависимости от характера каждой службы.</span><span class="sxs-lookup"><span data-stu-id="6130b-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="6130b-118">Сообщество микрослужбу способствует философии "[смарт-конечные точки и каналы ввода-вывода](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).»</span><span class="sxs-lookup"><span data-stu-id="6130b-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="6130b-119">Это слоган стимулирует макет, как связаны, как можно между микрослужбами и как целостного максимально в пределах одного микрослужбу.</span><span class="sxs-lookup"><span data-stu-id="6130b-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="6130b-120">Как упоминалось ранее, собственные данные и логику домена, принадлежат каждого микрослужбу.</span><span class="sxs-lookup"><span data-stu-id="6130b-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="6130b-121">Но микрослужбами, составление-готовое приложение обычно просто choreographed с помощью REST связи, а не сложных протоколов, таких как WS -\* и централизованное гибкие связи с событиями вместо бизнес процесс orchestrators.</span><span class="sxs-lookup"><span data-stu-id="6130b-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="6130b-122">Два часто используемых протоколов, запросов и ответов HTTP с ресурсом API-интерфейсы (при запросе большинство всех) и время упрощенных асинхронный обмен сообщениями при обмене данными через несколько микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="6130b-123">Это описано в следующих разделах более подробно.</span><span class="sxs-lookup"><span data-stu-id="6130b-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="6130b-124">Типы взаимодействия</span><span class="sxs-lookup"><span data-stu-id="6130b-124">Communication types</span></span>

<span data-ttu-id="6130b-125">Клиента и службы могут взаимодействовать через различные виды взаимодействия, предназначенные для различных сценариев и цели каждого из них.</span><span class="sxs-lookup"><span data-stu-id="6130b-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="6130b-126">Изначально этих типов сообщений могут быть классифицированы две оси.</span><span class="sxs-lookup"><span data-stu-id="6130b-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="6130b-127">Если протокол синхронный или асинхронный, является определение первой оси:</span><span class="sxs-lookup"><span data-stu-id="6130b-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="6130b-128">Синхронные протокол.</span><span class="sxs-lookup"><span data-stu-id="6130b-128">Synchronous protocol.</span></span> <span data-ttu-id="6130b-129">Синхронные протокол HTTP не.</span><span class="sxs-lookup"><span data-stu-id="6130b-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="6130b-130">Клиент отправляет запрос и ожидает ответа от службы.</span><span class="sxs-lookup"><span data-stu-id="6130b-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="6130b-131">Независимо от выполнения кода клиента, может быть синхронным (поток заблокирован) или асинхронные (поток не заблокирован, и ответ в конечном счете достигнет обратный вызов).</span><span class="sxs-lookup"><span data-stu-id="6130b-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="6130b-132">Здесь важно то, что протокол (HTTP/HTTPS) является синхронным и код клиента можно продолжить свою задачу, только при получении HTTP-ответа сервера.</span><span class="sxs-lookup"><span data-stu-id="6130b-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="6130b-133">Асинхронный протокол.</span><span class="sxs-lookup"><span data-stu-id="6130b-133">Asynchronous protocol.</span></span> <span data-ttu-id="6130b-134">Другие протоколы, например AMQP (протокол поддерживает несколько операционных систем и облачных средах) с помощью асинхронных сообщений.</span><span class="sxs-lookup"><span data-stu-id="6130b-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="6130b-135">Отправитель Код или сообщение клиента обычно не ожидает ответа.</span><span class="sxs-lookup"><span data-stu-id="6130b-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="6130b-136">Он просто отправляет сообщения в виде при отправке сообщения в очередь RabbitMQ или других брокер обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="6130b-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="6130b-137">Если обмен данными имеет один получатель или нескольким получателям, является определение второй оси:</span><span class="sxs-lookup"><span data-stu-id="6130b-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="6130b-138">Один получатель.</span><span class="sxs-lookup"><span data-stu-id="6130b-138">Single receiver.</span></span> <span data-ttu-id="6130b-139">Каждый запрос должен обрабатываться ровно один получатель или службой.</span><span class="sxs-lookup"><span data-stu-id="6130b-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="6130b-140">Примером этого является [команд](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="6130b-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="6130b-141">Нескольким получателям.</span><span class="sxs-lookup"><span data-stu-id="6130b-141">Multiple receivers.</span></span> <span data-ttu-id="6130b-142">Каждый запрос могут обрабатываться на ноль между несколькими получателями.</span><span class="sxs-lookup"><span data-stu-id="6130b-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="6130b-143">Этот тип обмена данными должен выполняться асинхронно.</span><span class="sxs-lookup"><span data-stu-id="6130b-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="6130b-144">Например, [публикации или подписки](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) механизм, используемый в шаблонах, таких как [событиями архитектура](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="6130b-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="6130b-145">Следующий пример основан на интерфейс или сообщения компонента broker событий шины при распространении обновлений данных между несколькими микрослужбами через события; он обычно реализуется с помощью шины обслуживания или аналогичные артефакт как [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) с помощью [разделы и подписки](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="6130b-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="6130b-146">Приложения на основе микрослужбу часто будет использовать сочетание этих стилей связи.</span><span class="sxs-lookup"><span data-stu-id="6130b-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="6130b-147">Наиболее распространенным типом является один получатель связь с синхронной протокол, такой как HTTP или HTTPS при вызове метода регулярное службы Web API HTTP.</span><span class="sxs-lookup"><span data-stu-id="6130b-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="6130b-148">Микрослужбами также обычно используют протоколы обмена сообщениями для асинхронной связи между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="6130b-149">Полезно знать, чтобы иметь ясности на механизмы возможные связи, но они не являются важные вопросы при построении микрослужбами используются эти оси.</span><span class="sxs-lookup"><span data-stu-id="6130b-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="6130b-150">Асинхронной природой выполнение потока клиента даже асинхронной природой выбранного протокола являются важных моментов при интеграции микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="6130b-151">Что *—* важным является возможность интегрировать ваш микрослужбами асинхронно сохранением независимости от микрослужбами, как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="6130b-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="6130b-152">Асинхронные микрослужбу принудительно автономность микрослужбу элемента</span><span class="sxs-lookup"><span data-stu-id="6130b-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="6130b-153">Как уже упоминалось, важно при построении приложения на основе микрослужбами является способом интеграции вашего микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="6130b-154">В идеальном случае следует попытаться свести к минимуму обмен данными между внутренней микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="6130b-155">Меньше взаимодействия между микрослужбами, тем лучше.</span><span class="sxs-lookup"><span data-stu-id="6130b-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="6130b-156">Но Конечно, во многих случаях необходимо интегрировать микрослужбами каким-либо образом.</span><span class="sxs-lookup"><span data-stu-id="6130b-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="6130b-157">При необходимости для этого правило критического является, обмен данными между микрослужбами должен быть асинхронным.</span><span class="sxs-lookup"><span data-stu-id="6130b-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="6130b-158">Это не означает наличие использование определенного протокола (например, асинхронный обмен сообщениями и синхронный HTTP).</span><span class="sxs-lookup"><span data-stu-id="6130b-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="6130b-159">Просто означает, обмен данными между микрослужбами может выполнять только передача данных асинхронно, что старайтесь не зависят от других внутренних микрослужбами как часть операции запроса и ответа HTTP начальной службы.</span><span class="sxs-lookup"><span data-stu-id="6130b-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="6130b-160">Если это возможно никогда не зависят от синхронной связи между несколькими микрослужбами, даже для запросов (запрос ответ).</span><span class="sxs-lookup"><span data-stu-id="6130b-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="6130b-161">Каждый микрослужбу предназначена для того, чтобы быть автономными и доступно для потребителя клиента, даже если другие службы, которые являются частью приложения начала до конца вниз или неработоспособное.</span><span class="sxs-lookup"><span data-stu-id="6130b-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="6130b-162">Если вы считаете, что необходимо вызвать один микрослужбу других микрослужбами (например, при выполнении запроса HTTP для запроса данных) в, чтобы предоставить ответа в клиентское приложение, у вас есть архитектуру, которая не будет устойчивой, если некоторые микрослужбами ошибкой.</span><span class="sxs-lookup"><span data-stu-id="6130b-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="6130b-163">Кроме того не только зависимости HTTP между микрослужбами, как и при создании много циклов запросов и ответов HTTP-запрос цепочки, как показано в первой части 4 Рисунок-15, приводит к микрослужбами не автономной, но также является их производительности так как только одна из служб в этой цепочке низкую производительность.</span><span class="sxs-lookup"><span data-stu-id="6130b-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="6130b-164">Чем больше добавляется синхронной зависимости между микрослужбами, такие как запросы, хуже возвращает общее время ответа для клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="6130b-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="6130b-165">**Рис. 4-15**.</span><span class="sxs-lookup"><span data-stu-id="6130b-165">**Figure 4-15**.</span></span> <span data-ttu-id="6130b-166">Антишаблоны и шаблонов в связи между микрослужбами</span><span class="sxs-lookup"><span data-stu-id="6130b-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="6130b-167">Если ваш микрослужбу должен вызывать дополнительные действия в другой микрослужбу, если это возможно, не выполнить это действие синхронно и как часть исходной операции запросов и ответов микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="6130b-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="6130b-168">Это можно сделать асинхронно (с помощью асинхронного обмена сообщениями или события интеграции, очереди, и т. д.).</span><span class="sxs-lookup"><span data-stu-id="6130b-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="6130b-169">Однако, по возможности, не вызвать действие синхронно в рамках исходного синхронной операции запроса и ответа.</span><span class="sxs-lookup"><span data-stu-id="6130b-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="6130b-170">И, наконец, и это, где большинство вопросов, возникающих при построении микрослужбами, если ваш исходный микрослужбу должны изначально, владельцем которого является другой микрослужбами, не следует полагаться на внесение синхронных запросов к этим данным.</span><span class="sxs-lookup"><span data-stu-id="6130b-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="6130b-171">Вместо этого реплицировать или распространить эти данные (только необходимые атрибуты, которые) в службе начальной базы данных с помощью окончательной согласованности (обычно с помощью события интеграции, как описано в следующих разделах).</span><span class="sxs-lookup"><span data-stu-id="6130b-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="6130b-172">Как уже упоминалось в разделе [определение границ модель домена для каждого микрослужбу](#identifying-domain-model-boundaries-for-each-microservice), дублирование некоторые данные через несколько микрослужбами не неверный подход — с другой стороны, при выполнении, который может транслировать данные в определенном языке и условия этого дополнительного домена или ограниченного контекста.</span><span class="sxs-lookup"><span data-stu-id="6130b-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="6130b-173">Например, в [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) приложения имеют микрослужбу, с именем identity.api, ответственный за большую часть данных пользователя с сущность с именем пользователя.</span><span class="sxs-lookup"><span data-stu-id="6130b-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="6130b-174">Тем не менее при необходимости хранить данные о пользователе в микрослужбу упорядочения элементов можно сохранить ее в качестве другую сущность с именем покупателей.</span><span class="sxs-lookup"><span data-stu-id="6130b-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="6130b-175">Покупатель сущности имеет то же удостоверение с исходной сущности пользователя, но он может быть несколько атрибутов, необходимые для упорядочения элементов домена, а не весь профиль.</span><span class="sxs-lookup"><span data-stu-id="6130b-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="6130b-176">Можно использовать любой протокол обмена данными и распространения данных асинхронно через микрослужбами для окончательной согласованности.</span><span class="sxs-lookup"><span data-stu-id="6130b-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="6130b-177">Как уже упоминалось, можно использовать события интеграции с помощью событий шины или сообщений посредника или даже использовать HTTP опрашивая других служб.</span><span class="sxs-lookup"><span data-stu-id="6130b-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="6130b-178">Он не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="6130b-178">It does not matter.</span></span> <span data-ttu-id="6130b-179">Главное правило — не создают синхронные зависимости между вашей микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="6130b-180">Ниже описаны различные стили связи, рассмотрите возможность использования в приложении микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="6130b-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="6130b-181">Стили связи</span><span class="sxs-lookup"><span data-stu-id="6130b-181">Communication styles</span></span>

<span data-ttu-id="6130b-182">Существует множество протоколов и варианты, которые можно использовать для взаимодействия, в зависимости от типа связи, которые вы хотите использовать.</span><span class="sxs-lookup"><span data-stu-id="6130b-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="6130b-183">При использовании механизма синхронной связи на основе запроса/ответа протоколов, таких как HTTP, так и REST подход наиболее распространены, особенно при развертывании служб за пределами кластера узла или микрослужбу Docker.</span><span class="sxs-lookup"><span data-stu-id="6130b-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="6130b-184">Если необходимо обмениваться данными между службами (внутри кластера узла или микрослужбами Docker) можно также использовать механизмы взаимодействия двоичный формат (например, удаленное взаимодействие Service Fabric или WCF с помощью TCP и в двоичном формате).</span><span class="sxs-lookup"><span data-stu-id="6130b-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="6130b-185">Кроме того можно использовать механизмы асинхронной связи на основе сообщения, такие как AMQP.</span><span class="sxs-lookup"><span data-stu-id="6130b-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="6130b-186">Также существует несколько форматов сообщений, как JSON или XML или даже двоичных форматов, которые могут быть более эффективными.</span><span class="sxs-lookup"><span data-stu-id="6130b-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="6130b-187">Если ваш выбранного двоичного формата не является стандартом, скорее всего, не рекомендуется, публично Публикация служб в этом формате.</span><span class="sxs-lookup"><span data-stu-id="6130b-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="6130b-188">Можно использовать нестандартный формат для внутренней связи между вашей микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="6130b-189">Это делается при обмене данными между микрослужбами в Docker узла или микрослужбу кластера (Docker orchestrators или Azure Service Fabric) или для собственных клиентских приложений, которые обращаются к микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6130b-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="6130b-190">Запрос ответ связь с HTTP и REST</span><span class="sxs-lookup"><span data-stu-id="6130b-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="6130b-191">Если клиент использует взаимодействия запрос ответ, он отправляет запрос к службе, а затем процессы службы запрос и отправляет ответ обратно.</span><span class="sxs-lookup"><span data-stu-id="6130b-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="6130b-192">Взаимодействия запрос ответ особенно хорошо подходит для запроса данных в режиме реального времени пользовательского интерфейса (динамической пользовательский интерфейс) из клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="6130b-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="6130b-193">Таким образом в архитектуре микрослужбу, скорее всего, используется этот механизм обмена данными для большинства запросов, как показано на рисунке 4-16.</span><span class="sxs-lookup"><span data-stu-id="6130b-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="6130b-194">**На рисунке 4 – 16**.</span><span class="sxs-lookup"><span data-stu-id="6130b-194">**Figure 4-16**.</span></span> <span data-ttu-id="6130b-195">С помощью запросов и ответов взаимодействие по протоколу HTTP (синхронный или асинхронный)</span><span class="sxs-lookup"><span data-stu-id="6130b-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="6130b-196">Клиент использует взаимодействия запрос ответ, предполагается, что ответ будут доставлены за короткий промежуток времени, обычно менее секунды или через несколько секунд не более.</span><span class="sxs-lookup"><span data-stu-id="6130b-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="6130b-197">Для отложенной ответов необходимо реализовать асинхронную связь на основе [обмена сообщениями](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) и [технологий обмена сообщениями](https://en.wikipedia.org/wiki/Message-oriented_middleware), который является другой подход, который рассматривается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="6130b-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="6130b-198">Популярный архитектурный стиль для взаимодействия запросов и ответов — [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="6130b-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="6130b-199">Этот подход основан, а также тесно связана с, [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) протокола, в рамках команды HTTP, такие как GET, POST и ПОМЕСТИТЬ.</span><span class="sxs-lookup"><span data-stu-id="6130b-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="6130b-200">REST подход наиболее часто используемые архитектуры связи при создании службы.</span><span class="sxs-lookup"><span data-stu-id="6130b-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="6130b-201">Службы REST можно реализовать при разработке веб-API ASP.NET Core services.</span><span class="sxs-lookup"><span data-stu-id="6130b-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="6130b-202">При использовании служб HTTP REST в качестве языка определения интерфейса нет никакой ценности.</span><span class="sxs-lookup"><span data-stu-id="6130b-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="6130b-203">Например при использовании [метаданных Swagger](http://swagger.io/) для описания API-Интерфейс службы, можно использовать средства, создав заглушки клиента, можно напрямую обнаружение и использование служб.</span><span class="sxs-lookup"><span data-stu-id="6130b-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="6130b-204">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="6130b-204">Additional resources</span></span>

-   <span data-ttu-id="6130b-205">**Мартин Фоулер (Martin Fowler). Модель зрелости Ричардсон.**</span><span class="sxs-lookup"><span data-stu-id="6130b-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="6130b-206">Описание модели REST.</span><span class="sxs-lookup"><span data-stu-id="6130b-206">A description of the REST model.</span></span>
    [<span data-ttu-id="6130b-207">*http://martinfowler.com/articles/richardsonMaturityModel.HTML*</span><span class="sxs-lookup"><span data-stu-id="6130b-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="6130b-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="6130b-208">**Swagger.**</span></span> <span data-ttu-id="6130b-209">Официальный сайт.</span><span class="sxs-lookup"><span data-stu-id="6130b-209">The official site.</span></span>
    [<span data-ttu-id="6130b-210">*http://swagger.IO/*</span><span class="sxs-lookup"><span data-stu-id="6130b-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="6130b-211">Push-уведомлений и в режиме реального времени соединения по протоколу HTTP</span><span class="sxs-lookup"><span data-stu-id="6130b-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="6130b-212">Другой вариант (обычно для разных целей, чем REST) — в режиме реального времени и один ко многим обмен данными с платформами более высокого уровня, таких как [ASP.NET SignalR](https://www.asp.net/signalr) и протоколов, таких как [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="6130b-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="6130b-213">Как показано на рисунке 4-17, в режиме реального времени соединения по протоколу HTTP означает, что можно иметь серверный код помещает содержимое подключенных клиентов, когда данные становятся доступны, а не ждать клиента для запроса новых данных сервера.</span><span class="sxs-lookup"><span data-stu-id="6130b-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="6130b-214">**На рисунке 4-17**.</span><span class="sxs-lookup"><span data-stu-id="6130b-214">**Figure 4-17**.</span></span> <span data-ttu-id="6130b-215">Один к одному в режиме реального времени асинхронный обмен сообщениями</span><span class="sxs-lookup"><span data-stu-id="6130b-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="6130b-216">Поскольку связи находится в режиме реального времени, клиентские приложения практически мгновенно отображать изменения.</span><span class="sxs-lookup"><span data-stu-id="6130b-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="6130b-217">Это обычно обрабатываются протокол, например WebSockets, с помощью большого количества подключений WebSockets (по одному для каждого клиента).</span><span class="sxs-lookup"><span data-stu-id="6130b-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="6130b-218">Типичным примером является служба, взаимодействующие изменение оценка игры спортивных множество клиентских веб-приложениям одновременно.</span><span class="sxs-lookup"><span data-stu-id="6130b-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="6130b-219">[Предыдущие] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Далее] (асинхронной сообщения — на основе communication.md)</span><span class="sxs-lookup"><span data-stu-id="6130b-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
