---
title: "Проблемы и решения для управления распределенными данными"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Проблемы и решения для управления распределенными данными"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="bcdf4-104">Проблемы и решения для управления распределенными данными</span><span class="sxs-lookup"><span data-stu-id="bcdf4-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="bcdf4-105">Запрос \#1: способ определения границ каждого микрослужбу</span><span class="sxs-lookup"><span data-stu-id="bcdf4-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="bcdf4-106">Определение границ микрослужбу является первой проверки, возникающих в любой пользователь.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="bcdf4-107">Каждый микрослужбу должно быть части приложения и каждого микрослужбу должен быть автономной все преимущества и проблемы, которые он предоставляет.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="bcdf4-108">Но как определить эти границы?</span><span class="sxs-lookup"><span data-stu-id="bcdf4-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="bcdf4-109">Во-первых необходимо сосредоточиться на моделях логического домена приложения и связанные данные.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="bcdf4-110">Необходимо попытаться выявить несвязанной острова данных и различных контекстах внутри одного приложения.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="bcdf4-111">В каждом контексте могут иметь различные языка (различные бизнес-терминологией).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="bcdf4-112">Контексты должен быть определяются и управляются независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="bcdf4-113">Термины и объекты, используемые в этих контекстах может показаться аналогичный, но может оказаться, что в указанном контексте бизнес-концепция, с одним используется для другой цели в другом контексте и даже может иметь другое имя.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="bcdf4-114">Например пользователя можно обращаться как пользователь в контексте удостоверения или членства как клиента в контексте CRM, в качестве покупателей в контексте порядка сортировки и так далее.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="bcdf4-115">Способ определения границ между несколькими контекстами приложение с другим доменом, для каждого контекста именно идентифицируете границы для каждого микрослужбу бизнеса и связанные с ним модели домена и данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="bcdf4-116">Всегда пытаются минимизировать связь между этими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="bcdf4-117">В этом руководстве приведены более подробные сведения об этом проектирования модели идентификации и домена в разделе [определение границ модель домена для каждого микрослужбу](#identifying-domain-model-boundaries-for-each-microservice) позже.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="bcdf4-118">Запрос \#2: создание запросов, получающих данные из нескольких микрослужбами</span><span class="sxs-lookup"><span data-stu-id="bcdf4-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="bcdf4-119">Второй запрос — способы реализации запросов, получающих данные из нескольких микрослужбами избегая частый обмен данными микрослужбами от удаленного клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="bcdf4-120">Пример может быть на одном экране из мобильного приложения, который необходимо показать сведения о пользователе, владельцем которого является корзины, каталогом и микрослужбами удостоверение пользователя.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="bcdf4-121">Другим примером может служить сложных отчетов, связанных с большим количеством таблиц, расположенных в нескольких микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="bcdf4-122">Решение зависит от сложности запросов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="bcdf4-123">Однако в любом случае потребуется способ статистические данные, если вы хотите повысить эффективность обмена данными вашей системы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="bcdf4-124">Ниже перечислены наиболее популярных решений.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="bcdf4-125">**Шлюз API**.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-125">**API Gateway**.</span></span> <span data-ttu-id="bcdf4-126">Для статистической обработки данных из нескольких микрослужбами, принадлежат разным базам данных рекомендуется микрослужбу статистической обработки, называются шлюз API.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="bcdf4-127">Тем не менее необходимо уделять особое внимание реализации этот шаблон, так как он может быть моментом стягиванием системы и он может нарушать принцип микрослужбу автономность.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="bcdf4-128">Чтобы устранить такую возможность, может иметь несколько шлюзов API Контролируемая влечет каждого один сосредоточиться на «срез» по вертикали или области деятельности системы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="bcdf4-129">Шаблон шлюза API является более подробно в разделе Using шлюз API в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="bcdf4-130">**CQRS с таблицами, запрос чтения**.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="bcdf4-131">Еще одно решение для статистической обработки данных из нескольких микрослужбами — [материализованные представления шаблон](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="bcdf4-132">При таком подходе можно создать, заранее (Подготовка денормализованные данные до возникновения фактическими запросами), с данными, владельцем которого является несколько микрослужбами таблицы только для чтения.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="bcdf4-133">Таблица имеет формат, соответствующий потребностям в клиентском приложении.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="bcdf4-134">Рассмотрим нечто похожее на экране для мобильного приложения.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="bcdf4-135">При наличии одной базы данных может объединяют данные для данного экрана, с помощью SQL-запрос, выполняющий сложного соединения с использованием нескольких таблиц.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="bcdf4-136">Тем не менее если у вас есть несколько баз данных, а каждая база данных принадлежит другой микрослужбу, нельзя запрашивать эти базы данных и создавать соединения SQL.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="bcdf4-137">Сложный запрос становится проблемой.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="bcdf4-138">Можно решить требования, используя подход CQRS — создать денормализованные таблицу в другой базе данных, который используется только для запросов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="bcdf4-139">Таблицы могут быть разработаны специально для данных, необходимые для сложных запросов, с отношением один к одному между полями, требуется экрана приложения и столбцы в таблице запрос.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="bcdf4-140">Его также можно использовать для создания отчетов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="bcdf4-141">Этот подход не только позволяет решить проблемы (как запроса и соединения между микрослужбами); также повышает производительность значительно при сравнении с сложного соединения, поскольку уже есть данные, приложение должно таблицы запроса.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="bcdf4-142">Конечно с помощью команды и разделение ответственности запросов (CQRS) с таблицами, запрос чтения означает дополнительная разработка, и вам потребуется принять окончательной согласованности.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="bcdf4-143">Тем не менее требования к производительности и высокого уровня масштабируемости в [совместной](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (или конкуренция в зависимости от того, с точки зрения) — где следует применять CQRS с несколькими базами данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="bcdf4-144">**«Холодный данных» в центре баз данных**.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="bcdf4-145">Сложные отчеты и запросы, которые могут не требовать данные в реальном времени, распространенным подходом является экспорт вашей «горячих данных» (данные о транзакциях из микрослужбами) как «холодных» данных в больших баз данных, которые используются только для отчетов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="bcdf4-146">Система, центральная база данных может быть систему большие наборы данных, таких как Hadoop, хранилище данных как на основе хранилища данных SQL Azure или даже одной базы данных SQL используется только для отчетов (если размер не будет проблемой).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="bcdf4-147">Имейте в виду, что эта централизованная база данных будет использоваться только для запросов и отчетов, не требующие данные в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="bcdf4-148">Исходные обновления и транзакции, как ваш источник достоверных, должны быть в микрослужбами данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="bcdf4-149">Способ, выполняется синхронизация данных будет с помощью связи с событиями (рассматривается в следующих разделах) или с помощью других средств импорта и экспорта инфраструктуры базы данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="bcdf4-150">Если используется связь с событиями, процесс этой интеграции будет выглядеть так же как при распространении данных, как описано выше для таблиц CQRS запроса.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="bcdf4-151">Тем не менее, если при разработке приложения включает в себя постоянно агрегация сведений из нескольких микрослужбами для сложных запросов, может быть признаком плохого проекта — микрослужбу должно быть в качестве изолированных максимально из других микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="bcdf4-152">(При этом исключаются отчетов или анализа, всегда следует использовать центра данных холодного баз данных). Часто наличие этой проблемы может быть причина для объединения микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="bcdf4-153">Необходимо соблюдать баланс между автономность развитие и развертывание каждого микрослужбу строгой зависимости, связности и объединение данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="bcdf4-154">Запрос \#3: как для поддержания согласованности между несколькими микрослужбами</span><span class="sxs-lookup"><span data-stu-id="bcdf4-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="bcdf4-155">Как уже говорилось ранее, данных, владельцем каждого микрослужбу является закрытым для этого микрослужбу и возможен только с помощью его микрослужбу API.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="bcdf4-156">Таким образом представленных сложной задачей является способ реализации конца в конец бизнес-процессов, сохраняя согласованность между несколькими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="bcdf4-157">Чтобы проанализировать эту проблему, давайте рассмотрим пример из [eShopOnContainers обращение к приложению](http://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="bcdf4-158">Каталог микрослужбу сохраняет сведения о всех продуктах, включая их уровень запасов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="bcdf4-159">Упорядочение микрослужбу управляет заказов и необходимо убедиться, что нового заказа не превышает акции продукции доступный каталог.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="bcdf4-160">(Или сценарий может включать логику, которая обрабатывает Задолженный продуктов). В гипотетической монолитные версии этого приложения подсистемы порядка сортировки может просто использовать транзакции ACID Проверьте доступность на складе, создания заказа в таблице Orders и обновить имеющиеся товары в таблице Products.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="bcdf4-161">Однако в приложении микрослужбами на основе таблиц заказов и продуктов принадлежат их соответствующих микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="bcdf4-162">Никогда не микрослужбу следует баз данных, принадлежащих другой микрослужбу в транзакции или запросы, как показано на рисунке 4 – 9.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="bcdf4-163">**На рисунке 4 – 9**.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-163">**Figure 4-9**.</span></span> <span data-ttu-id="bcdf4-164">Микрослужбу не может напрямую обращаться к таблице в другой микрослужбу</span><span class="sxs-lookup"><span data-stu-id="bcdf4-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="bcdf4-165">Микрослужбу упорядочения элементов не должны обновлять таблицы Products напрямую, так как в таблице продуктов принадлежит микрослужбу каталога.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="bcdf4-166">Чтобы внести обновления каталога микрослужбу, микрослужбу упорядочения элементов только когда-либо следует использовать асинхронное взаимодействие, таких как события интеграции (сообщение и связи на основе события).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="bcdf4-167">Это как [eShopOnContainers](http://aka.ms/eshoponcontainers) ссылка приложения выполняет этот тип обновления.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="bcdf4-168">Как уже говорилось [Крепления Теорема](https://en.wikipedia.org/wiki/CAP_theorem), необходимо выбрать между доступностью и ACID строгая согласованность.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="bcdf4-169">Большинство сценариев, основанных на микрослужбу требуется доступности и высокую масштабируемость, в отличие от строгая согласованность.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="bcdf4-170">Критически важные приложения должны оставаться копии и запуска и разработчиков можно обойти строгая согласованность с помощью методов для работы со слабой или окончательной согласованности.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="bcdf4-171">Именно этот подход, выполняемое большинство архитектуры на основе микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="bcdf4-172">Кроме того, стиль ACID или двухфазной фиксации транзакции не только с принципами микрослужбами; в большинстве баз данных NoSQL (например, базу данных Azure Cosmos, MongoDB, т. д.) не поддерживают двухфазной фиксации транзакции.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="bcdf4-173">Тем не менее обслуживание данных очень важно согласованность разных служб и баз данных.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="bcdf4-174">Этот запрос также связана с вопрос, как распространить изменения через несколько микрослужбами, если некоторые данные должны быть избыточным — например, при необходимости иметь имя или описание в каталоге микрослужбу и корзине продукта микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="bcdf4-175">Хорошим решением этой проблемы является использование окончательной согласованности между микрослужбами определена через связи с событиями и системой публикации и подписки.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="bcdf4-176">В этих разделах рассматриваются в разделе [асинхронной связи с событиями](#async_event_driven_communication) далее в этом руководстве.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="bcdf4-177">Запрос \#4: как создавать связи через границы микрослужбу</span><span class="sxs-lookup"><span data-stu-id="bcdf4-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="bcdf4-178">Границы, обмена данными через микрослужбу является серьезной проблемой.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="bcdf4-179">В этом контексте связи не ссылается на то, что вы протокола следует использовать (HTTP и REST, AMQP обмена сообщениями и т. д.).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="bcdf4-180">Вместо этого адреса, какой стиль связи, следует использовать, и особенно как связанная вашей микрослужбами должна быть.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="bcdf4-181">В зависимости от уровня соединения если происходит сбой, влияние, сбой в системе будет сильно различаться.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="bcdf4-182">В распределенной системе как микрослужбами-приложении с настолько большое количество артефактов, перемещения и распределенные службы через несколько серверов или узлы компоненты со временем не удастся.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="bcdf4-183">Частичный сбой и еще больше простои возникает, так, следует создать ваш микрослужбами и связи между ними принимая во внимание риски общих такого распределенной системе.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="bcdf4-184">Популярный подход заключается в реализации HTTP (REST)-микрослужбами из-за простоты их основе.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="bcdf4-185">Подход на основе HTTP, полностью приемлемо; Здесь проблема связана с ее использование.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="bcdf4-186">При использовании запросов и ответов HTTP только для взаимодействия с вашей микрослужбами из клиентских приложений, или из API шлюзов, это нормально.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="bcdf4-187">Однако при создании длинных цепочек синхронные вызовы HTTP через микрослужбами обмена данными через границами, как будто микрослужбами объектов в приложении монолитные приложения будет в конечном счете возникли проблемы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="bcdf4-188">Для экземпляра представьте, что клиентское приложение отправляет вызов HTTP API на отдельных микрослужбу как микрослужбу упорядочения элементов.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="bcdf4-189">Если микрослужбу упорядочения элементов в свою очередь вызывает дополнительных цикла микрослужбами через HTTP в пределах того же запрос ответ, вы создаете цепочки вызовов HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="bcdf4-190">Это может показаться разумным изначально.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-190">It might sound reasonable initially.</span></span> <span data-ttu-id="bcdf4-191">Однако есть важные моменты, которые следует учитывать при выхода из строя этот путь:</span><span class="sxs-lookup"><span data-stu-id="bcdf4-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="bcdf4-192">Блокировки и низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-192">Blocking and low performance.</span></span> <span data-ttu-id="bcdf4-193">Из-за особенностей синхронные HTTP первоначальный запрос не получит ответ, завершения внутренние вызовы HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="bcdf4-194">Предположим, если количество этих вызовов существенно повышает и в то же время, один из промежуточного HTTP вызовы микрослужбу блокируется.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="bcdf4-195">Результатом является влияет на производительность, что общая масштабируемость экспоненциально повлияют на дополнительных увеличение запросы HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="bcdf4-196">Взаимозависимость микрослужбами с HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="bcdf4-197">Business микрослужбами не должен быть связан с другим микрослужбами бизнеса.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="bcdf4-198">В идеальном случае они должны «неизвестно» о существовании других микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="bcdf4-199">Если приложение использует взаимозависимость микрослужбами, как показано в примере, достижение автономность каждого микрослужбу будет практически невозможно.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="bcdf4-200">Сбой при любой один микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-200">Failure in any one microservice.</span></span> <span data-ttu-id="bcdf4-201">Если реализован цепочки микрослужбами, связанных с HTTP-обращениях при сбое любой микрослужбами (а в конечном итоге произойдет сбой) вся цепочка микрослужбами завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="bcdf4-202">Необходимо предусмотреть системой микрослужбу и продолжить работу, а также возможные во время частичных сбоев.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="bcdf4-203">Даже если реализовать логику клиент, использующий повторные попытки с экспоненциально растущим или механизмы Размыкатель цепи, дополнительные цепочки вызовов комплексного HTTP будет, тем сложнее его будет реализовать стратегию сбоя, основанный на HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="bcdf4-204">На самом деле Если вашей внутренней микрослужбами обмениваются путем создания цепочки HTTP-запросов, как описано, может оказаться монолитные приложения, но его в соответствии с HTTP между процессами вместо механизмы intraprocess связи.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="bcdf4-205">Таким образом для обеспечения автономности микрослужбу и повышения устойчивости, необходимо свести использование цепочек запросов и ответов взаимодействия между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="bcdf4-206">Рекомендуется использовать только асинхронное взаимодействие для взаимодействия между микрослужбу, с помощью асинхронных сообщений и событий-связи на основе или с помощью HTTP-опросы независимо от исходного цикла запросов и ответов HTTP.</span><span class="sxs-lookup"><span data-stu-id="bcdf4-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="bcdf4-207">Объясняется использование асинхронное взаимодействие с дополнительными сведениями далее в этом руководстве в разделах [асинхронной микрослужбу принудительно автономность микрослужбу](#asynchronous-microservice-integration-enforce-microservices-autonomy) и [асинхронной связь на основе сообщений](#asynchronous-message-based-communication).</span><span class="sxs-lookup"><span data-stu-id="bcdf4-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="bcdf4-208">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="bcdf4-208">Additional resources</span></span>

-   <span data-ttu-id="bcdf4-209">**Теорема CAP**
    [*https://en.wikipedia.org/wiki/CAP\_Теорема*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="bcdf4-210">**Итоговая согласованность**
    [*https://en.wikipedia.org/wiki/Eventual\_согласованности*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="bcdf4-211">**Основные сведения о согласованности данных**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="bcdf4-212">**Мартин Фоулер (Martin Fowler). CQRS (команды и разделение ответственности запроса)**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="bcdf4-213">**Материализованные представления**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="bcdf4-214">**Чарльз строки. ACID vs. БАЗОВЫЙ: pH Shifting обработки транзакций базы данных**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="bcdf4-215">**Компенсирующие транзакции**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="bcdf4-216">**UDI Dahan. Сервисноориентированные композиции**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="bcdf4-217">[Предыдущие] (логический и физического architecture.md) [Далее] (идентификации микрослужбу домена модели boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="bcdf4-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>
