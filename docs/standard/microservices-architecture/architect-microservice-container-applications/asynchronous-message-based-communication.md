---
title: "Асинхронное взаимодействие на основе сообщений"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Асинхронное взаимодействие на основе сообщений"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df39771295d12e122edbe27e91cd899e3318e301
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="asynchronous-message-based-communication"></a>Асинхронное взаимодействие на основе сообщений

Асинхронный обмен сообщениями и связи с событиями критически важны при распространении изменений через несколько микрослужбами и их моделей связанных доменах. Как упоминалось ранее в обсуждение микрослужбами и ограниченных контекстах (BCs), модели (пользователь, клиент, продукта, учетная запись, т. д.) может иметь различные значения для разных микрослужбами или BCs. Что означает, что при внесении изменений, нужно каким-либо способом согласовать изменения различных моделей. Решением является окончательной согласованности и обмен данными на основе событий основании асинхронного обмена сообщениями.

При использовании обмена сообщениями, процессы взаимодействовать, обмениваясь сообщениями асинхронно. Клиент отправляет команду или запрос в службу, отправив сообщение. Если служба должна ответить, он отправляет разные сообщения обратно клиенту. Поскольку это связь на основе сообщений, клиент предполагает, что ответ не будут приниматься немедленно и возможного нет ответа на всех.

Сообщение сформирован заголовка (метаданные, например сведения о идентификации или безопасности) и текста. Обычно сообщения отправляются через асинхронные протоколы, такие как AMQP.

Предпочтительный инфраструктуры для этого типа обмена данными в сообществе микрослужбами является broker упрощенных сообщения, который отличается от больших брокеров и orchestrators, используемых в SOA. В брокеру упрощенных сообщение инфраструктуры — обычно «ввода-вывода, «выступает брокер обмена сообщениями с простой реализации, например RabbitMQ или масштабируемой служебной шины в облаке, такая как Azure Service Bus. В этом случае большая мышления «смарт-» по-прежнему находится в конечных точках, формирующего и получении сообщений, то есть в микрослужбами.

Другое правило, которое следует выполнить, насколько возможно, является использование только асинхронный обмен сообщениями между внутренних служб и использовать синхронное взаимодействие (например, HTTP) только из клиентских приложений для службы интерфейса (API шлюзы плюс первого уровня из микрослужбами).

Существует два типа асинхронной связи, обмена сообщениями: связи на основе сообщения одному получателю, а также несколько получателей связи на основе сообщений. В следующих разделах представлены сведения о них.

## <a name="single-receiver-message-based-communication"></a>Связь на основе сообщений одного получателя 

На основе сообщения асинхронное взаимодействие с один получатель означает, что обмен данными между узлами, доставляет сообщение только один из потребителей, чтение из канала и сообщение обрабатывается только один раз. Однако существуют особые случаи. Например в системе облака, предпринимается попытка автоматического восстановления после сбоя, и то же сообщение удалось отправить несколько раз. Из-за сетевых или других ошибок клиент должен иметь возможность повторить отправку сообщений, а сервер должен реализовать операцию быть идемпотентными, чтобы обработать определенное сообщение только один раз.

Связь на основе сообщений один получатель особенно хорошо подходят для отправки асинхронных команд из микрослужбу один в другой, как показано в на рисунке 4-18, этот подход показан.

После начала отправки связи на основе сообщения (или с помощью команд или события), не следует использовать связи на основе сообщений с синхронной взаимодействие по протоколу HTTP.

![](./media/image18.PNG)

**На рисунке 4-18**. Один микрослужбу Получение асинхронное сообщение

Обратите внимание, что если команды приходят из клиентских приложений, они могут быть реализованы как синхронные команды HTTP. При необходимости масштабируемости или если вы уже работаете на уровне сообщений бизнес-процесса, следует использовать команды на основе сообщений.

## <a name="multiple-receivers-message-based-communication"></a>Связи на основе сообщения нескольким получателям 

Как это более гибкий подход можно также использовать механизм публикации или подписки, чтобы связи от отправителя будет доступен для микрослужбами дополнительных подписчика или с внешними приложениями. Таким образом, он помогает выполните [открытый/закрытый принцип](https://en.wikipedia.org/wiki/Open/closed_principle) в службы отправки. Таким образом, дополнительные подписчики могут добавляться в будущем без необходимости изменить службу отправителя.

При использовании связи, публикации или подписки, возможно, вы используете интерфейс шины событий для публикации событий к любому подписчику.

## <a name="asynchronous-event-driven-communication"></a>Асинхронное взаимодействие с событиями

При использовании асинхронной связи с событиями, микрослужбу публикует интеграции событие, когда что-то происходит в рамках своего домена и другой микрослужбу должен знать, как изменения цен в микрослужбу каталога продукции. Дополнительные микрослужбами подписаться на события, что позволяет им получать их асинхронно. В этом случае получатели может обновить свои собственные домена сущностей, которые могут вызвать несколько событий интеграции для публикации. Эта система публикации или подписки обычно выполняется с помощью реализация шине событий. Шина событий могут быть разработаны как абстракция или интерфейса с помощью API, который необходим для подписки или отмены подписки на события и публикации события. Шина событие также может иметь одно или несколько реализаций на основании любые broker между процессами и обмена сообщениями, как очереди сообщений или служебной шины, который поддерживает асинхронное взаимодействие и модель публикации или подписки.

Если система использует окончательной согласованности интеграции управляется событиями, рекомендуется этот подход предоставления полную очистку для конечного пользователя. Система не следует использовать подход, который имитирует интеграции события, такие как SignalR или системами опроса от клиента. Конечный пользователь и владелец компании имеют явно окончательной согласованности в системе и понимать, во многих случаях бизнеса у все проблемы с этим подходом, пока он является явным.

Как отмечалось ранее в [проблемы и решения для распределенного управления данными](#challenges-and-solutions-for-distributed-data-management) разделе события интеграции можно использовать для реализации бизнес-задачи, которые охватывают несколько микрослужбами. Таким образом вы получите окончательной согласованности между этими службами. Транзакция согласованным состоит из коллекции действий, распределенных. В каждое действие связанные микрослужбу обновляет сущность домена и публикует другое событие интеграции, которое вызывает следующее действие в пределах той же задачи начала до конца.

Важно то, что может потребоваться связаться с несколькими микрослужбами, на которые подписан на том же событии. В этом случае можно использовать публикации или подписки обмена сообщениями на основе взаимодействия с событиями, как показано на рисунке 4-19. Этот механизм публикации и подписки не является исчерпывающим микрослужбу архитектуры. Это аналогично тому, как [ограниченных контекстах](http://martinfowler.com/bliki/BoundedContext.html) в DDD необходимо связаться или так же как при распространении обновлений из базы данных записи для чтения базы данных в [команда и ответственности разделения запросов (CQRS)](http://martinfowler.com/bliki/CQRS.html)шаблон архитектуры. Цель — иметь окончательной согласованности между несколькими источниками данных в распределенной системе.

![](./media/image19.png)

**На рисунке 4-19**. Асинхронный событиями обмен сообщениями

Реализация зависит от используемого протокола для связи с событиями, на основе сообщений через. [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) можно добиться надежного взаимодействия с использованием очередей.

При использовании шине событие, может потребоваться использовать уровень абстракции (например, интерфейс событий шины) на основе связанной реализации в классах с кодом с помощью API из брокера сообщений, таких как [RabbitMQ](https://www.rabbitmq.com/) или service bus как [Azure Service Bus с разделами](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions). Кроме того можно использовать более высокого уровня служебную шину как NServiceBus, MassTransit или Brighter сформулировать шины на события и системы публикации и подписки.

## <a name="a-note-about-messaging-technologies-for-production-systems"></a>Примечание о технологии для рабочих систем обмена сообщениями

Технологии обмена сообщениями для реализации вашей шины абстрактных событий находятся на разных уровнях. Например продуктах, например RabbitMQ (обмена сообщениями компонента broker транспорт) и Azure Service Bus разместить на более низком уровне, чем другие устройства, например, NServiceBus, MassTransit или Brighter, который может работать на базе RabbitMQ и Azure Service Bus. Выбор зависит от количества богатые возможности на уровне приложения и out of box масштабируемость, необходимые для приложения. Для реализации только событие подтверждение концепции шины для среды разработки, как сделано в образце eShopOnContainers простой реализации на основе ОС контейнера Docker RabbitMQ может оказаться достаточно.

Однако для критически важных и производственной системы, требующие hyper масштабируемости, вы можете оценить Azure Service Bus. Для высокого уровня абстракции и функции, облегчающие разработку распределенных приложений рекомендуется рассмотреть другие шин коммерческих и открытый исходный код службы, такие как NServiceBus, MassTransit и Brighter. Конечно вы можете создавать свои собственные функции шины обслуживания на основе технологии более низкого уровня, такие как RabbitMQ и Docker. Однако эту работу направляющее стоят слишком много для корпоративные приложения.

## <a name="resiliently-publishing-to-the-event-bus"></a>Выполнение приложением публикации на шине событий

При осуществлении архитектуру событиями через несколько микрослужбами сложной задачей является атомарным образом обновление состояния исходного микрослужбу при выполнение приложением публикации его интеграции связанных событий в событие шины, каким-либо образом на основе транзакции. Ниже приведены несколько способов для этого, несмотря на то, что может быть также дополнительные подходы.

-   С помощью транзакционной очереди (на основе DTC) как MSMQ. (Тем не менее, этот подход более прежних версий.)

-   С помощью [интеллектуального анализа данных журнала транзакций](http://www.scoop.it/t/sql-server-transaction-log-mining).

-   С помощью полной [источники событий](https://msdn.microsoft.com/en-us/library/dn589792.aspx) шаблон.

-   С помощью [шаблон папки "Исходящие"](http://gistlabs.com/2014/05/the-outbox/): таблицы как очереди сообщений, который будет иметь базовый генератор событий компонента, который может создать событие и его публикация транзакций базы данных.

Дополнительные разделы, которые следует учитывать при использовании асинхронной связи являются идемпотентность сообщения и сообщения дедупликации. В этих разделах рассматриваются в разделе [реализации взаимодействия на основе событий между микрослужбами (события интеграции)](#implementing_event_based_comms_microserv) далее в этом руководстве.

## <a name="additional-resources"></a>Дополнительные ресурсы

-   **Событие обмена сообщениями**
    [*http://soapatterns.org/design\_шаблонов и события\_управляемых\_обмена сообщениями*](http://soapatterns.org/design_patterns/event_driven_messaging)

-   **Публикация или подписка канала**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)

-   **UDI Dahan. Добавлено пояснение CQRS**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)

-   **Команды и запроса разделение ответственности (CQRS)**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)

-   **Взаимодействие между ограниченных контекстах**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)

-   **Итоговая согласованность**
    [*https://en.wikipedia.org/wiki/Eventual\_согласованности*](https://en.wikipedia.org/wiki/Eventual_consistency)

-   **Джимми Богард (Jimmy Bogard). Рефакторинг по направлению к устойчивости: Оценка взаимозависимости**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)


>[!div class="step-by-step"]
[Предыдущие] (связи в микрослужбу architecture.md) [Далее] (Ведение, микрослужбу apis.md)
