---
title: "Асинхронное взаимодействие на основе сообщений"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Асинхронное взаимодействие на основе сообщений"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df39771295d12e122edbe27e91cd899e3318e301
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="48d2a-104">Асинхронное взаимодействие на основе сообщений</span><span class="sxs-lookup"><span data-stu-id="48d2a-104">Asynchronous message-based communication</span></span>

<span data-ttu-id="48d2a-105">Асинхронный обмен сообщениями и связи с событиями критически важны при распространении изменений через несколько микрослужбами и их моделей связанных доменах.</span><span class="sxs-lookup"><span data-stu-id="48d2a-105">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="48d2a-106">Как упоминалось ранее в обсуждение микрослужбами и ограниченных контекстах (BCs), модели (пользователь, клиент, продукта, учетная запись, т. д.) может иметь различные значения для разных микрослужбами или BCs.</span><span class="sxs-lookup"><span data-stu-id="48d2a-106">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="48d2a-107">Что означает, что при внесении изменений, нужно каким-либо способом согласовать изменения различных моделей.</span><span class="sxs-lookup"><span data-stu-id="48d2a-107">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="48d2a-108">Решением является окончательной согласованности и обмен данными на основе событий основании асинхронного обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="48d2a-108">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="48d2a-109">При использовании обмена сообщениями, процессы взаимодействовать, обмениваясь сообщениями асинхронно.</span><span class="sxs-lookup"><span data-stu-id="48d2a-109">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="48d2a-110">Клиент отправляет команду или запрос в службу, отправив сообщение.</span><span class="sxs-lookup"><span data-stu-id="48d2a-110">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="48d2a-111">Если служба должна ответить, он отправляет разные сообщения обратно клиенту.</span><span class="sxs-lookup"><span data-stu-id="48d2a-111">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="48d2a-112">Поскольку это связь на основе сообщений, клиент предполагает, что ответ не будут приниматься немедленно и возможного нет ответа на всех.</span><span class="sxs-lookup"><span data-stu-id="48d2a-112">Since it is a message-based communication, the client assumes that the reply will not be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="48d2a-113">Сообщение сформирован заголовка (метаданные, например сведения о идентификации или безопасности) и текста.</span><span class="sxs-lookup"><span data-stu-id="48d2a-113">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="48d2a-114">Обычно сообщения отправляются через асинхронные протоколы, такие как AMQP.</span><span class="sxs-lookup"><span data-stu-id="48d2a-114">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="48d2a-115">Предпочтительный инфраструктуры для этого типа обмена данными в сообществе микрослужбами является broker упрощенных сообщения, который отличается от больших брокеров и orchestrators, используемых в SOA.</span><span class="sxs-lookup"><span data-stu-id="48d2a-115">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="48d2a-116">В брокеру упрощенных сообщение инфраструктуры — обычно «ввода-вывода, «выступает брокер обмена сообщениями с простой реализации, например RabbitMQ или масштабируемой служебной шины в облаке, такая как Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="48d2a-116">In a lightweight message broker, the infrastructure is typically “dumb,” acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="48d2a-117">В этом случае большая мышления «смарт-» по-прежнему находится в конечных точках, формирующего и получении сообщений, то есть в микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="48d2a-117">In this scenario, most of the “smart” thinking still lives in the endpoints that are producing and consuming messages—that is, in the microservices.</span></span>

<span data-ttu-id="48d2a-118">Другое правило, которое следует выполнить, насколько возможно, является использование только асинхронный обмен сообщениями между внутренних служб и использовать синхронное взаимодействие (например, HTTP) только из клиентских приложений для службы интерфейса (API шлюзы плюс первого уровня из микрослужбами).</span><span class="sxs-lookup"><span data-stu-id="48d2a-118">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="48d2a-119">Существует два типа асинхронной связи, обмена сообщениями: связи на основе сообщения одному получателю, а также несколько получателей связи на основе сообщений.</span><span class="sxs-lookup"><span data-stu-id="48d2a-119">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="48d2a-120">В следующих разделах представлены сведения о них.</span><span class="sxs-lookup"><span data-stu-id="48d2a-120">In the following sections we provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="48d2a-121">Связь на основе сообщений одного получателя</span><span class="sxs-lookup"><span data-stu-id="48d2a-121">Single-receiver message-based communication</span></span> 

<span data-ttu-id="48d2a-122">На основе сообщения асинхронное взаимодействие с один получатель означает, что обмен данными между узлами, доставляет сообщение только один из потребителей, чтение из канала и сообщение обрабатывается только один раз.</span><span class="sxs-lookup"><span data-stu-id="48d2a-122">Message-based asynchronous communication with a single receiver means there is point-to-point communication that delivers a message to exactly one of the consumers that is reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="48d2a-123">Однако существуют особые случаи.</span><span class="sxs-lookup"><span data-stu-id="48d2a-123">However, there are special situations.</span></span> <span data-ttu-id="48d2a-124">Например в системе облака, предпринимается попытка автоматического восстановления после сбоя, и то же сообщение удалось отправить несколько раз.</span><span class="sxs-lookup"><span data-stu-id="48d2a-124">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="48d2a-125">Из-за сетевых или других ошибок клиент должен иметь возможность повторить отправку сообщений, а сервер должен реализовать операцию быть идемпотентными, чтобы обработать определенное сообщение только один раз.</span><span class="sxs-lookup"><span data-stu-id="48d2a-125">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="48d2a-126">Связь на основе сообщений один получатель особенно хорошо подходят для отправки асинхронных команд из микрослужбу один в другой, как показано в на рисунке 4-18, этот подход показан.</span><span class="sxs-lookup"><span data-stu-id="48d2a-126">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="48d2a-127">После начала отправки связи на основе сообщения (или с помощью команд или события), не следует использовать связи на основе сообщений с синхронной взаимодействие по протоколу HTTP.</span><span class="sxs-lookup"><span data-stu-id="48d2a-127">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![](./media/image18.PNG)

<span data-ttu-id="48d2a-128">**На рисунке 4-18**.</span><span class="sxs-lookup"><span data-stu-id="48d2a-128">**Figure 4-18**.</span></span> <span data-ttu-id="48d2a-129">Один микрослужбу Получение асинхронное сообщение</span><span class="sxs-lookup"><span data-stu-id="48d2a-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="48d2a-130">Обратите внимание, что если команды приходят из клиентских приложений, они могут быть реализованы как синхронные команды HTTP.</span><span class="sxs-lookup"><span data-stu-id="48d2a-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="48d2a-131">При необходимости масштабируемости или если вы уже работаете на уровне сообщений бизнес-процесса, следует использовать команды на основе сообщений.</span><span class="sxs-lookup"><span data-stu-id="48d2a-131">You should use message-based commands when you need higher scalability or when you are already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="48d2a-132">Связи на основе сообщения нескольким получателям</span><span class="sxs-lookup"><span data-stu-id="48d2a-132">Multiple-receivers message-based communication</span></span> 

<span data-ttu-id="48d2a-133">Как это более гибкий подход можно также использовать механизм публикации или подписки, чтобы связи от отправителя будет доступен для микрослужбами дополнительных подписчика или с внешними приложениями.</span><span class="sxs-lookup"><span data-stu-id="48d2a-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="48d2a-134">Таким образом, он помогает выполните [открытый/закрытый принцип](https://en.wikipedia.org/wiki/Open/closed_principle) в службы отправки.</span><span class="sxs-lookup"><span data-stu-id="48d2a-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="48d2a-135">Таким образом, дополнительные подписчики могут добавляться в будущем без необходимости изменить службу отправителя.</span><span class="sxs-lookup"><span data-stu-id="48d2a-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="48d2a-136">При использовании связи, публикации или подписки, возможно, вы используете интерфейс шины событий для публикации событий к любому подписчику.</span><span class="sxs-lookup"><span data-stu-id="48d2a-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="48d2a-137">Асинхронное взаимодействие с событиями</span><span class="sxs-lookup"><span data-stu-id="48d2a-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="48d2a-138">При использовании асинхронной связи с событиями, микрослужбу публикует интеграции событие, когда что-то происходит в рамках своего домена и другой микрослужбу должен знать, как изменения цен в микрослужбу каталога продукции.</span><span class="sxs-lookup"><span data-stu-id="48d2a-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="48d2a-139">Дополнительные микрослужбами подписаться на события, что позволяет им получать их асинхронно.</span><span class="sxs-lookup"><span data-stu-id="48d2a-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="48d2a-140">В этом случае получатели может обновить свои собственные домена сущностей, которые могут вызвать несколько событий интеграции для публикации.</span><span class="sxs-lookup"><span data-stu-id="48d2a-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="48d2a-141">Эта система публикации или подписки обычно выполняется с помощью реализация шине событий.</span><span class="sxs-lookup"><span data-stu-id="48d2a-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="48d2a-142">Шина событий могут быть разработаны как абстракция или интерфейса с помощью API, который необходим для подписки или отмены подписки на события и публикации события.</span><span class="sxs-lookup"><span data-stu-id="48d2a-142">The event bus can be designed as an abstraction or interface, with the API that is needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="48d2a-143">Шина событие также может иметь одно или несколько реализаций на основании любые broker между процессами и обмена сообщениями, как очереди сообщений или служебной шины, который поддерживает асинхронное взаимодействие и модель публикации или подписки.</span><span class="sxs-lookup"><span data-stu-id="48d2a-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="48d2a-144">Если система использует окончательной согласованности интеграции управляется событиями, рекомендуется этот подход предоставления полную очистку для конечного пользователя.</span><span class="sxs-lookup"><span data-stu-id="48d2a-144">If a system uses eventual consistency driven by integration events, it is recommended that this approach be made completely clear to the end user.</span></span> <span data-ttu-id="48d2a-145">Система не следует использовать подход, который имитирует интеграции события, такие как SignalR или системами опроса от клиента.</span><span class="sxs-lookup"><span data-stu-id="48d2a-145">The system should not use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="48d2a-146">Конечный пользователь и владелец компании имеют явно окончательной согласованности в системе и понимать, во многих случаях бизнеса у все проблемы с этим подходом, пока он является явным.</span><span class="sxs-lookup"><span data-stu-id="48d2a-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business does not have any problem with this approach, as long as it is explicit.</span></span>

<span data-ttu-id="48d2a-147">Как отмечалось ранее в [проблемы и решения для распределенного управления данными](#challenges-and-solutions-for-distributed-data-management) разделе события интеграции можно использовать для реализации бизнес-задачи, которые охватывают несколько микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="48d2a-147">As noted earlier in the [Challenges and solutions for distributed data management](#challenges-and-solutions-for-distributed-data-management) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="48d2a-148">Таким образом вы получите окончательной согласованности между этими службами.</span><span class="sxs-lookup"><span data-stu-id="48d2a-148">Thus you will have eventual consistency between those services.</span></span> <span data-ttu-id="48d2a-149">Транзакция согласованным состоит из коллекции действий, распределенных.</span><span class="sxs-lookup"><span data-stu-id="48d2a-149">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="48d2a-150">В каждое действие связанные микрослужбу обновляет сущность домена и публикует другое событие интеграции, которое вызывает следующее действие в пределах той же задачи начала до конца.</span><span class="sxs-lookup"><span data-stu-id="48d2a-150">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="48d2a-151">Важно то, что может потребоваться связаться с несколькими микрослужбами, на которые подписан на том же событии.</span><span class="sxs-lookup"><span data-stu-id="48d2a-151">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="48d2a-152">В этом случае можно использовать публикации или подписки обмена сообщениями на основе взаимодействия с событиями, как показано на рисунке 4-19.</span><span class="sxs-lookup"><span data-stu-id="48d2a-152">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="48d2a-153">Этот механизм публикации и подписки не является исчерпывающим микрослужбу архитектуры.</span><span class="sxs-lookup"><span data-stu-id="48d2a-153">This publish/subscribe mechanism is not exclusive to the microservice architecture.</span></span> <span data-ttu-id="48d2a-154">Это аналогично тому, как [ограниченных контекстах](http://martinfowler.com/bliki/BoundedContext.html) в DDD необходимо связаться или так же как при распространении обновлений из базы данных записи для чтения базы данных в [команда и ответственности разделения запросов (CQRS)](http://martinfowler.com/bliki/CQRS.html)шаблон архитектуры.</span><span class="sxs-lookup"><span data-stu-id="48d2a-154">It is similar to the way [Bounded Contexts](http://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](http://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="48d2a-155">Цель — иметь окончательной согласованности между несколькими источниками данных в распределенной системе.</span><span class="sxs-lookup"><span data-stu-id="48d2a-155">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![](./media/image19.png)

<span data-ttu-id="48d2a-156">**На рисунке 4-19**.</span><span class="sxs-lookup"><span data-stu-id="48d2a-156">**Figure 4-19**.</span></span> <span data-ttu-id="48d2a-157">Асинхронный событиями обмен сообщениями</span><span class="sxs-lookup"><span data-stu-id="48d2a-157">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="48d2a-158">Реализация зависит от используемого протокола для связи с событиями, на основе сообщений через.</span><span class="sxs-lookup"><span data-stu-id="48d2a-158">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="48d2a-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) можно добиться надежного взаимодействия с использованием очередей.</span><span class="sxs-lookup"><span data-stu-id="48d2a-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="48d2a-160">При использовании шине событие, может потребоваться использовать уровень абстракции (например, интерфейс событий шины) на основе связанной реализации в классах с кодом с помощью API из брокера сообщений, таких как [RabbitMQ](https://www.rabbitmq.com/) или service bus как [Azure Service Bus с разделами](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="48d2a-160">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="48d2a-161">Кроме того можно использовать более высокого уровня служебную шину как NServiceBus, MassTransit или Brighter сформулировать шины на события и системы публикации и подписки.</span><span class="sxs-lookup"><span data-stu-id="48d2a-161">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="48d2a-162">Примечание о технологии для рабочих систем обмена сообщениями</span><span class="sxs-lookup"><span data-stu-id="48d2a-162">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="48d2a-163">Технологии обмена сообщениями для реализации вашей шины абстрактных событий находятся на разных уровнях.</span><span class="sxs-lookup"><span data-stu-id="48d2a-163">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="48d2a-164">Например продуктах, например RabbitMQ (обмена сообщениями компонента broker транспорт) и Azure Service Bus разместить на более низком уровне, чем другие устройства, например, NServiceBus, MassTransit или Brighter, который может работать на базе RabbitMQ и Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="48d2a-164">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="48d2a-165">Выбор зависит от количества богатые возможности на уровне приложения и out of box масштабируемость, необходимые для приложения.</span><span class="sxs-lookup"><span data-stu-id="48d2a-165">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="48d2a-166">Для реализации только событие подтверждение концепции шины для среды разработки, как сделано в образце eShopOnContainers простой реализации на основе ОС контейнера Docker RabbitMQ может оказаться достаточно.</span><span class="sxs-lookup"><span data-stu-id="48d2a-166">For implementing just a proof-of-concept event bus for your development environment, as we have done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="48d2a-167">Однако для критически важных и производственной системы, требующие hyper масштабируемости, вы можете оценить Azure Service Bus.</span><span class="sxs-lookup"><span data-stu-id="48d2a-167">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="48d2a-168">Для высокого уровня абстракции и функции, облегчающие разработку распределенных приложений рекомендуется рассмотреть другие шин коммерческих и открытый исходный код службы, такие как NServiceBus, MassTransit и Brighter.</span><span class="sxs-lookup"><span data-stu-id="48d2a-168">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="48d2a-169">Конечно вы можете создавать свои собственные функции шины обслуживания на основе технологии более низкого уровня, такие как RabbitMQ и Docker.</span><span class="sxs-lookup"><span data-stu-id="48d2a-169">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="48d2a-170">Однако эту работу направляющее стоят слишком много для корпоративные приложения.</span><span class="sxs-lookup"><span data-stu-id="48d2a-170">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="48d2a-171">Выполнение приложением публикации на шине событий</span><span class="sxs-lookup"><span data-stu-id="48d2a-171">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="48d2a-172">При осуществлении архитектуру событиями через несколько микрослужбами сложной задачей является атомарным образом обновление состояния исходного микрослужбу при выполнение приложением публикации его интеграции связанных событий в событие шины, каким-либо образом на основе транзакции.</span><span class="sxs-lookup"><span data-stu-id="48d2a-172">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="48d2a-173">Ниже приведены несколько способов для этого, несмотря на то, что может быть также дополнительные подходы.</span><span class="sxs-lookup"><span data-stu-id="48d2a-173">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

-   <span data-ttu-id="48d2a-174">С помощью транзакционной очереди (на основе DTC) как MSMQ.</span><span class="sxs-lookup"><span data-stu-id="48d2a-174">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="48d2a-175">(Тем не менее, этот подход более прежних версий.)</span><span class="sxs-lookup"><span data-stu-id="48d2a-175">(However, this is a legacy approach.)</span></span>

-   <span data-ttu-id="48d2a-176">С помощью [интеллектуального анализа данных журнала транзакций](http://www.scoop.it/t/sql-server-transaction-log-mining).</span><span class="sxs-lookup"><span data-stu-id="48d2a-176">Using [transaction log mining](http://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

-   <span data-ttu-id="48d2a-177">С помощью полной [источники событий](https://msdn.microsoft.com/en-us/library/dn589792.aspx) шаблон.</span><span class="sxs-lookup"><span data-stu-id="48d2a-177">Using full [Event Sourcing](https://msdn.microsoft.com/en-us/library/dn589792.aspx) pattern.</span></span>

-   <span data-ttu-id="48d2a-178">С помощью [шаблон папки "Исходящие"](http://gistlabs.com/2014/05/the-outbox/): таблицы как очереди сообщений, который будет иметь базовый генератор событий компонента, который может создать событие и его публикация транзакций базы данных.</span><span class="sxs-lookup"><span data-stu-id="48d2a-178">Using the [Outbox pattern](http://gistlabs.com/2014/05/the-outbox/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="48d2a-179">Дополнительные разделы, которые следует учитывать при использовании асинхронной связи являются идемпотентность сообщения и сообщения дедупликации.</span><span class="sxs-lookup"><span data-stu-id="48d2a-179">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="48d2a-180">В этих разделах рассматриваются в разделе [реализации взаимодействия на основе событий между микрослужбами (события интеграции)](#implementing_event_based_comms_microserv) далее в этом руководстве.</span><span class="sxs-lookup"><span data-stu-id="48d2a-180">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](#implementing_event_based_comms_microserv) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="48d2a-181">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="48d2a-181">Additional resources</span></span>

-   <span data-ttu-id="48d2a-182">**Событие обмена сообщениями**
    [*http://soapatterns.org/design\_шаблонов и события\_управляемых\_обмена сообщениями*](http://soapatterns.org/design_patterns/event_driven_messaging)</span><span class="sxs-lookup"><span data-stu-id="48d2a-182">**Event Driven Messaging**
[*http://soapatterns.org/design\_patterns/event\_driven\_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)</span></span>

-   <span data-ttu-id="48d2a-183">**Публикация или подписка канала**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span><span class="sxs-lookup"><span data-stu-id="48d2a-183">**Publish/Subscribe Channel**
[*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span></span>

-   <span data-ttu-id="48d2a-184">**UDI Dahan. Добавлено пояснение CQRS**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span><span class="sxs-lookup"><span data-stu-id="48d2a-184">**Udi Dahan. Clarified CQRS**
[*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span></span>

-   <span data-ttu-id="48d2a-185">**Команды и запроса разделение ответственности (CQRS)**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span><span class="sxs-lookup"><span data-stu-id="48d2a-185">**Command and Query Responsibility Segregation (CQRS)**
[*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span></span>

-   <span data-ttu-id="48d2a-186">**Взаимодействие между ограниченных контекстах**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span><span class="sxs-lookup"><span data-stu-id="48d2a-186">**Communicating Between Bounded Contexts**
[*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span></span>

-   <span data-ttu-id="48d2a-187">**Итоговая согласованность**
    [*https://en.wikipedia.org/wiki/Eventual\_согласованности*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="48d2a-187">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="48d2a-188">**Джимми Богард (Jimmy Bogard). Рефакторинг по направлению к устойчивости: Оценка взаимозависимости**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span><span class="sxs-lookup"><span data-stu-id="48d2a-188">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**
[*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="48d2a-189">[Предыдущие] (связи в микрослужбу architecture.md) [Далее] (Ведение, микрослужбу apis.md)</span><span class="sxs-lookup"><span data-stu-id="48d2a-189">[Previous] (communication-in-microservice-architecture.md) [Next] (maintain-microservice-apis.md)</span></span>
