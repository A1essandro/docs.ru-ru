---
title: "Создание развивается и управление версиями микрослужбу API-интерфейсы и контракты"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Создание развивается и управление версиями микрослужбу API-интерфейсы и контракты"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 433711c3479eafd52bf9f5d53faf8e5707c6c624
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="creating-evolving-and-versioning-microservice-apis-and-contracts"></a><span data-ttu-id="df05a-104">Создание развивается и управление версиями микрослужбу API-интерфейсы и контракты</span><span class="sxs-lookup"><span data-stu-id="df05a-104">Creating, evolving, and versioning microservice APIs and contracts</span></span>

<span data-ttu-id="df05a-105">Микрослужбу API-Интерфейс представляет собой контракт между службой и своих клиентов.</span><span class="sxs-lookup"><span data-stu-id="df05a-105">A microservice API is a contract between the service and its clients.</span></span> <span data-ttu-id="df05a-106">Можно развивать микрослужбу независимо друг от друга только в том случае, если не приводит к нарушению его API-Интерфейс контракта, почему так важно контракта.</span><span class="sxs-lookup"><span data-stu-id="df05a-106">You will be able to evolve a microservice independently only if you do not break its API contract, which is why the contract is so important.</span></span> <span data-ttu-id="df05a-107">Если изменить контракт, повлияет клиентские приложения или шлюз API.</span><span class="sxs-lookup"><span data-stu-id="df05a-107">If you change the contract, it will impact your client applications or your API Gateway.</span></span>

<span data-ttu-id="df05a-108">Характер определение API зависит от того, какой протокол используется.</span><span class="sxs-lookup"><span data-stu-id="df05a-108">The nature of the API definition depends on which protocol you are using.</span></span> <span data-ttu-id="df05a-109">Например при использовании обмена сообщениями (например [AMQP](https://www.amqp.org/)), API состоит из типов сообщений.</span><span class="sxs-lookup"><span data-stu-id="df05a-109">For instance, if you are using messaging (like [AMQP](https://www.amqp.org/)), the API consists of the message types.</span></span> <span data-ttu-id="df05a-110">При использовании HTTP и службы RESTful API состоит из URL-адреса и форматах JSON запросов и ответов.</span><span class="sxs-lookup"><span data-stu-id="df05a-110">If you are using HTTP and RESTful services, the API consists of the URLs and the request and response JSON formats.</span></span>

<span data-ttu-id="df05a-111">Тем не менее даже если вы собираетесь осторожно первоначальной контракта, API-Интерфейс службы будет необходимо изменить со временем.</span><span class="sxs-lookup"><span data-stu-id="df05a-111">However, even if you are thoughtful about your initial contract, a service API will need to change over time.</span></span> <span data-ttu-id="df05a-112">Когда это происходит, и особенно в том случае, если ваш API — это открытый API, используемые несколькими клиентскими приложениями, обычно не может заставить все клиенты должны обновить ваш новый контракт API.</span><span class="sxs-lookup"><span data-stu-id="df05a-112">When that happens—and especially if your API is a public API consumed by multiple client applications—you typically cannot force all clients to upgrade to your new API contract.</span></span> <span data-ttu-id="df05a-113">Обычно требуется последовательное развертывание новых версий службы, в результате которого старых и новых версиях контракта службы работают одновременно.</span><span class="sxs-lookup"><span data-stu-id="df05a-113">You usually need to incrementally deploy new versions of a service in a way that both old and new versions of a service contract are running simultaneously.</span></span> <span data-ttu-id="df05a-114">Таким образом важно иметь стратегию для вашей службы управления версиями.</span><span class="sxs-lookup"><span data-stu-id="df05a-114">Therefore, it is important to have a strategy for your service versioning.</span></span>

<span data-ttu-id="df05a-115">После изменения API имеют небольшой размер, например при добавлении атрибутов или параметры к вашему API, клиенты, использующие старую API должен перейдите и работать с новой версией службы.</span><span class="sxs-lookup"><span data-stu-id="df05a-115">When the API changes are small, like if you add attributes or parameters to your API, clients that use an older API should switch and work with the new version of the service.</span></span> <span data-ttu-id="df05a-116">Можно предоставить значения по умолчанию для отсутствующих атрибутов, которые требуются, и клиенты смогут игнорировать любые атрибуты лишние ответа.</span><span class="sxs-lookup"><span data-stu-id="df05a-116">You might be able to provide default values for any missing attributes that are required, and the clients might be able to ignore any extra response attributes.</span></span>

<span data-ttu-id="df05a-117">Однако иногда необходимо внести изменения на основной и несовместимый API-интерфейса службы.</span><span class="sxs-lookup"><span data-stu-id="df05a-117">However, sometimes you need to make major and incompatible changes to a service API.</span></span> <span data-ttu-id="df05a-118">Поскольку вы не сможете принудительно клиентские приложения и службы, сразу же выполнить обновление до новой версии, службы должен поддерживать старые версии API-интерфейса для некоторого периода.</span><span class="sxs-lookup"><span data-stu-id="df05a-118">Because you might not be able to force client applications or services to upgrade immediately to the new version, a service must support older versions of the API for some period.</span></span> <span data-ttu-id="df05a-119">Если используется механизм на основе HTTP, таких как REST, одним из подходов является внедрение номер версии API в URL-адрес или в заголовок HTTP.</span><span class="sxs-lookup"><span data-stu-id="df05a-119">If you are using an HTTP-based mechanism such as REST, one approach is to embed the API version number in the URL or into a HTTP header.</span></span> <span data-ttu-id="df05a-120">Затем можно выбрать между реализацией обе версии службы одновременно в один и тот же экземпляр службы или развертывание разных экземпляров, что каждый обрабатывать версии API-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="df05a-120">Then you can decide between implementing both versions of the service simultaneously within the same service instance, or deploying different instances that each handle a version of the API.</span></span> <span data-ttu-id="df05a-121">Для этого рекомендуется [шаблон посредником](https://en.wikipedia.org/wiki/Mediator_pattern) (например, [MediatR библиотеки](https://github.com/jbogard/MediatR)) для отделения версии другую реализацию в независимых обработчики.</span><span class="sxs-lookup"><span data-stu-id="df05a-121">A good approach for this is the [Mediator pattern](https://en.wikipedia.org/wiki/Mediator_pattern) (for example, [MediatR library](https://github.com/jbogard/MediatR)) to decouple the different implementation versions into independent handlers.</span></span>

<span data-ttu-id="df05a-122">Наконец, при использовании архитектуры REST [гипермедиа](https://www.infoq.com/articles/mark-baker-hypermedia) является оптимальным решением для управления версиями служб и позволяя развиваемой API-интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="df05a-122">Finally, if you are using a REST architecture, [Hypermedia](https://www.infoq.com/articles/mark-baker-hypermedia) is the best solution for versioning your services and allowing evolvable APIs.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="df05a-123">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="df05a-123">Additional resources</span></span>

-   <span data-ttu-id="df05a-124">**Скотт Хансельман. Управление версиями основных RESTful веб-API ASP.NET, стало проще**
    <http://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx></span><span class="sxs-lookup"><span data-stu-id="df05a-124">**Scott Hanselman. ASP.NET Core RESTful Web API versioning made easy**
<http://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx></span></span>

-   <span data-ttu-id="df05a-125">**Управление версиями API RESTful web**
    [*https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api*](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)</span><span class="sxs-lookup"><span data-stu-id="df05a-125">**Versioning a RESTful web API**
[*https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api*](https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api)</span></span>

-   <span data-ttu-id="df05a-126">**Roy Fielding. Управление версиями, гипермедиа и REST**
    <https://www.infoq.com/articles/roy-fielding-on-versioning></span><span class="sxs-lookup"><span data-stu-id="df05a-126">**Roy Fielding. Versioning, Hypermedia, and REST**
<https://www.infoq.com/articles/roy-fielding-on-versioning></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="df05a-127">[Предыдущие] (асинхронной сообщения — на основе communication.md) [Далее] (микрослужбами адресация service-registry.md)</span><span class="sxs-lookup"><span data-stu-id="df05a-127">[Previous] (asynchronous-message-based-communication.md) [Next] (microservices-addressability-service-registry.md)</span></span>
