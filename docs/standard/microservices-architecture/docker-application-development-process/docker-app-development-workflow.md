---
title: Рабочий процесс разработки для приложений Docker
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Рабочий процесс разработки для приложений Docker
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/05/2018
ms.openlocfilehash: 00cffde7e7eb548f755b60f64aa596210b570d07
ms.sourcegitcommit: 35316b768394e56087483cde93f854ba607b63bc
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2018
ms.locfileid: "52297521"
---
# <a name="development-workflow-for-docker-apps"></a>Рабочий процесс разработки для приложений Docker

Жизненный цикл разработки приложений начинается на компьютере каждого разработчика, где разработчик локально программирует приложение на предпочитаемом языке и тестирует его. Независимо от выбранного языка, инфраструктуры и платформы, в рамках этого рабочего процесса разработчик всегда разрабатывает и тестирует контейнеры Docker, но делает это локально.

В каждый контейнер (экземпляр образа Docker) входят следующие компоненты:

- Выбранная операционная система (например, дистрибутив Linux, Windows Nano Server или Windows Server Core).

- Файлы, добавленные разработчиком (двоичные файлы приложения и т. п.).

- Сведения о конфигурации (параметры среды и зависимости).

## <a name="workflow-for-developing-docker-container-based-applications"></a>Рабочий процесс разработки приложений Docker на основе контейнера

В этом разделе описывается рабочий процесс *внутреннего цикла* разработки приложений на основе контейнера Docker. Рабочий процесс внутреннего цикла означает, что речь идет только о разработке, которая выполняется на компьютере разработчика, не касаясь более широкого рабочего процесса DevOps. Начальные этапы настройки среды здесь не рассматриваются, так как они выполняются только один раз.

Приложение состоит из ваших собственных служб и дополнительных библиотек (зависимостей). Ниже приведены основные шаги, которые обычно выполняются при сборке приложения Docker, как показано на рисунке 5-1.

![Рис. "Пошаговый рабочий процесс разработки графики приложения на основе контейнеров Docker"](./media/image1.png)

**Рис. 5-1**. Пошаговый рабочий процесс разработки приложения на основе контейнера Docker

В этом руководстве подробно описывается весь процесс, и каждый важный шаг объясняется с акцентом на среду Visual Studio.

Если разработка выполняется с помощью редактора и CLI (например, Visual Studio Code и Docker CLI на macOS или Windows), то необходимо знать каждый шаг и обычно более детально, чем при использовании Visual Studio. Дополнительные сведения о работе в среде CLI см. в электронной книге [Жизненный цикл приложений в контейнерах Docker с платформами и средствами Майкрософт](https://aka.ms/dockerlifecycleebook/).

При использовании Visual Studio многие из этих шагов выполняются автоматически, что значительно повышает производительность. Это особенно справедливо в тех случаях, когда используется Visual Studio 2017 и планируется создание многоконтейнерных приложений. Например, всего лишь одним щелчком мыши Visual Studio добавляет в проект *Dockerfile* и файл *docker-compose.yml* с конфигурацией для вашего приложения. При запуске приложения в Visual Studio он создает образ Docker и запускает многоконтейнерное приложение непосредственно в Docker. Вы даже можете отлаживать несколько контейнеров одновременно. Эти возможности значительно повышают скорость разработки.

В этом руководстве мы расскажем, что происходит "за кулисами" в Docker.

![Рис. "Шаг 1. Создание кода приложения"](./media/image2.png)

## <a name="step-1-start-coding-and-create-your-initial-application-or-service-baseline"></a>Шаг 1. Начало программирования и создание первого приложения или базовой службы

Разработка приложения Docker аналогична разработке приложения без Docker. Разница заключается в том, что при разработке для Docker развертывание и тестирование приложения или служб, работающих в контейнерах Docker, выполняется в локальной среде. Этот контейнер может быть контейнером Linux или контейнером Windows.

### <a name="set-up-your-local-environment-with-visual-studio"></a>Настройка локальной среды с помощью Visual Studio

Перед началом работы убедитесь, что [Docker Community Edition (CE)](https://www.docker.com/community-edition) для Windows установлен, как описано в следующих инструкциях:

[Начало работы с Docker CE для Windows](https://docs.docker.com/docker-for-windows/)

Кроме того, вам нужна Visual Studio 2017 с установленной рабочей нагрузкой **Кроссплатформенная разработка .NET Core**, как показано на рис. 5-2.

![](./media/image3.png)

**Рис. 5-2**. Выбор рабочей нагрузки **.NET Core и Docker** при установке Visual Studio 2017

Можно приступать к программированию приложения в обычной среде .NET (как правило, в .NET Core, если вы планируете использовать контейнеры) даже до включения Docker в вашем приложении и развертывания и тестирования в Docker. Тем не менее рекомендуется начать работу в Docker как можно быстрее, поскольку это будет реальная среда, и любые проблемы можно будет обнаружить гораздо раньше. Это также рекомендуется потому, что Visual Studio настолько упрощает работу с Docker, что практически все действия очевидны; лучший пример — отладка многоконтейнерного приложения в Visual Studio.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Начало работы с Docker CE для Windows**

   [*https://docs.docker.com/docker-for-windows/*](https://docs.docker.com/docker-for-windows/)

- **Visual Studio 2017**

   [*https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs*](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)

![Рис. "Шаг 2. Запись файлов Dockerfile"](./media/image4.png)

## <a name="step-2-create-a-dockerfile-related-to-an-existing-net-base-image"></a>Шаг 2. Создание файла Dockerfile, связанного с существующим базовым образом .NET

Dockerfile необходим для каждого пользовательского образа, который вы хотите создать; кроме того, Dockerfile потребуется для каждого контейнера, который будет развертываться автоматически из Visual Studio или вручную с помощью Docker CLI (с помощью команд docker run и docker-compose). Если в приложении имеется единственный экземпляр пользовательской службы, необходим один Dockerfile. Если в приложении имеется несколько служб (как в архитектуре на основе микрослужб), потребуется по одному Dockerfile для каждой службы.

Dockerfile размещается в корневой папке приложения или службы. Он содержит команды, которые указывают Docker, как настраивать и запускать приложение или службу в контейнере. Можно вручную создать Dockerfile в коде и добавить его в проект вместе с зависимостями .NET.

Со средствами Visual Studio для Docker эта задача выполняется лишь несколькими щелчками мыши. При создании нового проекта в Visual Studio 2017 можно выбрать параметр **Включить поддержку Docker**, как показано на рисунке 5-3.

![Включение поддержки Docker при создании нового проекта в Visual Studio 2017](./media/image5.png)

**Рис. 5-3**. Включение поддержки Docker при создании нового проекта в Visual Studio 2017

Можно также включить поддержку Docker в существующий проект веб-приложения .NET Core, щелкнув правой кнопкой мыши проект в **обозревателе решений** и выбрав **Добавить** > **Поддержка Docker**, как показано на рисунке 5-4.

![Пункт меню "Добавить поддержку Docker" в Visual Studio](./media/add-docker-support.png)

**Рис. 5-4**. Включение поддержки Docker в существующем проекте Visual Studio 2017

Это действие добавляет *Dockerfile* в проект с необходимой конфигурацией и доступно только для проектов веб-приложений.NET Core.

Чтобы добавить файл *docker-compose.yml* для всего решения, щелкните правой кнопкой мыши проект в **обозревателе решений** и выберите **Добавить** >  **Поддержка оркестратора контейнеров**, как показано на рисунке 5-5.

![Пункт меню "Добавить оркестратор контейнеров" в Visual Studio](./media/add-container-orchestrator-support.png)

**Рис. 5-5**. Добавление поддержки оркестратора контейнеров в существующий проект в Visual Studio 2017.

В следующих разделах описывается информация, которая находится в каждом из этих файлов. Visual Studio может сделать это вместо вас, однако полезно разобраться, что входит в Dockerfile.

### <a name="option-a-creating-a-project-using-an-existing-official-net-docker-image"></a>Вариант А. Создание проекта с помощью существующего официального образа .NET Docker

Обычно вы создаете пользовательский образ для своего контейнера на основе базового образа, который можно получить из официального репозитория в реестре [Центра Docker](https://hub.docker.com/). Именно это происходит на внутреннем уровне при включении поддержки Docker в Visual Studio. Dockerfile использует существующий образ aspnetcore.

Ранее было показано, какие образы и репозитории Docker можно использовать в зависимости от выбранной платформы и операционной системы. Например, если вы выбрали ASP.NET Core (Windows или Linux), следует использовать образ microsoft/aspnetcore:2.0. Таким образом, достаточно просто указать, какой базовый образ Docker будет использоваться для контейнера. Для этого добавьте в Dockerfile строку FROM microsoft/aspnetcore:2.0. Visual Studio выполняет это автоматически, но в случае обновления версии вы обновляете это значение.

Использование официального репозитория образов .NET из Центра Docker с номером версии гарантирует, что на всех компьютерах (включая компьютеры для разработки, тестирования и работы) будут доступны одни и те же функции языка.

Ниже приведен пример Dockerfile для контейнера ASP.NET Core.

```Dockerfile
FROM microsoft/aspnetcore:2.0

ARG source

WORKDIR /app

EXPOSE 80

COPY ${source:-obj/Docker/publish} .

ENTRYPOINT ["dotnet", " MySingleContainerWebApp.dll "]
```

В этом случае контейнер основан на версии 2.0 официального образа Docker ASP.NET Core (мультиархитектурного для Linux и Windows). Это параметр `FROM microsoft/aspnetcore:2.0`. (Дополнительные сведения об этом базовом образе см. на страницах [Образ Docker ASP.NET Core](https://hub.docker.com/r/microsoft/aspnetcore/) и [Образ Docker .NET Core](https://hub.docker.com/r/microsoft/dotnet/).) Кроме того, в Dockerfile необходимо указать Docker прослушивать порт TCP, который будет использоваться во время выполнения (в данном случае это порт 80, как задано в параметре EXPOSE).

В Dockerfile можно задать дополнительные параметры конфигурации, в зависимости от используемого языка и платформы. Например, параметр ENTRYPOINT со значением \["dotnet", "MySingleContainerWebApp.dll"\] указывает Docker запускать приложение .NET Core. Если для создания и запуска приложения .NET используется пакет SDK и .NET Core CLI (dotnet CLI), этот параметр будет другим. Параметр ENTRYPOINT, который находится в нижней строке, и другие параметры будут отличаться в зависимости от языка и платформы, выбранных для приложения.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Создание образов Docker для приложений .NET Core**

   [*https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images*](../../../core/docker/building-net-docker-images.md)

- **Создание собственного образа**. В официальной документации Docker.

   [*https://docs.docker.com/engine/tutorials/dockerimages/*](https://docs.docker.com/engine/tutorials/dockerimages/)

### <a name="using-multi-arch-image-repositories"></a>Использование мультиархитектурных репозиториев

Один репозиторий может содержать варианты платформ, например образ Linux и образ Windows. Эта функция позволяет поставщикам, таким как Майкрософт, которые создают базовые образы, создать один репозиторий для охвата нескольких платформ (т. е. Windows и Linux). Например, репозиторий [microsoft/dotnet](https://hub.docker.com/r/microsoft/aspnetcore/) в реестре Центра Docker обеспечивает поддержку Linux и Windows Nano Server при использовании одного и того же имени репозитория.

Можно указать тег, явно задающий платформу, как в следующих случаях:

- **microsoft/aspnetcore:2.0.0-jessie**

        .NET Core 2.0 runtime-only on Linux

- **microsoft/aspnetcore:2.0.0-nanoserver**

        .NET Core 2.0 runtime-only on Windows Nano Server

Однако в середине 2017 г. появилась возможность указывать одно и то же имя образа, даже с одинаковым тегом, и новые мультиархитектурные образы (например, образ aspnetcore, поддерживающий мультиархитектурность) будут использовать версию Windows или Linux в зависимости от развернутой базовой ОС Docker, как показано в следующем примере:

- **microsoft/aspnetcore:2.0**

        Multi-arch: .NET Core 2.0 runtime-only on Linux or Windows Nano Server depending on the Docker host OS

Таким образом, при запросе образа с узла Windows будет получен вариант для Windows, а при запросе образа с тем же именем с узла Linux будет получен вариант для Linux.

### <a name="option-b-creating-your-base-image-from-scratch"></a>Вариант Б. Создание базового образа с нуля

Вы можете создать собственный базовый образ Docker с нуля. Этот сценарий не рекомендуется для тех, кто только начинает работать с Docker, но если вы хотите задать определенные биты базового образа, это можно сделать.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Мультиархитектурные образы .NET Core**.

   https://github.com/dotnet/announcements/issues/14

- **Создание базового образа**. Официальная документация Docker.

   [*https://docs.docker.com/engine/userguide/eng-image/baseimages/*](https://docs.docker.com/engine/userguide/eng-image/baseimages/)

![Рис. "Шаг 3. Создание образов"](./media/image7.png)

## <a name="step-3-create-your-custom-docker-images-and-embed-your-application-or-service-in-them"></a>Шаг 3. Создание пользовательских образов Docker и внедрение в них собственных приложений или служб

Для каждой службы в приложении необходимо создать связанный образ. Если приложение состоит из одной службы или веб-приложения, достаточно одного образа.

Образы Docker в Visual Studio создаются автоматически. Следующие действия потребуются только в рабочем процессе с использованием редактора/CLI и подробно описываются, чтобы показать, что происходит внутри.

Разработчик должен выполнять разработку и тестирование локально до тех пор, пока не завершит и отправит компонент или пока не перейдет в систему управления версиями (например, в GitHub). Это означает, что необходимо создавать образы Docker и разворачивать контейнеры на локальном узле Docker (на виртуальной машине Windows или Linux), а затем выполнять запуск, тестирование и отладку этих локальных контейнеров.

Чтобы создать пользовательский образ в локальной среде с помощью Docker CLI и Dockerfile, можно использовать команду docker build, как показано на рисунке 5-5.

![Создание пользовательского образа Docker](./media/image8.png)

**Рис. 5-5**. Создание пользовательского образа Docker

При необходимости вместо непосредственного выполнения команды docker build из папки проекта можно сначала создать развертываемую папку с нужными библиотеками .NET и двоичными файлами, выполнив команду dotnet publish, а затем использовать команду docker build.

Так будет создан образ Docker с именем **cesardl/netcore-webapi-microservice-docker:first**. В данном случае :first — это тег, представляющий конкретную версию. Этот шаг можно повторить для каждого пользовательского образа, который вам требуется создать для своего составного приложения Docker.

Если приложение состоит из нескольких контейнеров (т. е. это многоконтейнерное приложение), можно также использовать команду docker-compose up --build, чтобы собрать все связанные образы одной командой с помощью метаданных, представленных в связанном файле docker-compose.yml.

Вы можете найти существующие в локальном репозитории образы с помощью команды docker images, как показано на рисунке 5-6.

![Просмотр существующих образов с помощью команды docker images](./media/image9.png)

**Рис. 5-6**. Просмотр существующих образов с помощью команды docker images

### <a name="creating-docker-images-with-visual-studio"></a>Создание образов Docker с помощью Visual Studio

При использовании Visual Studio для создания проекта с поддержкой Docker не требуется создавать образ явно. Этот образ создается автоматически, когда вы нажимаете клавишу **F5** и запускаете приложение или службу, добавленную в Docker. Этот шаг выполняется в Visual Studio автоматически, и вы не увидите, как это происходит, но важно знать, что происходит внутри.

![Рис. "Шаг 4. Определение служб"](./media/image10.png)

## <a name="step-4-define-your-services-in-docker-composeyml-when-building-a-multi-container-docker-application"></a>Шаг 4. Определение служб в файле docker-compose.yml при сборке многоконтейнерного приложения Docker

В файле [docker-compose.yml](https://docs.docker.com/compose/compose-file/) можно задать ряд связанных служб для развертывания в качестве составного приложения с помощью команд развертывания.

Чтобы использовать файл docker-compose.yml, его необходимо создать в основной или корневой папке решения, и его содержимое должно быть аналогично приведенному в следующем примере.

```yml
version: '3'

services:

  webmvc:
    image: eshop/web
    environment:
      - CatalogUrl=http://catalog.api
      - OrderingUrl=http://ordering.api
    ports:
      - "80:80"
    depends_on:
      - catalog.api
      - ordering.api

  catalog.api:
    image: eshop/catalog.api
    environment:
      - ConnectionString=Server=sql.data;Database=CatalogDB;…
    ports:
      - "81:80"
    depends_on:
      - sql.data

  ordering.api:
    image: eshop/ordering.api
    environment:
      - ConnectionString=Server=sql.data;Database=OrderingDb;…
    ports:
      - "82:80"
    extra_hosts:
      - "CESARDLBOOKVHD:10.0.75.1"
    depends_on:
      - sql.data

  sql.data:
    image: mssql-server-linux:latest
    environment:
      - SA_PASSWORD=Pass@word
      - ACCEPT_EULA=Y
    ports:
      - "5433:1433"
```

Данный файл docker-compose.yml представляет собой упрощенную и объединенную версию. Он содержит статические данные конфигурации для каждого контейнера (такие как имя пользовательского образа), которые применяются всегда, а также сведения о конфигурации, которые могут зависеть от среды развертывания, такие как строка подключения. В следующих разделах вы узнаете, как можно разбить конфигурацию в файле docker-compose.yml на несколько файлов docker-compose и переопределить значения в зависимости от среды и типа выполнения (отладка или выпуск).

В примере файла docker-compose.yml определяются четыре службы: служба webmvc (веб-приложение), две микрослужбы (catalog.api и ordering.api) и один контейнер источника данных, sql.data, на основе SQL Server для Linux, работающего как контейнер. Каждая служба развертывается как контейнер, поэтому образ Docker требуется для каждой службы.

Файл docker-compose.yml задает не только используемые контейнеры, но и их индивидуальные конфигурации. Например, в определении контейнера webmvc в файле .yml задается следующее.

- Используется предварительно созданный образ eshop/web:latest. Однако вы также можете настроить сборку этого образа при выполнении команды docker-compose с дополнительной конфигурацией на основе раздела build: в файле docker-compose.

- Инициализируются две переменные среды (CatalogUrl и OrderingUrl).

- Предоставленный порт 80 в контейнере переадресуется на внешний порт 80 на хост-компьютере.

- Веб-приложение связывается со службами catalog и ordering с помощью параметра depends\_on. В результате данная служба будет ожидать запуска этих служб.

Мы вернемся к файлу docker-compose.yml в следующем разделе, когда будем рассматривать реализацию микрослужб и многоконтейнерных приложений.

### <a name="working-with-docker-composeyml-in-visual-studio-2017"></a>Работа с файлом docker-compose.yml в Visual Studio 2017

При добавлении поддержки оркестратора контейнеров в проект веб-приложения, как показано на рисунке 5-7, Visual Studio добавляет раздел служб (проект) в решение, содержащее файл docker-compose.yml. Это простой способ начать создание многоконтейнерного решения.

![Пункт меню "Добавить оркестратор контейнеров" в Visual Studio](./media/add-container-orchestrator-support.png)

**Рис. 5-7**. Добавление поддержки Docker в Visual Studio 2017 щелчком правой кнопкой мыши на проекте ASP.NET Core

Добавление поддержки оркестратора контейнеров добавляет Dockerfile в проект (если он еще не существует). Это действие также добавляет сведения о конфигурации в глобальный файл docker-compose.yml на уровне решения. Вы увидите новый узел проекта (файл проекта *docker-compose.dcproj*) в **обозревателе решений**, содержащий файл docker-compose.yml, как показано на рис. 5-8.

![Узел docker-compose в обозревателе решений](./media/docker-compose-files.png)

**Рис. 5-8**. Узел дерева **docker-compose**, добавленный в обозреватель решений Visual Studio 2017

Затем можно открыть файлы docker-compose.yml и добавить в них дополнительные возможности.

Можно развернуть многоконтейнерное приложение с единственным файлом docker-compose.yml с помощью команды `docker-compose up`.

![Рис. "Шаг 5. Запуск приложения"](./media/image12.png)

## <a name="step-5-build-and-run-your-docker-application"></a>Шаг 5. Сборка и запуск приложения Docker

Если в приложении имеется только один контейнер, его можно запустить путем развертывания на узле Docker (на виртуальной машине или физическом сервере). Но если приложение содержит несколько служб, его можно развернуть как составное приложение с помощью одной команды CLI (docker-compose up) или в Visual Studio, в котором внутри будет выполняться эта же команда. Давайте рассмотрим разные варианты.

### <a name="option-a-run-a-single-container-app"></a>Вариант А. Запуск одноконтейнерного приложения

#### <a name="docker-cli"></a>Docker CLI

Контейнер Docker можно запустить с помощью команды docker run, как показано на рисунке 5-9.

```console
  docker run -t -d -p 80:5000 cesardl/netcore-webapi-microservice-docker:first
```

![Запуск контейнера Docker с помощью команды docker run](./media/image13.png)

**Рис. 5-9**. Запуск контейнера Docker с помощью команды docker run

В этом случае команда привязывает внутренний порт 5000 контейнера к порту 80 хост-компьютера. Это означает, что узел выполняет прослушивание порта 80 и переадресацию в порт 5000 в контейнере.

#### <a name="visual-studio"></a>Visual Studio

Если вы еще не добавили поддержку оркестратора контейнеров, запустите одноконтейнерное приложение в Visual Studio, нажав клавишу **F5**. Контейнер запускается локально с помощью команды docker run.

### <a name="option-b-run-a-multi-container-app"></a>Вариант Б. Запуск многоконтейнерного приложения

В большинстве корпоративных сценариев приложение Docker будет состоять из нескольких служб; это означает, что необходимо запускать многоконтейнерное приложение, как показано на рисунке 5-10.

![Рисунок, изображающий виртуальную машину с развернутыми контейнерами Docker](./media/image14.png)

**Рис. 5-10**. Виртуальная машина с развернутыми контейнерами Docker

#### <a name="docker-cli"></a>Docker CLI

Чтобы запустить многоконтейнерное приложение с помощью Docker CLI, можно выполнить команду docker-compose up. Эта команда разворачивает многоконтейнерное приложение с помощью файла docker-compose.yml, существующего на уровне решения. На рисунке 5-11 показаны результаты выполнения этой команды из главного каталога проекта, в котором находится файл docker-compose.yml.

![Пример результата выполнения команды docker-compose up](./media/image15.png)

**Рис. 5-11**. Пример результата выполнения команды docker-compose up

После выполнения команды docker-compose up приложение и связанные с ним контейнеры развертываются в узле Docker.

#### <a name="visual-studio"></a>Visual Studio

Запустить многоконтейнерное приложение с помощью Visual Studio 2017 очень просто. Вы можете не только запускать многоконтейнерное приложение, но также и отлаживать все его контейнеры непосредственно в Visual Studio, установив обычные точки останова.

Как упоминалось ранее, каждый раз при добавлении поддержки оркестратора контейнеров в проект в решении этот проект настраивается в глобальном (на уровне решения) файле docker-compose.yml, что позволяет запускать или отлаживать все решение сразу. Visual Studio будет запускать по одному контейнеру для каждого проекта с включенной поддержкой решения Docker и выполнять все внутренние шаги автоматически (dotnet publish, docker build и т. д.).

Здесь важно то, что, как показано на рисунке 5-12, в Visual Studio 2017 имеется дополнительная команда **Docker** для действия клавиши **F5**. Эта возможность позволяет запускать или отлаживать многоконтейнерное приложение путем запуска всех контейнеров, определенных в файлах docker-compose.yml на уровне решения. Возможность отладки многоконтейнерных решений означает, что можно установить несколько точек останова, чтобы все они были в разных проектах (контейнерах), и во время отладки из Visual Studio вы будете останавливаться в точках останова, заданных в разных проектах, и работать в разных контейнерах.

![Запуск многоконтейнерных приложений в Visual Studio 2017](./media/image16.png)

**Рис. 5-12**. Запуск многоконтейнерных приложений в Visual Studio 2017

### <a name="additional-resources"></a>Дополнительные ресурсы

-  **Развертывание контейнера ASP.NET на удаленном узле Docker**

   [*https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker*](https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker)

### <a name="a-note-about-testing-and-deploying-with-orchestrators"></a>Примечание о тестировании и развертывании с использованием оркестраторов

Команды docker-compose up и docker run (или запуск и отладка контейнеров в Visual Studio) подходят для тестирования контейнеров в вашей среде разработки. Однако этот способ не подходит, если вы планируете использовать оркестраторы и кластеры Docker, такие как Docker Swarm, Mesosphere DC/OS и Kubernetes. Если вы используете кластер, например [режим Docker Swarm](https://docs.docker.com/engine/swarm/) (доступный в Docker CE для Windows и Mac, начиная с версии 1.12), необходимо выполнять развертывание и тестирование единственных служб с помощью дополнительных команд, таких как [docker service create](https://docs.docker.com/engine/reference/commandline/service_create/). При развертывании приложения, состоящего из нескольких контейнеров, следует использовать команды [docker compose bundle](https://docs.docker.com/compose/reference/bundle/) и [docker deploy myBundleFile](https://docs.docker.com/engine/reference/commandline/deploy/), чтобы развернуть составное приложение как *стек*. Дополнительные сведения см. в записи блога [Introducing Experimental Distributed Application Bundles](https://blog.docker.com/2016/06/docker-app-bundle/) (Общие сведения об экспериментальных пакетах распределенных приложений) в документации Docker на сайте Docker.

Для [DC/OS](https://mesosphere.com/blog/2015/09/02/dcos-cli-command-line-tool-datacenter/) и [Kubernetes](https://kubernetes.io/docs/user-guide/deployments/) вы также должны использовать другие скрипты и команды развертывания.

![Рис. "Шаг 6"](./media/image17.png)

## <a name="step-6-test-your-docker-application-using-your-local-docker-host"></a>Шаг 6. Тестирование приложения Docker с помощью локального узла Docker

Этот шаг будет зависеть от того, что делает ваше приложение. В случае простого веб-приложения .NET Core, развернутого в виде единственного контейнера или службы, можно получить доступ к этой службе, открыв на узле Docker браузер и перейдя в нем на этот сайт, как показано на рисунке 5-13. (Если конфигурация в Dockerfile сопоставляет контейнер с портом узла, отличным от 80, укажите этот порт узла в URL-адресе.)

![Пример локального тестирования приложения Docker с помощью localhost](./media/image18.png)

**Рис. 5-13**. Пример локального тестирования приложения Docker с помощью localhost

Если localhost не указывает на IP-адрес узла Docker (при использовании Docker CE это должно происходить по умолчанию), то для перехода к службе используйте IP-адрес сетевой карты вашего компьютера.

Этот URL-адрес в браузере использует порт 80 для рассматриваемого примера конкретного контейнера. Однако внутренние запросы перенаправляются на порт 5000, поскольку именно так было выполнено развертывание с помощью команды docker run, как описано в предыдущем шаге.

Вы также можете тестировать приложение с помощью команды curl с терминала, как показано на рисунке 5-14. В случае установки Docker в Windows по умолчанию всегда будет использоваться IP-адрес узла Docker 10.0.75.1 помимо фактического IP-адреса вашего компьютера.

![Пример локального тестирования приложения Docker с помощью curl](./media/image19.png)

**Рис. 5-14**. Пример локального тестирования приложения Docker с помощью curl

### <a name="testing-and-debugging-containers-with-visual-studio-2017"></a>Тестирование и отладка контейнеров в Visual Studio 2017

При запуске и отладке контейнеров в Visual Studio 2017 вы можете отлаживать приложения .NET в основном так же, как при запуске без контейнеров.

### <a name="testing-and-debugging-without-visual-studio"></a>Тестирование и отладка без Visual Studio

Если при разработке используется редактор или CLI, отлаживать контейнеры будет значительно труднее, и вы захотите выполнять отладку путем создания трассировок.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Отладка приложений в локальном контейнере Docker**

   [*https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh*](https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh)

- **Стив Ласкер (Steve Lasker). Сборка, отладка, развертывание приложений ASP.NET Core с помощью Docker.** Видео.

   [*https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115*](https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115)

## <a name="simplified-workflow-when-developing-containers-with-visual-studio"></a>Упрощенный рабочий процесс при разработке контейнеров в Visual Studio

В сущности, при использовании Visual Studio рабочий процесс гораздо проще, чем при использовании редактора или CLI. Большинство шагов, необходимых для Docker и связанных с Dockerfile и docker-compose.yml, выполняются скрыто от пользователя или значительно упрощаются благодаря Visual Studio, как показано на рисунке 5-15.

![Упрощенный рабочий процесс при разработке в Visual Studio](./media/image20.png)

**Рис. 5-15**. Упрощенный рабочий процесс при разработке в Visual Studio

Кроме того, вам достаточно будет выполнить шаг 2 (добавление поддержки Docker в проекты) только один раз. Таким образом, рабочий процесс аналогичен другим обычным задачам разработки, когда для разработки используется .NET. Вам нужно знать, что происходит на самом деле (процесс создания образа, какие базовые образы используются, развертывание контейнеров и т. п.), и в некоторых случаях также может потребоваться изменить файл Dockerfile или docker-compose.yml, чтобы настроить функциональность. Но благодаря Visual Studio большую часть работы можно выполнить гораздо проще, что существенно повышает эффективность работы.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Стив Ласкер (Steve Lasker). Разработка .NET Docker в Visual Studio 2017**

   [*https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111*](https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111)

- **Джеффри Т. Фриц (Jeffrey T. Fritz). Помещение приложения .NET Core в контейнер с помощью новых средств Docker для Visual Studio**

   [*https://blogs.msdn.microsoft.com/webdev/2016/11/16/new-docker-tools-for-visual-studio/*](https://blogs.msdn.microsoft.com/webdev/2016/11/16/new-docker-tools-for-visual-studio/)

## <a name="using-powershell-commands-in-a-dockerfile-to-set-up-windows-containers"></a>Использование команд PowerShell в DockerFile для настройки контейнеров Windows

[Контейнеры Windows](/virtualization/windowscontainers/about/) позволяют преобразовывать существующие приложения Windows в образы Docker и развертывать их с помощью тех же средств, что и остальную часть экосистемы Docker. Чтобы использовать контейнеры Windows, выполните команды PowerShell в Dockerfile, как показано в следующем примере:

```Dockerfile
FROM microsoft/windowsservercore

LABEL Description="IIS" Vendor="Microsoft" Version="10"

RUN powershell -Command Add-WindowsFeature Web-Server

CMD [ "ping", "localhost", "-t" ]
```

В этом случае мы используем базовый образ Windows Server Core (параметр FROM) и устанавливаем службы IIS с помощью команды PowerShell (параметр RUN). Аналогичным образом можно также использовать команды PowerShell для настройки дополнительных компонентов, таких как ASP.NET 4.x, .NET 4.6 и другого программного обеспечения Windows. Например, следующая команда в Dockerfile настраивает ASP.NET 4.5:

```Dockerfile
RUN powershell add-windowsfeature web-asp-net45
```

### <a name="additional-resources"></a>Дополнительные ресурсы

- **aspnet-docker/Dockerfile.** Примеры команд Powershell, которые можно выполнять в файлах Dockerfile для включения компонентов Windows.

   [*https://github.com/Microsoft/aspnet-docker/blob/master/4.6.2/Dockerfile*](https://github.com/Microsoft/aspnet-docker/blob/master/4.6.2/Dockerfile)

>[!div class="step-by-step"]
[Назад](index.md)
[Вперед](../net-core-single-containers-linux-windows-server-hosts/index.md)