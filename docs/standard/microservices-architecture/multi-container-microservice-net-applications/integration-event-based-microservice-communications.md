---
title: "Реализация на основе событий взаимодействия между микрослужбами (события интеграции)"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Реализация на основе событий взаимодействия между микрослужбами (события интеграции)"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: e438607ab3549d63b89bef6af64c6723a4cac950
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="implementing-event-based-communication-between-microservices-integration-events"></a>Реализация на основе событий взаимодействия между микрослужбами (события интеграции)

Как было описано ранее, когда используется связь на основе событий, микрослужбу публикует событие, когда происходит событие важные, например когда он обновляет бизнес-сущности. Другие микрослужбами подписываться на эти события. При получении события микрослужбу можно было обновить свои собственные бизнес-сущности, что может привести к дополнительные события при публикации. Эта система публикации или подписки обычно выполняется с помощью реализация шине событий. Шина событий может быть построена как интерфейс API, необходимо, чтобы подписка и Отмена подписки на события и для публикации событий. Он также может иметь один или несколько реализаций, в зависимости от любого связь между процессами или обмена сообщениями, например очереди сообщений или служебной шины, который поддерживает асинхронное взаимодействие и модель публикации или подписки.

События можно использовать для реализации бизнес-транзакций, которые охватывают несколько служб, дающий окончательной согласованности между этими службами. Транзакция согласованным состоит из ряда распределенных действий. В каждое действие микрослужбу обновляет бизнес-сущности и публикует события, которое вызывает следующее действие.

![](./media/image19.PNG)

**На рисунке 8-18**. Соединения событиями по шине событий

В этом разделе описывается реализация этого типа обмена данными в .NET Framework с помощью интерфейса шины Универсальное событие, как показано на рисунке 8-18. Существует несколько потенциальных реализаций, использующих различные технологии или инфраструктуры, такие как RabbitMQ, Azure Service Bus или любые другие открытым исходным кодом сторонних разработчиков или коммерческого service bus.

## <a name="using-message-brokers-and-services-buses-for-production-systems"></a>С помощью сообщений посредниками и службы шины для рабочих систем

Как упоминалось в разделе архитектуры, можно выбрать из нескольких технологии обмена сообщениями для реализации вашей шины абстрактных событий. Но эти технологии на разных уровнях. Например RabbitMQ транспорт брокера обмена сообщениями, — на более низком уровне, чем коммерческих продуктов, таких как Azure Service Bus, NServiceBus, MassTransit или Brighter. Большинство этих продуктов можно работать над RabbitMQ или шины обслуживания Azure. Выбор продукта зависит от того, как многие функции и сколько out-of--box масштабируемость, необходимые для приложения.

Для реализации только событий шины-экспериментальной среды разработки, как показано в примере eShopOnContainers простой реализации на основе RabbitMQ, выполняющиеся как контейнер может оказаться достаточно. Но для критически важных и рабочих систем, которым требуется высокий уровень масштабируемости, вы можете оценить и использовать Azure Service Fabric. При необходимости высокого уровня абстракции и более широкие возможности, например [sagas](https://docs.particular.net/nservicebus/sagas/) для длительных рабочих процессов, которые делают разработку распределенного шин удобного и коммерческих и открытый исходный код службы как NServiceBus MassTransit, и Светлой заслуживают оценки. Конечно всегда можно строить собственные функции шины службы на основе технологии более низкого уровня, такие как RabbitMQ и Docker, но объем работы, необходимой для обновления колесико мыши может быть слишком много ресурсов для пользовательских корпоративного приложения.

Повторимся: образец событий шины абстракции и демонстрировать в образце eShopOnContainers реализацию предназначены для использования только в качестве эксперимента. После определения того, что приложение должно выполнять асинхронные и событийно управляемыми данными, как описано в текущем разделе, необходимо выбрать продукт шины службы, который наилучшим образом соответствует вашим потребностям.

## <a name="integration-events"></a>События интеграции

События интеграции используются для объединения нескольких микрослужбами или внешними системами состояние синхронизации с доменом. Это делается путем публикации события интеграции за пределами микрослужбы. При публикации события в нескольких микрослужбами получателя (чтобы столько микрослужбами как подписка на события интеграции), соответствующий обработчик событий в каждый получатель микрослужбу обрабатывает событие.

Событие интеграции по сути является класс хранения данных, как показано в следующем примере:

```csharp
public class ProductPriceChangedIntegrationEvent : IntegrationEvent
{
    public int ProductId { get; private set; }
    public decimal NewPrice { get; private set; }
    public decimal OldPrice { get; private set; }

    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice,
        decimal oldPrice)
    {
        ProductId = productId;
        NewPrice = newPrice;
        OldPrice = oldPrice;
    }
}
```

Класс событий интеграции могут быть простыми; Например он содержит идентификатор GUID для его идентификатора.

Можно определить события интеграции каждого микрослужбу на уровне приложения, они связаны с другими микрослужбами образом аналогично определение ViewModels в клиенте и сервере. Что не рекомендуется совместному использованию общей библиотеки события интеграции нескольких микрослужбами; этим способом может быть взаимозависимость этих микрослужбами с библиотекой одного события определения данных. Не хотите сделать это, по тем же причинам, не требуется совместное использование нескольких микрослужбами общую модель домена: микрослужбами должен быть полностью автономной.

Существует несколько видов библиотек, которые следует распределить по микрослужбами. Один является библиотеки, являющиеся блоки конечного приложения, таких как [API клиента событий шины](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), как показано в eShopOnContainers. Другой, библиотек, которые составляют средства, которые также могут совместно как компоненты NuGet, например сериализаторов JSON.

## <a name="the-event-bus"></a>Событие шины

Событие шины обеспечивает взаимодействие публикации/подписки стиль между микрослужбами без использования компонентов следует явным образом учитывать друг от друга, как показано на рисунке 8-19.

![](./media/image20.png)

**На рисунке 8-19**. Основы с шиной событий публикации и подписки

Событие шины связана шаблон наблюдателя и публикация-шаблон подписки.

### <a name="observer-pattern"></a>Шаблон наблюдателя

В [шаблон наблюдателя](https://en.wikipedia.org/wiki/Observer_pattern), первичный объект (известный как наблюдаемым) сообщает другим объектам (известный как наблюдатели) с соответствующей информацией (события).

### <a name="publish-subscribe-pubsub-pattern"></a>Шаблон публикации подписки (Pub/Sub) 

Назначение [шаблон Pub/Sub](https://msdn.microsoft.com/en-us/library/ff649664.aspx) является таким же, как шаблон наблюдателя: уведомлять другие службы при возникновении определенных событий. Однако одним важным отличием семантической между шаблонами наблюдателя и Pub/Sub. В шаблоне Pub/Sub основное внимание уделяется широковещательная рассылка сообщений. В отличие от этого в шаблоне наблюдателя наблюдаемым не знает, события будет, так же, они прошли out. Другими словами наблюдаемый объект (издатель) не знает, которые наблюдатели (подписчиков).

### <a name="the-middleman-or-event-bus"></a>Шина посредника или события 

Как добиться анонимность между издателем и подписчиком? Простым способом является let посредника за весь обмен данными. Шина событие имеет одного посредника.

Шина событий, обычно состоит из двух частей:

-   Абстракция или интерфейса.

-   Один или несколько реализаций.

На рисунке 8-19 можно увидеть как из приложения точки зрения шины событий — это ничто иное канала Pub/Sub. Можно изменять способ реализации этой асинхронной связи. Он может иметь несколько реализаций, чтобы при переключении между ними в зависимости от требования к среде (например, производство Сравнение сред разработки).

На рисунке 8-20 абстракцию шине событий можно просматривать с несколько реализаций на основе инфраструктуры обмена сообщениями таких технологий, как RabbitMQ, служебную шину Azure или других шины службы как NServiceBus, MassTransit и т. д.

![](./media/image21.png)

**На рисунке 8 – 20.** Несколько реализаций шине событий

Тем не менее как видно ранее, абстрактные классы (интерфейс шины событий) с помощью возможна только в том случае, если требуется, чтобы основные события шины функций, поддерживаемых вашей абстрактные классы. Если требуется более широкие возможности service bus, возможно, следует использовать API, предоставляемые предпочтительный service bus вместо собственных абстрактные классы.

### <a name="defining-an-event-bus-interface"></a>Определение интерфейса шины событий

Давайте начнем с некоторых код реализации для интерфейса события шины и возможных реализаций для целей просмотра. Интерфейс должен быть универсальным и простым, как и следующий интерфейс.

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent @event);
    void Subscribe<T>(IIntegrationEventHandler<T> handler)
        where T: IntegrationEvent;

    void Unsubscribe<T>(IIntegrationEventHandler<T> handler)
        where T : IntegrationEvent;
}
```

Метод публикации нетрудно. Событие шины будут разосланы интеграции события, передаваемый любой микрослужбу подписка на события. Этот метод используется микрослужбу, которая публикует события.

Метод Subscribe используется микрослужбами, чтобы получать события. Этот метод состоит из двух частей. Первый — события интеграции для подписки (IntegrationEvent). Вторая часть — обработчик событий интеграции (или метод обратного вызова) для вызова (IIntegrationEventHandler&lt;T&gt;) когда микрослужбу получает сообщение о событии, интеграции.


>[!div class="step-by-step"]
[Предыдущие] (база данных server-container.md) [Далее] (rabbitmq-event-bus-development-test-environment.md)
