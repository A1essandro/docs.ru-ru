---
title: "Реализация на основе событий взаимодействия между микрослужбами (события интеграции)"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Реализация на основе событий взаимодействия между микрослужбами (события интеграции)"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: e438607ab3549d63b89bef6af64c6723a4cac950
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="implementing-event-based-communication-between-microservices-integration-events"></a><span data-ttu-id="11902-104">Реализация на основе событий взаимодействия между микрослужбами (события интеграции)</span><span class="sxs-lookup"><span data-stu-id="11902-104">Implementing event-based communication between microservices (integration events)</span></span>

<span data-ttu-id="11902-105">Как было описано ранее, когда используется связь на основе событий, микрослужбу публикует событие, когда происходит событие важные, например когда он обновляет бизнес-сущности.</span><span class="sxs-lookup"><span data-stu-id="11902-105">As described earlier, when you use event-based communication, a microservice publishes an event when something notable happens, such as when it updates a business entity.</span></span> <span data-ttu-id="11902-106">Другие микрослужбами подписываться на эти события.</span><span class="sxs-lookup"><span data-stu-id="11902-106">Other microservices subscribe to those events.</span></span> <span data-ttu-id="11902-107">При получении события микрослужбу можно было обновить свои собственные бизнес-сущности, что может привести к дополнительные события при публикации.</span><span class="sxs-lookup"><span data-stu-id="11902-107">When a microservice receives an event, it can update its own business entities, which might lead to more events being published.</span></span> <span data-ttu-id="11902-108">Эта система публикации или подписки обычно выполняется с помощью реализация шине событий.</span><span class="sxs-lookup"><span data-stu-id="11902-108">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="11902-109">Шина событий может быть построена как интерфейс API, необходимо, чтобы подписка и Отмена подписки на события и для публикации событий.</span><span class="sxs-lookup"><span data-stu-id="11902-109">The event bus can be designed as an interface with the API needed to subscribe and unsubscribe to events and to publish events.</span></span> <span data-ttu-id="11902-110">Он также может иметь один или несколько реализаций, в зависимости от любого связь между процессами или обмена сообщениями, например очереди сообщений или служебной шины, который поддерживает асинхронное взаимодействие и модель публикации или подписки.</span><span class="sxs-lookup"><span data-stu-id="11902-110">It can also have one or more implementations based on any inter-process or messaging communication, such as a messaging queue or a service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="11902-111">События можно использовать для реализации бизнес-транзакций, которые охватывают несколько служб, дающий окончательной согласованности между этими службами.</span><span class="sxs-lookup"><span data-stu-id="11902-111">You can use events to implement business transactions that span multiple services, which gives you eventual consistency between those services.</span></span> <span data-ttu-id="11902-112">Транзакция согласованным состоит из ряда распределенных действий.</span><span class="sxs-lookup"><span data-stu-id="11902-112">An eventually consistent transaction consists of a series of distributed actions.</span></span> <span data-ttu-id="11902-113">В каждое действие микрослужбу обновляет бизнес-сущности и публикует события, которое вызывает следующее действие.</span><span class="sxs-lookup"><span data-stu-id="11902-113">At each action, the microservice updates a business entity and publishes an event that triggers the next action.</span></span>

![](./media/image19.PNG)

<span data-ttu-id="11902-114">**На рисунке 8-18**.</span><span class="sxs-lookup"><span data-stu-id="11902-114">**Figure 8-18**.</span></span> <span data-ttu-id="11902-115">Соединения событиями по шине событий</span><span class="sxs-lookup"><span data-stu-id="11902-115">Event-driven communication based on an event bus</span></span>

<span data-ttu-id="11902-116">В этом разделе описывается реализация этого типа обмена данными в .NET Framework с помощью интерфейса шины Универсальное событие, как показано на рисунке 8-18.</span><span class="sxs-lookup"><span data-stu-id="11902-116">This section describes how you can implement this type of communication with .NET by using a generic event bus interface, as shown in Figure 8-18.</span></span> <span data-ttu-id="11902-117">Существует несколько потенциальных реализаций, использующих различные технологии или инфраструктуры, такие как RabbitMQ, Azure Service Bus или любые другие открытым исходным кодом сторонних разработчиков или коммерческого service bus.</span><span class="sxs-lookup"><span data-stu-id="11902-117">There are multiple potential implementations, each using a different technology or infrastructure such as RabbitMQ, Azure Service Bus, or any other third-party open source or commercial service bus.</span></span>

## <a name="using-message-brokers-and-services-buses-for-production-systems"></a><span data-ttu-id="11902-118">С помощью сообщений посредниками и службы шины для рабочих систем</span><span class="sxs-lookup"><span data-stu-id="11902-118">Using message brokers and services buses for production systems</span></span>

<span data-ttu-id="11902-119">Как упоминалось в разделе архитектуры, можно выбрать из нескольких технологии обмена сообщениями для реализации вашей шины абстрактных событий.</span><span class="sxs-lookup"><span data-stu-id="11902-119">As noted in the architecture section, you can choose from multiple messaging technologies for implementing your abstract event bus.</span></span> <span data-ttu-id="11902-120">Но эти технологии на разных уровнях.</span><span class="sxs-lookup"><span data-stu-id="11902-120">But these technologies are at different levels.</span></span> <span data-ttu-id="11902-121">Например RabbitMQ транспорт брокера обмена сообщениями, — на более низком уровне, чем коммерческих продуктов, таких как Azure Service Bus, NServiceBus, MassTransit или Brighter.</span><span class="sxs-lookup"><span data-stu-id="11902-121">For instance, RabbitMQ, a messaging broker transport, is at a lower level than commercial products like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span> <span data-ttu-id="11902-122">Большинство этих продуктов можно работать над RabbitMQ или шины обслуживания Azure.</span><span class="sxs-lookup"><span data-stu-id="11902-122">Most of these products can work on top of either RabbitMQ or Azure Service Bus.</span></span> <span data-ttu-id="11902-123">Выбор продукта зависит от того, как многие функции и сколько out-of--box масштабируемость, необходимые для приложения.</span><span class="sxs-lookup"><span data-stu-id="11902-123">Your choice of product depends on how many features and how much out-of-the-box scalability you need for your application.</span></span>

<span data-ttu-id="11902-124">Для реализации только событий шины-экспериментальной среды разработки, как показано в примере eShopOnContainers простой реализации на основе RabbitMQ, выполняющиеся как контейнер может оказаться достаточно.</span><span class="sxs-lookup"><span data-stu-id="11902-124">For implementing just an event bus proof-of-concept for your development environment, as in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running as a container might be enough.</span></span> <span data-ttu-id="11902-125">Но для критически важных и рабочих систем, которым требуется высокий уровень масштабируемости, вы можете оценить и использовать Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="11902-125">But for mission-critical and production systems that need high scalability, you might want to evaluate and use Azure Service Fabric.</span></span> <span data-ttu-id="11902-126">При необходимости высокого уровня абстракции и более широкие возможности, например [sagas](https://docs.particular.net/nservicebus/sagas/) для длительных рабочих процессов, которые делают разработку распределенного шин удобного и коммерческих и открытый исходный код службы как NServiceBus MassTransit, и Светлой заслуживают оценки.</span><span class="sxs-lookup"><span data-stu-id="11902-126">If you require high-level abstractions and richer features like [sagas](https://docs.particular.net/nservicebus/sagas/) for long-running processes that make distributed development easier, other commercial and open-source service buses like NServiceBus, MassTransit, and Brighter are worth evaluating.</span></span> <span data-ttu-id="11902-127">Конечно всегда можно строить собственные функции шины службы на основе технологии более низкого уровня, такие как RabbitMQ и Docker, но объем работы, необходимой для обновления колесико мыши может быть слишком много ресурсов для пользовательских корпоративного приложения.</span><span class="sxs-lookup"><span data-stu-id="11902-127">Of course, you could always build your own service bus features on top of lower-level technologies like RabbitMQ and Docker, but the work needed to reinvent the wheel might be too costly for a custom enterprise application.</span></span>

<span data-ttu-id="11902-128">Повторимся: образец событий шины абстракции и демонстрировать в образце eShopOnContainers реализацию предназначены для использования только в качестве эксперимента.</span><span class="sxs-lookup"><span data-stu-id="11902-128">To reiterate: the sample event bus abstractions and implementation showcased in the eShopOnContainers sample are intended to be used only as a proof of concept.</span></span> <span data-ttu-id="11902-129">После определения того, что приложение должно выполнять асинхронные и событийно управляемыми данными, как описано в текущем разделе, необходимо выбрать продукт шины службы, который наилучшим образом соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="11902-129">Once you have decided that you want to have asynchronous and event-driven communication, as explained in the current section, you should choose the service bus product that best fits your needs.</span></span>

## <a name="integration-events"></a><span data-ttu-id="11902-130">События интеграции</span><span class="sxs-lookup"><span data-stu-id="11902-130">Integration events</span></span>

<span data-ttu-id="11902-131">События интеграции используются для объединения нескольких микрослужбами или внешними системами состояние синхронизации с доменом.</span><span class="sxs-lookup"><span data-stu-id="11902-131">Integration events are used for bringing domain state in sync across multiple microservices or external systems.</span></span> <span data-ttu-id="11902-132">Это делается путем публикации события интеграции за пределами микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="11902-132">This is done by publishing integration events outside the microservice.</span></span> <span data-ttu-id="11902-133">При публикации события в нескольких микрослужбами получателя (чтобы столько микрослужбами как подписка на события интеграции), соответствующий обработчик событий в каждый получатель микрослужбу обрабатывает событие.</span><span class="sxs-lookup"><span data-stu-id="11902-133">When an event is published to multiple receiver microservices (to as many microservices as are subscribed to the integration event), the appropriate event handler in each receiver microservice handles the event.</span></span>

<span data-ttu-id="11902-134">Событие интеграции по сути является класс хранения данных, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="11902-134">An integration event is basically a data-holding class, as in the following example:</span></span>

```csharp
public class ProductPriceChangedIntegrationEvent : IntegrationEvent
{
    public int ProductId { get; private set; }
    public decimal NewPrice { get; private set; }
    public decimal OldPrice { get; private set; }

    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice,
        decimal oldPrice)
    {
        ProductId = productId;
        NewPrice = newPrice;
        OldPrice = oldPrice;
    }
}
```

<span data-ttu-id="11902-135">Класс событий интеграции могут быть простыми; Например он содержит идентификатор GUID для его идентификатора.</span><span class="sxs-lookup"><span data-stu-id="11902-135">The integration event class can be simple; for example, it might contain a GUID for its ID.</span></span>

<span data-ttu-id="11902-136">Можно определить события интеграции каждого микрослужбу на уровне приложения, они связаны с другими микрослужбами образом аналогично определение ViewModels в клиенте и сервере.</span><span class="sxs-lookup"><span data-stu-id="11902-136">The integration events can be defined at the application level of each microservice, so they are decoupled from other microservices, in a way comparable to how ViewModels are defined in the server and client.</span></span> <span data-ttu-id="11902-137">Что не рекомендуется совместному использованию общей библиотеки события интеграции нескольких микрослужбами; этим способом может быть взаимозависимость этих микрослужбами с библиотекой одного события определения данных.</span><span class="sxs-lookup"><span data-stu-id="11902-137">What is not recommended is sharing a common integration events library across multiple microservices; doing that would be coupling those microservices with a single event definition data library.</span></span> <span data-ttu-id="11902-138">Не хотите сделать это, по тем же причинам, не требуется совместное использование нескольких микрослужбами общую модель домена: микрослужбами должен быть полностью автономной.</span><span class="sxs-lookup"><span data-stu-id="11902-138">You do not want to do that for the same reasons that you do not want to share a common domain model across multiple microservices: microservices must be completely autonomous.</span></span>

<span data-ttu-id="11902-139">Существует несколько видов библиотек, которые следует распределить по микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="11902-139">There are only a few kinds of libraries you should share across microservices.</span></span> <span data-ttu-id="11902-140">Один является библиотеки, являющиеся блоки конечного приложения, таких как [API клиента событий шины](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), как показано в eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="11902-140">One is libraries that are final application blocks, like the [Event Bus client API](https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/BuildingBlocks/EventBus), as in eShopOnContainers.</span></span> <span data-ttu-id="11902-141">Другой, библиотек, которые составляют средства, которые также могут совместно как компоненты NuGet, например сериализаторов JSON.</span><span class="sxs-lookup"><span data-stu-id="11902-141">Another is libraries that constitute tools that could also be shared as NuGet components, like JSON serializers.</span></span>

## <a name="the-event-bus"></a><span data-ttu-id="11902-142">Событие шины</span><span class="sxs-lookup"><span data-stu-id="11902-142">The event bus</span></span>

<span data-ttu-id="11902-143">Событие шины обеспечивает взаимодействие публикации/подписки стиль между микрослужбами без использования компонентов следует явным образом учитывать друг от друга, как показано на рисунке 8-19.</span><span class="sxs-lookup"><span data-stu-id="11902-143">An event bus allows publish/subscribe-style communication between microservices without requiring the components to explicitly be aware of each other, as shown in Figure 8-19.</span></span>

![](./media/image20.png)

<span data-ttu-id="11902-144">**На рисунке 8-19**.</span><span class="sxs-lookup"><span data-stu-id="11902-144">**Figure 8-19**.</span></span> <span data-ttu-id="11902-145">Основы с шиной событий публикации и подписки</span><span class="sxs-lookup"><span data-stu-id="11902-145">Publish/subscribe basics with an event bus</span></span>

<span data-ttu-id="11902-146">Событие шины связана шаблон наблюдателя и публикация-шаблон подписки.</span><span class="sxs-lookup"><span data-stu-id="11902-146">The event bus is related to the Observer pattern and the publish-subscribe pattern.</span></span>

### <a name="observer-pattern"></a><span data-ttu-id="11902-147">Шаблон наблюдателя</span><span class="sxs-lookup"><span data-stu-id="11902-147">Observer pattern</span></span>

<span data-ttu-id="11902-148">В [шаблон наблюдателя](https://en.wikipedia.org/wiki/Observer_pattern), первичный объект (известный как наблюдаемым) сообщает другим объектам (известный как наблюдатели) с соответствующей информацией (события).</span><span class="sxs-lookup"><span data-stu-id="11902-148">In the [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern), your primary object (known as the Observable) notifies other interested objects (known as Observers) with relevant information (events).</span></span>

### <a name="publish-subscribe-pubsub-pattern"></a><span data-ttu-id="11902-149">Шаблон публикации подписки (Pub/Sub)</span><span class="sxs-lookup"><span data-stu-id="11902-149">Publish-subscribe (Pub/Sub) pattern</span></span> 

<span data-ttu-id="11902-150">Назначение [шаблон Pub/Sub](https://msdn.microsoft.com/en-us/library/ff649664.aspx) является таким же, как шаблон наблюдателя: уведомлять другие службы при возникновении определенных событий.</span><span class="sxs-lookup"><span data-stu-id="11902-150">The purpose of the [Pub/Sub pattern](https://msdn.microsoft.com/en-us/library/ff649664.aspx) is the same as the Observer pattern: you want to notify other services when certain events take place.</span></span> <span data-ttu-id="11902-151">Однако одним важным отличием семантической между шаблонами наблюдателя и Pub/Sub.</span><span class="sxs-lookup"><span data-stu-id="11902-151">But there is an important semantic difference between the Observer and Pub/Sub patterns.</span></span> <span data-ttu-id="11902-152">В шаблоне Pub/Sub основное внимание уделяется широковещательная рассылка сообщений.</span><span class="sxs-lookup"><span data-stu-id="11902-152">In the Pub/Sub pattern, the focus is on broadcasting messages.</span></span> <span data-ttu-id="11902-153">В отличие от этого в шаблоне наблюдателя наблюдаемым не знает, события будет, так же, они прошли out. Другими словами наблюдаемый объект (издатель) не знает, которые наблюдатели (подписчиков).</span><span class="sxs-lookup"><span data-stu-id="11902-153">In contrast, in the Observer pattern, the Observable does not know who the events are going to, just that they have gone out. In other words, the Observable (the publisher) does not know who the Observers (the subscribers) are.</span></span>

### <a name="the-middleman-or-event-bus"></a><span data-ttu-id="11902-154">Шина посредника или события</span><span class="sxs-lookup"><span data-stu-id="11902-154">The middleman or event bus</span></span> 

<span data-ttu-id="11902-155">Как добиться анонимность между издателем и подписчиком?</span><span class="sxs-lookup"><span data-stu-id="11902-155">How do you achieve anonymity between publisher and subscriber?</span></span> <span data-ttu-id="11902-156">Простым способом является let посредника за весь обмен данными.</span><span class="sxs-lookup"><span data-stu-id="11902-156">An easy way is let a middleman take care of all the communication.</span></span> <span data-ttu-id="11902-157">Шина событие имеет одного посредника.</span><span class="sxs-lookup"><span data-stu-id="11902-157">An event bus is one such middleman.</span></span>

<span data-ttu-id="11902-158">Шина событий, обычно состоит из двух частей:</span><span class="sxs-lookup"><span data-stu-id="11902-158">An event bus is typically composed of two parts:</span></span>

-   <span data-ttu-id="11902-159">Абстракция или интерфейса.</span><span class="sxs-lookup"><span data-stu-id="11902-159">The abstraction or interface.</span></span>

-   <span data-ttu-id="11902-160">Один или несколько реализаций.</span><span class="sxs-lookup"><span data-stu-id="11902-160">One or more implementations.</span></span>

<span data-ttu-id="11902-161">На рисунке 8-19 можно увидеть как из приложения точки зрения шины событий — это ничто иное канала Pub/Sub.</span><span class="sxs-lookup"><span data-stu-id="11902-161">In Figure 8-19 you can see how, from an application point of view, the event bus is nothing more than a Pub/Sub channel.</span></span> <span data-ttu-id="11902-162">Можно изменять способ реализации этой асинхронной связи.</span><span class="sxs-lookup"><span data-stu-id="11902-162">The way you implement this asynchronous communication can vary.</span></span> <span data-ttu-id="11902-163">Он может иметь несколько реализаций, чтобы при переключении между ними в зависимости от требования к среде (например, производство Сравнение сред разработки).</span><span class="sxs-lookup"><span data-stu-id="11902-163">It can have multiple implementations so that you can swap between them, depending on the environment requirements (for example, production versus development environments).</span></span>

<span data-ttu-id="11902-164">На рисунке 8-20 абстракцию шине событий можно просматривать с несколько реализаций на основе инфраструктуры обмена сообщениями таких технологий, как RabbitMQ, служебную шину Azure или других шины службы как NServiceBus, MassTransit и т. д.</span><span class="sxs-lookup"><span data-stu-id="11902-164">In Figure 8-20 you can see an abstraction of an event bus with multiple implementations based on infrastructure messaging technologies like RabbitMQ, Azure Service Bus, or other service buses like NServiceBus, MassTransit, etc.</span></span>

![](./media/image21.png)

<span data-ttu-id="11902-165">**На рисунке 8 – 20.**</span><span class="sxs-lookup"><span data-stu-id="11902-165">**Figure 8- 20.**</span></span> <span data-ttu-id="11902-166">Несколько реализаций шине событий</span><span class="sxs-lookup"><span data-stu-id="11902-166">Multiple implementations of an event bus</span></span>

<span data-ttu-id="11902-167">Тем не менее как видно ранее, абстрактные классы (интерфейс шины событий) с помощью возможна только в том случае, если требуется, чтобы основные события шины функций, поддерживаемых вашей абстрактные классы.</span><span class="sxs-lookup"><span data-stu-id="11902-167">However, as highlighted previously, using abstractions (the event bus interface) is possible only if you need basic event bus features supported by your abstractions.</span></span> <span data-ttu-id="11902-168">Если требуется более широкие возможности service bus, возможно, следует использовать API, предоставляемые предпочтительный service bus вместо собственных абстрактные классы.</span><span class="sxs-lookup"><span data-stu-id="11902-168">If you need richer service bus features, you should probably use the API provided by your preferred service bus instead of your own abstractions.</span></span>

### <a name="defining-an-event-bus-interface"></a><span data-ttu-id="11902-169">Определение интерфейса шины событий</span><span class="sxs-lookup"><span data-stu-id="11902-169">Defining an event bus interface</span></span>

<span data-ttu-id="11902-170">Давайте начнем с некоторых код реализации для интерфейса события шины и возможных реализаций для целей просмотра.</span><span class="sxs-lookup"><span data-stu-id="11902-170">Let’s start with some implementation code for the event bus interface and possible implementations for exploration purposes.</span></span> <span data-ttu-id="11902-171">Интерфейс должен быть универсальным и простым, как и следующий интерфейс.</span><span class="sxs-lookup"><span data-stu-id="11902-171">The interface should be generic and straightforward, as in the following interface.</span></span>

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent @event);
    void Subscribe<T>(IIntegrationEventHandler<T> handler)
        where T: IntegrationEvent;

    void Unsubscribe<T>(IIntegrationEventHandler<T> handler)
        where T : IntegrationEvent;
}
```

<span data-ttu-id="11902-172">Метод публикации нетрудно.</span><span class="sxs-lookup"><span data-stu-id="11902-172">The Publish method is straightforward.</span></span> <span data-ttu-id="11902-173">Событие шины будут разосланы интеграции события, передаваемый любой микрослужбу подписка на события.</span><span class="sxs-lookup"><span data-stu-id="11902-173">The event bus will broadcast the integration event passed to it to any microservice subscribed to that event.</span></span> <span data-ttu-id="11902-174">Этот метод используется микрослужбу, которая публикует события.</span><span class="sxs-lookup"><span data-stu-id="11902-174">This method is used by the microservice that is publishing the event.</span></span>

<span data-ttu-id="11902-175">Метод Subscribe используется микрослужбами, чтобы получать события.</span><span class="sxs-lookup"><span data-stu-id="11902-175">The Subscribe method is used by the microservices that want to receive events.</span></span> <span data-ttu-id="11902-176">Этот метод состоит из двух частей.</span><span class="sxs-lookup"><span data-stu-id="11902-176">This method has two parts.</span></span> <span data-ttu-id="11902-177">Первый — события интеграции для подписки (IntegrationEvent).</span><span class="sxs-lookup"><span data-stu-id="11902-177">The first is the integration event to subscribe to (IntegrationEvent).</span></span> <span data-ttu-id="11902-178">Вторая часть — обработчик событий интеграции (или метод обратного вызова) для вызова (IIntegrationEventHandler&lt;T&gt;) когда микрослужбу получает сообщение о событии, интеграции.</span><span class="sxs-lookup"><span data-stu-id="11902-178">The second part is the integration event handler (or callback method) to be called (IIntegrationEventHandler&lt;T&gt;) when the microservice receives that integration event message.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="11902-179">[Предыдущие] (база данных server-container.md) [Далее] (rabbitmq-event-bus-development-test-environment.md)</span><span class="sxs-lookup"><span data-stu-id="11902-179">[Previous] (database-server-container.md) [Next] (rabbitmq-event-bus-development-test-environment.md)</span></span>
