---
title: Разработка приложения на основе микрослужб
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Разработка приложения на основе микрослужб
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 4adf7e759d4475d0bb9b3aa0abe8dbdc5e57edd3
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/02/2018
ms.locfileid: "43470120"
---
# <a name="designing-a-microservice-oriented-application"></a><span data-ttu-id="25913-103">Разработка приложения на основе микрослужб</span><span class="sxs-lookup"><span data-stu-id="25913-103">Designing a microservice-oriented application</span></span>

<span data-ttu-id="25913-104">В этом разделе рассматривается разработка гипотетического серверного корпоративного приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-104">This section focuses on developing a hypothetical server-side enterprise application.</span></span>

## <a name="application-specifications"></a><span data-ttu-id="25913-105">Спецификации приложения</span><span class="sxs-lookup"><span data-stu-id="25913-105">Application specifications</span></span>

<span data-ttu-id="25913-106">Это гипотетическое приложение обрабатывает запросы путем выполнения бизнес-логики, обращения к базам данных и последующего возврата ответов HTML, JSON или XML.</span><span class="sxs-lookup"><span data-stu-id="25913-106">The hypothetical application handles requests by executing business logic, accessing databases, and then returning HTML, JSON, or XML responses.</span></span> <span data-ttu-id="25913-107">Мы хотим сказать, что приложение должно поддерживать множество клиентов, включая браузеры рабочего стола, в которых работают одностраничные приложения (SPA), классические веб-приложения, мобильные веб-приложения и собственные мобильные приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-107">We will say that the application must support a variety of clients, including desktop browsers running Single Page Applications (SPAs), traditional web apps, mobile web apps, and native mobile apps.</span></span> <span data-ttu-id="25913-108">Приложение также может предоставлять интерфейс API для использования третьими лицами.</span><span class="sxs-lookup"><span data-stu-id="25913-108">The application might also expose an API for third parties to consume.</span></span> <span data-ttu-id="25913-109">Также должна быть предусмотрена возможность асинхронной интеграции его микрослужб или внешних приложений, поскольку такой подход помогает повысить устойчивость микрослужб в случае частичных сбоев.</span><span class="sxs-lookup"><span data-stu-id="25913-109">It should also be able to integrate its microservices or external applications asynchronously, so that approach will help resiliency of the microservices in the case of partial failures.</span></span>

<span data-ttu-id="25913-110">Приложение будет состоять из следующих типов компонентов.</span><span class="sxs-lookup"><span data-stu-id="25913-110">The application will consist of these types of components:</span></span>

-   <span data-ttu-id="25913-111">Компоненты уровня представления.</span><span class="sxs-lookup"><span data-stu-id="25913-111">Presentation components.</span></span> <span data-ttu-id="25913-112">Они отвечают за обработку пользовательского интерфейса и использование удаленных служб.</span><span class="sxs-lookup"><span data-stu-id="25913-112">These are responsible for handling the UI and consuming remote services.</span></span>

-   <span data-ttu-id="25913-113">Логика предметной области или бизнес-логика.</span><span class="sxs-lookup"><span data-stu-id="25913-113">Domain or business logic.</span></span> <span data-ttu-id="25913-114">Это логика домена приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-114">This is the application’s domain logic.</span></span>

-   <span data-ttu-id="25913-115">Логика доступа к базе данных.</span><span class="sxs-lookup"><span data-stu-id="25913-115">Database access logic.</span></span> <span data-ttu-id="25913-116">Сюда входят компоненты доступа к данным, обеспечивающие доступ к базам данных (SQL или NoSQL).</span><span class="sxs-lookup"><span data-stu-id="25913-116">This consists of data access components responsible for accessing databases (SQL or NoSQL).</span></span>

-   <span data-ttu-id="25913-117">Логика интеграции приложений.</span><span class="sxs-lookup"><span data-stu-id="25913-117">Application integration logic.</span></span> <span data-ttu-id="25913-118">Сюда входит канал обмена сообщениями, построенный главным образом на брокерах сообщений.</span><span class="sxs-lookup"><span data-stu-id="25913-118">This includes a messaging channel, mainly based on message brokers.</span></span>

<span data-ttu-id="25913-119">Приложению потребуется высокая степень масштабируемости, при этом его вертикальные подсистемы должны иметь возможность автономной масштабируемости, так как одним подсистемам будет требоваться более высокая степень масштабируемости, чем другим.</span><span class="sxs-lookup"><span data-stu-id="25913-119">The application will require high scalability, while allowing its vertical subsystems to scale out autonomously, because certain subsystems will require more scalability than others.</span></span>

<span data-ttu-id="25913-120">Должна быть предусмотрена возможность развертывания приложения в нескольких инфраструктурных средах (в общедоступных облачных и локальных средах), и желательно, чтобы это приложение было кроссплатформенным, способным легко перемещаться с Linux на Windows (или наоборот).</span><span class="sxs-lookup"><span data-stu-id="25913-120">The application must be able to be deployed in multiple infrastructure environments (multiple public clouds and on-premises) and ideally should be cross-platform, able to move from Linux to Windows (or vice versa) easily.</span></span>

## <a name="development-team-context"></a><span data-ttu-id="25913-121">Контекст команды разработчиков</span><span class="sxs-lookup"><span data-stu-id="25913-121">Development team context</span></span>

<span data-ttu-id="25913-122">Также предполагаются следующие особенности процесса разработки для приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-122">We also assume the following about the development process for the application:</span></span>

-   <span data-ttu-id="25913-123">Имеется несколько команд разработчиков, работающих над разными областями приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-123">You have multiple dev teams focusing on different business areas of the application.</span></span>

-   <span data-ttu-id="25913-124">Новые члены команд должны быстро включаться в работу, и приложение должно быть простым для понимания и легко модифицируемым.</span><span class="sxs-lookup"><span data-stu-id="25913-124">New team members must become productive quickly, and the application must be easy to understand and modify.</span></span>

-   <span data-ttu-id="25913-125">Приложение будет иметь долгий срок развития и постоянно меняющиеся бизнес-правила.</span><span class="sxs-lookup"><span data-stu-id="25913-125">The application will have a long-term evolution and ever-changing business rules.</span></span>

-   <span data-ttu-id="25913-126">Вам потребуется хорошая долгосрочная поддержка, что означает гибкость при реализации будущих изменений и возможность обновления нескольких подсистем с минимальным воздействием на другие подсистемы.</span><span class="sxs-lookup"><span data-stu-id="25913-126">You need good long-term maintainability, which means having agility when implementing new changes in the future while being able to update multiple subsystems with minimum impact on the other subsystems.</span></span>

-   <span data-ttu-id="25913-127">Вы хотите реализовать непрерывную интеграцию и непрерывное развертывание приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-127">You want to practice continuous integration and continuous deployment of the application.</span></span>

-   <span data-ttu-id="25913-128">Вы хотите использовать преимущества новых технологий (платформы, языки программирования и т. д.) при развитии приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-128">You want to take advantage of emerging technologies (frameworks, programming languages, etc.) while evolving the application.</span></span> <span data-ttu-id="25913-129">Вы не хотите, чтобы при переходе на новые технологии приходилось выполнять полную миграцию приложения, так как это может вызвать высокие затраты и повлиять на предсказуемость и стабильность работы приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-129">You do not want to make full migrations of the application when moving to new technologies, because that would result in high costs and impact the predictability and stability of the application.</span></span>

## <a name="choosing-an-architecture"></a><span data-ttu-id="25913-130">Выбор архитектуры</span><span class="sxs-lookup"><span data-stu-id="25913-130">Choosing an architecture</span></span>

<span data-ttu-id="25913-131">Какой должна быть архитектура развертывания приложения?</span><span class="sxs-lookup"><span data-stu-id="25913-131">What should the application deployment architecture be?</span></span> <span data-ttu-id="25913-132">Спецификации для приложения наряду с контекстом разработки дают веские основания предположить, что следует конструировать приложение путем его разделения на автономные подсистемы в виде совместно работающих микрослужб и контейнеров, где микрослужба представляет собой контейнер.</span><span class="sxs-lookup"><span data-stu-id="25913-132">The specifications for the application, along with the development context, strongly suggest that you should architect the application by decomposing it into autonomous subsystems in the form of collaborating microservices and containers, where a microservice is a container.</span></span>

<span data-ttu-id="25913-133">При таком подходе каждая служба (контейнер) реализует набор целостных и тесно связанных функций.</span><span class="sxs-lookup"><span data-stu-id="25913-133">In this approach, each service (container) implements a set of cohesive and narrowly related functions.</span></span> <span data-ttu-id="25913-134">Например, приложение может состоять из таких служб, как служба каталога, служба заказов, служба корзины, служба профилей пользователей и т. п.</span><span class="sxs-lookup"><span data-stu-id="25913-134">For example, an application might consist of services such as the catalog service, ordering service, basket service, user profile service, etc.</span></span>

<span data-ttu-id="25913-135">Микрослужбы взаимодействуют с помощью протоколов, таких как HTTP (REST), но также и по возможности асинхронно (например, с помощью AMQP), особенно при распространении обновлений с помощью событий интеграции.</span><span class="sxs-lookup"><span data-stu-id="25913-135">Microservices communicate using protocols such as HTTP (REST), but also asynchronously (for example, using AMQP) whenever possible, especially when propagating updates with integration events.</span></span>

<span data-ttu-id="25913-136">Микрослужбы разрабатываются и разворачиваются как контейнеры, независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="25913-136">Microservices are developed and deployed as containers independently of one another.</span></span> <span data-ttu-id="25913-137">Это означает, что команда разработчиков может разрабатывать и разворачивать определенную микрослужбу, не затрагивая другие подсистемы.</span><span class="sxs-lookup"><span data-stu-id="25913-137">This means that a development team can be developing and deploying a certain microservice without impacting other subsystems.</span></span>

<span data-ttu-id="25913-138">Каждая микрослужба имеет собственную базу данных, что позволяет ей быть полностью отделенной от других микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-138">Each microservice has its own database, allowing it to be fully decoupled from other microservices.</span></span> <span data-ttu-id="25913-139">При необходимости согласованность между базами данных разных микрослужб достигается с помощью событий интеграции уровня приложения (через шину логических событий), которые обрабатываются в CQRS.</span><span class="sxs-lookup"><span data-stu-id="25913-139">When necessary, consistency between databases from different microservices is achieved using application-level integration events (through a logical event bus), as handled in Command and Query Responsibility Segregation (CQRS).</span></span> <span data-ttu-id="25913-140">Из-за этого бизнес-ограничения должны учитывать итоговую согласованность между несколькими микрослужбами и связанными базами данных.</span><span class="sxs-lookup"><span data-stu-id="25913-140">Because of that, the business constraints must embrace eventual consistency between the multiple microservices and related databases.</span></span>

### <a name="eshoponcontainers-a-reference-application-for-net-core-and-microservices-deployed-using-containers"></a><span data-ttu-id="25913-141">eShopOnContainers: эталонное приложение для .NET Core и микрослужб, развернутых с использованием контейнеров</span><span class="sxs-lookup"><span data-stu-id="25913-141">eShopOnContainers: A reference application for .NET Core and microservices deployed using containers</span></span>

<span data-ttu-id="25913-142">Чтобы вы могли сосредоточиться на архитектуре и технологиях и не думать о гипотетической области бизнеса, в которой вы можете не разбираться, мы выбрали хорошо известную область бизнеса, а именно упрощенное приложение электронной коммерции (интернет-магазин), которое представляет каталог продукции, принимает заказы от клиентов, проверяет склад и выполняет другие бизнес-функции.</span><span class="sxs-lookup"><span data-stu-id="25913-142">So that you can focus on the architecture and technologies instead of thinking about a hypothetic business domain that you might not know, we have selected a well-known business domain—namely, a simplified e-commerce (e-shop) application that presents a catalog of products, takes orders from customers, verifies inventory, and performs other business functions.</span></span> <span data-ttu-id="25913-143">Исходный код этого приложения на основе контейнеров можно найти в репозитории GitHub [eShopOnContainers](https://aka.ms/MicroservicesArchitecture).</span><span class="sxs-lookup"><span data-stu-id="25913-143">This container-based application source code is available in the [eShopOnContainers](https://aka.ms/MicroservicesArchitecture) GitHub repo.</span></span>

<span data-ttu-id="25913-144">Приложение состоит из нескольких подсистем, в том числе нескольких внешних пользовательских интерфейсов магазина (веб-приложения и собственного мобильного приложения), а также внутренних микрослужб и контейнеров для всех необходимых серверных операций.</span><span class="sxs-lookup"><span data-stu-id="25913-144">The application consists of multiple subsystems, including several store UI front ends (a Web application and a native mobile app), along with the back-end microservices and containers for all the required server-side operations.</span></span> <span data-ttu-id="25913-145">На рис. 8-1 показана архитектура этого эталонного приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-145">Figure 8-1 shows the architecture of the reference application.</span></span>

![](./media/image1.png)

<span data-ttu-id="25913-146">**Рис. 8-1**.</span><span class="sxs-lookup"><span data-stu-id="25913-146">**Figure 8-1**.</span></span> <span data-ttu-id="25913-147">Эталонное приложение EShopOnContainers, демонстрирующее прямое взаимодействие клиента с микрослужбами, и шина событий</span><span class="sxs-lookup"><span data-stu-id="25913-147">The eShopOnContainers reference application, showing a direct client-to-microservice communication and the event bus</span></span>

<span data-ttu-id="25913-148">**Среда размещения**.</span><span class="sxs-lookup"><span data-stu-id="25913-148">**Hosting environment**.</span></span> <span data-ttu-id="25913-149">На рисунке 8-1 вы видите несколько контейнеров, развернутых в одном узле Docker.</span><span class="sxs-lookup"><span data-stu-id="25913-149">In Figure 8-1, you see several containers deployed within a single Docker host.</span></span> <span data-ttu-id="25913-150">Этого можно добиться, выполнив развертывание на один узел Docker с помощью команды docker-compose up.</span><span class="sxs-lookup"><span data-stu-id="25913-150">That would be the case when deploying to a single Docker host with the docker-compose up command.</span></span> <span data-ttu-id="25913-151">Однако если вы используете оркестратор или контейнерный кластер, каждый контейнер может работать на другом узле, и на любом узле может выполняться любое количество контейнеров, как описывалось ранее в разделе, посвященном архитектуре.</span><span class="sxs-lookup"><span data-stu-id="25913-151">However, if you are using an orchestrator or container cluster, each container could be running in a different host (node), and any node could be running any number of containers, as we explained earlier in the architecture section.</span></span>

<span data-ttu-id="25913-152">**Архитектура взаимодействия**.</span><span class="sxs-lookup"><span data-stu-id="25913-152">**Communication architecture**.</span></span> <span data-ttu-id="25913-153">В приложении EShopOnContainers используются два типа взаимодействия, в зависимости от вида функционального действия (запросы или обновления и транзакции).</span><span class="sxs-lookup"><span data-stu-id="25913-153">The eShopOnContainers application uses two communication types, depending on the kind of the functional action (queries versus updates and transactions):</span></span>

-   <span data-ttu-id="25913-154">Прямое взаимодействие клиента и микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="25913-154">Direct client-to-microservice communication.</span></span> <span data-ttu-id="25913-155">Такое взаимодействие используется для запросов и при получении обновлений или команд транзакций от клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="25913-155">This is used for queries and when accepting update or transactional commands from the client apps.</span></span>

-   <span data-ttu-id="25913-156">Асинхронное взаимодействие на основе событий.</span><span class="sxs-lookup"><span data-stu-id="25913-156">Asynchronous event-based communication.</span></span> <span data-ttu-id="25913-157">Такое взаимодействие осуществляется через шину событий для распространения обновлений на микрослужбы или для интеграции с внешними приложениями.</span><span class="sxs-lookup"><span data-stu-id="25913-157">This occurs through an event bus to propagate updates across microservices or to integrate with external applications.</span></span> <span data-ttu-id="25913-158">Шина событий может быть реализована с помощью какой-либо технологии инфраструктуры брокера обмена сообщениями, например RabbitMQ, или с помощью служебных шин более высокого уровня, таких как служебная шина Azure, NServiceBus, MassTransit или Brighter.</span><span class="sxs-lookup"><span data-stu-id="25913-158">The event bus can be implemented with any messaging-broker infrastructure technology like RabbitMQ, or using higher-level service buses like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span>

<span data-ttu-id="25913-159">Приложение разворачивается как набор микрослужб в форме контейнеров.</span><span class="sxs-lookup"><span data-stu-id="25913-159">The application is deployed as a set of microservices in the form of containers.</span></span> <span data-ttu-id="25913-160">Клиентские приложения могут взаимодействовать с этими контейнерами; микрослужбы также могут взаимодействовать между собой.</span><span class="sxs-lookup"><span data-stu-id="25913-160">Client apps can communicate with those containers as well as communicate between microservices.</span></span> <span data-ttu-id="25913-161">Как уже упоминалось, эта начальная архитектура использует архитектуру прямого взаимодействия клиента с микрослужбой; это означает, что клиентское приложение может выполнять запросы к каждой микрослужбе напрямую.</span><span class="sxs-lookup"><span data-stu-id="25913-161">As mentioned, this initial architecture is using a direct client-to-microservice communication architecture, which means that a client application can make requests to each of the microservices directly.</span></span> <span data-ttu-id="25913-162">У каждой микрослужбы есть открытая конечная точка, например https://servicename.applicationname.companyname.</span><span class="sxs-lookup"><span data-stu-id="25913-162">Each microservice has a public endpoint like https://servicename.applicationname.companyname.</span></span> <span data-ttu-id="25913-163">При необходимости каждая микрослужба может использовать другой порт TCP.</span><span class="sxs-lookup"><span data-stu-id="25913-163">If required, each microservice can use a different TCP port.</span></span> <span data-ttu-id="25913-164">В рабочей среде этот URL-адрес будет сопоставляться с подсистемой балансировки нагрузки микрослужб, которая распределяет запросы по доступным экземплярам микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-164">In production, that URL would map to the microservices’ load balancer, which distributes requests across the available microservice instances.</span></span>

<span data-ttu-id="25913-165">**Важное примечание о шлюзе API в сравнении с прямым взаимодействием в eShopOnContainers.**</span><span class="sxs-lookup"><span data-stu-id="25913-165">**Important note on API Gateway vs. Direct Communication in eShopOnContainers.**</span></span> <span data-ttu-id="25913-166">Как описано в разделе "Архитектура" данного руководства, при построении большого и сложного приложения на основе микрослужб архитектура прямого взаимодействия клиента с микрослужбами может иметь определенные недостатки.</span><span class="sxs-lookup"><span data-stu-id="25913-166">As explained in the architecture section of this guide, the direct client-to-microservice communication architecture can have drawbacks when you are building a large and complex microservice-based application.</span></span> <span data-ttu-id="25913-167">Но она может достаточно хорошо подходить для небольших приложений, таких как приложение eShopOnContainers, когда цель заключается в том, чтобы упростить запуск приложения Docker на основе контейнеров, и мы не хотим создавать единый монолитный шлюз API, который может повлиять на автономность разработки микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-167">But it can be good enough for a small application, such as in the eShopOnContainers application, where the goal is to focus on a simpler getting started Docker container-based application and we didn’t want to create a single monolithic API Gateway that can impact the microservices’ development autonomy.</span></span>

<span data-ttu-id="25913-168">Однако если планируется разработка большого приложения на основе микрослужб с десятками микрослужб, мы настоятельно рекомендуем подумать об использовании модели шлюза API, как описывается в разделе, посвященном архитектуре.</span><span class="sxs-lookup"><span data-stu-id="25913-168">But, if you are going to design a large microservice-based application with dozens of microservices, we strongly recommend that you consider the API Gateway pattern, as we explained in the architecture section.</span></span>
<span data-ttu-id="25913-169">Это архитектурное решение может быть реорганизовано после обдумывания готовых к применению в рабочей среде приложений и специально изготовленных интерфейсов для удаленных клиентов.</span><span class="sxs-lookup"><span data-stu-id="25913-169">This architectural decision could be refactored once thinking about production-ready applications and specially-made facades for remote clients.</span></span> <span data-ttu-id="25913-170">Наличие нескольких пользовательских шлюзов API в зависимости от форм-фактора клиентских приложений может обеспечить преимущества в отношении агрегирования разных данных по клиентским приложениям; кроме того, вы можете скрыть внутренние микрослужбы или интерфейсы API для клиентских приложений и выполнять авторизацию на этом единственном уровне.</span><span class="sxs-lookup"><span data-stu-id="25913-170">Having multiple custom API Gateways depending on the client apps' form-factor can provide benefits in regard to different data aggregation per client app plus you can hide internal microservices or APIs to the client apps and authorize in that single tier.</span></span> 

<span data-ttu-id="25913-171">Однако, как уже упоминалось, будьте осторожны с большими и монолитными шлюзами API, которые могут уничтожить автономию разработки ваших микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-171">However, and as mentioned, beware against large and monolithic API Gateways that might kill your microservices' development autonomy.</span></span>

### <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="25913-172">Владение данными в каждой микрослужбе</span><span class="sxs-lookup"><span data-stu-id="25913-172">Data sovereignty per microservice</span></span>

<span data-ttu-id="25913-173">В этом примере приложения каждая микрослужба имеет свою собственную базу данных или источник данных, и каждая база данных или источник данных разворачивается как отдельный контейнер.</span><span class="sxs-lookup"><span data-stu-id="25913-173">In the sample application, each microservice owns its own database or data source, and each database or data source is deployed as another container.</span></span> <span data-ttu-id="25913-174">Такое проектное решение было принято только для того, чтобы облегчить разработчику получение кода из GitHub, его клонирование и открытие в Visual Studio или Visual Studio Code.</span><span class="sxs-lookup"><span data-stu-id="25913-174">This design decision was made only to make it easy for a developer to get the code from GitHub, clone it, and open it in Visual Studio or Visual Studio Code.</span></span> <span data-ttu-id="25913-175">Или же оно облегчает компиляцию пользовательских образов Docker с помощью CLI .NET Core и CLI Docker и последующее развертывание и запуск их в среде разработки Docker.</span><span class="sxs-lookup"><span data-stu-id="25913-175">Or alternatively, it makes it easy to compile the custom Docker images using .NET Core CLI and the Docker CLI, and then deploy and run them in a Docker development environment.</span></span> <span data-ttu-id="25913-176">В любом случае использование контейнеров для источников данных позволяет разработчикам выполнять сборку и развертывание за считанные минуты без необходимости подготовки внешней базы данных или любого другого источника данных с жесткими зависимостями от инфраструктуры (облачной или локальной).</span><span class="sxs-lookup"><span data-stu-id="25913-176">Either way, using containers for data sources lets developers build and deploy in a matter of minutes without having to provision an external database or any other data source with hard dependencies on infrastructure (cloud or on-premises).</span></span>

<span data-ttu-id="25913-177">В реальной рабочей среде для обеспечения высокой доступности и масштабируемости базы данных должны размещаться на серверах баз данных в облаке или в локальной среде, но не в контейнерах.</span><span class="sxs-lookup"><span data-stu-id="25913-177">In a real production environment, for high availability and for scalability, the databases should be based on database servers in the cloud or on-premises, but not in containers.</span></span>

<span data-ttu-id="25913-178">Таким образом, единицы развертывания для микрослужб (и даже для баз данных в этом приложении) представляют собой контейнеры Docker, а эталонное приложение является многоконтейнерным приложением, использующим принципы микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-178">Therefore, the units of deployment for microservices (and even for databases in this application) are Docker containers, and the reference application is a multi-container application that embraces microservices principles.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="25913-179">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="25913-179">Additional resources</span></span>

-   <span data-ttu-id="25913-180">Репозиторий GitHub **eShopOnContainers. Исходный код для эталонного приложения**
    *https://aka.ms/eShopOnContainers/*</span><span class="sxs-lookup"><span data-stu-id="25913-180">**eShopOnContainers GitHub repo. Source code for the reference application**
*https://aka.ms/eShopOnContainers/*</span></span>

## <a name="benefits-of-a-microservice-based-solution"></a><span data-ttu-id="25913-181">Преимущества решения на основе микрослужб</span><span class="sxs-lookup"><span data-stu-id="25913-181">Benefits of a microservice-based solution</span></span>

<span data-ttu-id="25913-182">Решение на основе микрослужб, такое как представленное здесь, имеет множество преимуществ.</span><span class="sxs-lookup"><span data-stu-id="25913-182">A microservice based solution like this has many benefits:</span></span>

<span data-ttu-id="25913-183">**Каждая микрослужба относительно невелика, соответственно ею легко управлять и развивать**.</span><span class="sxs-lookup"><span data-stu-id="25913-183">**Each microservice is relatively small—easy to manage and evolve**.</span></span> <span data-ttu-id="25913-184">В частности:</span><span class="sxs-lookup"><span data-stu-id="25913-184">Specifically:</span></span>

-   <span data-ttu-id="25913-185">Разработчик может легко разобраться и быстро приступить к работе с хорошей производительностью.</span><span class="sxs-lookup"><span data-stu-id="25913-185">It is easy for a developer to understand and get started quickly with good productivity.</span></span>

-   <span data-ttu-id="25913-186">Контейнеры запускаются быстро, что повышает производительность разработчиков.</span><span class="sxs-lookup"><span data-stu-id="25913-186">Containers start fast, which makes developers more productive.</span></span>

-   <span data-ttu-id="25913-187">Интегрированная среда разработки, такая как Visual Studio, может загружать небольшие проекты быстрее, что тоже повышает производительность разработчиков.</span><span class="sxs-lookup"><span data-stu-id="25913-187">An IDE like Visual Studio can load smaller projects fast, making developers productive.</span></span>

-   <span data-ttu-id="25913-188">Каждую микрослужбу можно проектировать, разрабатывать и развертывать независимо от других микрослужб, что обеспечивает гибкость, так как становится проще часто развертывать новые версии микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-188">Each microservice can be designed, developed, and deployed independently of other microservices, which provides agility because it is easier to deploy new versions of microservices frequently.</span></span>

<span data-ttu-id="25913-189">**Можно масштабировать отдельные области приложения**.</span><span class="sxs-lookup"><span data-stu-id="25913-189">**It is possible to scale out individual areas of the application**.</span></span> <span data-ttu-id="25913-190">Например, может потребоваться масштабирование службы каталога или службы корзины, но не процесса заказа.</span><span class="sxs-lookup"><span data-stu-id="25913-190">For instance, the catalog service or the basket service might need to be scaled out, but not the ordering process.</span></span> <span data-ttu-id="25913-191">Инфраструктура микрослужб будет намного более эффективной с точки зрения ресурсов, используемых при масштабировании, чем монолитная архитектура.</span><span class="sxs-lookup"><span data-stu-id="25913-191">A microservices infrastructure will be much more efficient with regard to the resources used when scaling out than a monolithic architecture would be.</span></span>

<span data-ttu-id="25913-192">**Можно разделить работу между несколькими командами разработки**.</span><span class="sxs-lookup"><span data-stu-id="25913-192">**You can divide the development work between multiple teams**.</span></span> <span data-ttu-id="25913-193">Каждая служба может принадлежать одной команде разработки.</span><span class="sxs-lookup"><span data-stu-id="25913-193">Each service can be owned by a single development team.</span></span> <span data-ttu-id="25913-194">Каждая команда может управлять своими службами, разрабатывать, развертывать и масштабировать их независимо от остальных команд.</span><span class="sxs-lookup"><span data-stu-id="25913-194">Each team can manage, develop, deploy, and scale their service independently of the rest of the teams.</span></span>

<span data-ttu-id="25913-195">**Проблемы более изолированы**.</span><span class="sxs-lookup"><span data-stu-id="25913-195">**Issues are more isolated**.</span></span> <span data-ttu-id="25913-196">Если в одной службе возникает проблема, она изначально влияет только на эту службу (за исключением случая использования неправильного проекта с прямыми зависимостями между микрослужбами), и другие службы могут продолжать обрабатывать запросы.</span><span class="sxs-lookup"><span data-stu-id="25913-196">If there is an issue in one service, only that service is initially impacted (except when the wrong design is used, with direct dependencies between microservices), and other services can continue to handle requests.</span></span> <span data-ttu-id="25913-197">Напротив, один вышедший из строя компонент в архитектуре монолитного развертывания может привести к остановке всей системы, особенно когда речь идет о ресурсах, например об утечке памяти.</span><span class="sxs-lookup"><span data-stu-id="25913-197">In contrast, one malfunctioning component in a monolithic deployment architecture can bring down the entire system, especially when it involves resources, such as a memory leak.</span></span> <span data-ttu-id="25913-198">Кроме того, после устранения проблемы в микрослужбе можно развернуть только затронутую микрослужбу без ущерба для остальной части приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-198">Additionally, when an issue in a microservice is resolved, you can deploy just the affected microservice without impacting the rest of the application.</span></span>

<span data-ttu-id="25913-199">**Можно использовать новейшие технологии**.</span><span class="sxs-lookup"><span data-stu-id="25913-199">**You can use the latest technologies**.</span></span> <span data-ttu-id="25913-200">Так как возможно независимо разрабатывать службы и запускать их параллельно (благодаря контейнерам и .NET Core), вы можете приступать к использованию последних технологий и платформ в нужный момент и не застревать на устаревшем стеке или платформе для всего приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-200">Because you can start developing services independently and run them side by side (thanks to containers and .NET Core), you can start using the latest technologies and frameworks expediently instead of being stuck on an older stack or framework for the whole application.</span></span>

## <a name="downsides-of-a-microservice-based-solution"></a><span data-ttu-id="25913-201">Недостатки решения на основе микрослужб</span><span class="sxs-lookup"><span data-stu-id="25913-201">Downsides of a microservice-based solution</span></span>

<span data-ttu-id="25913-202">Решение на основе микрослужб, такое как представленное здесь, имеет некоторые недостатки:</span><span class="sxs-lookup"><span data-stu-id="25913-202">A microservice based solution like this also has some drawbacks:</span></span>

<span data-ttu-id="25913-203">**Распределенное приложение**.</span><span class="sxs-lookup"><span data-stu-id="25913-203">**Distributed application**.</span></span> <span data-ttu-id="25913-204">Распределенное приложение усложняет разработчикам проектирование и создание служб.</span><span class="sxs-lookup"><span data-stu-id="25913-204">Distributing the application adds complexity for developers when they are designing and building the services.</span></span> <span data-ttu-id="25913-205">Например, разработчики должны реализовать взаимодействие между службами с помощью протоколов, таких как HTTP и AMPQ, что повышает сложность тестирования и обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="25913-205">For example, developers must implement interservice communication using protocols like HTTP or AMPQ, which adds complexity for testing and exception handling.</span></span> <span data-ttu-id="25913-206">Это также приводит к увеличению задержек в системе.</span><span class="sxs-lookup"><span data-stu-id="25913-206">It also adds latency to the system.</span></span>

<span data-ttu-id="25913-207">**Сложность развертывания**.</span><span class="sxs-lookup"><span data-stu-id="25913-207">**Deployment complexity**.</span></span> <span data-ttu-id="25913-208">Приложение, имеющее множество типов микрослужб, которому требуется высокий уровень масштабируемости (должна быть предусмотрена возможность создания большого количества экземпляров каждой и балансировки этих служб на большом числе узлов), подразумевает высокую степень сложности развертывания для ИТ-операций и управления.</span><span class="sxs-lookup"><span data-stu-id="25913-208">An application that has dozens of microservices types and needs high scalability (it needs to be able to create many instances per service and balance those services across many hosts) means a high degree of deployment complexity for IT operations and management.</span></span> <span data-ttu-id="25913-209">Если вы не используете инфраструктуру на основе микрослужб (например, оркестратор и планировщик), то на реализацию этой дополнительной сложности может потребоваться гораздо больше усилий разработчиков, чем на само бизнес-приложение.</span><span class="sxs-lookup"><span data-stu-id="25913-209">If you are not using a microservice-oriented infrastructure (like an orchestrator and scheduler), that additional complexity can require far more development efforts than the business application itself.</span></span>

<span data-ttu-id="25913-210">**Атомарные транзакции**.</span><span class="sxs-lookup"><span data-stu-id="25913-210">**Atomic transactions**.</span></span> <span data-ttu-id="25913-211">Атомарные транзакции между несколькими микрослужбами обычно невозможны.</span><span class="sxs-lookup"><span data-stu-id="25913-211">Atomic transactions between multiple microservices usually are not possible.</span></span> <span data-ttu-id="25913-212">Бизнес-требования должны включать итоговую согласованность между несколькими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="25913-212">The business requirements have to embrace eventual consistency between multiple microservices.</span></span>

<span data-ttu-id="25913-213">**Увеличенная потребность в глобальных ресурсах** (таких как общий объем памяти, диски и сетевые ресурсы для всех серверов или узлов).</span><span class="sxs-lookup"><span data-stu-id="25913-213">**Increased global resource needs** (total memory, drives, and network resources for all the servers or hosts).</span></span> <span data-ttu-id="25913-214">Во многих случаях при замене монолитного приложения на приложение с микрослужбами объем глобальных ресурсов, необходимых новому приложению на основе микрослужб, будет больше инфраструктурных требований исходного монолитного приложения.</span><span class="sxs-lookup"><span data-stu-id="25913-214">In many cases, when you replace a monolithic application with a microservices approach, the amount of global resources needed by the new microservice-based application will be larger than the infrastructure needs of the original monolithic application.</span></span> <span data-ttu-id="25913-215">Это объясняется тем, что более высокий уровень детализации и распределенные службы требуют больше глобальных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="25913-215">This is because the higher degree of granularity and distributed services requires more global resources.</span></span> <span data-ttu-id="25913-216">Однако учитывая низкую стоимость ресурсов в целом и преимущества возможности масштабирования только определенных частей приложения, повышенная стоимость ресурсов в сравнении с долгосрочными затратами при разработке монолитных приложений обычно является лучшим выбором для больших, долгосрочных приложений.</span><span class="sxs-lookup"><span data-stu-id="25913-216">However, given the low cost of resources in general and the benefit of being able to scale out just certain areas of the application compared to long-term costs when evolving monolithic applications, the increased use of resources is usually a good tradeoff for large, long-term applications.</span></span>

<span data-ttu-id="25913-217">**Проблемы с прямым взаимодействием клиента и микрослужбы**.</span><span class="sxs-lookup"><span data-stu-id="25913-217">**Issues with direct client‑to‑microservice communication**.</span></span> <span data-ttu-id="25913-218">Когда приложение большое и имеет десятки микрослужб, возникают проблемы и ограничения, если приложению требуется прямое взаимодействие клиента с микрослужбой.</span><span class="sxs-lookup"><span data-stu-id="25913-218">When the application is large, with dozens of microservices, there are challenges and limitations if the application requires direct client-to-microservice communications.</span></span> <span data-ttu-id="25913-219">Одна из проблем заключается в возможном несоответствии между потребностями клиента и интерфейсами API, предоставляемыми каждой микрослужбой.</span><span class="sxs-lookup"><span data-stu-id="25913-219">One problem is a potential mismatch between the needs of the client and the APIs exposed by each of the microservices.</span></span> <span data-ttu-id="25913-220">В некоторых случаях клиентскому приложению может потребоваться выполнить много отдельных запросов для создания пользовательского интерфейса, что может оказаться неэффективным в Интернете и непрактичным в мобильной сети.</span><span class="sxs-lookup"><span data-stu-id="25913-220">In certain cases, the client application might need to make many separate requests to compose the UI, which can be inefficient over the Internet and would be impractical over a mobile network.</span></span> <span data-ttu-id="25913-221">Таким образом, запросы от клиентского приложения в серверную систему необходимо максимально сократить.</span><span class="sxs-lookup"><span data-stu-id="25913-221">Therefore, requests from the client application to the back-end system should be minimized.</span></span>

<span data-ttu-id="25913-222">Другая проблема, связанная с прямым взаимодействием клиента с микрослужбой, состоит в том, что некоторые микрослужбы могут использовать протоколы, не адаптированные для Интернета.</span><span class="sxs-lookup"><span data-stu-id="25913-222">Another problem with direct client-to-microservice communications is that some microservices might be using protocols that are not Web-friendly.</span></span> <span data-ttu-id="25913-223">Одна служба может использовать двоичный протокол, в то время как другая — обмен сообщениями AMQP.</span><span class="sxs-lookup"><span data-stu-id="25913-223">One service might use a binary protocol, while another service might use AMQP messaging.</span></span> <span data-ttu-id="25913-224">Эти протоколы не адаптированы для брандмауэра, и их лучше использовать внутренним образом.</span><span class="sxs-lookup"><span data-stu-id="25913-224">Those protocols are not firewall‑friendly and are best used internally.</span></span> <span data-ttu-id="25913-225">Как правило, для взаимодействия за пределами брандмауэра в приложении следует использовать такие протоколы, как HTTP и WebSockets.</span><span class="sxs-lookup"><span data-stu-id="25913-225">Usually, an application should use protocols such as HTTP and WebSockets for communication outside of the firewall.</span></span>

<span data-ttu-id="25913-226">Еще одним недостатком прямого взаимодействия клиента со службами является то, что оно затрудняет выполнение рефакторинга контрактов для этих микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-226">Yet another drawback with this direct client‑to‑service approach is that it makes it difficult to refactor the contracts for those microservices.</span></span> <span data-ttu-id="25913-227">Со временем разработчикам может потребоваться изменить способ разделения системы на службы.</span><span class="sxs-lookup"><span data-stu-id="25913-227">Over time developers might want to change how the system is partitioned into services.</span></span> <span data-ttu-id="25913-228">Например, они могут объединить две службы или разбить службу на несколько служб.</span><span class="sxs-lookup"><span data-stu-id="25913-228">For example, they might merge two services or split a service into two or more services.</span></span> <span data-ttu-id="25913-229">Однако если клиенты взаимодействуют со службами напрямую, выполнение такого рода рефакторинга может нарушить совместимость с клиентскими приложениями.</span><span class="sxs-lookup"><span data-stu-id="25913-229">However, if clients communicate directly with the services, performing this kind of refactoring can break compatibility with client apps.</span></span>

<span data-ttu-id="25913-230">Как упоминалось в разделе, посвященном архитектуре, при разработке и сборке сложного приложения на основе микрослужб следует обдумать целесообразность использования нескольких детальных шлюзов API вместо более простого прямого взаимодействия клиента с микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="25913-230">As mentioned in the architecture section, when designing and building a complex application based on microservices, you might consider the use of multiple fine-grained API Gateways instead of the simpler direct client‑to‑microservice communication approach.</span></span>

<span data-ttu-id="25913-231">**Разделение на микрослужбы**.</span><span class="sxs-lookup"><span data-stu-id="25913-231">**Partitioning the microservices**.</span></span> <span data-ttu-id="25913-232">Наконец, независимо от подхода, выбранного для архитектуры микрослужб, еще одна задача состоит в том, чтобы решить, как разделить все приложение на несколько микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-232">Finally, no matter which approach you take for your microservice architecture, another challenge is deciding how to partition an end-to-end application into multiple microservices.</span></span> <span data-ttu-id="25913-233">Как упоминалось в разделе, посвященном архитектуре, существует несколько методов и подходов.</span><span class="sxs-lookup"><span data-stu-id="25913-233">As noted in the architecture section of the guide, there are several techniques and approaches you can take.</span></span> <span data-ttu-id="25913-234">В сущности, вам нужно определить области приложения, которые отделены от других областей и имеют небольшое количество жестких зависимостей.</span><span class="sxs-lookup"><span data-stu-id="25913-234">Basically, you need to identify areas of the application that are decoupled from the other areas and that have a low number of hard dependencies.</span></span> <span data-ttu-id="25913-235">Во многих случаях это согласуется с разделением на службы по варианту использования.</span><span class="sxs-lookup"><span data-stu-id="25913-235">In many cases, this is aligned to partitioning services by use case.</span></span> <span data-ttu-id="25913-236">Например, в нашем приложении интернет-магазина имеется служба заказов, отвечающая за всю бизнес-логику, относящуюся к процессу заказа.</span><span class="sxs-lookup"><span data-stu-id="25913-236">For example, in our e-shop application, we have an ordering service that is responsible for all the business logic related to the order process.</span></span> <span data-ttu-id="25913-237">У нас также есть служба каталога и служба корзины, которые реализуют другие возможности.</span><span class="sxs-lookup"><span data-stu-id="25913-237">We also have the catalog service and the basket service that implement other capabilities.</span></span> <span data-ttu-id="25913-238">Желательно, чтобы каждая служба имела только небольшой набор задач.</span><span class="sxs-lookup"><span data-stu-id="25913-238">Ideally, each service should have only a small set of responsibilities.</span></span> <span data-ttu-id="25913-239">Это аналогично принципу разделения обязанностей (SRP), используемому для классов, который утверждает, что класс должен иметь только одну причину для изменения.</span><span class="sxs-lookup"><span data-stu-id="25913-239">This is similar to the single responsibility principle (SRP) applied to classes, which states that a class should only have one reason to change.</span></span> <span data-ttu-id="25913-240">Однако в данном случае это относится к микрослужбам, поэтому область будет больше, чем один класс.</span><span class="sxs-lookup"><span data-stu-id="25913-240">But in this case, it is about microservices, so the scope will be larger than a single class.</span></span> <span data-ttu-id="25913-241">Прежде всего, микрослужба должна быть полностью автономной, с начала до конца, включая ответственность за свои источники данных.</span><span class="sxs-lookup"><span data-stu-id="25913-241">Most of all, a microservice has to be completely autonomous, end to end, including responsibility for its own data sources.</span></span>

## <a name="external-versus-internal-architecture-and-design-patterns"></a><span data-ttu-id="25913-242">Внешняя и внутренняя архитектура и конструктивные шаблоны</span><span class="sxs-lookup"><span data-stu-id="25913-242">External versus internal architecture and design patterns</span></span>

<span data-ttu-id="25913-243">Внешняя архитектура — это архитектура микрослужб, состоящая из нескольких служб и соответствующая принципам, описанным в разделе "Архитектура" данного руководства.</span><span class="sxs-lookup"><span data-stu-id="25913-243">The external architecture is the microservice architecture composed by multiple services, following the principles described in the architecture section of this guide.</span></span> <span data-ttu-id="25913-244">Однако в зависимости от характера каждой микрослужбы и независимо от выбранной высокоуровневой архитектуры микрослужб распространенный и иногда рекомендуемый подход заключается в наличии разных внутренних архитектур на основе разных шаблонов для различных микрослужб.</span><span class="sxs-lookup"><span data-stu-id="25913-244">However, depending on the nature of each microservice, and independently of high-level microservice architecture you choose, it is common and sometimes advisable to have different internal architectures, each based on different patterns, for different microservices.</span></span> <span data-ttu-id="25913-245">Микрослужбы даже могут использовать разные технологии и языки программирования.</span><span class="sxs-lookup"><span data-stu-id="25913-245">The microservices can even use different technologies and programming languages.</span></span> <span data-ttu-id="25913-246">На рисунке 8-2 показано это разнообразие.</span><span class="sxs-lookup"><span data-stu-id="25913-246">Figure 8-2 illustrates this diversity.</span></span>

![](./media/image2.png)

<span data-ttu-id="25913-247">**Рис. 8-2**.</span><span class="sxs-lookup"><span data-stu-id="25913-247">**Figure 8-2**.</span></span> <span data-ttu-id="25913-248">Внешняя и внутренняя архитектура и конструктивные шаблоны</span><span class="sxs-lookup"><span data-stu-id="25913-248">External versus internal architecture and design</span></span>

<span data-ttu-id="25913-249">Например, в нашем эталонном приложении *eShopOnContainers* микрослужбы каталога, корзины и пользовательские профили являются простыми (в основном это подсистемы CRUD).</span><span class="sxs-lookup"><span data-stu-id="25913-249">For instance, in our *eShopOnContainers* sample, the catalog, basket, and user profile microservices are simple (basically, CRUD subsystems).</span></span> <span data-ttu-id="25913-250">Следовательно, их внутренняя архитектура и конструктивный шаблон достаточно просты.</span><span class="sxs-lookup"><span data-stu-id="25913-250">Therefore, their internal architecture and design is straightforward.</span></span> <span data-ttu-id="25913-251">Однако у вас могут быть другие микрослужбы, например микрослужба заказов, которая является более сложной и представляет постоянно меняющиеся бизнес-правила с высокой степенью сложности предметной области.</span><span class="sxs-lookup"><span data-stu-id="25913-251">However, you might have other microservices, such as the ordering microservice, which is more complex and represents ever-changing business rules with a high degree of domain complexity.</span></span> <span data-ttu-id="25913-252">В подобных случаях может потребоваться реализация в конкретной микрослужбе более сложных шаблонов, например таких, которые определяются с помощью предметно-ориентированного проектирования (DDD), как мы это делаем в микрослужбе заказов *eShopOnContainers*.</span><span class="sxs-lookup"><span data-stu-id="25913-252">In cases like these, you might want to implement more advanced patterns within a particular microservice, like the ones defined with domain-driven design (DDD) approaches, as we are doing in the *eShopOnContainers* ordering microservice.</span></span> <span data-ttu-id="25913-253">(Мы рассмотрим эти шаблоны DDD позднее, в разделе, посвященном реализации микрослужбы заказов *eShopOnContainers*.)</span><span class="sxs-lookup"><span data-stu-id="25913-253">(We will review these DDD patterns in the section later that explains the implementation of the *eShopOnContainers* ordering microservice.)</span></span>

<span data-ttu-id="25913-254">Другая причина использования разных технологий для микрослужб может заключаться в сути каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="25913-254">Another reason for a different technology per microservice might be the nature of each microservice.</span></span> <span data-ttu-id="25913-255">Например, при разработке для области AI или машинного обучения может оказаться предпочтительнее использовать такой функциональный язык программирования, как F\# или даже R вместо объектно-ориентированного языка программирования, такого как C\#.</span><span class="sxs-lookup"><span data-stu-id="25913-255">For example, it might be better to use a functional programming language like F\#, or even a language like R if you are targeting AI and machine learning domains, instead of a more object-oriented programming language like C\#.</span></span>

<span data-ttu-id="25913-256">Суть в том, что каждая микрослужба может иметь другую внутреннюю архитектуру на основе других конструктивных шаблонов.</span><span class="sxs-lookup"><span data-stu-id="25913-256">The bottom line is that each microservice can have a different internal architecture based on different design patterns.</span></span> <span data-ttu-id="25913-257">Не все микрослужбы следует реализовывать с помощью расширенных шаблонов DDD, так как это может оказаться чрезмерным техническим усложнением.</span><span class="sxs-lookup"><span data-stu-id="25913-257">Not all microservices should be implemented using advanced DDD patterns, because that would be over-engineering them.</span></span> <span data-ttu-id="25913-258">Аналогично, сложные микрослужбы с постоянно меняющейся бизнес-логикой не следует реализовывать как компоненты CRUD, иначе вы можете получить код низкого качества.</span><span class="sxs-lookup"><span data-stu-id="25913-258">Similarly, complex microservices with ever-changing business logic should not be implemented as CRUD components, or you can end up with low-quality code.</span></span>



## <a name="the-new-world-multiple-architectural-patterns-and-polyglot-microservices"></a><span data-ttu-id="25913-259">Новый мир: множество архитектурных шаблонов и многоязыковые микрослужбы</span><span class="sxs-lookup"><span data-stu-id="25913-259">The new world: multiple architectural patterns and polyglot microservices</span></span>

<span data-ttu-id="25913-260">Существует множество архитектурных шаблонов, используемых архитекторами и разработчиками программного обеспечения.</span><span class="sxs-lookup"><span data-stu-id="25913-260">There are many architectural patterns used by software architects and developers.</span></span> <span data-ttu-id="25913-261">Ниже приведены некоторые из них (смешанные архитектурные стили и архитектурные шаблоны).</span><span class="sxs-lookup"><span data-stu-id="25913-261">The following are a few (mixing architecture styles and architecture patterns):</span></span>

-   <span data-ttu-id="25913-262">Простая CRUD, однослойная, одноуровневая архитектура.</span><span class="sxs-lookup"><span data-stu-id="25913-262">Simple CRUD, single-tier, single-layer.</span></span>

-   <span data-ttu-id="25913-263">[Классическая многоуровневая архитектура](https://msdn.microsoft.com/library/ee658109.aspx#Layers).</span><span class="sxs-lookup"><span data-stu-id="25913-263">[Traditional N-Layered](https://msdn.microsoft.com/library/ee658109.aspx#Layers).</span></span>

-   <span data-ttu-id="25913-264">[Многоуровневая архитектура с предметно-ориентированным проектированием](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/).</span><span class="sxs-lookup"><span data-stu-id="25913-264">[Domain-Driven Design N-layered](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/).</span></span>

-   <span data-ttu-id="25913-265">[Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) (как используется в [eShopOnWeb](https://aka.ms/WebAppArchitecture)).</span><span class="sxs-lookup"><span data-stu-id="25913-265">[Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) (as used with [eShopOnWeb](https://aka.ms/WebAppArchitecture))</span></span>

-   <span data-ttu-id="25913-266">[Архитектура с разделением обязанностей запросов и команд](https://martinfowler.com/bliki/CQRS.html) (CQRS).</span><span class="sxs-lookup"><span data-stu-id="25913-266">[Command and Query Responsibility Segregation](https://martinfowler.com/bliki/CQRS.html) (CQRS).</span></span>

-   <span data-ttu-id="25913-267">[Событийно-управляемая архитектура](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA).</span><span class="sxs-lookup"><span data-stu-id="25913-267">[Event-Driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA).</span></span>

<span data-ttu-id="25913-268">Вы также можете создавать микрослужбы с помощью множества технологий и языков, таких как веб-API ASP.NET Core, NancyFx, SignalR ASP.NET Core (доступный в .NET Core 2), F\#, Node.js, Python, Java, C++, GoLang и многих других.</span><span class="sxs-lookup"><span data-stu-id="25913-268">You can also build microservices with many technologies and languages, such as ASP.NET Core Web APIs, NancyFx, ASP.NET Core SignalR (available with .NET Core 2), F\#, Node.js, Python, Java, C++, GoLang, and more.</span></span>

<span data-ttu-id="25913-269">Важно отметить, что ни один конкретный архитектурный шаблон или стиль и ни одна конкретная технология не подходят для всех ситуаций.</span><span class="sxs-lookup"><span data-stu-id="25913-269">The important point is that no particular architecture pattern or style, nor any particular technology, is right for all situations.</span></span> <span data-ttu-id="25913-270">На рисунке 8-3 показаны некоторые подходы и технологии (хотя и не в каком-либо определенном порядке), которые могут использоваться в различных микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="25913-270">Figure 8-3 shows some approaches and technologies (although not in any particular order) that could be used in different microservices.</span></span>

![](./media/image3.png)

<span data-ttu-id="25913-271">**Рис. 8-3**.</span><span class="sxs-lookup"><span data-stu-id="25913-271">**Figure 8-3**.</span></span> <span data-ttu-id="25913-272">Множество архитектурных шаблонов и многоязыковые микрослужбы</span><span class="sxs-lookup"><span data-stu-id="25913-272">Multi-architectural patterns and the polyglot microservices world</span></span>

<span data-ttu-id="25913-273">Как показано на рисунке 8-3, в приложениях, состоящий из многих микрослужб (с ограниченным контекстом в технологии с предметно-ориентированным проектированием, или просто "подсистем" как автономных микрослужб), можно реализовывать каждую микрослужбу по-разному.</span><span class="sxs-lookup"><span data-stu-id="25913-273">As shown in Figure 8-3, in applications composed of many microservices (Bounded Contexts in domain-driven design terminology, or simply “subsystems” as autonomous microservices), you might implement each microservice in a different way.</span></span> <span data-ttu-id="25913-274">Каждая микрослужба может иметь свой архитектурный шаблон и использовать разные языки и базы данных в зависимости от характера приложения, бизнес-требований и приоритетов.</span><span class="sxs-lookup"><span data-stu-id="25913-274">Each might have a different architecture pattern and use different languages and databases depending on the application’s nature, business requirements, and priorities.</span></span> <span data-ttu-id="25913-275">В некоторых случаях микрослужбы могут быть аналогичными.</span><span class="sxs-lookup"><span data-stu-id="25913-275">In some cases, the microservices might be similar.</span></span> <span data-ttu-id="25913-276">Но обычно это не так, потому что границы контекста и требования каждой подсистемы, как правило, различны.</span><span class="sxs-lookup"><span data-stu-id="25913-276">But that is not usually the case, because each subsystem’s context boundary and requirements are usually different.</span></span>

<span data-ttu-id="25913-277">Например, для простого служебного приложения CRUD разработка и реализация шаблонов DDD может не иметь смысла.</span><span class="sxs-lookup"><span data-stu-id="25913-277">For instance, for a simple CRUD maintenance application, it might not make sense to design and implement DDD patterns.</span></span> <span data-ttu-id="25913-278">Но для вашей основной предметной области или бизнеса может потребоваться применение расширенных шаблонов для решения сложных бизнес-задач с постоянно меняющимися бизнес-правилами.</span><span class="sxs-lookup"><span data-stu-id="25913-278">But for your core domain or core business, you might need to apply more advanced patterns to tackle business complexity with ever-changing business rules.</span></span>

<span data-ttu-id="25913-279">Особенно в случае крупных приложений, состоящих из нескольких подсистем, не следует ограничиваться одной архитектурой верхнего уровня на основе единственного архитектурного шаблона.</span><span class="sxs-lookup"><span data-stu-id="25913-279">Especially when you deal with large applications composed by multiple sub-systems, you should not apply a single top-level architecture based on a single architecture pattern.</span></span> <span data-ttu-id="25913-280">Например, CQRS не подходит в качестве архитектуры верхнего уровня для всего приложения, но может оказаться полезной для определенной группы служб.</span><span class="sxs-lookup"><span data-stu-id="25913-280">For instance, CQRS should not be applied as a top-level architecture for a whole application, but might be useful for a specific set of services.</span></span>

<span data-ttu-id="25913-281">Не существует простого решения или правильного архитектурного шаблона для каждого конкретного случая.</span><span class="sxs-lookup"><span data-stu-id="25913-281">There is no silver bullet or a right architecture pattern for every given case.</span></span> <span data-ttu-id="25913-282">Вы не можете получить "один архитектурный шаблон, подходящий для всего".</span><span class="sxs-lookup"><span data-stu-id="25913-282">You cannot have “one architecture pattern to rule them all.”</span></span> <span data-ttu-id="25913-283">В зависимости от приоритетов микрослужб необходимо выбирать свой подход для каждой из них, как описано в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="25913-283">Depending on the priorities of each microservice, you must choose a different approach for each, as explained in the following sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="25913-284">[Назад](index.md)
[Вперед](data-driven-crud-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="25913-284">[Previous](index.md)
[Next](data-driven-crud-microservice.md)</span></span>
