---
title: "Подписка на события"
description: "Архитектура Микрослужбами .NET для приложений .NET в контейнерах | Подписка на события"
keywords: "Docker, микрослужбы, ASP.NET, контейнер"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: fe17b53a39ff2964cd60183e291e2936d3ba28df
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="subscribing-to-events"></a>Подписка на события

Первым шагом для использования шины событий является подписаться микрослужбами события, которые они хотят получать. Что необходимо сделать в микрослужбами получателя.

Следующем простом коде показано, что микрослужбу каждый получатель должен реализовывать при запуске службы (то есть в начальный класс), он подписывается на события он требуется. Например микрослужбу basket.api необходимо подписаться ProductPriceChangedIntegrationEvent сообщений. Это делает микрослужбу сведения обо всех изменениях цену продукта и позволяет его предупредить пользователя об изменениях, если этого продукта в корзину пользователя.

```csharp
var eventBus = app.ApplicationServices.GetRequiredService<IEventBus>();
eventBus.Subscribe<ProductPriceChangedIntegrationEvent>(
    ProductPriceChangedIntegrationEventHandler);
```

После выполнения этого кода микрослужбу подписчика будет осуществлять прослушивание по каналам RabbitMQ. По прибытии сообщения типа ProductPriceChangedIntegrationEvent код вызывает обработчик событий, который передается в него и обрабатывает событие.

## <a name="publishing-events-through-the-event-bus"></a>Публикация событий через шину событий

Наконец отправителя сообщения (источник микрослужбу) публикует события интеграции с код, аналогичный приведенному ниже. (Это упрощенном примере, который не принимает атомарность в учетную запись). Аналогичный код будет реализовывать каждый раз, когда события должны быть распространены между несколькими микрослужбами, обычно непосредственно после фиксации данных или транзакций из микрослужбу источника.

Во-первых объект события шины реализацию (на RabbitMQ на основе или service bus) будет вставлен на конструктор контроллера, как показано в следующем коде:

```csharp
[Route("api/v1/[controller]")]
public class CatalogController : ControllerBase
{
    private readonly CatalogContext _context;
    private readonly IOptionsSnapshot<Settings> _settings;
    private readonly IEventBus _eventBus;

    public CatalogController(CatalogContext context,
        IOptionsSnapshot<Settings> settings,
        IEventBus eventBus)
    {
        _context = context;
        _settings = settings;
        _eventBus = eventBus;
    }
    // ...
}
```

Затем она используется с помощью методов своего устройства, как метод UpdateProduct:

```csharp
[Route("update")]
[HttpPost]
public async Task<IActionResult> UpdateProduct([FromBody]CatalogItem product)
{
    var item = await _context.CatalogItems.SingleOrDefaultAsync(
        i => i.Id == product.Id);
    // ...
    if (item.Price != product.Price)
    {
        var oldPrice = item.Price;
        item.Price = product.Price;
        _context.CatalogItems.Update(item);
        var @event = new ProductPriceChangedIntegrationEvent(item.Id,
            item.Price,
            oldPrice);
        // Commit changes in original transaction
        await _context.SaveChangesAsync();
        // Publish integration event to the event bus
        // (RabbitMQ or a service bus underneath)
        _eventBus.Publish(@event);
        // ...
    }
    // ...
}
```

Таким образом так как источник микрослужбу простой микрослужбу CRUD, этот код помещается справа в контроллер веб-API. В более сложных микрослужбами он может быть реализован в классе CommandHandler справа после фиксации исходных данных.

### <a name="designing-atomicity-and-resiliency-when-publishing-to-the-event-bus"></a>Проектирование атомарность и гибкости при публикации на шине событий

При публикации события интеграции с помощью распределенным обменом сообщениями системы, например ваш шины событий и имеет проблем с единым блоком обновление исходной базы данных и публикация события. Для экземпляра в упрощенном примере приведенный выше код фиксирует данные в базу данных при цена продукта изменяется и затем публикует сообщение ProductPriceChangedIntegrationEvent. Изначально может выглядеть essential атомарным образом выполнить следующие операции. Однако при использовании распределенных транзакций с использованием базы данных и сообщения компонента service broker, как и в старых системах, таких как [очередь сообщений (MSMQ)](https://msdn.microsoft.com/library/ms711472(v=vs.85).aspx), это не рекомендуется по соображениям, описываемого [Крепления Теорема](https://www.quora.com/What-Is-CAP-Theorem-1).

По сути микрослужбами используется для построения высокой надежности и масштабируемой системы. Упрощение немного, теоремы CAP говорит, то нельзя создать базу данных (или микрослужбу, которому принадлежит его модели) постоянно доступны и в полной мере согласованно *и* нечувствительного к ошибкам для любого раздела. Необходимо выбрать два из этих трех свойств.

В основе микрослужбами архитектур необходимо выбрать доступности и отказоустойчивость и следует уменьшения входа строгая согласованность. Таким образом, в большинстве современных микрослужбу приложений на основе обычно не требуется для использования распределенных транзакций в обмене сообщениями, как и при реализации [распределенные транзакции](https://msdn.microsoft.com/library/ms978430.aspx#bdadotnetasync2_topic3c) зависимости от распределенной транзакции Windows Координатор (DTC) с [MSMQ](https://msdn.microsoft.com/library/ms711472(v=vs.85).aspx).

Вернемся к начальной проблемы и его пример. Если служба завершает работу после обновления базы данных (в этом случае сразу после строки кода, \_контекста. SaveChangesAsync()), но прежде чем публикации события интеграции общей системы могут оказаться несогласованными. Это может быть критически важных, в зависимости от конкретной операцию, которую вы имеете дело с бизнес.

Как уже упоминалось в разделе "Архитектура" может иметь несколько способов решения этой проблемы:

-   С помощью полного [источники событий шаблон](https://msdn.microsoft.com/en-us/library/dn589792.aspx).

-   С помощью [интеллектуального анализа данных журнала транзакций](http://www.scoop.it/t/sql-server-transaction-log-mining).

-   С помощью [шаблон папки "Исходящие"](http://gistlabs.com/2014/05/the-outbox/). Это транзакций таблицы будут сохранены события интеграции (расширение локальных транзакций).

Для этого сценария использование полного шаблона Event Sourcing (ES) является одним из лучших подходов, если не *лучшим*. Однако во многих сценариях приложений не можно реализовать полной системы ES. ES означает хранение только события домена в транзакционной базе данных, вместо сохранения данных текущего состояния. Сохранение только события домена может иметь значительные преимущества, такие как наличие журнал системы доступны и не сможет определить состояние системы в любой момент в прошлом. Однако реализации полной системы ES необходимо переработайте большая часть системы и предоставляет много осложнений и требований. Например, может потребоваться использовать базу данных, специально предназначенных для источники событий, таких как [хранилища событий](https://geteventstore.com/), или базы данных ориентированные на Azure Cosmos DB, MongoDB, Cassandra, CouchDB или RavenDB. ES — это отличный подход для этой проблемы, но не простейшим решением, если вы уже знакомы с источники событий.

Возможность использования журнала транзакций, интеллектуального анализа данных первоначально выглядит очень прозрачным. Однако чтобы использовать этот подход, микрослужбу имеет для соединения с журнала транзакций реляционной СУБД, такие как журнал транзакций SQL Server. Это возможно, нежелательно. Другим недостатком является то, что нижнего уровня обновления записываются в журнал транзакций может быть на том же уровне, как события высокого уровня интеграции. В этом случае процесс реконструирования эти операции журнала транзакций могут затруднить.

Сбалансированный подход зависит от используемых таблицу транзакций базы данных и упрощенный шаблон ES. Можно использовать в состояние, например «все готово для публикации события,» которого задано в оригинальном событии при фиксации в таблицу событий интеграции. Затем, при попытке публикации события в канале событий. Если действие публикации события завершается успешно, запустить другой транзакции в исходной службе и переместите состояние из «все готово для публикации события» «событие уже опубликован.»

Если действие публикации события в событии шины завершается с ошибкой, данные по-прежнему не будет согласовано в микрослужбу источника — он по-прежнему отмечен как «Готово к публикации события» и по отношению к остальным службам, его в конечном итоге будет согласованным. Можно всегда имеют фоновых заданий, проверка состояния транзакции или события интеграции. Если задание поиск события в состоянии «Готово к публикации события», можно попытаться повторно публиковать события в канале событий.

Обратите внимание, что при таком подходе, сохранении только события интеграции для каждого источника микрослужбу и только события, которые вы хотите связаться с другими микрослужбами или внешними системами. В отличие от этого в полной системы ES, хранятся также все события домена.

Таким образом этот сбалансированный подход — это упрощенная система ES. Вам требуется список события интеграции с их текущее состояние («готовность к публикации» и «публикации»). Однако необходимо реализовать для события интеграции этих состояний. И, при таком подходе вы не обязательно должны хранить все данные домена как события в транзакционной базе данных, как и в полной системы ES.

Если вы уже используете реляционной базы данных, можно использовать таблицу транзакций, события интеграции хранилища. Для достижения атомарности в приложении, используется в два этапа, на основании локальных транзакций. По сути имеется таблица IntegrationEvent в той же базе данных, в которой имеется сущности домена. Эту таблицу работает как страховку для достижения атомарности, чтобы включить события интеграции сохраняются в те же операции, которые фиксируются данные домена.

Шаг за шагом процесс выглядит следующим образом: приложение начинает транзакцию локальной базы данных. Затем обновляет состояние домена сущностей и вставляет в таблицу событий интеграции событие. Наконец он фиксирует транзакцию. Вы получаете требуемой атомарность.

При реализации процесс публикации событий, существуют следующие варианты:

-   Опубликовать событие интеграции сразу же после фиксации транзакции и использовать другой локальной транзакции, чтобы пометить события в качестве публикуемой таблицы. Затем таблица используется только в качестве артефакта для отслеживания событий интеграции в случае проблем в удаленном микрослужбами и выполнять Компенсационный выходной действия на основе событий хранимых интеграции.

-   Используйте таблицу как тип очереди. Отдельное приложение потока или процесса запрашивает таблицу событий интеграции, публикует события в канале событий, а затем использует локальную транзакцию для пометки события как опубликованные.

На рисунке 8-22 показана архитектура для первого из этих подходов.

![](./media/image23.png)

**На рисунке 8-22**. Атомарность при публикации события в канале событий

Этот подход показан на рисунке 8-22 отсутствует дополнительных рабочих микрослужбу, ответственный за проверки и подтверждения успешности интеграции опубликованного события. В случае сбоя этого микрослужбу дополнительные проверки рабочих можно считывать события из таблицы и повторно опубликуйте их.

О второй подход: используйте таблицу EventLog очереди и для публикации сообщения всегда используют микрослужбу работника. В этом случае процесс подобное показан на рисунке 8-23. В следующем примере показано дополнительных микрослужбу и таблица является единственным источником при публикации события.

![](./media/image24.png)

**На рисунке 8-23**. Атомарность при публикации событий в шине событий с микрослужбу работника

Для простоты образец eShopOnContainers используется первый подход (с без дополнительных процессов или проверки микрослужбами) плюс шины событий. Однако eShopOnContainers не обрабатывает все случаи возможных сбоев. В реальном приложении развернут в облаке должны поддерживать тот факт, что со временем могут возникнуть проблемы, и должны быть реализованы, проверьте и повторите отправку логику. С помощью таблицы в качестве очереди может быть более эффективным, чем первый подход при наличии этой таблицы как единый источник события при их публикации через шину событий.

### <a name="implementing-atomicity-when-publishing-integration-events-through-the-event-bus"></a>Реализация атомарность при публикации события интеграции через шину событий

В следующем коде показано, как можно создать одну транзакцию, включающие несколько объектов DbContext — один относящиеся к исходным данным выполняется обновление и второй контекста связано с таблицей IntegrationEventLog.

Обратите внимание, что транзакции в приведенном ниже примере кода не будет устойчивой, имея любые проблемы соединения с базой данных во время, когда выполняется код. Это может произойти в облачных систем, таких как база данных SQL Azure, которого может переместить базы данных между серверами. Реализация устойчивым транзакций разных контекстах, в разделе [реализация устойчивым соединений Entity Framework Core SQL](#implementing_resilient_EFCore_SQL_conns) данного руководства.

Для ясности в примере показан весь процесс в одну часть кода. Однако реализация eShopOnContainers действительно рефакторинга и разбить на несколько классов эту логику, чтобы было проще для поддержки.

```csharp
// Update Product from the Catalog microservice
//
public async Task<IActionResult>
    UpdateProduct([FromBody]CatalogItem productToUpdate)
{
    var catalogItem = await _catalogContext.CatalogItems
        .SingleOrDefaultAsync(i => i.Id == productToUpdate.Id);

    if (catalogItem == null) return NotFound();

    bool raiseProductPriceChangedEvent = false;

    IntegrationEvent priceChangedEvent = null;

    if (catalogItem.Price != productToUpdate.Price)
        raiseProductPriceChangedEvent = true;

    if (raiseProductPriceChangedEvent) // Create event if price has changed
    {
        var oldPrice = catalogItem.Price;
        priceChangedEvent = new ProductPriceChangedIntegrationEvent(catalogItem.Id,
            productToUpdate.Price,
            oldPrice);
    }

    // Update current product
    catalogItem = productToUpdate;
    // Achieving atomicity between original DB and the IntegrationEventLog
    // with a local transaction

    using (var transaction = _catalogContext.Database.BeginTransaction())
    {
        _catalogContext.CatalogItems.Update(catalogItem);

        await _catalogContext.SaveChangesAsync();

        // Save to EventLog only if product price changed
        if(raiseProductPriceChangedEvent)
            await _integrationEventLogService.SaveEventAsync(priceChangedEvent);
        transaction.Commit();
   }

   // Publish to event bus only if product price changed

   if (raiseProductPriceChangedEvent)
   {
       _eventBus.Publish(priceChangedEvent);
       integrationEventLogService.MarkEventAsPublishedAsync(
           priceChangedEvent);
   }

   return Ok();
}
```

После создания события интеграции ProductPriceChangedIntegrationEvent транзакцию, которая хранит исходную операцию домена (обновление элемента каталога) также сохраняемости события из таблицы журнала событий. В результате одной транзакции, и вы всегда сможете проверить, были ли отправлены сообщения о событиях.

Таблица журнала событий обновляется атомарным образом с исходной операцией базы данных, с помощью локальной транзакции к той же базе данных. В случае неудачи любой из операций, возникает исключение и откатить транзакцию любой завершенной операции, таким образом поддержания согласованности между операций домена и отправки сообщения о событиях.

### <a name="receiving-messages-from-subscriptions-event-handlers-in-receiver-microservices"></a>Получение сообщений из подписки: обработчиков событий в приемник микрослужбами

Помимо логики подписки событий необходимо реализовать внутренний код для интеграции обработчиков событий (например, метод обратного вызова). Обработчик событий задается где получение и обработку сообщения события определенного типа.

Обработчик событий получает экземпляр события от шины событий. Затем она выполняет поиск компонента для обработки связанных с этим событием интеграции, распространение и сохранение как изменение в состоянии микрослужбу приемника события. Например если событие ProductPriceChanged инициируется в микрослужбу каталога, обрабатывается в микрослужбу корзины и изменяет состояние в этот получатель корзины микрослужбу также, как показано в следующем коде.

```csharp
namespace Microsoft.eShopOnContainers.Services.Basket.API.IntegrationEvents.EventHandling
{
    public class ProductPriceChangedIntegrationEventHandler :
        IIntegrationEventHandler<ProductPriceChangedIntegrationEvent>
    {
        private readonly IBasketRepository _repository;

        public ProductPriceChangedIntegrationEventHandler(
            IBasketRepository repository)
        {
            _repository = repository;
        }

        public async Task Handle(ProductPriceChangedIntegrationEvent @event)
        {
            var userIds = await _repository.GetUsers();
            foreach (var id in userIds)
            {
                var basket = await _repository.GetBasket(id);
                await UpdatePriceInBasketItems(@event.ProductId, @event.NewPrice, basket);
            }
        }

        private async Task UpdatePriceInBasketItems(int productId, decimal newPrice,
            CustomerBasket basket)
        {
            var itemsToUpdate = basket?.Items?.Where(x => int.Parse(x.ProductId) ==
                productId).ToList();
            if (itemsToUpdate != null)
            {
                foreach (var item in itemsToUpdate)
                {
                    if(item.UnitPrice != newPrice)
                    {
                        var originalPrice = item.UnitPrice;
                        item.UnitPrice = newPrice;
                        item.OldUnitPrice = originalPrice;
                    }
                }
                await _repository.UpdateBasket(basket);
            }
        }
    }
}
```

Обработчик событий должен проверить, существует ли продукт в любом из случаев корзины. Он также обновляет цену для каждого элемента корзины связанные строки. Наконец он создает предупреждение, выдаваемое пользователю об изменении цены, как показано на рисунке 8-24.

![](./media/image25.png)

**Рис. 8-24**. Отображение изменение цены товара в корзину, как взаимодействуют с события интеграции

## <a name="idempotency-in-update-message-events"></a>Идемпотентности в сообщения событий обновления

Важным аспектом событий обновления сообщений является сбой в любой момент при обмене данными должны быть причиной сообщения для повторной попытки. В противном случае в фоновом режиме может попытаться опубликовать событие, которое уже опубликован, создание состояние гонки. Вам необходимо убедитесь в том, чтобы обновления были идемпотентными или что они предоставляют достаточно сведений, чтобы убедиться, что можно определить повторяется, отменить изменения и отправить ответ назад только один.

Как отмечалось ранее, идемпотентности означает, что операция может выполняться несколько раз без изменения результатов. В среде обмена сообщениями Если в качестве при обмене данными события, события идемпотентными несколько раз может быть передан без изменения результатов для микрослужбу получателя. Это необходимо из-за особенностей самого события или из-за способа система обрабатывает событие. Сообщение идемпотентности важен в любое приложение, которое использует обмен сообщениями, а не только в приложения, которые реализуют шаблон шины событий.

Пример операции идемпотентными — инструкция SQL, который вставляет данные в таблицу только в том случае, если эти данные еще не в таблице. Он не имеет значения, сколько раз запускается, вставить инструкцию SQL; результат будет таким же, таблица будет содержать эти данные. Также может быть идемпотентности следующим образом, необходимые при работе с сообщениями, если потенциально отправляться сообщения и поэтому обработанные более одного раза. Для экземпляра Если логику повторных попыток приводит отправителя для отправки точно повторяется более одного раза, необходимо убедитесь в том, что это идемпотентными.

Существует возможность разработки идемпотентными сообщения. Например, можно создать событие, которое говорит» значение цена продукта \$25» вместо «добавить \$5 цену продукта.» Вы может безопасно обработать первое сообщение любое число раз и результат будет таким же. Это не касается второе сообщение. Но даже в первом случае может не потребоваться обработать первое событие, поскольку система также мог быть отправлен более новые события изменения цен и будет перезапись новая цена.

Другим примером может служить событие завершения заказа распространены на несколько подписчиков. Очень важно, что сведения о заказе обновляться в других системах, только один раз, даже при наличии события повторяющихся сообщений для одного события завершения заказа.

Удобно иметь какой-то удостоверение каждого события, чтобы вы могли создавать логику, которая обеспечивает, что каждое событие обрабатывается только один раз на приемник.

Определенные операции по обработке сообщений по своей природе является идемпотентной. Например если система создает эскизы изображений, может не важно, сколько раз сообщение о созданного эскиза обрабатывается; Результатом является создаются эскизы и они одинаковы каждый раз. С другой стороны операции, такие как вызов платежный шлюз взимать плату кредитной карты может оказаться идемпотентными вообще. В этих случаях необходимо обеспечить обработку сообщения несколько раз, предполагается, что эффект.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Учитывая идемпотентности сообщение** (подзаголовок на этой странице) [ *https://msdn.microsoft.com/en-us/library/jj591565.aspx*](https://msdn.microsoft.com/en-us/library/jj591565.aspx)

## <a name="deduplicating-integration-event-messages"></a>Дедупликация интеграции сообщения о событиях

Можно гарантировать, что события сообщений, отправленных и обработано только один раз для подписчика на разных уровнях. Можно использовать функцию дедупликации, предлагаемых инфраструктуры обмена сообщениями, которую вы используете. Другой, чтобы реализовать пользовательскую логику в вашей микрослужбу назначения. Наличие проверки на уровне приложения и уровне транспорта является лучшим решением.

### <a name="deduplicating-message-events-at-the-eventhandler-level"></a>Дедупликация сообщение события на уровне EventHandler

Путем реализации определенных логики, при обработке события в обработчиках событий сообщений — один из способов обеспечить обработку события только один раз с любой приемник. Например, именно этот подход используется в приложении eShopOnContainers, как видно в [исходный код](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.API/Controllers/OrdersController.cs) класса OrdersController при получении команды CreateOrderCommand. (В данном случае мы используем команду запроса HTTP не команду с помощью сообщений, но имеет аналогичную логику, необходимо внести идемпотентными команд на основе сообщений.)

### <a name="deduplicating-messages-when-using-rabbitmq"></a>Дедупликация сообщения при использовании RabbitMQ

При возникновении периодически возникающие сетевые сбои, сообщения могут повторяться и получатель сообщения должен быть готов для обработки этих повторяющихся сообщений. По возможности приемники должен обрабатывать сообщения идемпотентными способом, что лучше, чем явно обрабатывая их при дедупликации.

Согласно [RabbitMQ документации](https://www.rabbitmq.com/reliability.html#consumer), «если сообщение доставлено получателю, а затем повторно поставлен в очередь (поскольку она не была подтверждена, перед удалением подключения потребителя, например), то RabbitMQ будет устанавливать флаг redelivered на он при попытку доставки (ли к одному клиенту или другой).

Если установлен флаг «redelivered», получатель должны учитывать, поскольку сообщения могут уже обработаны. Однако, не гарантируется; сообщение может никогда не достигнут получателя после его оставить брокер обмена сообщениями, возможно из-за сетевых проблем. С другой стороны Если флаг «redelivered» не задано, это гарантирует, что сообщение не было отправлено несколько раз. Таким образом получатель должен для нее сообщения или сообщения процесса способом идемпотентными только в том случае, если флаг «redelivered» устанавливается в сообщении.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Событие обмена сообщениями**
    [*http://soapatterns.org/design\_шаблонов и события\_управляемых\_обмена сообщениями*](http://soapatterns.org/design_patterns/event_driven_messaging)

-   **Джимми Богард (Jimmy Bogard). Рефакторинг по направлению к устойчивости: Оценка взаимозависимости**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)

-   **Публикация-подписка на канал**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)

-   **Взаимодействие между ограниченных контекстах**
    [*https://msdn.microsoft.com/en-us/library/jj591572.aspx*](https://msdn.microsoft.com/en-us/library/jj591572.aspx)

-   **Итоговая согласованность**
    [*https://en.wikipedia.org/wiki/Eventual\_согласованности*](https://en.wikipedia.org/wiki/Eventual_consistency)

-   **Филипп Brown. Стратегии для интеграции ограниченных контекстах**
    [*http://culttt.com/2014/11/26/strategies-integrating-bounded-contexts/*](http://culttt.com/2014/11/26/strategies-integrating-bounded-contexts/)

-   **Крис Ричардсон. Разработка транзакций Микрослужбами с использованием статистических функций, источники событий и CQRS — часть 2**
    [*https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-2-richardson*](https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-2-richardson)

-   **Крис Ричардсон. Использование модели событий**
    [*http://microservices.io/patterns/data/event-sourcing.html*](http://microservices.io/patterns/data/event-sourcing.html)

-   **Знакомство с источники событий**
    [*https://msdn.microsoft.com/en-us/library/jj591559.aspx*](https://msdn.microsoft.com/en-us/library/jj591559.aspx)

-   **База данных хранилища событий**. Официальный сайт
    [*https://geteventstore.com/*](https://geteventstore.com/)

-   **Патрик Nommensen. Управляемые событиями управления данными для Микрослужбами**
    *<https://dzone.com/articles/event-driven-data-management-for-microservices-1>*

-   **Теорема CAP**
    [*https://en.wikipedia.org/wiki/CAP\_Теорема*](https://en.wikipedia.org/wiki/CAP_theorem)

-   **Что такое ограничение Теорема? ** 
     [ *https://www.quora.com/What-Is-CAP-Theorem-1*](https://www.quora.com/What-Is-CAP-Theorem-1)

-   **Основные сведения о согласованности данных**
    [*https://msdn.microsoft.com/en-us/library/dn589800.aspx*](https://msdn.microsoft.com/en-us/library/dn589800.aspx)

-   **Рик Сейлинг. Теорема CAP: Почему «все разные» облако и Интернете**
    [*https://blogs.msdn.microsoft.com/rickatmicrosoft/2013/01/03/the-cap-theorem-why-everything-is-different-with-the-cloud-and-internet/*](https://blogs.msdn.microsoft.com/rickatmicrosoft/2013/01/03/the-cap-theorem-why-everything-is-different-with-the-cloud-and-internet/)

-   **Эрик Brewer. Ограничение Двенадцатилетнего позже: как «Правила» были изменены**
    [*https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed*](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed)

-   **Участие в транзакции (DTC) внешние** (MSMQ) [ *https://msdn.microsoft.com/en-us/library/ms978430.aspx\#bdadotnetasync2\_topic3c*](https://msdn.microsoft.com/en-us/library/ms978430.aspx%23bdadotnetasync2_topic3c)

-   **Шина обслуживания Azure. Обмен сообщениями через посредника: Поиск повторяющихся**
    [*https://code.msdn.microsoft.com/Brokered-Messaging-c0acea25*](https://code.msdn.microsoft.com/Brokered-Messaging-c0acea25)

-   **Руководство по надежности** (RabbitMQ документация) [ *https://www.rabbitmq.com/reliability.html\#потребителя*](https://www.rabbitmq.com/reliability.html%23consumer)




>[!div class="step-by-step"]
[Предыдущие] (rabbitmq-event-bus-development-test-environment.md) [Далее] (test-aspnet-core-services-web-apps.md)
