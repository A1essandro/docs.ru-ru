---
title: "Обзор .NET | Документация Майкрософт"
description: "Обзор некоторых важных функций .NET."
keywords: ".NET, .NET Core, обзор, языки программирования, небезопасный, управление памятью, безопасность типа, асинхронный"
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.translationtype: HT
ms.sourcegitcommit: 2762cdc983465979a530192716c33de7044dd1ed
ms.openlocfilehash: c64a3113cf4e9e9ff203ed2cf449359f67ee9d10
ms.contentlocale: ru-ru
ms.lasthandoff: 08/21/2017

---

# <a name="tour-of-net"></a><span data-ttu-id="1372e-104">Обзор .NET</span><span class="sxs-lookup"><span data-stu-id="1372e-104">Tour of .NET</span></span>

<span data-ttu-id="1372e-105">.NET — это платформа разработки общего назначения.</span><span class="sxs-lookup"><span data-stu-id="1372e-105">.NET is a general purpose development platform.</span></span> <span data-ttu-id="1372e-106">Она включает несколько основных функций (к примеру, поддержку нескольких языков программирования, модели асинхронного и параллельного программирования и взаимодействие на уровне машинного кода), благодаря которым на различных платформах доступно множество разнообразных сценариев.</span><span class="sxs-lookup"><span data-stu-id="1372e-106">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="1372e-107">В этой статье представлен обзор некоторых основных функций .NET.</span><span class="sxs-lookup"><span data-stu-id="1372e-107">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="1372e-108">В разделе об [архитектурных компонентах .NET](components.md) вы сможете узнать о фрагментах архитектуры .NET и их целевом предназначении.</span><span class="sxs-lookup"><span data-stu-id="1372e-108">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="1372e-109">Выполнение примеров кода</span><span class="sxs-lookup"><span data-stu-id="1372e-109">How to run the code samples</span></span>

<span data-ttu-id="1372e-110">Сведения о том, как настроить среду разработки для выполнения примеров кода, представлены в разделе [о начале работы](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-110">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="1372e-111">Можно скопировать примеры кода с этой страницы и вставить их в вашу среду для выполнения.</span><span class="sxs-lookup"><span data-stu-id="1372e-111">Copy and paste code samples from this page into your environment to execute them.</span></span> 

## <a name="programming-languages"></a><span data-ttu-id="1372e-112">Языки программирования</span><span class="sxs-lookup"><span data-stu-id="1372e-112">Programming languages</span></span>

<span data-ttu-id="1372e-113">Архитектура .NET поддерживает различные языки программирования.</span><span class="sxs-lookup"><span data-stu-id="1372e-113">.NET supports multiple programming languages.</span></span> <span data-ttu-id="1372e-114">Реализации .NET реализуют [инфраструктуру CLI (Common Language Infrastructure)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), которая, среди прочего, указывает среду выполнения, не зависящую от языка, а также взаимодействие языков.</span><span class="sxs-lookup"><span data-stu-id="1372e-114">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="1372e-115">Это означает, что для создания приложений и служб на платформе .NET можно выбрать любой язык .NET.</span><span class="sxs-lookup"><span data-stu-id="1372e-115">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="1372e-116">Корпорация Майкрософт активно занимается разработкой и поддержкой трех языков .NET: C#, F# и Visual Basic (VB).</span><span class="sxs-lookup"><span data-stu-id="1372e-116">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic (VB).</span></span> 

* <span data-ttu-id="1372e-117">C# — это простой, эффективный, типобезопасный и объектно-ориентированный язык, сохраняющий выразительность и элегантность, присущие языкам C.</span><span class="sxs-lookup"><span data-stu-id="1372e-117">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="1372e-118">Все, кто знаком с C и схожими языками, могут без проблем перейти на C#.</span><span class="sxs-lookup"><span data-stu-id="1372e-118">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="1372e-119">Чтобы узнать больше о языке C#, ознакомьтесь с [этим руководством](../csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-119">Check out the [C# Guide](../csharp/index.md) to learn more about C#.</span></span>

* <span data-ttu-id="1372e-120">F# — это кроссплатформенный и функционально-императивный язык программирования, который также поддерживает объектно-ориентированное и императивное программирование.</span><span class="sxs-lookup"><span data-stu-id="1372e-120">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="1372e-121">Чтобы узнать больше о языке F#, ознакомьтесь с [этим руководством](../fsharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-121">Check out the [F# Guide](../fsharp/index.md) to learn more about F#.</span></span>

* <span data-ttu-id="1372e-122">Visual Basic — это простой язык, позволяющий научиться разрабатывать разнообразные приложения на .NET.</span><span class="sxs-lookup"><span data-stu-id="1372e-122">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="1372e-123">Среди языков .NET синтаксис VB лучше всего соответствует обычному естественному языку, часто упрощая разработку для новичков.</span><span class="sxs-lookup"><span data-stu-id="1372e-123">Among the .NET languages, the syntax of VB is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="1372e-124">Автоматическое управление памятью</span><span class="sxs-lookup"><span data-stu-id="1372e-124">Automatic memory management</span></span>

<span data-ttu-id="1372e-125">Архитектура .NET использует [сборку мусора](garbagecollection/index.md), чтобы обеспечить автоматическое управление памятью для программ.</span><span class="sxs-lookup"><span data-stu-id="1372e-125">.NET uses [garbage collection (GC)](garbagecollection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="1372e-126">Сборка мусора отражает отложенный подход к управлению памятью, когда пропускная способность приложения предпочитается немедленной сборке памяти.</span><span class="sxs-lookup"><span data-stu-id="1372e-126">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="1372e-127">Чтобы узнать больше о сборке мусора в .NET, см. статью [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md) (Базовые понятия сборки мусора).</span><span class="sxs-lookup"><span data-stu-id="1372e-127">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md).</span></span>

<span data-ttu-id="1372e-128">Обе приведенные ниже строки выделяют память:</span><span class="sxs-lookup"><span data-stu-id="1372e-128">The following two lines both allocate memory:</span></span>

<span data-ttu-id="1372e-129">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]</span><span class="sxs-lookup"><span data-stu-id="1372e-129">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]</span></span>

<span data-ttu-id="1372e-130">Аналогичных ключевых слов для отмены выделения памяти не существует, так как отмена осуществляется автоматически, когда сборщик мусора освобождает память в рамках запланированного выполнения.</span><span class="sxs-lookup"><span data-stu-id="1372e-130">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="1372e-131">Сборщик мусора — это одна из служб, которые помогают обеспечить *безопасность памяти*.</span><span class="sxs-lookup"><span data-stu-id="1372e-131">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="1372e-132">Программа является безопасной по памяти, если она обращается только к выделенной памяти.</span><span class="sxs-lookup"><span data-stu-id="1372e-132">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="1372e-133">Например, среда выполнения гарантирует, что приложение не обращается к невыделенной памяти за пределами границ массива.</span><span class="sxs-lookup"><span data-stu-id="1372e-133">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="1372e-134">В следующем примере среда выполнения порождает исключение `InvalidIndexException` для обеспечения безопасности памяти.</span><span class="sxs-lookup"><span data-stu-id="1372e-134">In the following example, the runtime throws an `InvalidIndexException` exception to enforce memory safety:</span></span>

<span data-ttu-id="1372e-135">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]</span><span class="sxs-lookup"><span data-stu-id="1372e-135">[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]</span></span>

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="1372e-136">Работа с неуправляемыми ресурсами</span><span class="sxs-lookup"><span data-stu-id="1372e-136">Working with unmanaged resources</span></span>

<span data-ttu-id="1372e-137">Некоторые объекты ссылаются на *неуправляемые ресурсы*.</span><span class="sxs-lookup"><span data-stu-id="1372e-137">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="1372e-138">Неуправляемые ресурсы — это ресурсы, которые не обслуживаются средой выполнения .NET автоматически.</span><span class="sxs-lookup"><span data-stu-id="1372e-138">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="1372e-139">Например, к неуправляемым ресурсам относятся дескрипторы файлов.</span><span class="sxs-lookup"><span data-stu-id="1372e-139">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="1372e-140">Объект <xref:System.IO.FileStream> — управляемый, но он ссылается на дескриптор файла, который является неуправляемым ресурсом.</span><span class="sxs-lookup"><span data-stu-id="1372e-140">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="1372e-141">После окончания работы с <xref:System.IO.FileStream> нужно освободить дескриптор файла.</span><span class="sxs-lookup"><span data-stu-id="1372e-141">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="1372e-142">В среде .NET объекты, которые ссылаются на неуправляемые ресурсы, реализуют интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="1372e-142">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="1372e-143">После окончания работы с объектом вызовите метод <xref:System.IDisposable.Dispose> объекта, который отвечает за освобождение неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="1372e-143">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="1372e-144">В языках .NET для таких объектов есть удобный синтаксис `using`, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="1372e-144">.NET languages provide a convenient `using` syntax for such objects, as shown in the following example:</span></span>

<span data-ttu-id="1372e-145">[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]</span><span class="sxs-lookup"><span data-stu-id="1372e-145">[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]</span></span>

<span data-ttu-id="1372e-146">После окончания блока `using` среда выполнения .NET автоматически вызывает метод <xref:System.IDisposable.Dispose> объекта `stream`, который освобождает дескриптор файла.</span><span class="sxs-lookup"><span data-stu-id="1372e-146">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="1372e-147">Среда выполнения также делает это, если управление переходит за пределы блока из-за исключения.</span><span class="sxs-lookup"><span data-stu-id="1372e-147">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="1372e-148">Дополнительные сведения см в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="1372e-148">For more details, see the following topics:</span></span>

* <span data-ttu-id="1372e-149">Для C# — [Оператор using (Справочник по C#)](../csharp/language-reference/keywords/using-statement.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-149">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="1372e-150">Для For F# — [Управление ресурсами: ключевое слово use](../fsharp/language-reference/resource-management-the-use-keyword.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-150">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="1372e-151">Для VB — [Оператор Using (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-151">For VB, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="1372e-152">Безопасность типа</span><span class="sxs-lookup"><span data-stu-id="1372e-152">Type safety</span></span>

<span data-ttu-id="1372e-153">Объект является экземпляром определенного типа.</span><span class="sxs-lookup"><span data-stu-id="1372e-153">An object is an instance of a specific type.</span></span> <span data-ttu-id="1372e-154">Разрешенные операции для заданного объекта определяются его типом.</span><span class="sxs-lookup"><span data-stu-id="1372e-154">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="1372e-155">Тип `Dog` может иметь методы `Jump` и `WagTail`, но не метод `SumTotal`.</span><span class="sxs-lookup"><span data-stu-id="1372e-155">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="1372e-156">Программа вызывает только методы, принадлежащие данному типу.</span><span class="sxs-lookup"><span data-stu-id="1372e-156">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="1372e-157">Все другие вызовы приводят к ошибке во время компиляции или исключению во время выполнения (при использовании динамических функций или `object`).</span><span class="sxs-lookup"><span data-stu-id="1372e-157">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="1372e-158">Языки .NET являются объектно-ориентированными и имеют иерархии базовых и производных классов.</span><span class="sxs-lookup"><span data-stu-id="1372e-158">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="1372e-159">Среда выполнения .NET допускает только те приведения и вызовы объектов, которые соответствуют иерархии объектов.</span><span class="sxs-lookup"><span data-stu-id="1372e-159">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="1372e-160">Помните, что любой тип, определенный в любом языке .NET, является производным от базового типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="1372e-160">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

<span data-ttu-id="1372e-161">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]</span><span class="sxs-lookup"><span data-stu-id="1372e-161">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]</span></span>

<span data-ttu-id="1372e-162">Безопасность типа также используется для принудительной инкапсуляции, обеспечивая точность ключевых слов метода доступа.</span><span class="sxs-lookup"><span data-stu-id="1372e-162">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="1372e-163">Ключевые слова метода доступа являются артефактами, которые управляют доступом к членам определенного типа из другого кода.</span><span class="sxs-lookup"><span data-stu-id="1372e-163">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="1372e-164">Обычно они используются для различных видов данных внутри типа, которые позволяют управлять его поведением.</span><span class="sxs-lookup"><span data-stu-id="1372e-164">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

<span data-ttu-id="1372e-165">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]</span><span class="sxs-lookup"><span data-stu-id="1372e-165">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]</span></span>

<span data-ttu-id="1372e-166">Языки C#, Visual Basic и F# поддерживают *вывод локального типа*.</span><span class="sxs-lookup"><span data-stu-id="1372e-166">C#, VB, and F# support local *type inference*.</span></span> <span data-ttu-id="1372e-167">Определение типа означает, что компилятор выводит тип выражения в левой части из выражения в правой части.</span><span class="sxs-lookup"><span data-stu-id="1372e-167">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="1372e-168">Это не значит, что безопасность типа нарушается или исключается.</span><span class="sxs-lookup"><span data-stu-id="1372e-168">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="1372e-169">Результирующий тип имеет строгий тип со всем, что подразумевается.</span><span class="sxs-lookup"><span data-stu-id="1372e-169">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="1372e-170">В предыдущем примере `dog` и `cat` перезаписываются для представления вывода типа, а оставшаяся часть примера остается без изменений:</span><span class="sxs-lookup"><span data-stu-id="1372e-170">From the previous example, `dog` and `cat` are rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

<span data-ttu-id="1372e-171">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]</span><span class="sxs-lookup"><span data-stu-id="1372e-171">[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]</span></span>

<span data-ttu-id="1372e-172">В языке F# имеется даже больше возможностей вывода для типов, чем локальных выводов для типов методов в языках C# и VB.</span><span class="sxs-lookup"><span data-stu-id="1372e-172">F# has even further type inference capabilities than the method-local type inference found in C# and VB.</span></span> <span data-ttu-id="1372e-173">Для получения дополнительных сведений ознакомьтесь с разделом о [выводе типа](../fsharp/language-reference/type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-173">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="1372e-174">Делегаты и лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="1372e-174">Delegates and lambdas</span></span>

<span data-ttu-id="1372e-175">Делегат представлен сигнатурой метода.</span><span class="sxs-lookup"><span data-stu-id="1372e-175">A delegate is represented by a method signature.</span></span> <span data-ttu-id="1372e-176">Делегату можно назначить любой метод с этой сигнатурой и выполнить при вызове делегата.</span><span class="sxs-lookup"><span data-stu-id="1372e-176">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="1372e-177">Делегаты похожи на указатели функций в C++, но являются типобезопасными.</span><span class="sxs-lookup"><span data-stu-id="1372e-177">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="1372e-178">Они представляют собой разновидность отключенного метода в системе типов CLR.</span><span class="sxs-lookup"><span data-stu-id="1372e-178">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="1372e-179">Обычные методы присоединены к классу и вызываются только напрямую с помощью соглашений о статических вызовах или вызовах экземпляров.</span><span class="sxs-lookup"><span data-stu-id="1372e-179">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="1372e-180">В .NET делегаты обычно используются в обработчиках событий, при определении асинхронных операций и в лямбда-выражениях, которые являются основой LINQ.</span><span class="sxs-lookup"><span data-stu-id="1372e-180">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="1372e-181">Дополнительные сведения см. в разделе [Делегаты и лямбда-выражения](delegates-lambdas.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-181">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="1372e-182">Универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="1372e-182">Generics</span></span>

<span data-ttu-id="1372e-183">Универсальные шаблоны позволяют программисту при разработке своих классов вводить *параметр типа*, который позволяет клиентскому коду (пользователям типа) указать точный тип, используемый вместо параметра типа.</span><span class="sxs-lookup"><span data-stu-id="1372e-183">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="1372e-184">Универсальные шаблоны были добавлены, чтобы помочь программистам реализовывать универсальные структуры данных.</span><span class="sxs-lookup"><span data-stu-id="1372e-184">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="1372e-185">До их появления, чтобы тип `List` был универсальным, он должен был работать с элементами, имеющими тип `object`.</span><span class="sxs-lookup"><span data-stu-id="1372e-185">Before their arrival in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="1372e-186">Это бы вызвало различные проблемы, связанные с производительностью и семантикой, а также неочевидные ошибки во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="1372e-186">This had various performance and semantic problems, along with possible subtle runtime errors.</span></span> <span data-ttu-id="1372e-187">Наиболее печально известным вариантом последних является ситуация, когда структура данных содержит, например, как целые числа, так и строки, и при работе с элементами списка возникает исключение `InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="1372e-187">The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members.</span></span>

<span data-ttu-id="1372e-188">В следующем примере показано выполнение простой программы с использованием экземпляра типов <xref:System.Collections.Generic.List%601>.</span><span class="sxs-lookup"><span data-stu-id="1372e-188">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

<span data-ttu-id="1372e-189">[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]</span><span class="sxs-lookup"><span data-stu-id="1372e-189">[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]</span></span>

<span data-ttu-id="1372e-190">Дополнительные сведения см. в разделе [Обзор универсальных типов (универсальных шаблонов)](generics.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-190">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="1372e-191">Асинхронное программирование</span><span class="sxs-lookup"><span data-stu-id="1372e-191">Async programming</span></span>

<span data-ttu-id="1372e-192">Асинхронное программирование является одной из ключевых концепций на платформе .NET, включающей асинхронную поддержку среды выполнения, библиотек платформы и языковых конструкций .NET.</span><span class="sxs-lookup"><span data-stu-id="1372e-192">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="1372e-193">На внутреннем уровне это основано на объектах (таких как `Task`), которые используют возможности операционной системы для максимально эффективного выполнения заданий ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="1372e-193">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="1372e-194">Дополнительные сведения об асинхронном программировании в .NET см. в разделе [Обзор асинхронной модели](async.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-194">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="1372e-195">Синтаксис LINQ</span><span class="sxs-lookup"><span data-stu-id="1372e-195">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="1372e-196">LINQ — это эффективный набор функций для C# и VB, которые позволяют писать простой и декларативный код для работы с данными.</span><span class="sxs-lookup"><span data-stu-id="1372e-196">LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="1372e-197">Данные могут быть представлены разными формами (например, объектами в памяти, содержимым базы данных SQL или XML-документом), но обычно создаваемый код LINQ не отличается для каждого из источников данных.</span><span class="sxs-lookup"><span data-stu-id="1372e-197">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="1372e-198">Для получения дополнительных сведений и ознакомления с примерами см. раздел [Синтаксис LINQ](using-linq.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-198">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="1372e-199">Взаимодействие на уровне машинного кода</span><span class="sxs-lookup"><span data-stu-id="1372e-199">Native interoperability</span></span>

<span data-ttu-id="1372e-200">Все операционные системы имеют API-интерфейс, предоставляющий системные службы.</span><span class="sxs-lookup"><span data-stu-id="1372e-200">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="1372e-201">.NET предоставляет несколько способов использовать эти API.</span><span class="sxs-lookup"><span data-stu-id="1372e-201">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="1372e-202">Основным способом осуществления такого взаимодействия является вызов неуправляемого кода или сокращенно P/Invoke, который поддерживается на платформах Linux и Windows.</span><span class="sxs-lookup"><span data-stu-id="1372e-202">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="1372e-203">Способ, который подходит только для Windows, называется "COM-взаимодействием" и используется для работы с [COM-компонентами](https://msdn.microsoft.com/library/bwa2bx93.aspx) в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="1372e-203">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code.</span></span> <span data-ttu-id="1372e-204">Он основан на инфраструктуре P/Invoke, но работает иначе.</span><span class="sxs-lookup"><span data-stu-id="1372e-204">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="1372e-205">Основная часть поддержки взаимодействия Mono (и, следовательно, Xamarin) для Java и Objective-C построена аналогичным образом, то есть использует схожие принципы.</span><span class="sxs-lookup"><span data-stu-id="1372e-205">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="1372e-206">Дополнительные сведения о взаимодействии на уровне машинного кода см. в документе [Взаимодействие на уровне машинного кода](native-interop.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-206">Read more about it native interoperability in the [Native interoperability](native-interop.md) topic.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="1372e-207">Небезопасный код</span><span class="sxs-lookup"><span data-stu-id="1372e-207">Unsafe code</span></span>

<span data-ttu-id="1372e-208">В зависимости от языковой поддержки среды CLR позволяет обращаться к внутренней памяти выполнять арифметические операции с указателями в коде `unsafe`.</span><span class="sxs-lookup"><span data-stu-id="1372e-208">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="1372e-209">Эти операции необходимы для реализации определенных алгоритмов и системного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="1372e-209">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="1372e-210">Хотя небезопасный код и предоставляет обширные возможности, использовать его не рекомендуется, если только это не требуется для взаимодействия с системными API или реализации максимально эффективного алгоритма.</span><span class="sxs-lookup"><span data-stu-id="1372e-210">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="1372e-211">Небезопасный код может выполняться по-разному в разных средах, а также терять преимущества сборщика мусора и безопасности типов.</span><span class="sxs-lookup"><span data-stu-id="1372e-211">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="1372e-212">Рекомендуется четко отделить и централизовать небезопасный код, а также тщательно протестировать его.</span><span class="sxs-lookup"><span data-stu-id="1372e-212">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="1372e-213">В следующем примере показана измененная версия метода `ToString()` из класса `StringBuilder`.</span><span class="sxs-lookup"><span data-stu-id="1372e-213">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="1372e-214">Этот пример иллюстрирует, как с помощью кода `unsafe` можно эффективно реализовать алгоритм, перемещая блоки памяти напрямую:</span><span class="sxs-lookup"><span data-stu-id="1372e-214">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

<span data-ttu-id="1372e-215">[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]</span><span class="sxs-lookup"><span data-stu-id="1372e-215">[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]</span></span>

## <a name="next-steps"></a><span data-ttu-id="1372e-216">Следующие шаги</span><span class="sxs-lookup"><span data-stu-id="1372e-216">Next steps</span></span>

<span data-ttu-id="1372e-217">Если вас интересуют возможности языка C#, ознакомьтесь с [соответствующим обзором](../csharp/tour-of-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-217">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="1372e-218">Если вас интересуют возможности языка F#, ознакомьтесь с [соответствующим обзором](../fsharp/tour.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-218">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="1372e-219">Если вы хотите приступить к написанию собственного кода, ознакомьтесь с [руководством по началу работы](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-219">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="1372e-220">Дополнительные сведения о важных [компонентах архитектуры .NET](components.md).</span><span class="sxs-lookup"><span data-stu-id="1372e-220">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>

