---
title: "Учебник по .NET для начинающих"
description: "Учебник по .NET для начинающих"
keywords: .NET, .NET Core
author: richlander
manager: wpickett
ms.date: 10/05/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
translationtype: Human Translation
ms.sourcegitcommit: be774ae1291def36baafffbf2f717cf98565cd60
ms.openlocfilehash: fba870a93784b579da1065a07d82974951ac7e28

---

# <a name="net-primer"></a>Учебник по .NET для начинающих

> Ознакомьтесь с учебниками [Начало работы с .NET Core](../core/getting-started.md), чтобы узнать, как создать простое приложение .NET Core. На создание и запуск первого приложения потребуется буквально несколько минут.

.NET — это платформа разработки общего назначения. Ее можно использовать для любых типов приложений и рабочих нагрузок, где применяются универсальные решения. В ней есть ряд ключевых особенностей, которые высоко ценятся многими разработчиками, включая автоматическое управление памятью и современные языки программирования, которые упрощают эффективное создание высококачественных приложений. .NET предлагает среду высокоуровневого программирования с множеством удобных функций, предоставляя при этом низкоуровневый доступ к API и внутренней памяти.

Существуют различные реализации .NET, основанные на открытых [стандартах .NET](https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/dotnet-standards.md), в которых определяются базовые принципы платформы. Они оптимизированы для отдельных типов приложений (например, классических настольных, мобильных, игровых, облачных) и поддерживают многие процессоры (например, x86/x64, ARM) и операционные системы (например, Windows, Linux, iOS, Android, macOS). Не менее важной частью экосистемы .NET является сообщество открытого исходного кода, где имеется множество реализаций .NET и библиотек, доступных по утвержденным OSI лицензиям.

В документе [Обзор реализаций .NET](../about/products.md) описаны все доступные выпуски платформы .NET, как корпорации Майкрософт, так и других разработчиков.

Этот учебник познакомит вас с некоторыми основными понятиями платформы .NET и поможет найти дополнительные материалы по каждой из рассматриваемых тем. Прочитав его полностью, вы получите достаточно информации, чтобы ориентироваться в основных терминах и концепциях платформы .NET и углублять знания в интересующих вас областях. 

## <a name="a-stroll-through-net"></a>Обзор .NET

Как любая зрелая и полнофункциональная платформа разработки приложений, .NET имеет множество эффективных функций, которые облегчают труд разработчиков и делают процесс написания кода более оптимальным и выразительным. В этом разделе приведены общие сведения о наиболее существенных возможностях и даны ссылки на более подробные материалы. После ознакомления с обзором вы получите достаточно информации для чтения примеров в репозиториях GitHub и другого кода, чтобы понимать, что там происходит.

*   [Языки программирования](#programming-languages)
*   [Автоматическое управление памятью](#automatic-memory-management)
*   [Безопасность типов](#type-safety)
*   [Делегаты и лямбда-выражения](#delegates-and-lambdas)
*   [Универсальные типы (универсальные шаблоны)](#generic-types-generics)
*   [LINQ](#language-integrated-query-linq)
*   [Асинхронное программирование](#async-programming)
*   [Взаимодействие на уровне машинного кода](#native-interoperability)
*   [Небезопасный код](#unsafe-code)

### <a name="programming-languages"></a>Языки программирования

Разработчики могут создавать приложения на любом языке программирования, поддерживающем платформу .NET. Поскольку платформа .NET обеспечивает независимость и взаимодействие языков, вы можете взаимодействовать с другими приложениями и компонентами платформы .NET независимо от языка, с помощью которого они были разработаны.

Языки программирования, позволяющие разрабатывать приложения для платформы .NET, соответствуют [спецификации Common Language Infrastructure (CLI)](https://www.visualstudio.com/en-us/mt639507).

К языкам корпорации Майкрософт, поддерживаемым платформой .NET, относятся C#, F# и Visual Basic. 

* C# — это простой, эффективный, типобезопасный и объектно-ориентированный язык, сохраняющий выразительность и элегантность, присущую языкам C. Все, кто знаком с C и схожими языками, смогут без проблем перейти на C#.

* F# — это кроссплатформенный и функционально-императивный язык программирования, который также поддерживает объектно-ориентированное и императивное программирование.

* Visual Basic — это простой язык, позволяющий научиться разрабатывать разнообразные приложения на платформе .NET.

> [!NOTE]
> В текущем выпуске .NET Core для всех инструментов Майкрософт полностью поддерживается только C#.  F# поддерживается в пакете SDK для .NET Core, но пока не имеет инструментов Visual Studio.  Поддержка Visual Basic для пакета SDK и инструментов Visual Studio запланирована к реализации.

### <a name="automatic-memory-management"></a>Автоматическое управление памятью

Сборка мусора является наиболее известной функцией .NET. Разработчикам не требуется активно управлять памятью, хотя существуют механизмы для предоставления дополнительных сведений сборщику мусора. C# содержит ключевое слово `new` для выделения памяти в отношении определенного типа и ключевое слово `using` для предоставления области использования объекта. Сборщик мусора отражает отложенный подход к управлению памятью, когда пропускная способность приложения предпочитается немедленной сборке памяти.

Обе приведенные ниже строки выделяют память:

```cs
var title = ".NET Primer";
var list = new List<string>;

```

Аналогичных ключевых слов для отмены выделения памяти не существует, так как она осуществляется автоматически, когда сборщик мусора освобождает память в рамках запланированного выполнения.

Переменные метода обычно выходят за пределы области действия после завершения метода, после чего они могут быть собраны. Однако с помощью оператора `using` сборщику мусора можно указать, что определенный объект выходит из области действия еще до завершения метода.

```cs
using(FileStream stream = GetFileStream(context))
{
    //operations on the stream
}

```

После завершения блока `using` сборщик мусора будет знать, что объект `stream` в приведенном выше примере можно собрать для освобождения памяти.

Одной из менее очевидных, но довольно перспективных функций сборщика мусора является безопасность памяти. Инвариантность безопасности памяти очень проста: программа является безопасной с точки зрения памяти, если обращается только к выделенной (и не освобожденной) памяти. Оборванные указатели всегда являются ошибками, и их отслеживание часто затруднено.

Среда выполнения .NET предоставляет дополнительные службы для выполнения обещания по безопасности памяти, чего обычно нет в сборщике мусора. Она гарантирует, что программы не выйдут за пределы массива и не будут обращаться к фантомным полям после окончания объекта.

Следующий пример вызывает исключение в результате безопасности памяти.

```cs
int[] numbers = new int[42];
int number = numbers[42]; // will throw (indexes are 0-based)

```

### <a name="type-safety"></a>Безопасность типа

Объекты выделяются с учетом типов. Разрешенные операции и занимаемая память для заданного объекта определяются его типом. Тип `Dog` может иметь методы `Jump` и `WagTail`, но не метод `SumTotal`. Программа может вызывать только объявленные методы заданного типа. Все другие вызовы приведут к ошибке во время компиляции или исключению во время выполнения (при использовании динамических функций или `object`).

Языки .NET являются объектно-ориентированными и имеют иерархии базовых и производных классов. Среда выполнения .NET допускает только те приведения и вызовы объектов, которые соответствуют иерархии объектов. Помните, что любой тип, определенный в любом языке .NET, является производным от базового типа `object`.

```cs
Dog dog = Dog.AdoptDog(); // Returns a Dog type
Pet pet = (Pet)dog; // Dog derives from Pet
pet.ActCute();
Car car = (Car)dog; // will throw - no relationship between Car and Dog
object temp = (object)dog; // legal - a Dog is an object
car = (Car)temp; // will throw - the runtime isn't fooled
car.Accelerate() // the dog won't like this, nor will the program get this far

```

Безопасность типа также используется для принудительной инкапсуляции, обеспечивая точность ключевых слов метода доступа. Ключевые слова метода доступа являются артефактами, которые управляют доступом к членам определенного типа из другого кода. Обычно они используются для различных видов данных внутри типа, которые позволяют управлять его поведением.

```cs
Dog dog = Dog._nextDogToBeAdopted; // will throw - this is a private field

```

Некоторые языки .NET поддерживают **определение типа**. Определение типа означает, что компилятор выводит тип выражения в левой части из выражения в правой части. Это не значит, что безопасность типа нарушается или исключается. Результирующий тип **имеет** строгий тип со всем, что подразумевается. Давайте перепишем две первые строки в предыдущем примере, чтобы ввести определение типа. Обратите внимание, что остальная часть примера не меняется.

```cs
  var dog = Dog.AdoptDog();
  var pet = (Pet)dog;
  pet.ActCute();
  Car car = (Car)dog; // will throw - no relationship between Car and Dog
  object temp = (object)dog; // legal - a Dog is an object
  car = (Car)temp; // will throw - the runtime isn't fooled
  car.Accelerate() // the dog won't like this, nor will the program get this far

```

### <a name="delegates-and-lambdas"></a>Делегаты и лямбда-выражения

Делегаты похожи на указатели функций в C++, однако имеют значительное отличие — безопасность типа. Они представляют собой разновидность отключенного метода в системе типов CLR. Обычные методы присоединены к классу и вызываются только напрямую с помощью соглашений о статических вызовах или вызовах экземпляров.

Делегаты используются в различных API и компонентах .NET, особенно через лямбда-выражения, которые являются основой LINQ.

Дополнительные сведения см. в документе [Делегаты и лямбда-выражения](delegates-lambdas.md).

### <a name="generic-types-generics"></a>Универсальные типы (универсальные шаблоны)

Универсальные типы, которые также называют "универсальными шаблонами", были добавлены в .NET Framework 2.0. Проще говоря, универсальные шаблоны позволяют программисту при разработке своих классов ввести "параметр типа", который позволит клиентскому коду (пользователям типа) указать точный тип, используемый вместо параметра типа.

Универсальные шаблоны были добавлены, чтобы помочь программистам реализовывать универсальные структуры данных. До их появления, чтобы тип _List_ был универсальным, он должен был работать с элементами, имеющими тип _object_. Это бы вызвало различные проблемы, связанные с производительностью и семантикой, а также неочевидные ошибки во время выполнения. Наиболее печально известным вариантом последних является ситуация, когда структура данных содержит, например, как целые числа, так и строки, и при работе с элементами списка возникает _InvalidCastException_.

В следующем примере показано выполнение простой программы с использованием экземпляра типов @System.Collections.Generic.List%601.

```cs
using System;
using System.Collections.Generic;

namespace GenericsSampleShort {
    public static void Main(string[] args){
        // List<string> is the client way of specifying the actual type for the type parameter T
        List<string> listOfStrings = new List<string> { "First", "Second", "Third" };

        // listOfStrings can accept only strings, both on read and write.
        listOfStrings.Add("Fourth");

        // Below will throw a compile-time error, since the type parameter
        // specifies this list as containing only strings.
        listOfStrings.Add(1);

    }
}

```

Дополнительные сведения см. в разделе [Обзор универсальных типов (универсальных шаблонов)](generics.md).

### <a name="async-programming"></a>Асинхронное программирование

Асинхронное программирование является одной из ключевых концепций на платформе .NET, включающей асинхронную поддержку среды выполнения, библиотек платформы и языковых конструкций .NET. На внутреннем уровне это основано на объектах (таких как `Task`), которые используют возможности операционной системы для максимально эффективного выполнения заданий ввода-вывода.

Дополнительные сведения об асинхронном программировании в .NET см. в разделе [Обзор асинхронной модели](async.md).

### <a name="language-integrated-query-linq"></a>Синтаксис LINQ

LINQ — это эффективный набор функций для C# и VB, которые позволяют писать простой и декларативный код для работы с данными. Данные могут быть представлены разными формами (например, объектами в памяти, содержимым базы данных SQL или XML-документом), но обычно создаваемый код LINQ не отличается для каждого из источников данных.

Для получения дополнительных сведений и ознакомления с примерами см. раздел [Синтаксис LINQ](using-linq.md).

### <a name="native-interoperability"></a>Взаимодействие на уровне машинного кода

Все используемые в настоящее время операционные системы предоставляют значительную платформенную поддержку для различных задач программирования. .NET предоставляет несколько способов использовать эти API. В совокупности такая поддержка называется "взаимодействием на уровне машинного кода". В этом разделе мы рассмотрим, как обратиться к собственным API из управляемого кода .NET.

Основным способом осуществления такого взаимодействия является вызов неуправляемого кода или сокращенно P/Invoke. Такая поддержка в .NET Core доступна на платформах Windows и Linux. Другой способ, который подходит только для Windows, называется "COM-взаимодействием" и используется для работы с [COM-компонентами](https://msdn.microsoft.com/library/bwa2bx93.aspx) в управляемом коде. Он основан на инфраструктуре P/Invoke, но работает иначе.

Основная часть поддержки взаимодействия Mono (и, следовательно, Xamarin) для Java и Objective-C построена аналогичным образом, то есть использует схожие принципы.

Дополнительные сведения см. в документе [Взаимодействие на уровне машинного кода](native-interop.md).

### <a name="unsafe-code"></a>Небезопасный код

Среда CLR позволяет обращаться к внутренней памяти и выполнять арифметические операции с указателями в коде `unsafe`. Эти операции необходимы для реализации определенных алгоритмов и системного взаимодействия. Хотя небезопасный код и предоставляет обширные возможности, использовать его не рекомендуется, если только это не требуется для взаимодействия с системными API или реализации максимально эффективного алгоритма. Небезопасный код может выполняться по-разному в разных средах, а также теряет преимущества сборщика мусора и безопасности типов. Рекомендуется четко отделить и централизовать небезопасный код, а также тщательно протестировать его.

Метод `ToString()` из [класса StringBuilder](https://github.com/dotnet/coreclr/blob/master/src/mscorlib/src/System/Text/StringBuilder.cs#L327) иллюстрирует, как с помощью кода `unsafe` можно эффективно реализовать алгоритм, перемещая блоки памяти напрямую:

```cs
public override String ToString() {
          Contract.Ensures(Contract.Result<String>() != null);

          VerifyClassInvariant();

          if (Length == 0)
              return String.Empty;

          string ret = string.FastAllocateString(Length);
          StringBuilder chunk = this;
          unsafe {
              fixed (char* destinationPtr = ret)
              {
                  do
                  {
                      if (chunk.m_ChunkLength > 0)
                      {
                          // Copy these into local variables so that they are stable even in the presence of ----s (hackers might do this)
                          char[] sourceArray = chunk.m_ChunkChars;
                          int chunkOffset = chunk.m_ChunkOffset;
                          int chunkLength = chunk.m_ChunkLength;

                          // Check that we will not overrun our boundaries.
                          if ((uint)(chunkLength + chunkOffset) <= ret.Length && (uint)chunkLength <= (uint)sourceArray.Length)
                          {
                              fixed (char* sourcePtr = sourceArray)
                                  string.wstrcpy(destinationPtr + chunkOffset, sourcePtr, chunkLength);
                          }
                          else
                          {
                              throw new ArgumentOutOfRangeException("chunkLength", Environment.GetResourceString("ArgumentOutOfRange_Index"));
                          }
                      }
                      chunk = chunk.m_ChunkPrevious;
                  } while (chunk != null);
              }
          }
          return ret;
      }

```

## <a name="notes"></a>Примечания

Используемый в документе термин "среда выполнения .NET" включает в себя несколько разных реализаций .NET, таких как CLR, Mono, IL2CPP и другие. Конкретные названия указываются только по мере необходимости.

Этот документ не предназначен для обзора истории продукта, а описывает платформу .NET в том виде, который она имеет сейчас. Значение имеет не то, был ли компонент .NET доступен с самого начала или появился лишь недавно, а то, насколько этот компонент важен и заслуживает рассмотрения.



<!--HONumber=Nov16_HO1-->


