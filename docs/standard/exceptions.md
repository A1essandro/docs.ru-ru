---
title: "Обработка и создание исключений в .NET"
description: "Общие сведения об использовании исключений в .NET"
keywords: .NET, .NET Core
author: mairaw
ms.author: mairaw
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bf116df6-0042-46bf-be13-b69864816210
translationtype: Human Translation
ms.sourcegitcommit: 9584699ad7e745ae3cb059b1bb8327301c9a3286
ms.openlocfilehash: 5271b63a47aa2fcc81cd9c8b1ffd22e618829412

---

# <a name="handling-and-throwing-exceptions-in-net"></a>Обработка и создание исключений в .NET

Необходимо реализовать возможность единообразной обработки приложениями ошибок, происходящих во время выполнения. Среда .NET предоставляет модель для единообразного уведомления приложений об ошибках: операции .NET информируют о сбое посредством выдачи исключений.

## <a name="exceptions"></a>Исключения

Исключение — это любое состояние ошибки или непредвиденное поведение, возникающее при выполнении программы. Исключения могут возникать из-за сбоя в вашем или вызываемом коде (например, в общей библиотеке), недоступности ресурсов ОС, неожиданных состояний, возникающих в среде выполнения (например, код, который невозможно проверить), и так далее. После некоторых из этих состояний приложение может восстановиться, после других — нет. Несмотря на то что можно выполнить восстановление после большинства исключений приложения, выполнить восстановление после большинства исключений среды выполнения невозможно.

В .NET исключение — это объект, наследуемый от класса [System.Exception](xref:System.Exception). Исключение создается из области кода, где произошла проблема. Исключение передается вверх по стеку до тех пор, пока его не обработает приложение либо программа не завершится.

## <a name="exceptions-vs-traditional-error-handling-methods"></a>Сравнение исключений и традиционных методов обработки ошибок

Традиционно модели обработки ошибок разных языков программирования основываются либо на уникальном для языка способе обнаружения ошибок и отыскании для них обработчиков, либо на механизме обработки ошибок, предоставляемом операционной системой. Способ обработки исключений, реализуемый в .NET, обладает следующими преимуществами:

- Создание и обработка исключений работают одинаково для языков программирования .NET.

- Не требует определенного синтаксиса языка для обработки исключений, а позволяет каждому языку определить свой собственный синтаксис.

- Исключения можно создавать между разными процессами и даже компьютерами.

- В приложение можно добавить код обработки исключений для повышения надежности программы.

Исключения обеспечивают ряд преимуществ по сравнению с другими методами уведомления об ошибках, например кодами возврата. Сбои не остаются незамеченными, так как при наличии необработанного исключения среда выполнения завершает работу приложения. Недопустимые значения не распространяются по системе из-за того, что код не способен выполнить проверку кода возврата ошибки. 

## <a name="exception-class-and-properties"></a>Класс и свойства исключений

@System.Exception — это базовый класс, от которого наследуются исключения. Например, иерархия класса @System.InvalidCastException имеет следующий вид:

```
Object
  Exception
    SystemException
       InvalidCastException
```

Класс @System.Exception имеет следующие свойства, которые облегчают анализ исключения.

| Имя свойства | Описание |
| ------------- | ----------- |
| @System.Exception.Data | Свойство @System.Collections.IDictionary, которое содержит произвольные данные в парах "ключ–значение". |
| @System.Exception.HelpLink | Может содержать URL-адрес (или URN) файла справки, который предоставляет подробные сведения о причине возникновения исключения. |
| @System.Exception.InnerException | Это свойство может использоваться для создания и сохранения последовательностей исключений во время обработки исключений. Его можно использовать для создания нового исключения, содержащего ранее перехваченные исключения. Исходное исключение может быть перехвачено вторым исключением в свойстве @System.Exception.InnerException, что позволяет коду, обрабатывающему второе исключение, проверить дополнительные данные. Например, предположим, что у вас есть метод, который принимает аргумент в неправильном формате.  Код пытается считать аргумент, но создается исключение. Метод перехватывает исключение и порождает исключение @System.FormatException.. Чтобы расширить возможности вызывающего объекта для определения причины исключения, иногда желательно, чтобы метод перехватывал исключение, порожденное вспомогательной процедурой, а затем порождал исключение, содержащее больше сведений о возникшей ошибке. Можно создать новое и более информативное исключение, где ссылка на внутреннее исключение может указывать на исходное исключение. Затем это более информативное исключение может выдаваться вызывающему объекту. Обратите внимание, что с помощью данной функции можно создать последовательность связанных исключений, которая завершается первым выданным исключением. |
| @System.Exception.Message | Предоставляет сведения о причине возникновения исключения.
| @System.Exception.Source | Возвращает или задает имя приложения или объекта, вызывавшего ошибку. |
| @System.Exception.StackTrace | Содержит трассировку стека, которую можно использовать для определения места возникновения ошибки. Эта трассировка стека содержит имя исходного файла и, при наличии отладочной информации, номер программной строки. |

В большинстве классов, унаследованных от @System.Exception, не реализуются дополнительные элементы и не предоставляются дополнительные функции; они просто наследуются от @System.Exception.. Таким образом, наиболее важные сведения для исключения можно найти в иерархии классов исключений, имени исключения и информации, содержащейся в самом исключении.

Рекомендуется создавать и перехватывать только те объекты, которые являются производными от @System.Exception,, но в качестве исключения можно породить любой объект, производный от класса @System.Object. Обратите внимание, что не все языки поддерживают создание и перехват объектов, не являющихся производными от @System.Exception..

## <a name="common-exceptions"></a>Общие исключения

В следующей таблице перечислены некоторые общие исключения с примерами возможных причин.

| Тип исключения | Базовый тип | Описание | Пример |
| -------------- | --------- | ----------- | ------- |
| @System.Exception | @System.Object | Базовый класс для всех исключений. | Отсутствует (используйте производный класс этого исключения). |
| @System.IndexOutOfRangeException | @System.Exception | Вызывается средой выполнения только при неправильной индексации массива. | Индексирование массива вне допустимого диапазона: `arr[arr.Length+1]` |
| @System.NullReferenceException | @System.Exception | Вызывается средой выполнения только в том случае, если имеется ссылка на пустой объект. | `object o = null; o.ToString();` |
| @System.InvalidOperationException | @System.Exception | Вызывается методами в недопустимом состоянии. | Вызов `Enumerator.GetNext()` после удаления элемента из базовой коллекции. |
| @System.ArgumentException | @System.Exception | Базовый класс для всех исключений аргументов. | Отсутствует (используйте производный класс этого исключения). |
| @System.ArgumentNullException | @System.Exception | Вызывается методами, которые не допускают пустой аргумент. | `String s = null; "Calculate".IndexOf (s);` |
| @System.ArgumentOutOfRangeException | @System.Exception | Вызывается методами, проверяющими попадание аргументов в заданный диапазон. | `String s = "string"; s.Substring(s.Length+1);` |

## <a name="how-to-use-the-trycatch-block-to-catch-exceptions"></a>Использование блока try/catch для перехвата исключений

Поместите фрагмент кода, который может выдавать исключения, в `try` блок, а код, который обрабатывает исключения, — в блок `catch`. Блок `catch` — это последовательность операторов, начинающаяся с ключевого слова `catch`, за которым следует тип исключения и требуемое действие.

В следующем примере кода блок `try`/`catch` используется для перехвата возможного исключения. Метод `Main` содержит блок `try` с оператором @System.IO.StreamReader, который открывает файл данных `data.txt` и записывает строку из этого файла. Следующий блок `try` — это блок `catch`, который перехватывает все исключения, поступающие из блока `try`.

C#
```
using System;
using System.IO;

public class ProcessFile
{
    public static void Main()
    {
        try
        {
            StreamReader sr = File.OpenText("data.txt");
            Console.WriteLine("The first line of this file is {0}", sr.ReadLine());
            sr.Dispose();
        }
        catch (Exception e)
        {
            Console.WriteLine("An error occurred: '{0}'", e);
        }
    }
}
```

Среда CLR перехватывает исключения, которые не перехватываются блоком catch. В зависимости от настроек среды выполнения появляется диалоговое окно отладки, работа программы завершается и отображается диалоговое окно со сведениями об исключении либо ошибка выводится в STDERR.

> [!NOTE] 
> Практически любая строка кода может вызвать исключение (в частности, исключения могут выдаваться самой общеязыковой средой выполнения, такой как @System.OutOfMemoryException.). Большинству приложений не требуется обрабатывать эти исключения, но вы должны помнить об этом при написании библиотек, предназначенных для других пользователей. Рекомендации о том, когда следует помещать код в блок Try, см. в разделе о [лучших методиках обработки исключений](#best-practices-for-exceptions).
 
## <a name="how-to-use-specific-exceptions-in-a-catch-block"></a>Использование определенных исключений в блоке Catch

В предыдущем примере кода показан базовый оператор `catch`, перехватывающий все исключения. В общем случае вместо использования базового оператора `catch` рекомендуется перехватывать исключения определенного типа.

При возникновении исключения оно передается вверх по стеку, и каждый блок catch получает возможность обработать его. Важен порядок операторов catch. Размещайте блоки catch, предназначенные для определенных исключений, до общего блока перехвата исключений. В противном случае компилятор может выдать ошибку. Соответствующий блок catch определяется путем соотнесения типа исключения с именем исключения, указанным в блоке catch. Когда специальный блок catch отсутствует, исключение перехватывается общим блоком catch, если он существует.

В следующем примере кода используется блок `try`/`catch` для перехвата @System.InvalidCastException.. В примере создается класс `Employee` с единственным свойством — уровнем сотрудника (`Emlevel`). Метод `PromoteEmployee` принимает объект и повышает уровень сотрудника. Исключение @System.InvalidCastException возникает, когда в метод `PromoteEmployee` передается экземпляр @System.DateTime.

В#
```
using System;

public class Employee
{
    //Create employee level property.
    public int Emlevel
    {
        get
        {
            return(emlevel);
        }
        set
        {
            emlevel = value;
        }
    }

    private int emlevel = 0;
}

public class Ex13
{
    public static void PromoteEmployee(Object emp)
    {
        //Cast object to Employee.
        Employee e = (Employee) emp;
        // Increment employee level.
        e.Emlevel = e.Emlevel + 1;
    }

    public static void Main()
    {
        try
        {
            Object o = new Employee();
            DateTime newyears = new DateTime(2001, 1, 1);
            //Promote the new employee.
            PromoteEmployee(o);
            //Promote DateTime; results in InvalidCastException as newyears is not an employee instance.
            PromoteEmployee(newyears);
        }
        catch (InvalidCastException e)
        {
            Console.WriteLine("Error passing data to PromoteEmployee method. " + e.Message);
        }
    }
}
```

## <a name="how-to-use-finally-blocks"></a>Использование блоков finally

При возникновении исключения выполнение останавливается, и управление передается соответствующему обработчику исключений. Часто это означает, что ожидаемые вами строки кода пропускаются. Даже при возникновении исключения требуется определенная очистка ресурсов, например закрытие файла. Для этого можно использовать блок `finally`. Блок `finally` выполняются всегда, независимо от того, возникает ли исключение.

В следующем примере кода используется блок `try`/`catch` для перехвата @System.ArgumentOutOfRangeException.. Метод `Main` использует два массива и пытается скопировать один массив в другой. Это действие создает исключение @System.ArgumentOutOfRangeException, и ошибка выводится на консоль. Блок `finally` выполняется вне зависимости от результата операции копирования.

C#
```
using System;

class ArgumentOutOfRangeExample
{
    public static void Main()
    {
        int[] array1 = {0, 0};
        int[] array2 = {0, 0};

        try
        {
            Array.Copy(array1, array2, -1);
        }
        catch (ArgumentOutOfRangeException e)
        {
            Console.WriteLine("Error: {0}", e);
        }
        finally
        {
            Console.WriteLine("This statement is always executed.");
        }
    }
}
```

## <a name="how-to-explicitly-throw-exceptions"></a>Явное создание исключений

Исключение можно вызвать явным образом с помощью оператора `throw`. Перехваченное исключение можно вызвать повторно с помощью оператора `throw`. При написании кода рекомендуется добавлять сведения в исключение, которое выдается повторно, чтобы предоставить дополнительную информацию при отладке.

В следующем примере кода используется блок `try`/`catch` для перехвата возможного исключения @System.IO.FileNotFoundException.. После блока `try` находится блок `catch`, который перехватывает @System.IO.FileNotFoundException и выводит сообщение на консоль, если файл данных не найден. Следующий оператор `throw` создает новое исключение @System.IO.FileNotFoundException и добавляет в него текстовую информацию.

В#
```
using System;
using System.IO;

public class ProcessFile
{
   public static void Main()
      {
      FileStream fs = null;
      try   
      {
         //Opens a text tile.
         fs = new FileStream(@"C:\temp\data.txt", FileMode.Open);
         StreamReader sr = new StreamReader(fs);
         string line;

         //A value is read from the file and output to the console.
         line = sr.ReadLine();
         Console.WriteLine(line);
      }
      catch(FileNotFoundException e)
      {
         Console.WriteLine("[Data File Missing] {0}", e);
         throw new FileNotFoundException(@"[data.txt not in c:\temp directory]",e);
      }
      finally
      {
         if (fs != null)
            fs.Dispose();
      }
   }
}
```

## <a name="how-to-create-user-defined-exceptions"></a>Создание пользовательских исключений

Платформа .NET предоставляет иерархию классов исключений, производных от базового класса @System.Exception. Тем не менее, если ни одно из стандартных исключений не подходит, можно создать собственные классы исключений путем наследования от класса @System.Exception.

При создании собственных исключений заканчивайте имя класса пользовательского исключения словом "Exception" и реализовывайте три общих конструктора, как показано в следующем примере. В примере определяется новый класс исключений `EmployeeListNotFoundException`. Этот класс является производным от @System.Exception и включает три конструктора.

В#
```
using System;

public class EmployeeListNotFoundException: Exception
{
    public EmployeeListNotFoundException()
    {
    }

    public EmployeeListNotFoundException(string message)
        : base(message)
    {
    }

    public EmployeeListNotFoundException(string message, Exception inner)
        : base(message, inner)
    {
    }
}
```

> [!NOTE]
> В ситуациях, когда используется удаленное взаимодействие, необходимо убедиться, что метаданные для пользовательского исключения доступны на сервере (вызываемый объект) и для клиента (прокси-объект или вызывающий объект). Дополнительные сведения см. в разделе [Лучшие методики обработки исключений](#best-practices-for-exceptions).

## <a name="best-practices-for-exceptions"></a>Лучшие методики обработки исключений

Хорошо спроектированное приложение обрабатывает исключения и ошибки, чтобы предотвратить сбои приложения. В этом разделе описываются рекомендации по обработке и созданию исключений.

### <a name="use-trycatchfinally-blocks"></a>Использование блоков try/catch/finally

Используйте блоки `try`/`catch`/`finally` для выделения кода, который может стать источником исключения. 

В блоках `catch` следует всегда упорядочивать исключения от более конкретных к более общим.

Используйте блок `finally` для очистки ресурсов с учетом возможности восстановления.

### <a name="handle-common-conditions-without-throwing-exceptions"></a>Обработка общих условий без выдачи исключений

Для условий, которые могут возникнуть, но способны вызвать исключение, рекомендуется реализовать обработку таким способом, который позволит избежать исключения. Например, при попытке закрыть уже закрытое подключение возникает `InvalidOperationException`. Этого можно избежать, используя оператор `if` для проверки состояния подключения перед попыткой закрыть его.

C#
```
if (conn.State != ConnectionState.Closed)
{
    conn.Close();
}
```

Если состояние подключения перед закрытием не проверяется, исключение `InvalidOperationException` можно перехватить.

C#
```
try
{
    conn.Close();
}
catch (InvalidOperationException ex)
{
    Console.WriteLine(ex.GetType().FullName);
    Console.WriteLine(ex.Message);
}
```

Выбор конкретного способа зависит от того, насколько часто ожидается возникновение данного события.

- Используйте обработку исключений, если событие не происходит очень часто, то есть если событие носит действительно исключительный характер и указывает на ошибку (например, в случае неожиданного конца файла). При использовании обработки исключений в обычных условиях выполняется меньше кода.

- Если событие происходит регулярно в рамках нормальной работы программы, выполняйте проверку на наличие ошибок прямо в коде. Проверка на наличие распространенных условий ошибки позволяет выполнять меньший объем кода благодаря устранению исключений.

### <a name="design-classes-so-that-exceptions-can-be-avoided"></a>Устранение исключений при разработке классов

Класс может предоставлять методы и свойства, позволяющие избежать вызова, способного выдать исключение. Например, класс @System.IO.FileStream содержит методы, позволяющие определить, достигнут ли конец файла. Это позволяет избежать появления исключения, создаваемого в случае выполнения чтения после окончания файла. В следующем примере показан способ чтения до конца файла без выдачи исключения.

C#
```
class FileRead
{
    public void ReadAll(FileStream fileToRead)
    {
        // This if statement is optional
        // as it is very unlikely that
        // the stream would ever be null.
        if (fileToRead == null)
        {
            throw new System.ArgumentNullException();
        }

        int b;

        // Set the stream position to the beginning of the file.
        fileToRead.Seek(0, SeekOrigin.Begin);

        // Read each byte to the end of the file.
        for (int i = 0; i < fileToRead.Length; i++)
        {
            b = fileToRead.ReadByte();
            Console.Write(b.ToString());
            // Or do something else with the byte.
        }
    }
}
```

Другой способ устранения исключений заключается в том, что для наиболее общих и часто встречающихся ошибок следует возвращать значение NULL. Такие ошибки могут относиться к обычному потоку управления. Возвращая значение null в таких случаях, можно сократить влияние на производительность приложения.

### <a name="throw-exceptions-instead-of-returning-an-error-code"></a>Выдача исключений вместо возврата кода ошибки

Исключения гарантируют, что сбои не останутся незамеченными из-за того, что вызывающий код не проверил код возврата. 

### <a name="use-the-predefined-net-exception-types"></a>Использование предопределенных типов исключений .NET

Создавайте новый класс исключений, только если предопределенное исключение не подходит. Например:

- Вызывайте исключение @System.InvalidOperationException, если значение свойства или вызов метода не соответствуют текущему состоянию объекта.

- Порождайте исключение @System.ArgumentException или одного из предварительно определенных классов, которые являются производными от @System.ArgumentException, если передаются недопустимые параметры.

### <a name="end-exception-class-names-with-the-word-exception"></a>Завершайте имена классов исключений словом `Exception`

Если требуется пользовательское исключение, присвойте ему соответствующее имя и сделайте его производным от класса @System.Exception. Например:

C#
```
public class MyFileNotFoundException : Exception
{
}
```

### <a name="include-three-constructors-in-custom-exception-classes"></a>Включение трех конструкторов в пользовательские классы исключений

При создании собственных классов исключений можно использовать по меньшей мере три общих конструктора: конструктор по умолчанию, конструктор, принимающий строковое сообщение, и конструктор, принимающий строковое сообщение и внутреннее исключение.

- @System.Exception.%23ctor,, использующий значения по умолчанию.

- @System.Exception.%23ctor(System.String),, принимающий строковое сообщение.

- @System.Exception.%23ctor(System.String,System.Exception),, принимающий строковое сообщение и внутреннее исключение.

Пример см. в разделе [Практическое руководство. Создание пользовательских исключений](#how-to-create-user-defined-exceptions).

### <a name="ensure-that-exception-data-is-available-when-code-executes-remotely"></a>Обеспечение доступности данных об исключении при удаленном выполнении кода

При создании пользовательских исключений следует обеспечить доступность метаданных исключений для удаленно исполняемого кода. 

Например, для сред выполнения .NET, реализующих домены приложений, исключения могут возникать между доменами приложений. Предположим, что домен приложения А создает домен приложения В, который выполняет код, вызывающий исключение. Чтобы домен приложения A правильно перехватил и обработал исключение, он должен найти сборку, которая содержит исключение, порожденное доменом приложения B. Если домен приложения B порождает исключение, содержащееся в сборке в его базовой папке приложения, но не в базовой папке приложения домена A, то домен приложения A не сможет найти исключение и среда CLR породит исключение @System.IO.FileNotFoundException. Чтобы избежать такой ситуации, можно развернуть сборку, содержащую сведения об исключении, двумя способами:

- Поместите эту сборку в общую базу приложения, совместно используемую обоими доменами приложений.

    \- или -

- Если у этих доменов нет общей базы приложения, то подпишите сборку, содержащую сведения об исключении, строгим именем и разверните ее в глобальном кэше сборок.

### <a name="include-a-localized-description-string-in-every-exception"></a>Включение локализованной строки описания в каждое исключение

Сообщение об ошибке, показываемое пользователю, извлекается из строки описания созданного исключения, а не из имени класса исключения.

### <a name="use-grammatically-correct-error-messages"></a>Использование грамматически правильных сообщений об ошибке

Составляйте понятные предложения, указывая в конце знаки препинания. Каждое предложение в строке описания должно заканчиваться точкой. Например, "Таблица журнала переполнена." будет подходящей строкой описания.

### <a name="in-custom-exceptions-provide-additional-properties-as-needed"></a>Предоставление дополнительных свойств в пользовательских исключениях по мере необходимости

Дополнительные сведения (кроме строки описания) включайте в исключение только в тех случаях, когда в соответствии со сценарием программирования такие дополнительные сведения могут оказаться полезными. Например, исключение @System.IO.FileNotFoundException предоставляет свойство @System.IO.FileNotFoundException.FileName.

### <a name="place-throw-statements-so-that-the-stack-trace-will-be-helpful"></a>Размещение операторов throw для удобной трассировки стека

Трассировка стека начинается в операторе, породившем исключение, и завершается оператором `catch`, перехватывающим это исключение.

### <a name="use-exception-builder-methods"></a>Использование методов построителя исключений

Обычно класс генерирует одно и то же исключение из различных мест своей реализации. Чтобы избежать повторения кода, используйте вспомогательные методы, создающие исключение и затем возвращающие его. Пример:

C#
```
class FileReader
{
    private string fileName;

    public FileReader(string path)
    {
        fileName = path;
    }

    public byte[] Read(int bytes)
    {
        byte[] results = FileUtils.ReadFromFile(fileName, bytes);
        if (results == null)
        {
            throw NewFileIOException();
        }
        return results;
    }

    FileReaderException NewFileIOException()
    {
        string description = "My NewFileIOException Description";

        return new FileReaderException(description);
    }
}

```

В некоторых случаях для создания исключения лучше воспользоваться конструктором исключений. В качестве примера можно привести класс глобальных исключений, например @System.ArgumentException,. 

### <a name="clean-up-intermediate-results-when-throwing-an-exception"></a>Очистка промежуточных результатов при выдаче исключения

Вызывающие объекты должны предполагать, что при создании исключения из метода не возникают побочные эффекты. Например, если у вас есть код, который передает деньги, списывая их с одного счета и внося на другой, и при начислении средств возникает исключение, списание средств применяться не должно.

C#
```
public void TransferFunds(Account from, Account to, decimal amount)
{
    from.Withdrawal(amount);
    // If the deposit fails, the withdrawal shouldn't remain in effect. 
    to.Deposit(amount);
}
```

Один из способов обработки в этой ситуации заключается в перехвате всех исключений, выданных транзакцией начисления средств, и откате транзакции списания средств.

В#
```
private static void TransferFunds(Account from, Account to, decimal amount)
{
    string withdrawalTrxID = from.Withdrawal(amount);
    try
    {
        to.Deposit(amount);
    }
    catch
    {
        from.RollbackTransaction(withdrawalTrxID);
        throw
    }
}
```

В этом примере показано использование `throw` для повторного порождения исходного исключения. Это позволяет вызывающим объектам проще установить фактическую причину проблемы, не обращаясь к свойству @System.Exception.InnerException. Альтернативным способом является выдача нового исключения с включением исходного исключения в качестве внутреннего:

C#
```
catch (Exception ex)
{
    from.RollbackTransaction(withdrawalTrxID);
    throw new Exception("Withdrawal failed", ex);
}
```

## <a name="see-also"></a>См. также

Дополнительные сведения о работе исключений в .NET см. в разделе [Что должен знать любой разработчик об исключениях в среде выполнения](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md).



<!--HONumber=Nov16_HO3-->


