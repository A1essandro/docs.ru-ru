---
title: "Разработка свойств | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "рекомендации по разработке членов, свойства"
  - "свойства [платформа .NET Framework] рекомендации по проектированию"
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
caps.latest.revision: 12
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 12
---
# Разработка свойств
Несмотря на то, что свойства технически очень похожи на методы, они существенно отличаются в терминах сценарии их использования. Они должны рассматриваться как смарт\-поля. Они имеют синтаксис вызова полей и гибкости методов.  
  
 **✓ сделать** создать свойства только для чтения, если вызывающий объект не следует изменить значение свойства.  
  
 Следует помнить, что если тип свойства является изменяемым ссылочным типом, можно изменить значение свойства, даже если свойство доступно только для чтения.  
  
 **X не** предоставить метод задания с более широкой доступностью, чем метод считывания свойства или свойств только для набора.  
  
 Например не используйте свойства с общедоступным методом задания и защищенный метод считывания.  
  
 Если метод считывания свойства не может быть предоставлено, следует Реализуйте функцию как метод. Начните имя метода с `Set` а после то, что вам будет имя свойства. Например <xref:System.AppDomain> содержит метод с именем `SetCachePath` вместо свойство только для набора с именем `CachePath`.  
  
 **✓ сделать** предоставить значения по умолчанию для всех свойств, убедившись, что значения по умолчанию не приводят к брешь в системе безопасности или очень неэффективный код.  
  
 **✓ сделать** разрешить свойства, чтобы задать в любом порядке, даже если это приводит к временной недопустимое состояние объекта.  
  
 Чаще всего два или несколько свойств быть взаимосвязанных до точки, где некоторые значения одного из свойств могут быть недопустимыми данных значений других свойств на тот же объект. В таких случаях исключения, возникающие в недопустимом состоянии должны быть отложены до взаимосвязанных свойства фактически используются совместно с объектом.  
  
 **✓ сделать** сохранения предыдущего значения, если установщик свойства вызывает исключение.  
  
 **ИЗБЕЖАТЬ X** создание исключений из получателей значений свойств.  
  
 Получатели значений свойств должны быть простыми операциями и не должны иметь каких\-либо условий. Если получения может создавать исключения, он, вероятно, должны быть переработаны методом. Обратите внимание, что это правило не применяется для индексаторов, где ожидается, что исключения, в результате проверки аргументов.  
  
### Разработка индексированных свойств  
 Индексированное свойство представляет собой специальное свойство, которое может иметь параметры и могут вызываться с помощью специального синтаксиса, аналогично индексации массива.  
  
 Индексированные свойства, часто называют индексаторов. Индексаторы можно использовать только в API, которые обеспечивают доступ к элементам в логические коллекции. Например, строка — это совокупность символов и индексатор на <xref:System.String?displayProperty=fullName> был добавлен для доступа к его символов.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** использовать индексаторы для предоставления доступа к данным, хранящимся во внутреннем массиве.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** обеспечить индексаторы для типов, представляющих коллекции элементов.  
  
 **ИЗБЕЖАТЬ X** использование индексированных свойств с более чем одним параметром.  
  
 Если для разработки требуются несколько параметров, пересмотрите ли свойство в действительности является метод доступа к логической коллекции. В этом случае не следует используйте методы. Начните имя метода с `Get` или `Set`.  
  
 **ИЗБЕЖАТЬ X** индексаторов с типами параметров, отличных от <xref:System.Int32?displayProperty=fullName>, <xref:System.Int64?displayProperty=fullName>, <xref:System.String?displayProperty=fullName>, <xref:System.Object?displayProperty=fullName>, или перечисления.  
  
 Если для разработки требуются другие типы параметров, проверьте ли API действительно представляет метод доступа к логической коллекции. Если нет, используйте метод. Начните имя метода с `Get` или `Set`.  
  
 **✓ сделать** используйте имя `Item` для индексированных свойств, если очевидно более понятные имена \(например, см. <xref:System.String.Chars%2A> свойство `System.String`\).  
  
 В C\# индексаторов используются по умолчанию имя элемента.<xref:System.Runtime.CompilerServices.IndexerNameAttribute> Может использоваться для настройки этого имени.  
  
 **X не** индексатор и методы, которые семантически эквивалентны.  
  
 **X не** обеспечивают более одного семейства перегруженных индексаторов в одном типе.  
  
 Это реализуется с помощью компилятора C\#.  
  
 **X не** нестандартное использование индексированных свойств.  
  
 Это реализуется с помощью компилятора C\#.  
  
### События уведомления об изменении свойства  
 Иногда полезно предоставить событие уведомления пользователя об изменениях значения свойства. Например `System.Windows.Forms.Control` вызывает `TextChanged` событие после изменения значения его `Text` измененное свойство.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** вызов изменения события уведомления при изменении значений свойств в API высокого уровня \(обычно компонентов конструктора\).  
  
 При наличии хорошей сценарий для пользователя знать, когда изменяется свойство объекта, объект должен вызывать событие уведомления об изменении свойства.  
  
 Тем не менее это вряд ли стоит издержки, чтобы создать такие события по интерфейсам API низкого уровня, таких как базовые типы или коллекций. Например <xref:System.Collections.Generic.List%601> не приведет к возникновению таких событий, при добавлении нового элемента в список и `Count` изменения свойств.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** вызов изменения события уведомления при изменении значения свойства через внешних факторов.  
  
 При изменении значения свойства через некоторые внешние force \(таким образом, отличных от путем вызова методов объекта\), вызывают события указывают разработчику, что значение изменяется и изменилось. Хорошим примером является `Text` Свойства элемента управления текстовым полем. Когда пользователь вводит текст в `TextBox`, автоматически изменяет значение свойства.  
  
 *Частей © 2005, 2009 корпорации Microsoft. Все права защищены.*  
  
 *Воспроизведены разрешении Пирсон образования, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для повторного использования библиотеки .NET, второе издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс опубликованы 22 октября 2008 г., издательство Addison\-Wesley Professional как часть цикла разработки Microsoft Windows.*  
  
## См. также  
 [Рекомендации по разработке членов](../../../docs/standard/design-guidelines/member.md)   
 [Рекомендации по проектированию Framework](../../../docs/standard/design-guidelines/index.md)