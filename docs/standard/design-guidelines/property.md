---
title: Разработка свойств
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 4a4aec965753fe8f89b8bd89469f8dc5739a6a7c
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="property-design"></a>Разработка свойств
Несмотря на то, что свойства технически очень похожи на методы, между ними есть различия с точки зрения сценариев их использования. Они должны рассматриваться как смарт-поля. У них синтаксис вызова полей и гибкость методов.  
  
 **✓ СДЕЛАТЬ** Создание свойства только для чтения, если вызывающий объект не следует изменять значение свойства.  
  
 Следует помнить, что если тип свойства является изменяемым ссылочным типом, можно изменить значение свойства, даже если свойство доступно только для чтения.  
  
 **X не** предоставить только для набора свойств или свойств задания, имеющих широкий доступ, нежели метод считывания.  
  
 Например не используйте свойства с общедоступным методом задания и защищенный метод получения.  
  
 Если метод считывания свойства не может быть указан, следует Реализуйте функцию как метод. Начните имя метода с `Set` и следом за то, что вы будет имя свойства. Например <xref:System.AppDomain> содержит метод с именем `SetCachePath` вместо свойство только для набора с именем `CachePath`.  
  
 **✓ СДЕЛАТЬ** предоставить значения по умолчанию для всех свойств, убедившись, что значения по умолчанию не приводят к брешь в системе безопасности или совсем неэффективный код.  
  
 **✓ СДЕЛАТЬ** позволяют устанавливать в любом порядке, даже если это приводит к временной недопустимое состояние объекта свойства.  
  
 Чаще всего два или несколько свойств быть взаимосвязанных к точке, где некоторые значения одно свойство может быть неверным данных значений других свойств того же объекта. В таких случаях исключения, возникающие в результате в недопустимом состоянии должны быть отложены, пока взаимосвязанных свойства фактически используются совместно в объекте.  
  
 **✓ СДЕЛАТЬ** сохраняют предыдущее значение, если метод задания свойства вызывает исключение.  
  
 **X ИЗБЕГАЙТЕ** исключения из методов получения свойства.  
  
 Методы получения свойств должны быть простыми операциями и не должны иметь каких-либо условий. Если метод получения может создавать исключения, он, скорее всего, быть переработан методом. Обратите внимание, что это правило не применяется к индексаторы, где ожидается, что исключения, в результате проверки аргументов.  
  
### <a name="indexed-property-design"></a>Разработка индексированных свойств  
 Индексированное свойство является особым свойством, которое может иметь параметры и может быть вызван с помощью специального синтаксиса, аналогично индексации массива.  
  
 Индексированные свойства, часто называют индексаторов. Индексаторы можно использовать только в API-интерфейсы, которые обеспечивают доступ к элементам это логическая коллекция. Например, строка — это совокупность символы и указатель на <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символов.  
  
 **✓ Попробуйте** использовать индексаторы для предоставления доступа к данным, хранящимся во внутреннем массиве.  
  
 **✓ Попробуйте** обеспечить индексаторы для типов, представляющих коллекции элементов.  
  
 **X ИЗБЕГАЙТЕ** использование индексированных свойств с более чем одним параметром.  
  
 Если в программе требуется несколько параметров, пересмотрите ли свойство в действительности является методом доступа к логической коллекции. В этом случае не следует используйте методы. Начните имя метода с `Get` или `Set`.  
  
 **X ИЗБЕГАЙТЕ** индексаторы с типами параметров, отличных от <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, или перечисления.  
  
 Если для разработки требуются другие типы параметров, проверьте ли API в действительности является методом доступа к логической коллекции. Если этого не произошло, используйте метод. Начните имя метода с `Get` или `Set`.  
  
 **✓ ВЫПОЛНИТЕ** используйте имя `Item` для индексированных свойств при отсутствии очевидно, что более понятные имена (например, см. <xref:System.String.Chars%2A> свойство `System.String`).  
  
 В C# Индексаторы доступны по умолчанию имя элемента. <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Можно использовать для настройки этого имени.  
  
 **X не** предоставляют индексатор и методы, которые семантически эквивалентны.  
  
 **X не** предоставляют более одного семейства перегруженных индексаторов в одном типе.  
  
 Это требование с помощью компилятора C#.  
  
 **X не** нестандартное использование индексированных свойств.  
  
 Это требование с помощью компилятора C#.  
  
### <a name="property-change-notification-events"></a>События уведомления об изменении свойства  
 Иногда полезно создать событие уведомления пользователя об изменениях значения свойства. Например `System.Windows.Forms.Control` вызывает `TextChanged` событий после изменения значения его `Text` измененное свойство.  
  
 **✓ Попробуйте** вызов изменения события уведомления при изменении значений свойств в API высокого уровня (обычно компонентов конструктора).  
  
 Если хорошо сценарий для пользователю возможность узнать, при изменении свойства объекта, объект должен вызывать событие уведомления об изменении свойства.  
  
 Однако это правило, не стоит издержки для создания таких событий для низкоуровневого API, например базовых типов или коллекций. Например <xref:System.Collections.Generic.List%601> не приведет к возникновению таких событий, когда элемент добавляется в список и `Count` изменения свойств.  
  
 **✓ Попробуйте** вызов изменения события уведомления при изменении значения свойства через внешних событий.  
  
 При изменении значения свойства через некоторые внешние force (таким образом, отличных от путем вызова методов в объекте), создает события указывают разработчику, что значение изменяется и был изменен. Хорошим примером является `Text` свойство элемента управления текстового поля. Когда пользователь вводит текст в `TextBox`, автоматически изменяет значение свойства.  
  
 *Фрагменты © 2005, 2009 корпорации Майкрософт. Все права защищены.*  
  
 *Перепечатываются разрешении Пирсона для образовательных учреждений, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2-е издание](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс, опубликованные 22 октября 2008 г., Addison-Wesley Professional в составе ряда разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также  
 [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)  
 [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
