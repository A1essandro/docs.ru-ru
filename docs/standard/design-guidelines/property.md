---
title: Разработка свойств
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- member design guidelines, properties
- properties [.NET Framework], design guidelines
ms.assetid: 127cbc0c-cbed-48fd-9c89-7c5d4f98f163
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7e6bc0230afe2dfc03b1aeeae46a3ba54599c8da
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/07/2018
ms.locfileid: "44084938"
---
# <a name="property-design"></a>Разработка свойств
Несмотря на то, что свойства с технической точки зрения очень похожи на методы, между ними есть различия с точки зрения сценарии их использования. Они должны рассматриваться как интеллектуальные поля. Они имеют синтаксис вызова полей и гибкость методов.  
  
 **✓ DO** Создание свойства только для чтения, если вызывающий объект не следует изменять значение свойства.  
  
 Следует помнить, что если тип свойства является изменяемым ссылочным типом, значение свойства можно изменить, даже если свойство только для чтения.  
  
 **X DO NOT** предоставить только для набора свойств или свойств задания, имеющих широкий доступ, нежели метод считывания.  
  
 Например не используйте свойства с помощью открытого метода задания и защищенного метода получения.  
  
 Если не может быть указан метод получения свойства, следует реализуйте функции как метод. Начните имя метода с `Set` , а после что вы будет имя свойства. Например <xref:System.AppDomain> имеет метод под названием `SetCachePath` вместо того, свойство только для задания с именем `CachePath`.  
  
 **✓ DO** предоставить значения по умолчанию для всех свойств, убедившись, что значения по умолчанию не приводят к брешь в системе безопасности или совсем неэффективный код.  
  
 **✓ DO** позволяют устанавливать в любом порядке, даже если это приводит к временной недопустимое состояние объекта свойства.  
  
 Чаще всего два или несколько свойств быть взаимосвязанных в точку, где некоторые значения одного свойства могут быть недопустимыми данных значений других свойств того же объекта. В таких случаях исключения, полученный в результате в недопустимом состоянии должны быть отложены, пока взаимосвязанных свойства фактически используются совместно с объектом.  
  
 **✓ DO** сохраняют предыдущее значение, если метод задания свойства вызывает исключение.  
  
 **X AVOID** исключения из методов получения свойства.  
  
 Методы получения свойств должны быть простыми операциями и не должен иметь каких-либо условий. Если свойства getter может создавать исключения, он, вероятно, должны быть переработаны методом. Обратите внимание, что это правило не применяется к индексаторов, где ожидается, что исключения, в результате проверки аргументов.  
  
### <a name="indexed-property-design"></a>Разработка индексированных свойств  
 Индексированное свойство представляет собой специальное свойство, которое может иметь параметры и могут вызываться с помощью специального синтаксиса, аналогично индексации массива.  
  
 Индексированные свойства обычно называются индексаторов. Индексаторы следует использовать только в API, которые обеспечивают доступ к элементам в это логическая коллекция. Например, строка — это совокупность символов и индексатор по <xref:System.String?displayProperty=nameWithType> был добавлен для доступа к его символов.  
  
 **✓ CONSIDER** использовать индексаторы для предоставления доступа к данным, хранящимся во внутреннем массиве.  
  
 **✓ CONSIDER** обеспечить индексаторы для типов, представляющих коллекции элементов.  
  
 **X AVOID** использование индексированных свойств с более чем одним параметром.  
  
 Если в программе требуется несколько параметров, пересмотрите ли свойство действительно представляет метод доступа к логической коллекции. Если этого не произошло, следует используйте методы. Начните имя метода с `Get` или `Set`.  
  
 **X AVOID** индексаторы с типами параметров, отличных от <xref:System.Int32?displayProperty=nameWithType>, <xref:System.Int64?displayProperty=nameWithType>, <xref:System.String?displayProperty=nameWithType>, <xref:System.Object?displayProperty=nameWithType>, или перечисления.  
  
 Если для разработки требуются другие типы параметров, проверьте ли API действительно представляет метод доступа к логической коллекции. Если этого не произошло, используйте метод. Начните имя метода с `Get` или `Set`.  
  
 **✓ DO** используйте имя `Item` для индексированных свойств при отсутствии очевидно, что более понятные имена (например, см. <xref:System.String.Chars%2A> свойство `System.String`).  
  
 В C# индексаторы, по умолчанию, с именем элемента. <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Можно использовать для настройки этого имени.  
  
 **X DO NOT** предоставляют индексатор и методы, которые семантически эквивалентны.  
  
 **X DO NOT** предоставляют более одного семейства перегруженных индексаторов в одном типе.  
  
 Это реализуется с помощью компилятора C#.  
  
 **X DO NOT** нестандартное использование индексированных свойств.  
  
 Это реализуется с помощью компилятора C#.  
  
### <a name="property-change-notification-events"></a>События уведомления об изменении свойства  
 Иногда полезно предоставляют событие, уведомляя пользователя об изменениях значения свойства. Например `System.Windows.Forms.Control` вызывает `TextChanged` событий после значение его `Text` свойство изменилось.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значений свойств в API высокого уровня (обычно компонентов конструктора).  
  
 Если подходящий сценарий для пользователя, чтобы знать, когда изменения свойства объекта, объект должен вызывать событие уведомления об изменении свойства.  
  
 Однако маловероятно, чтобы его стоило трудозатрат, связанных с создавать эти события для API низкого уровня, например базовых типов или коллекций. Например <xref:System.Collections.Generic.List%601> не будет вызывать такие события, когда новый элемент добавляется в список и `Count` изменения свойств.  
  
 **✓ CONSIDER** вызов изменения события уведомления при изменении значения свойства через внешних событий.  
  
 При изменении значения свойства с помощью некоторых внешних столь (отличных от путем вызова методов в объекте), вызвано события указывают разработчику, что значение изменяется и изменилось. Хорошим примером является `Text` свойства элемент управления текстовым полем. Когда пользователь вводит текст в `TextBox`, автоматически изменяет значение свойства.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)  
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
