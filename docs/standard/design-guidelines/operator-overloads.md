---
title: "Перегрузки операторов | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "операторы [платформа .NET Framework] перегрузки"
  - "имена [платформа .NET Framework] перегруженные операторы"
  - "рекомендации по разработке членов, операторы"
  - "перегруженные операторы"
ms.assetid: 37585bf2-4c27-4dee-849a-af70e3338cc1
caps.latest.revision: 11
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 11
---
# Перегрузки операторов
Перегрузки операторов позволяют отображаются, как если бы они были примитивы языка встроенные типы framework.  
  
 Несмотря на то, что разрешены или в определенных ситуациях перегрузки операторов следует использовать осторожно. Есть много вариантов, в которых оператор перегрузка были неправильно, например при framework разработчики начали использовать операторы для операций, которые должны быть простые методы. Следующие рекомендации помогут решить, когда и как использовать перегрузку операторов.  
  
 **ИЗБЕЖАТЬ X** определения перегрузки оператора, за исключением типов, которые следует считать типы\-примитивы \(встроенные\).  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** определения перегрузки оператора в типе, который следует считать тип\-примитив.  
  
 Например <xref:System.String?displayProperty=fullName> имеет `operator==` и `operator!=` определены.  
  
 **✓ сделать** определения перегрузки оператора в структурах, представления чисел \(например, <xref:System.Decimal?displayProperty=fullName>\).  
  
 **X не** быть оригинальное при определении перегрузки операторов.  
  
 Перегрузка оператора полезна в случаях, когда очевиден результат операции, которые будут. Например, имеет смысл иметь возможность вычесть единицу <xref:System.DateTime> из другого `DateTime` и <xref:System.TimeSpan>. Тем не менее он не подходит для использования оператора union логического объединения двух запросов к базе данных или использовать оператор shift для записи в поток.  
  
 **X не** предоставляют перегрузки оператор, если по крайней мере один из операндов имеет тип, определив перегрузку.  
  
 **✓ сделать** перегрузку операторов симметричную.  
  
 Например, при перегрузке `operator==`, то следует перегрузить `operator!=`. Аналогичным образом при перегрузке `operator<`, то следует перегрузить `operator>`, и т. д.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** обеспечивая понятные имена, соответствующие методы для каждого перегруженного оператора.  
  
 Многие языки не поддерживают перегрузки операторов. По этой причине рекомендуется Включение дополнительный метод с соответствующим именем конкретного домена, который предоставляет эквивалент функциональных возможностей типов, перегрузку операторов.  
  
 Следующая таблица содержит список операторов и имена соответствующих методов понятное.  
  
|Символ оператора C\#|Имя метаданных|Понятное имя|  
|--------------------------|--------------------|------------------|  
|`N/A`|`op_Implicit`|`To<TypeName>/From<TypeName>`|  
|`N/A`|`op_Explicit`|`To<TypeName>/From<TypeName>`|  
|`+ (binary)`|`op_Addition`|`Add`|  
|`- (binary)`|`op_Subtraction`|`Subtract`|  
|`* (binary)`|`op_Multiply`|`Multiply`|  
|`/`|`op_Division`|`Divide`|  
|`%`|`op_Modulus`|`Mod or Remainder`|  
|`^`|`op_ExclusiveOr`|`Xor`|  
|`& (binary)`|`op_BitwiseAnd`|`BitwiseAnd`|  
|`&#124;`|`op_BitwiseOr`|`BitwiseOr`|  
|`&&`|`op_LogicalAnd`|`And`|  
|`&#124;&#124;`|`op_LogicalOr`|`Or`|  
|`=`|`op_Assign`|`Assign`|  
|`<<`|`op_LeftShift`|`LeftShift`|  
|`>>`|`op_RightShift`|`RightShift`|  
|`N/A`|`op_SignedRightShift`|`SignedRightShift`|  
|`N/A`|`op_UnsignedRightShift`|`UnsignedRightShift`|  
|`==`|`op_Equality`|`Equals`|  
|`!=`|`op_Inequality`|`Equals`|  
|`>`|`op_GreaterThan`|`CompareTo`|  
|`<`|`op_LessThan`|`CompareTo`|  
|`>=`|`op_GreaterThanOrEqual`|`CompareTo`|  
|`<=`|`op_LessThanOrEqual`|`CompareTo`|  
|`*=`|`op_MultiplicationAssignment`|`Multiply`|  
|`-=`|`op_SubtractionAssignment`|`Subtract`|  
|`^=`|`op_ExclusiveOrAssignment`|`Xor`|  
|`<<=`|`op_LeftShiftAssignment`|`LeftShift`|  
|`%=`|`op_ModulusAssignment`|`Mod`|  
|`+=`|`op_AdditionAssignment`|`Add`|  
|`&=`|`op_BitwiseAndAssignment`|`BitwiseAnd`|  
|`&#124;=`|`op_BitwiseOrAssignment`|`BitwiseOr`|  
|`,`|`op_Comma`|`Comma`|  
|`/=`|`op_DivisionAssignment`|`Divide`|  
|`--`|`op_Decrement`|`Decrement`|  
|`++`|`op_Increment`|`Increment`|  
|`- (unary)`|`op_UnaryNegation`|`Negate`|  
|`+ (unary)`|`op_UnaryPlus`|`Plus`|  
|`~`|`op_OnesComplement`|`OnesComplement`|  
  
### Перегрузка оператора \=\=  
 Перегрузка `operator ==` довольно сложен. Семантика оператора должны совместимы с несколько других членов, таких как <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
### Операторы преобразования  
 Операторы преобразования являются унарные операторы, которые позволяют преобразование из одного типа в другой. Операторы должен быть определен как статических членов операнда или возвращаемого типа. Существует два типа операторов преобразования: явные и неявные.  
  
 **X не** укажите оператор преобразования, если такое преобразование не ожидается конечными пользователями.  
  
 **X не** определить операторы преобразования за пределами области типа.  
  
 Например <xref:System.Int32>, <xref:System.Double>, и <xref:System.Decimal> являются все числовые типы, в то время как <xref:System.DateTime> не является. Таким образом, должно быть не оператор преобразования `Double(long)` для `DateTime`. В этом случае является предпочтительным конструктор.  
  
 **X не** предоставить неявный оператор преобразования, если преобразование является потенциально с потерями.  
  
 Например, не должно быть неявного преобразования из `Double` к `Int32` из\-за `Double` имеет широкий диапазон, чем `Int32`. Оператор явного преобразования могут быть предоставлены, даже если преобразование является потенциально с потерями.  
  
 **X не** исключения из неявных приведений типов.  
  
 Очень сложно конечным пользователям понять, что произошло, поскольку не будут знать, что происходит преобразования.  
  
 **✓ сделать** исключение <xref:System.InvalidCastException?displayProperty=fullName> Если вызов оператора преобразования приводит к преобразование с потерями и контракт оператора не позволяет.  
  
 *Частей © 2005, 2009 корпорации Microsoft. Все права защищены.*  
  
 *Воспроизведены разрешении Пирсон образования, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для повторного использования библиотеки .NET, второе издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс опубликованы 22 октября 2008 г., издательство Addison\-Wesley Professional как часть цикла разработки Microsoft Windows.*  
  
## См. также  
 [Рекомендации по разработке членов](../../../docs/standard/design-guidelines/member.md)   
 [Рекомендации по проектированию Framework](../../../docs/standard/design-guidelines/index.md)