---
title: "Разработка событий | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "до события"
  - "события [платформа .NET Framework] рекомендации по проектированию"
  - "рекомендации по разработке членов, события"
  - "обработчики событий [платформа .NET Framework] рекомендации по разработке событий"
  - "После события"
  - "подписи, обработка событий"
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
caps.latest.revision: 15
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 15
---
# Разработка событий
События являются наиболее часто используемые формой обратные вызовы \(конструкции, позволяющие framework для вызова кода пользователя\). Другие механизмы обратного вызова включают элементы делегаты, виртуальные члены и на основе интерфейса подключаемых модулей. Данные из исследования удобства использования указывают удобнее работать с помощью события не используются другие механизмы обратного вызова большинства разработчиков. События хорошо интегрированы с Visual Studio и многих языков.  
  
 Важно отметить, что есть две группы событий: события, созданные до состояния изменения в системе, называются предварительного события и события, возникающие после изменения состояния, вызывается после события. Пример событий до `Form.Closing`, который вызывается перед закрытием формы. Пример после события `Form.Closed`, который вызывается после закрытия формы.  
  
 **✓ сделать** использовать термин «повышение» для событий, а не «fire» или «триггер».  
  
 **✓ сделать** используйте <xref:System.EventHandler%601?displayProperty=fullName> вместо того чтобы вручную создавать новых делегатов в качестве обработчиков событий.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** с помощью подкласс <xref:System.EventArgs> в качестве аргумента события, если вы абсолютно уверены, что событию никогда не понадобится передавать данные метода обработки событий в этом случае можно использовать `EventArgs` ввести непосредственно.  
  
 Если вы отправляете интерфейса API с помощью `EventArgs` напрямую, вы никогда не будет возможность добавлять данные на проведение без риска нарушить совместимость с событием. Если используется подкласс, даже если изначально полностью пуста, можно добавить свойства для подкласса, при необходимости.  
  
 **✓ сделать** использовать защищенный виртуальный метод для каждого события. Это значение применимо только на нестатические незапечатанные классы, структуры, запечатанные классы или статические события для события.  
  
 Назначение метода является предоставление способа для производного класса для обработки события с помощью переопределения. Переопределение является более гибким, быстрее и более естественный способ обработки событий базового класса в производных классах. В соответствии с соглашением имя метода должно начинаться с «On» и идти на имя события.  
  
 Производный класс можно не вызвать базовую реализацию метода в его перезаписи. Быть готовым к этому, не включая обработки в методе, который необходим для правильной работы базового класса.  
  
 **✓ сделать** принимать один параметр в защищенный метод, который вызывает событие.  
  
 Параметр должен иметь имя `e` и должны вводиться как класс аргументов события.  
  
 **X не** передает null в качестве отправителя при нестатические события.  
  
 **✓ сделать** передает null в качестве отправителя при статические события.  
  
 **X не** передает null в качестве параметра данных события при возникновении события.  
  
 Необходимо передать `EventArgs.Empty` Если вы не хотите передать данные для метода обработчика событий. Разработчики предполагают, что этот параметр не должен иметь значение null.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** вызов событий, которые конечный пользователь может отменить. Это относится только к предварительного события.  
  
 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=fullName> или его подкласс как аргумент события, чтобы разрешить пользователю отменить события.  
  
### Разработка настраиваемого обработчика событий  
 Бывают случаи, в котором `EventHandler<T>` не может использоваться, например, когда платформа нужно работать с более ранними версиями среды CLR не поддерживает универсальные шаблоны. В таких случаях может потребоваться проектировать и разрабатывать делегата обработчика пользовательского события.  
  
 **✓ сделать** использовать тип возвращаемого значения void для обработчиков событий.  
  
 Обработчик событий может вызывать методы, возможно с несколькими объектами обработки нескольких событий. Если разрешена методы обработки событий для возврата значения, будет несколько возвращаемых значений для каждого вызова события.  
  
 **✓ сделать** использовать `object` как тип первого аргумента обработчика событий и назовите его `sender`.  
  
 **✓ сделать** использовать <xref:System.EventArgs?displayProperty=fullName> или его подкласс в качестве типа второго аргумента обработчика событий и назовите его `e`.  
  
 **X не** иметь более двух параметров на обработчики событий.  
  
 *Частей © 2005, 2009 корпорации Microsoft. Все права защищены.*  
  
 *Воспроизведены разрешении Пирсон образования, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для повторного использования библиотеки .NET, второе издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс опубликованы 22 октября 2008 г., издательство Addison\-Wesley Professional как часть цикла разработки Microsoft Windows.*  
  
## См. также  
 [Рекомендации по разработке членов](../../../docs/standard/design-guidelines/member.md)   
 [Рекомендации по проектированию Framework](../../../docs/standard/design-guidelines/index.md)