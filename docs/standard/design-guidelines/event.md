---
title: Разработка событий
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: b257da73d33fae54ef464e9dd69906316b87fd88
ms.sourcegitcommit: 4b6490b2529707627ad77c3a43fbe64120397175
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2018
ms.locfileid: "44270910"
---
# <a name="event-design"></a>Разработка событий
События являются наиболее часто используемые формой обратные вызовы (конструкции, которые позволяют framework для вызова пользовательского кода). Другие механизмы обратного вызова участием делегатов, виртуальные члены и основанная на интерфейсах подключаемых модулей. Данные из исследований об удобстве использования, указывают, что большинство разработчиков удобнее работать с помощью событий, чем они при использовании других методов обратного вызова. События хорошо интегрированы с Visual Studio и многих языков.  
  
 Важно отметить, что две группы событий: события, возникающие до состояния изменения в системе, вызывается предварительного события и события, возникающие после изменения состояния, вызывается после события. Примером предварительного события может служить `Form.Closing`, который вызывается перед закрытием формы. Примером после события может служить `Form.Closed`, который вызывается после закрытия формы.  
  
 **✓ DO** использовать термин «raise» для событий, а не «fire» или «триггер».  
  
 **✓ DO** используйте <xref:System.EventHandler%601?displayProperty=nameWithType> вместо того чтобы вручную создавать новые делегаты для использования в качестве обработчиков событий.  
  
 **✓ CONSIDER** с помощью подкласс <xref:System.EventArgs> в качестве аргумента события, пока не будет точно знать, что событие никогда не понадобится передавать данные метода обработки событий в этом случае можно использовать `EventArgs` ввести напрямую.  
  
 При доставке API с помощью `EventArgs` напрямую, вы никогда не сможете добавить данные, разделяя без риска нарушить совместимость с событием. Если вы используете подкласс, даже если изначально полностью пустым, можно для добавления свойств в подкласс, при необходимости.  
  
 **✓ DO** использовать защищенный виртуальный метод для каждого события. Это значение применимо только на нестатические события незапечатанных классов, не для структур, запечатанные классы или статические события.  
  
 Метод предназначена для предоставления способа для производного класса для обработки события с помощью переопределения. Переопределение является более гибким, быстрее и более естественный способ обработки событий базового класса в производных классах. По соглашению имя метода должно начинаться с «On» и следовать имя события.  
  
 Производный класс можно не вызывать базовую реализацию метода в его переопределения. Быть готовы к этому, не включив обработку в метод, который необходим для базового класса для правильной работы.  
  
 **✓ DO** принимать один параметр для защищенный метод, который вызывает событие.  
  
 Параметр должен иметь имя `e` и должны быть типизированы как класс аргументов события.  
  
 **X DO NOT** передает null в качестве отправителя при нестатические события.  
  
 **✓ DO** передает null в качестве отправителя при статические события.  
  
 **X DO NOT** передает null в качестве параметра данных события при возникновении события.  
  
 Необходимо передать `EventArgs.Empty` Если вы не хотите передавать все данные в метод обработки события. Разработчики предполагают, что этот параметр не должен иметь значение null.  
  
 **✓ CONSIDER** вызов событий, которые можно отменить конечного пользователя. Это относится только к предварительного события.  
  
 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс как аргумент и позволяющие конечным пользователям для отмены события.  
  
### <a name="custom-event-handler-design"></a>Разработка настраиваемого обработчика событий  
 Бывают случаи, в котором `EventHandler<T>` не может использоваться, например когда платформа должна работать в более ранних версиях среды CLR, который не поддерживает универсальные шаблоны. В таких случаях может потребоваться для проектирования и разработки делегат обработчика пользовательского события.  
  
 **✓ DO** использовать тип возвращаемого значения void для обработчиков событий.  
  
 Обработчик событий может вызывать несколько событий, обработка методов, возможно, на несколько объектов. Если методы обработки событий было разрешено для возврата значения, то должно быть несколько возвращаемые значения для каждого вызова событий.  
  
 **✓ DO** использовать `object` как тип первого аргумента обработчика событий и вызывает его `sender`.  
  
 **✓ DO** использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго аргумента обработчика событий и вызывает его `e`.  
  
 **X DO NOT** иметь более двух параметров на обработчики событий.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)  
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
