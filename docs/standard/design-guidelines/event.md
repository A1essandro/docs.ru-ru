---
title: Разработка событий
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- pre-events
- events [.NET Framework], design guidelines
- member design guidelines, events
- event handlers [.NET Framework], event design guidelines
- post-events
- signatures, event handling
ms.assetid: 67b3c6e2-6a8f-480d-a78f-ebeeaca1b95a
caps.latest.revision: 15
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 3d66d4e137c52310710f8b178167ceb3cca042c7
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2018
---
# <a name="event-design"></a>Разработка событий
События, наиболее часто используемые формы обратных вызовов (конструкций, позволяющих framework вызов кода пользователя). Другие механизмы обратного вызова включаются элементы, которые занимает делегатов, виртуальные члены и основанная на интерфейсах подключаемых модулей. Данные из исследования удобства использования указывает, что большинство разработчиков удобнее с помощью событий, не используют другие механизмы обратного вызова. События хорошо интегрированы с Visual Studio и многих языков.  
  
 Это важно отметить, что имеются две группы событий: события, возникающие до изменений системы, событий и событий, возникающих после изменения состояния в состояние вызывается после события. Примером событий до такого `Form.Closing`, который вызывается перед закрытием формы. Пример после события будет `Form.Closed`, который вызывается после закрытия формы.  
  
 **✓ СДЕЛАТЬ** использовать термин «raise» для событий, а не «fire» или «триггер».  
  
 **СДЕЛАТЬ ✓** используйте <xref:System.EventHandler%601?displayProperty=nameWithType> вместо того чтобы вручную создавать новые делегаты для использования в качестве обработчиков событий.  
  
 **✓ Попробуйте** с помощью подкласс <xref:System.EventArgs> в качестве аргумента события, пока не будет точно знать, что событие никогда не понадобится передавать данные метода обработки событий в этом случае можно использовать `EventArgs` ввести напрямую.  
  
 Если планируется API с помощью `EventArgs` напрямую, никогда не появится возможность добавления всех данных выполнена без нарушения совместимости с событием. При использовании подкласс, даже если изначально полностью пуста, вы сможете для добавления свойств в подклассе, если это требуется.  
  
 **✓ СДЕЛАТЬ** использовать защищенный виртуальный метод для каждого события. Это значение применимо только нестатические на незапечатанные классы, структуры, запечатанные классы или статические события для события.  
  
 Метод предназначен для предоставления возможности для производного класса для обработки события, с помощью переопределения. Переопределение является более гибким, быстрее и более естественным способом обработки событий базового класса в производных классах. По соглашению имя метода должно начинаться с «On» и идти с именем события.  
  
 Производный класс можно выбрать не вызвать базовую реализацию метода в его переопределения. Быть готовым к этому, не включая какой-либо обработки, необходим для правильной работы базового класса в методе.  
  
 **✓ СДЕЛАТЬ** принимать один параметр для защищенный метод, который вызывает событие.  
  
 Параметр должен иметь имя `e` и должны быть типизированы как класс аргументов события.  
  
 **X не** передает null в качестве отправителя при нестатические события.  
  
 **✓ СДЕЛАТЬ** передает null в качестве отправителя при статические события.  
  
 **X не** передает null в качестве параметра данных события при возникновении события.  
  
 Необходимо передать `EventArgs.Empty` Если вы не хотите передавать все данные в метод обработки событий. Разработчики предполагают, что этот параметр не должен иметь значение null.  
  
 **✓ Попробуйте** вызов событий, которые можно отменить конечного пользователя. Это относится только к событий.  
  
 Используйте <xref:System.ComponentModel.CancelEventArgs?displayProperty=nameWithType> или его подкласс, в качестве аргумента события, чтобы разрешить конечным пользователям отмены события.  
  
### <a name="custom-event-handler-design"></a>Разработка настраиваемого обработчика событий  
 Существуют случаи, в котором `EventHandler<T>` не может использоваться, например, когда платформа должно работать в более ранних версиях среды CLR, который не поддерживает универсальные шаблоны. В таких случаях может потребоваться для проектирования и разработки делегата обработчика пользовательского события.  
  
 **✓ СДЕЛАТЬ** использовать тип возвращаемого значения void для обработчиков событий.  
  
 Обработчик событий может вызывать методы, возможно с несколькими объектами обработки нескольких событий. Если допускается методы обработки событий для возврата значения, будет несколько значений для каждого вызова события.  
  
 **СДЕЛАТЬ ✓** использовать `object` как тип первого аргумента обработчика событий и вызывает его `sender`.  
  
 **СДЕЛАТЬ ✓** использовать <xref:System.EventArgs?displayProperty=nameWithType> или его подкласс в качестве типа второго аргумента обработчика событий и вызывает его `e`.  
  
 **X не** иметь более двух параметров на обработчики событий.  
  
 *Фрагменты © 2005, 2009 корпорации Майкрософт. Все права защищены.*  
  
 *Перепечатываются разрешении Пирсона для образовательных учреждений, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2-е издание](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс, опубликованные 22 октября 2008 г., Addison-Wesley Professional в составе ряда разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также  
 [Правила разработки членов](../../../docs/standard/design-guidelines/member.md)  
 [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)
