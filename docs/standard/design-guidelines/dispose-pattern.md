---
title: "Шаблон удаления | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "Dispose - метод"
  - "Класс рекомендации по разработке библиотек [платформа .NET Framework], метод Dispose"
  - "Класс рекомендации по разработке библиотек [платформа .NET Framework] метод Finalize"
  - "Изменение имени метода Dispose"
  - "Finalize - метод"
ms.assetid: 31a6c13b-d6a2-492b-9a9f-e5238c983bcb
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Шаблон удаления
Все программы получить один или несколько системных ресурсов, таких как память, дескрипторы системы или подключения к базе данных во время их выполнения. Разработчики должны соблюдать осторожность при использовании таких ресурсов системы, так как они должны быть освобождены после их получения и использования.  
  
 Среда CLR поддерживает автоматическое управление памятью. Управляемой памяти \(память, выделенную с помощью оператора C\# `new`\) не должны быть освобождены явно. Он автоматически освобождается сборщиком мусора \(GC\). Это освобождает разработчиков от нудной и сложной задачи освобождение памяти и была одна из основных причин исключительную производительность, обеспечиваемая платформой .NET Framework.  
  
 К сожалению управляемой памяти является только одним из многих типов системных ресурсов. Ресурсов, отличных от управляемой памяти по\-прежнему необходимо явно освободить и называются неуправляемые ресурсы. Сборка Мусора была специально не предназначен для управления таких неуправляемых ресурсов, это означает, что ответственность за управление неуправляемых ресурсов находится в руках разработчиков.  
  
 Среда CLR предоставляет некоторые справки в освобождения неуправляемых ресурсов.<xref:System.Object?displayProperty=fullName> Объявляет виртуальный метод <xref:System.Object.Finalize%2A> \(также называемые финализатор\) вызывается сборщиком Мусора до объекта памяти освобождается сборщиком Мусора и может быть переопределен для освобождения неуправляемых ресурсов. Типы, которые переопределяют метод завершения, называются завершаемые типов.  
  
 Несмотря на то, что финализаторы вступают в силу в некоторых сценариях очистки, у них есть два существенных недостатка:  
  
-   Метод finalizer вызывается, когда сборщик Мусора обнаруживает, что объект является доступным для коллекции. Это происходит в некоторое неопределенное время после ресурс больше не нужен. Задержка между при разработчик может или хотите для освобождения ресурсов и времени, на самом деле освобождения ресурса, финализатор может быть неприемлемо, в программах, которые запрашивают многие дефицитных ресурсов \(ресурсы, которые могут быть легко исчерпаны\) или в случаях, когда ресурсы дороже используется \(например, буферов большого объема неуправляемой памяти\).  
  
-   Когда среда CLR должна вызывать метод завершения, он должен отложить коллекцию памяти объекта до округления следующего сбора мусора \(методы завершения, запустите между коллекциями\). Это означает, что памяти объекта \(и все объекты, которые она ссылается\) не будет освобожден для длительного периода времени.  
  
 Таким образом полагаясь исключительно на методы завершения не можно использовать во многих ситуациях, когда важно освободить неуправляемые ресурсы как можно скорее, при работе с дефицитных ресурсов или в высокой производительностью сценариев, в которых добавлены GC издержки выполнения финализации неприемлемо.  
  
 Платформа предоставляет <xref:System.IDisposable?displayProperty=fullName> интерфейс, который должен быть реализован для предоставления разработчику ручной способ освободить неуправляемые ресурсы, как только они не нужны. Он также предоставляет <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> метод, который можно обязать сборщик Мусора, объект был вручную удален и не требует выполнения операции Finalize больше, в этом случае памяти объекта могут быть освобождены ранее. Типы, реализующие `IDisposable` интерфейс называются уничтожаемых типов.  
  
 Шаблон Dispose предназначен для стандартизации использования и реализации методов завершения и `IDisposable` интерфейса.  
  
 Является главным поводом для шаблона для снижения сложности реализации <xref:System.Object.Finalize%2A> и <xref:System.IDisposable.Dispose%2A> методы. Сложность состоит в том, что методы используют некоторые, но не все пути кода \(различия описаны далее в этой главе\). Кроме того существует историческим причинам, для некоторых элементов шаблона, относящиеся к эволюции языковая поддержка для управления ресурсами детерминированной.  
  
 **✓ сделать** реализовать базовый шаблон Dispose для типов, содержащая экземпляры уничтожаемых типов. В разделе [базовый шаблон Dispose](#basic_pattern) Дополнительные сведения об основной шаблон.  
  
 Если тип отвечает в течение времени существования других уничтожаемых объектов, разработчики должны способ избавиться от них, слишком. С помощью контейнера `Dispose` метод является удобным способом для этого.  
  
 **✓ сделать** реализовать базовый шаблон Dispose и предоставлять метод завершения на типах удерживающим ресурсы, которые должны быть освобождены явно и не имеют методов завершения.  
  
 Например шаблон должен реализовываться в типах хранения буферов неуправляемой памяти.[Завершаемые типы](#finalizable_types) разделе представлены рекомендации, относящиеся к реализации методов завершения.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** реализации базовый шаблон Dispose для классов, не хранят сами неуправляемых ресурсов или Уничтожаемые объекты но, скорее всего, имеются подтипы, которые выполняют.  
  
 Хорошим примером этого является <xref:System.IO.Stream?displayProperty=fullName> класса. Хотя это абстрактный базовый класс, который не содержит все ресурсы, выполнить большинство из его подклассов, и по этой причине он реализует этот шаблон.  
  
<a name="basic_pattern"></a>   
## Шаблон удаления основные  
 Базовая реализация шаблон включает реализацию `System.IDisposable` интерфейс и объявление `Dispose(bool)` метод, который реализует всю логику очистки ресурсов, совместно `Dispose` метод и необязательный метод завершения.  
  
 В следующем примере показана простая реализация основных шаблона:  
  
```  
public class DisposableResourceHolder : IDisposable {  
  
    private SafeHandle resource; // handle to a resource  
  
    public DisposableResourceHolder(){  
        this.resource = ... // allocates the resource  
    }  
  
    public void Dispose(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
  
    protected virtual void Dispose(bool disposing){  
        if (disposing){  
            if (resource!= null) resource.Dispose();  
        }  
    }  
}  
```  
  
 Логический параметр `disposing` показывает, вызван ли метод из `IDisposable.Dispose` реализации или из метода завершения.`Dispose(bool)` Реализации следует проверить параметр перед получением доступа к другим ссылаться на объекты \(например, поле ресурса в предыдущем примере\). Такие объекты должны быть доступны только при вызове метода из `IDisposable.Dispose` реализации \(если `disposing` параметр имеет значение true\). Если метод вызывается из метода завершения \(`disposing` имеет значение false\), другие объекты не должны быть доступны. Причина — что объекты были закрыты в непредсказуемой последовательности, и поэтому они, или их зависимости, может быть уже закрыт.  
  
 Кроме того этот раздел относится к классам с базовыми, который не реализует шаблон Dispose. При наследовании от класса, который уже реализует шаблон просто заменить `Dispose(bool)` метод для предоставления логики очистки дополнительных ресурсов.  
  
 **✓ сделать** объявить защищенный виртуальный void `Dispose(bool disposing)` способ централизовать всю логику, связанную с освобождением неуправляемые ресурсы.  
  
 Очистка всех ресурсов должно выполняться в этом методе. Метод вызывается из метода завершения обеих и `IDisposable.Dispose` метод. Параметр будет иметь значение false, если вызваны внутри метода завершения. Его следует использовать, чтобы убедиться, что любой код, выполняемый во время завершения не имеет доступа к другим объектам. В следующем разделе описываются подробности реализации методов завершения.  
  
```  
protected virtual void Dispose(bool disposing){  
    if (disposing){  
        if (resource!= null) resource.Dispose();  
    }  
}  
```  
  
 **✓ сделать** реализовать `IDisposable` интерфейс, просто вызвав `Dispose(true)` следуют `GC.SuppressFinalize(this)`.  
  
 Вызов `SuppressFinalize` произойдет только в том случае, если `Dispose(true)` выполняется успешно.  
  
```  
public void Dispose(){  
    Dispose(true);  
    GC.SuppressFinalize(this);  
}  
```  
  
 **X не** сделать без параметров `Dispose` виртуальный метод.  
  
 `Dispose(bool)` Метод является тот, который должен быть переопределен в подклассах.  
  
```  
// bad design  
public class DisposableResourceHolder : IDisposable {  
    public virtual void Dispose(){ ... }  
    protected virtual void Dispose(bool disposing){ ... }  
}  
  
// good design  
public class DisposableResourceHolder : IDisposable {  
    public void Dispose(){ ... }  
    protected virtual void Dispose(bool disposing){ ... }  
}  
```  
  
 **X не** объявлять все перегрузки `Dispose` метод, отличный от `Dispose()` и `Dispose(bool)`.  
  
 `Dispose` следует рассматривать зарезервированное слово, чтобы кодировать этот шаблон и избежать путаницы между компиляторы, разработчиков и пользователей. В некоторых языках можно автоматически реализации этого шаблона для определенных типов.  
  
 **✓ сделать** Разрешить `Dispose(bool)` метод, который вызывается несколько раз. Метод можно ничего не делать после первого вызова.  
  
```  
public class DisposableResourceHolder : IDisposable {  
  
    bool disposed = false;  
  
    protected virtual void Dispose(bool disposing){  
        if(disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **ИЗБЕЖАТЬ X** исключение изнутри `Dispose(bool)` только под критических ситуаций, где был поврежден процесс, содержащий \(утечки, несогласованные общее состояние и т. д.\).  
  
 Пользователи ожидают, что вызов `Dispose` не вызывает исключение.  
  
 Если `Dispose` может вызвать исключение, дальнейшей логики очистки блок finally не будет выполняться. Чтобы обойти это, пользователю необходимо в качестве оболочки для каждого вызова `Dispose` \(в блоке finally\!\) в блоке try, что приводит к очень сложной очистки обработчиков. Если при выполнении `Dispose(bool disposing)` метод никогда не выдал исключение, если аргумент disposing равен false. Таким образом будет завершить процесс, если выполнение происходит внутри контекста метода завершения.  
  
 **✓ сделать** исключение <xref:System.ObjectDisposedException> от любого члена, который не может использоваться после удаления объекта.  
  
```  
public class DisposableResourceHolder : IDisposable {  
    bool disposed = false;  
    SafeHandle resource; // handle to a resource  
  
    public void DoSomething(){  
           if(disposed) throw new ObjectDisposedException(...);  
        // now call some native methods using the resource   
            ...  
    }  
    protected virtual void Dispose(bool disposing){  
        if(disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** предоставляет метод `Close()`, в дополнение к `Dispose()`, если закрыть является стандартной терминологии в области.  
  
 При этом очень важно сделать `Close` реализация идентична `Dispose` и рассмотрите возможность реализации `IDisposable.Dispose` метод явным образом.  
  
```  
public class Stream : IDisposable {  
    IDisposable.Dispose(){  
        Close();  
    }  
    public void Close(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
<a name="finalizable_types"></a>   
## Финализируемое типов  
 Завершаемые типы — это типы, которые расширяют базовый шаблон Dispose путем переопределения метода завершения и предоставляя код финализации, в `Dispose(bool)` метод.  
  
 Методы завершения их сложно реализовать правильно, в первую очередь потому, что нельзя сделать некоторые \(обычно действуют\) предположения о состоянии системы во время их выполнения. Тщательного анализа нужно учитывать следующие рекомендации.  
  
 Обратите внимание, что некоторые правила применяются не только к `Finalize` метод, но в любой код вызывается из метода завершения. В случае базовый шаблон Dispose определенные ранее, это означает логику, которая выполняется внутри `Dispose(bool disposing)` при `disposing` параметр имеет значение false.  
  
 Если базовый класс уже завершаемые и реализует базовый шаблон Dispose, не должен переопределять `Finalize` еще раз. Следует вместо этого просто переопределить `Dispose(bool)` метод для предоставления логики очистки дополнительных ресурсов.  
  
 Следующий код является примером завершаемые типа:  
  
```  
public class ComplexResourceHolder : IDisposable {  
  
    private IntPtr buffer; // unmanaged memory buffer  
    private SafeHandle resource; // disposable handle to a resource  
  
    public ComplexResourceHolder(){  
        this.buffer = ... // allocates memory  
        this.resource = ... // allocates the resource  
    }  
  
    protected virtual void Dispose(bool disposing){  
            ReleaseBuffer(buffer); // release unmanaged memory  
        if (disposing){ // release other disposable objects  
            if (resource!= null) resource.Dispose();  
        }  
    }  
  
    ~ ComplexResourceHolder(){  
        Dispose(false);  
    }  
  
    public void Dispose(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
 **ИЗБЕЖАТЬ X** создания типов подлежащим завершению.  
  
 Внимательно рассмотрите все случаи, в которой вы считаете, что необходим метод завершения. Есть настоящие затраты, связанные с экземплярами с финализаторами, с точки зрения сложность кода и производительности. Предпочтение с помощью оболочки ресурса, например <xref:System.Runtime.InteropServices.SafeHandle> для инкапсуляции неуправляемых ресурсов, где это возможно, в этом случае метод завершения необязательной поскольку отвечает оболочки для очистки ресурсов.  
  
 **X не** сделать типы значений, подлежащим завершению.  
  
 Только ссылочные типы фактически получить закрыты средой CLR, и таким образом будет игнорироваться любая попытка поместить метод завершения для типа значения. Это правило применяется компиляторы C\# и C\+\+.  
  
 **✓ сделать** сделать тип завершаемых, если тип несет ответственность за освобождение неуправляемых ресурсов, который не имеет свой собственный метод завершения.  
  
 При реализации метода завершения, просто вызовите `Dispose(false)` и поместить всю логику очистки ресурсов внутри `Dispose(bool disposing)` метод.  
  
```  
public class ComplexResourceHolder : IDisposable {  
  
    ~ ComplexResourceHolder(){  
        Dispose(false);  
    }  
  
    protected virtual void Dispose(bool disposing){  
        ...  
    }  
}  
```  
  
 **✓ сделать** реализовать базовый шаблон Dispose на каждый тип подлежащим завершению.  
  
 Это предоставляет пользователям типа средства для явного выполнения детерминированная Очистка те же ресурсы, за которые отвечает метод завершения.  
  
 **X не** доступ к любой Завершаемые объекты в ветвь кода метода завершения, поскольку существует значительный риск, что они будут уже был финализирован.  
  
 Например, финализируемые объект A содержит ссылку на другой объект подлежащим завершению B нельзя использовать надежно B в виде метода завершения, или наоборот. Методы завершения вызываются в произвольном порядке \(хватает слабые гарантия упорядочивания критическое завершение\).  
  
 Также следует помнить, что объекты, хранящиеся в статических переменных будет собрана в определенных точках во время выгрузки домена приложения или при выходе из процесса. Доступ к статической переменной, ссылающейся на объект подлежащим завершению \(или вызова статического метода, который может использовать значения, хранящиеся в статических переменных\) не может быть безопасно if <xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> возвращает значение true.  
  
 **✓ сделать** сделать ваш `Finalize` защищенного метода.  
  
 C\#, C\+\+ и VB.NET разработчики не волноваться об этом, так как компиляторы позволяют применять это правило.  
  
 **X не** escape let исключения из метода завершения логики, за исключением критических системных сбоев.  
  
 Если исключение вызывается из метода завершения, среда CLR будет завершать работу всего процесса \(начиная с .NET Framework версии 2.0\), предотвращая других финализаторов выполнения и ресурсы освобождение контролируемым образом.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** Создание и использование критических завершению объект \(тип в иерархии типов, содержащий <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>\) в ситуациях, в которых финализатор абсолютно должны выполняться даже в случае домена принудительного приложения выгружается и отменой потоков.  
  
 *Частей © 2005, 2009 корпорации Microsoft. Все права защищены.*  
  
 *Воспроизведены разрешении Пирсон образования, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для повторного использования библиотеки .NET, второе издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс опубликованы 22 октября 2008 г., издательство Addison\-Wesley Professional как часть цикла разработки Microsoft Windows.*  
  
## См. также  
 <xref:System.IDisposable.Dispose%2A?displayProperty=fullName>   
 <xref:System.Object.Finalize%2A?displayProperty=fullName>   
 [Рекомендации по проектированию Framework](../../../docs/standard/design-guidelines/index.md)   
 [Общие шаблоны разработки](../../../docs/standard/design-guidelines/common-design-patterns.md)   
 [Garbage Collection](../../../docs/standard/garbage-collection/index.md)