---
title: Шаблон ликвидации
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Dispose method
- class library design guidelines [.NET Framework], Dispose method
- class library design guidelines [.NET Framework], Finalize method
- customizing Dispose method name
- Finalize method
ms.assetid: 31a6c13b-d6a2-492b-9a9f-e5238c983bcb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bdcb746ae2d8c2262b0cd0c6c9dcaababb12bd63
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="dispose-pattern"></a>Шаблон ликвидации
Все программы получить один или несколько системных ресурсов, таких как память, дескрипторы системы или подключения к базе данных в процессе их выполнения. Разработчикам нужно соблюдать осторожность при использовании таких системных ресурсов, так как они должны быть освобождены после их получения и использования.  
  
 Среда CLR поддерживает автоматическое управление памятью. Управляемой памяти (память, выделенную с помощью оператора C# `new`) не должны быть освобождены явно. Оно автоматически освобождается сборщиком мусора (GC). Это освобождает разработчиков от трудоемкой и сложной задачи по освобождению памяти и был одним из основных причин для беспрецедентную производительности, предоставляемых платформой .NET Framework.  
  
 К сожалению управляемой памяти — лишь одна из многих типов системных ресурсов. Ресурсы Кроме управляемой памяти по-прежнему необходимо явным образом освободить и называются неуправляемые ресурсы. Сборка Мусора была специально не предназначен для управления таких неуправляемых ресурсов, это означает, что ответственность за управление неуправляемые ресурсы лежит на разработчике разработчики.  
  
 Среда CLR предоставляет помощь в освобождения неуправляемых ресурсов. <xref:System.Object?displayProperty=nameWithType> Объявляет виртуальный метод <xref:System.Object.Finalize%2A> (также называемый метод завершения), вызывается сборщик мусора перед памяти объекта будет удален сборщиком Мусора и может быть переопределен для освобождения неуправляемых ресурсов. Типы, переопределять финализатор называются завершаемые типов.  
  
 Несмотря на то, что методы завершения вступают в силу в некоторых сценариях очистки, они имеют два существенные недостатки:  
  
-   Метод завершения вызывается, когда сборщик Мусора обнаруживает, что объект является доступным для коллекции. Это происходит при некоторых неопределенные периода времени после ресурс больше не нужен. Задержка между когда разработчик может или нужно для освобождения ресурсов и времени, фактически освобождения ресурса, метод завершения может быть неприемлемо, в программах, которые запрашивают много нехватке ресурсов (ресурсы, которые могут быть легко исчерпана) или в случаи, в которых ресурсы дороже используется (например, буферов большого объема неуправляемой памяти).  
  
-   Когда среда CLR должен вызывать метод завершения, он должен отложенный сбор данных памяти объекта до следующего округления сборки мусора (в методах завершения выполнения между коллекций). Это означает, что памяти объекта (и все объекты, на который он ссылается) не будет освобожден для более длительный период времени.  
  
 Таким образом, полагаясь исключительно на методы завершения не будет соответствовать во многих сценариях, когда важно для освобождения неуправляемых ресурсов, как можно скорее, при работе с дефицитные ресурсы или в высокой высокопроизводительных сценариев, в которых добавленных издержек GC для выполнения операции Finalize недопустима.  
  
 Платформа предоставляет <xref:System.IDisposable?displayProperty=nameWithType> интерфейс, который должен быть реализован для предоставления разработчику возможность вручную освободить неуправляемые ресурсы, как только они не нужны. Он также предоставляет <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод, который можно определить сервер глобального Каталога, что объект был вручную удален и не требует финализации, в этом случае памяти объекта могут быть освобождены ранее. Типы, реализующие `IDisposable` интерфейса называются высвобождаемые типы.  
  
 Шаблон Dispose предназначен для стандартизации использования и реализации методов завершения и `IDisposable` интерфейса.  
  
 Основные причины использования шаблона является Уменьшение сложности реализации <xref:System.Object.Finalize%2A> и <xref:System.IDisposable.Dispose%2A> методы. Сложность состоит в том, что методы совместно используют некоторые, но не все ветви кода (различия описаны далее в этой главе). Кроме того существует исторических причин для некоторых элементов, относящиеся к эволюции языковая поддержка для управления ресурсами детерминированным шаблона.  
  
 **✓ СДЕЛАТЬ** реализация базовый шаблон Dispose для типов, содержащей экземпляры высвобождаемые типы. В разделе [базовый шаблон Dispose](#basic_pattern) подробные сведения о базовый шаблон см.  
  
 Если тип отвечает в течение времени существования другие высвобождаемые объекты, разработчики должны способ удалить, слишком. С помощью контейнера `Dispose` метод — удобный способ сделать это невозможно.  
  
 **✓ СДЕЛАТЬ** реализовать базовый шаблон Dispose и предоставлять метод завершения для типов, удерживающим ресурсы, которые должны быть освобождены явно и, не имеющие методов завершения.  
  
 Например шаблон должен реализовываться в типах хранения буферов неуправляемой памяти. [Завершаемые типы](#finalizable_types) разделе представлены рекомендации, относящиеся к реализации методов завершения.  
  
 **✓ Попробуйте** реализации базовый шаблон Dispose в классах, сами не содержат неуправляемых ресурсов или высвобождаемые объекты но скорее всего имеются подтипы, которые выполняют.  
  
 Хорошим примером этого является <xref:System.IO.Stream?displayProperty=nameWithType> класса. Хотя это абстрактный базовый класс, который не содержит какие-либо ресурсы, большинство из его подклассов выполните и по этой причине реализует этот шаблон.  
  
<a name="basic_pattern"></a>   
## <a name="basic-dispose-pattern"></a>Шаблон удаления Basic  
 Включает базовую реализацию шаблона `System.IDisposable` интерфейс и объявление `Dispose(bool)` метод, который реализует все логика очистки ресурсов совместно `Dispose` метод и необязательный метод завершения.  
  
 В следующем примере показана простая реализация из базового шаблона:  
  
```  
public class DisposableResourceHolder : IDisposable {  
  
    private SafeHandle resource; // handle to a resource  
  
    public DisposableResourceHolder(){  
        this.resource = ... // allocates the resource  
    }  
  
    public void Dispose(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
  
    protected virtual void Dispose(bool disposing){  
        if (disposing){  
            if (resource!= null) resource.Dispose();  
        }  
    }  
}  
```  
  
 Логический параметр `disposing` показывает, вызван ли метод из `IDisposable.Dispose` реализацию или из метода завершения. `Dispose(bool)` Реализации следует проверить параметр перед получением доступа к другим объектам ссылки (например, поле ресурса в предыдущем примере). Такие объекты должны быть доступны только при вызове метода из `IDisposable.Dispose` реализацию (если `disposing` параметр имеет значение true). Если метод вызывается из метода завершения (`disposing` имеет значение false), другие объекты не должны быть доступны. Причина заключается в том, что объекты были закрыты в непредсказуемой последовательности и таким образом они или любой из их зависимостей может быть уже закрыт.  
  
 Кроме того этот раздел относится к классам с базовым, который не реализует шаблон Dispose. При наследовании от класса, который уже реализует шаблон просто переопределить `Dispose(bool)` метод для предоставления дополнительных ресурсов логика очистки.  
  
 **СДЕЛАТЬ ✓** объявить `protected virtual void Dispose(bool disposing)` метод для централизации всю логику, связанную с освобождением неуправляемые ресурсы.  
  
 Очистка всех ресурсов должны происходить в этот метод. Метод вызывается из метода завершения обоих и `IDisposable.Dispose` метод. Параметр будет иметь значение false, если вызывался из внутри метода завершения. Его следует использовать, чтобы убедиться, что любой код, выполняемый во время завершения не имеет доступа к другим объектам. В следующем разделе описываются подробности реализации методов завершения.  
  
```  
protected virtual void Dispose(bool disposing){  
    if (disposing){  
        if (resource!= null) resource.Dispose();  
    }  
}  
```  
  
 **СДЕЛАТЬ ✓** реализовать `IDisposable` интерфейс, просто вызвав `Dispose(true)` следуют `GC.SuppressFinalize(this)`.  
  
 Вызов `SuppressFinalize` следует только в случае `Dispose(true)` выполняется успешно.  
  
```  
public void Dispose(){  
    Dispose(true);  
    GC.SuppressFinalize(this);  
}  
```  
  
 **X не** сделать без параметров `Dispose` виртуального метода.  
  
 `Dispose(bool)` Метод является тот, который должен быть переопределен в подклассах.  
  
```  
// bad design  
public class DisposableResourceHolder : IDisposable {  
    public virtual void Dispose(){ ... }  
    protected virtual void Dispose(bool disposing){ ... }  
}  
  
// good design  
public class DisposableResourceHolder : IDisposable {  
    public void Dispose(){ ... }  
    protected virtual void Dispose(bool disposing){ ... }  
}  
```  
  
 **X не** объявлять все перегрузки `Dispose` не `Dispose()` и `Dispose(bool)`.  
  
 `Dispose` следует рассматривать является зарезервированным словом, для обеспечения пожалейте этот шаблон и предотвращения путаницы между компиляторы, разработчиков и пользователей. В некоторых языках можно автоматически реализовывать этот шаблон для определенных типов.  
  
 **СДЕЛАТЬ ✓** Разрешить `Dispose(bool)` метод, который вызывается несколько раз. Метод можно не выполнять никаких действий после первого вызова.  
  
```  
public class DisposableResourceHolder : IDisposable {  
  
    bool disposed = false;  
  
    protected virtual void Dispose(bool disposing){  
        if(disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **X ИЗБЕГАЙТЕ** исключения изнутри `Dispose(bool)` только под критических ситуаций, где процесс, содержащий повреждена (утечки, несогласованные общее состояние и т. д.).  
  
 Пользователи ожидают, что вызов `Dispose` не вызовет исключение.  
  
 Если `Dispose` может вызвать исключение, дальнейшие логика очистки в блок finally не будет выполняться. Чтобы обойти это, пользователи должны будут программы-оболочки для каждого вызова к `Dispose` (в пределах блока finally!) в блоке try, что приводит к очень сложной очистки обработчиков. Если при выполнении `Dispose(bool disposing)` метод никогда не выдал исключение, если disposing имеет значение false. Таким образом, процесс будет прерван при выполнении внутри контекста метода завершения.  
  
 **СДЕЛАТЬ ✓** throw <xref:System.ObjectDisposedException> из любой элемент, который нельзя использовать после удаления объекта.  
  
```  
public class DisposableResourceHolder : IDisposable {  
    bool disposed = false;  
    SafeHandle resource; // handle to a resource  
  
    public void DoSomething(){  
           if(disposed) throw new ObjectDisposedException(...);  
        // now call some native methods using the resource   
            ...  
    }  
    protected virtual void Dispose(bool disposing){  
        if(disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **✓ Попробуйте** предоставление метода `Close()`, в дополнение к `Dispose()`, если закрыть является стандартной терминологии в области.  
  
 При этом важно сделать `Close` реализация идентична `Dispose` и рассмотрите возможность реализации `IDisposable.Dispose` метод явным образом.  
  
```  
public class Stream : IDisposable {  
    IDisposable.Dispose(){  
        Close();  
    }  
    public void Close(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
<a name="finalizable_types"></a>   
## <a name="finalizable-types"></a>Завершаемые типов  
 Завершаемые типами являются типы, расширяющие базовый шаблон Dispose путем переопределения метода завершения и предоставляя код финализации в `Dispose(bool)` метод.  
  
 Методы завершения их сложно реализовать правильно, в первую очередь, так как не удается сделать определенные (обычно действуют) предположения о состоянии системы во время их выполнения. Тщательного анализа нужно учитывать следующие рекомендации.  
  
 Обратите внимание, что некоторые правила применяются не только к `Finalize` метода, но в любой код вызывается из метода завершения. В случае базовый шаблон Dispose ранее определен, это означает логику, которая выполняется внутри `Dispose(bool disposing)` при `disposing` параметр имеет значение false.  
  
 Если базовый класс уже является завершаемые и реализует базовый шаблон Dispose, не должен переопределять `Finalize` еще раз. Следует вместо этого просто переопределить `Dispose(bool)` метод для предоставления дополнительных ресурсов логика очистки.  
  
 Ниже приведен пример завершаемые типа:  
  
```  
public class ComplexResourceHolder : IDisposable {  
  
    private IntPtr buffer; // unmanaged memory buffer  
    private SafeHandle resource; // disposable handle to a resource  
  
    public ComplexResourceHolder(){  
        this.buffer = ... // allocates memory  
        this.resource = ... // allocates the resource  
    }  
  
    protected virtual void Dispose(bool disposing){  
            ReleaseBuffer(buffer); // release unmanaged memory  
        if (disposing){ // release other disposable objects  
            if (resource!= null) resource.Dispose();  
        }  
    }  
  
    ~ ComplexResourceHolder(){  
        Dispose(false);  
    }  
  
    public void Dispose(){  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
 **X ИЗБЕГАЙТЕ** внесения завершаемые типов.  
  
 Внимательно рассмотрите все случаи, в котором вы думаете, что необходим метод завершения. Нет реальную затраты, связанные с экземплярами с методов завершения, с точки зрения сложности кода и производительности. Предпочтительно с помощью оболочки ресурсов, таких как <xref:System.Runtime.InteropServices.SafeHandle> для инкапсуляции неуправляемых ресурсов, где это возможно, в этом случае метод завершения необязательной поскольку оболочки отвечает за очистки ресурсов.  
  
 **X не** сделать завершаемые типов значений.  
  
 Только ссылочные типы фактически получить закрыты средой CLR, и таким образом любая попытка поместить метод завершения для типа значения будут игнорироваться. Компиляторы C# и C++ обеспечивает применение этого правила.  
  
 **✓ СДЕЛАТЬ** тип стал завершаемые, если тип отвечает за освобождение неуправляемых ресурсов, не имеет свой собственный метод завершения.  
  
 При реализации метода завершения, просто вызовите `Dispose(false)` и поместите вся логика очистки ресурсов внутри `Dispose(bool disposing)` метод.  
  
```  
public class ComplexResourceHolder : IDisposable {  
  
    ~ ComplexResourceHolder(){  
        Dispose(false);  
    }  
  
    protected virtual void Dispose(bool disposing){  
        ...  
    }  
}  
```  
  
 **✓ СДЕЛАТЬ** реализовать базовый шаблон Dispose для каждого типа подлежащим завершению.  
  
 Это предоставляет пользователям типа средства для явного выполнения детерминированной очистки те же ресурсы, за которые отвечает метод завершения.  
  
 **X не** доступ к любой это Завершаемые объекты в ветвь кода метода завершения, так как имеется значительный риск, что они будут уже завершен.  
  
 Например, что подлежащий завершению объект A содержит ссылку на другой объект подлежащим завершению B нельзя использовать надежно B в виде метода завершения, или наоборот. Методы завершения вызываются в произвольном порядке (во всех остальных случаях слабое гарантии порядка сортировки критическое завершение).  
  
 Кроме того помните, что объекты, хранящиеся в статических переменных будет собираются в некоторых точках во время выгрузки домена приложения или при выходе из процесса. Доступ к статической переменной, которая ссылается на объект подлежащим завершению (или вызов статического метода, который может использовать значения, хранящиеся в статических переменных) не может быть безопасно if <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> возвращает значение true.  
  
 **СДЕЛАТЬ ✓** сделать ваш `Finalize` метод, защищенный.  
  
 Разработчикам C#, C++ и VB.NET нет необходимости беспокоиться об этом, так как компиляторы позволяют применять это правило.  
  
 **X не** escape позволяют исключения из метода завершения логики, за исключением критических системных сбоев.  
  
 Если исключение вызывается из метода завершения, среда CLR будет завершать работу всего процесса (начиная с .NET Framework версии 2.0), другие методы завершения, предотвращая выполнение и ресурсы освобождение контролируемым образом.  
  
 **✓ Попробуйте** Создание и использование критических завершению объект (тип с типом иерархии, которая содержит <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>) для ситуаций, в которых есть метод завершения абсолютно необходимо выполнить даже в случае выгрузки домена приложения принудительного и поток прерывает выполнение.  
  
 *Фрагменты © 2005, 2009 корпорации Майкрософт. Все права защищены.*  
  
 *Перепечатываются разрешении Пирсона для образовательных учреждений, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2-е издание](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс, опубликованные 22 октября 2008 г., Addison-Wesley Professional в составе ряда разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также  
 <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>  
 <xref:System.Object.Finalize%2A?displayProperty=nameWithType>  
 [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)  
 [Обычные шаблоны разработки](../../../docs/standard/design-guidelines/common-design-patterns.md)  
 [Сборка мусора](../../../docs/standard/garbage-collection/index.md)
