---
title: Шаблон ликвидации
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Dispose method
- class library design guidelines [.NET Framework], Dispose method
- class library design guidelines [.NET Framework], Finalize method
- customizing Dispose method name
- Finalize method
ms.assetid: 31a6c13b-d6a2-492b-9a9f-e5238c983bcb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: ff52e17cfe4a4236e4d165c0961ca3a23fed9a72
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2018
ms.locfileid: "43864648"
---
# <a name="dispose-pattern"></a>Шаблон ликвидации
Все программы получить один или несколько системных ресурсов, таких как память, дескрипторы системы и подключения к базе данных, в ходе их выполнения. Разработчикам нужно соблюдать осторожность при использовании таких системных ресурсов, так как они должны быть освобождены после их получения и использования.  
  
 Среда CLR поддерживает автоматическое управление памятью. Управляемая память (память, выделенную с помощью оператора C# `new`) не должны быть сняты явно. Он автоматически освобождается сборщиком мусора (GC). Это освобождает разработчиков от нудной и сложной задачи по освобождению памяти и была одной из основных причин для беспрецедентной производительности, обеспечиваемая платформой .NET Framework.  
  
 К сожалению управляемой памяти — один из многих типов системных ресурсов. Ресурсов, отличных от управляемой памяти по-прежнему должны быть сняты явно и называются неуправляемые ресурсы. Сборщик Мусора был специально не предназначен для управления таких неуправляемых ресурсов, что означает, что, отвечает за управление неуправляемыми ресурсами заключается в руках разработчиков.  
  
 Среда CLR предоставляет помощь в освобождения неуправляемых ресурсов. <xref:System.Object?displayProperty=nameWithType> Объявляет виртуальный метод <xref:System.Object.Finalize%2A> (также называемый метод завершения) вызывается сборщик мусора, прежде чем памяти объекта будет удален при сборке Мусора и может быть переопределен для освобождения неуправляемых ресурсов. Типы, которые переопределяют метод завершения, называются завершаемые типов.  
  
 Несмотря на то, что методы завершения эффективны в некоторых сценариях очистки, у них есть два существенные недостатки:  
  
-   Метод finalizer вызывается, когда сборщик Мусора обнаруживает, что объект является доступным для коллекции. Это происходит в некоторых неопределенного периода времени после ресурс больше не нужен. Задержка между когда разработчик может либо вы хотите для освобождения ресурсов и времени, когда ресурс освобождается фактически финализатором может быть неприемлемо в программах, которые запрашивают много дефицитные ресурсы (ресурсы, которые можно легко исчерпать) или в случаи, в которых ресурсы довольно сложно поддерживать используется (например, буферов большого объема неуправляемой памяти).  
  
-   Когда среда CLR должен вызывать метод завершения, его необходимо отложенный сбор данных памяти объекта до следующей округления сбора мусора (методы завершения, выполните между коллекциями). Это означает, что памяти объекта (и все объекты, которые он ссылается) не будет освобожден для более длительного периода времени.  
  
 Таким образом, полагаясь исключительно на методы завершения могут не подходить во многих ситуациях, когда важно освободить неуправляемые ресурсы, как можно скорее, при работе с дефицитные ресурсы, или в высокой производительности сценариев, в которых добавлена мусора выполнения финализации неприемлем.  
  
 Платформа предоставляет <xref:System.IDisposable?displayProperty=nameWithType> интерфейс, который должен быть реализован для предоставления разработчику ручной способ освободить неуправляемые ресурсы, как только они не нужны. Он также предоставляет <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод, который можно обязать сборщик Мусора, объект был вручную удален и не требует финализации, в этом случае памяти объекта могут быть освобождены ранее. Типы, реализующие `IDisposable` интерфейса называются уничтожаемых типов.  
  
 Шаблон Dispose предназначен для стандартизации использования и реализации методов завершения и `IDisposable` интерфейс.  
  
 Основной шаблон призвана уменьшить сложность реализации <xref:System.Object.Finalize%2A> и <xref:System.IDisposable.Dispose%2A> методы. Сложность состоит в том, что методы используют некоторые, но не все ветви кода (различия описаны далее в этой главе). Кроме того являются историческим причинам, для некоторых элементов шаблона, связанными с развитием языковая поддержка управления ресурсами детерминированной.  
  
 **✓ DO** реализация базовый шаблон Dispose для типов, содержащей экземпляры высвобождаемые типы. См. в разделе [базовый шаблон Dispose](#basic_pattern) Дополнительные сведения об базовый шаблон.  
  
 Если тип отвечает в течение времени существования других Уничтожаемые объекты, разработчикам необходим способ удалить, слишком. С помощью контейнера `Dispose` метод является удобным способом для этого.  
  
 **✓ DO** реализовать базовый шаблон Dispose и предоставлять метод завершения для типов, удерживающим ресурсы, которые должны быть освобождены явно и, не имеющие методов завершения.  
  
 Например шаблон должен быть реализован для типов хранения буферов неуправляемой памяти. [Завершаемые типы](#finalizable_types) разделе представлены рекомендации, относящиеся к реализации методов завершения.  
  
 **✓ CONSIDER** реализации базовый шаблон Dispose в классах, сами не содержат неуправляемых ресурсов или высвобождаемые объекты но скорее всего имеются подтипы, которые выполняют.  
  
 Хорошим примером этого является <xref:System.IO.Stream?displayProperty=nameWithType> класса. Несмотря на то, что это абстрактный базовый класс, который не содержит все ресурсы, у большинства из его подклассов, и по этой причине реализует этот шаблон.  
  
<a name="basic_pattern"></a>   
## <a name="basic-dispose-pattern"></a>Шаблон удаления базовый  
 Включает базовую реализацию шаблона `System.IDisposable` интерфейс и объявление `Dispose(bool)` метод, который реализует всю логику очистки ресурсов, совместный доступ к `Dispose` метод и необязательный метод завершения.  
  
 В следующем примере показана простая реализация из базового шаблона:  
  
```csharp
public class DisposableResourceHolder : IDisposable {  
  
    private SafeHandle resource; // handle to a resource  
  
    public DisposableResourceHolder() {  
        this.resource = ... // allocates the resource  
    }  
  
    public void Dispose() {  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
  
    protected virtual void Dispose(bool disposing) {  
        if (disposing) {  
            if (resource!= null) resource.Dispose();  
        }  
    }  
}  
```  
  
 Логический параметр `disposing` указывает, был ли метод вызван из `IDisposable.Dispose` реализации или из метода завершения. `Dispose(bool)` Реализации следует проверить параметр перед доступом к другим ссылаться на объекты (например, поле ресурса в предыдущем примере). Такие объекты должны быть доступны, только если метод вызывается из `IDisposable.Dispose` реализации (при `disposing` параметр имеет значение true). Если метод вызывается из метода завершения (`disposing` имеет значение false), другие объекты не должны быть доступны. Причина в том что завершаются объекты, в непредсказуемой последовательности, и поэтому они, или любой из их зависимостей может быть уже закрыт.  
  
 Кроме того этот раздел относится к классам с базовым, который не реализует шаблон Dispose. Если вы наследуете от класса, который уже реализует шаблон, просто заменить `Dispose(bool)` метод, чтобы предоставить логику очистки дополнительных ресурсов.  
  
 **✓ DO** объявить `protected virtual void Dispose(bool disposing)` метод для централизации всю логику, связанную с освобождением неуправляемые ресурсы.  
  
 Очистка всех ресурсов должно выполняться в этом методе. Метод вызывается из оба метода завершения и `IDisposable.Dispose` метод. Параметр будет иметь значение false, если вызван метод из внутри метода завершения. Его следует использовать, чтобы убедиться, что любой код, выполняемый во время завершения не имеет доступа к другим объектам. В следующем разделе описываются подробности реализации методов завершения.  
  
```csharp
protected virtual void Dispose(bool disposing) {  
    if (disposing) {  
        if (resource!= null) resource.Dispose();  
    }  
}  
```  
  
 **✓ DO** реализовать `IDisposable` интерфейс, просто вызвав `Dispose(true)` следуют `GC.SuppressFinalize(this)`.  
  
 Вызов `SuppressFinalize` произойдет только в том случае, если `Dispose(true)` выполняется успешно.  
  
```csharp
public void Dispose(){  
    Dispose(true);  
    GC.SuppressFinalize(this);  
}  
```  
  
 **X DO NOT** сделать без параметров `Dispose` виртуального метода.  
  
 `Dispose(bool)` Метод является тот, который должен переопределяться подклассами.  
  
```csharp
// bad design  
public class DisposableResourceHolder : IDisposable {  
    public virtual void Dispose() { ... }  
    protected virtual void Dispose(bool disposing) { ... }  
}  
  
// good design  
public class DisposableResourceHolder : IDisposable {  
    public void Dispose() { ... }  
    protected virtual void Dispose(bool disposing) { ... }  
}  
```  
  
 **X DO NOT** объявлять все перегрузки `Dispose` не `Dispose()` и `Dispose(bool)`.  
  
 `Dispose` можно рассматривать зарезервированным словом для обозначения этот шаблон и избежать путаницы между компиляторы, разработчиков и пользователей. В некоторых языках можно автоматически реализовать этот шаблон для определенных типов.  
  
 **✓ DO** Разрешить `Dispose(bool)` метод, который вызывается несколько раз. Метод можно ничего не делать после первого вызова.  
  
```csharp
public class DisposableResourceHolder : IDisposable {  
  
    bool disposed = false;  
  
    protected virtual void Dispose(bool disposing) {  
        if (disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **X AVOID** исключения изнутри `Dispose(bool)` только под критических ситуаций, где процесс, содержащий повреждена (утечки, несогласованные общее состояние и т. д.).  
  
 Пользователи ожидают, что вызов `Dispose` не приведет к появлению исключения.  
  
 Если `Dispose` может вызвать исключение, дальнейшей логики очистки в блок finally не будет выполняться. Чтобы обойти эту проблему, пользователю может потребоваться перенос при каждом вызове `Dispose` (в блоке finally!) в блоке try, что приводит к очень сложные очистки обработчиков. Если выполнение `Dispose(bool disposing)` метода, никогда не выдал исключение, если disposing имеет значение false. Таким образом, процесс будет прерван при выполнении внутри контекста метода завершения.  
  
 **✓ DO** throw <xref:System.ObjectDisposedException> из любой элемент, который нельзя использовать после удаления объекта.  
  
```csharp
public class DisposableResourceHolder : IDisposable {  
    bool disposed = false;  
    SafeHandle resource; // handle to a resource  
  
    public void DoSomething() {  
        if (disposed) throw new ObjectDisposedException(...);  
        // now call some native methods using the resource   
        ...  
    }  
    protected virtual void Dispose(bool disposing) {  
        if (disposed) return;  
        // cleanup  
        ...  
        disposed = true;  
    }  
}  
```  
  
 **✓ CONSIDER** предоставление метода `Close()`, в дополнение к `Dispose()`, если закрыть является стандартной терминологии в области.  
  
 При этом очень важно, что вносимые `Close` реализация идентична `Dispose` и рассмотрите возможность реализации `IDisposable.Dispose` метод явным образом.  
  
```csharp
public class Stream : IDisposable {  
    IDisposable.Dispose() {  
        Close();  
    }  
    public void Close() {  
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
<a name="finalizable_types"></a>   
## <a name="finalizable-types"></a>Финализируемое типы  
 Финализируемое типы являются типами, которые расширяют базовый шаблон Dispose, переопределение метода завершения и предоставляя код финализации в `Dispose(bool)` метод.  
  
 Методы завершения их сложно реализовать правильно, в первую очередь потому, что нельзя сделать определенные (обычно) допущений о состоянии системы во время их выполнения. Тщательного анализа нужно учитывать следующие рекомендации.  
  
 Обратите внимание, что некоторые рекомендации применяются не только к `Finalize` метод, но для кода, вызывается из метода завершения. В случае базовый шаблон Dispose определен ранее, это означает логику, которая выполняется внутри `Dispose(bool disposing)` при `disposing` параметр имеет значение false.  
  
 Если базовый класс уже завершаемые и реализует базовый шаблон Dispose, не следует переопределять `Finalize` еще раз. Следует вместо этого просто переопределить `Dispose(bool)` метод, чтобы предоставить логику очистки дополнительных ресурсов.  
  
 Следующий код является примером завершаемые типа:  
  
```csharp
public class ComplexResourceHolder : IDisposable {  
  
    private IntPtr buffer; // unmanaged memory buffer  
    private SafeHandle resource; // disposable handle to a resource  
  
    public ComplexResourceHolder() {  
        this.buffer = ... // allocates memory  
        this.resource = ... // allocates the resource  
    }  
  
    protected virtual void Dispose(bool disposing) {  
            ReleaseBuffer(buffer); // release unmanaged memory  
        if (disposing) { // release other disposable objects  
            if (resource!= null) resource.Dispose();  
        }  
    }  
  
    ~ComplexResourceHolder() {
        Dispose(false);  
    }  
  
    public void Dispose() {
        Dispose(true);  
        GC.SuppressFinalize(this);  
    }  
}  
```  
  
 **X AVOID** внесения завершаемые типов.  
  
 Внимательно рассмотрите любой вариант, в которой вы считаете, что необходим метод завершения. Что представляет собой реальное затраты, связанные с экземплярами с методы завершения, зрения сложность кода и производительности. Предпочитать, с помощью оболочки ресурса, например <xref:System.Runtime.InteropServices.SafeHandle> для инкапсуляции неуправляемых ресурсов, где это возможно, в этом случае метод завершения становится ненужным, так как оболочка отвечает за собственную очистки ресурсов.  
  
 **X DO NOT** сделать завершаемые типов значений.  
  
 Только ссылочные типы фактически получить работу над средой CLR, и поэтому любая попытка поместить метод завершения для типа значения, будет игнорироваться. Компиляторы C# и C++ обеспечивает применение этого правила.  
  
 **✓ DO** тип стал завершаемые, если тип отвечает за освобождение неуправляемых ресурсов, не имеет свой собственный метод завершения.  
  
 При реализации метода завершения, просто вызовите `Dispose(false)` и поместить всю логику очистки ресурсов внутри `Dispose(bool disposing)` метод.  
  
```csharp
public class ComplexResourceHolder : IDisposable {  
  
    ~ComplexResourceHolder() {
        Dispose(false);  
    }  
  
    protected virtual void Dispose(bool disposing) {
        ...  
    }  
}  
```  
  
 **✓ DO** реализовать базовый шаблон Dispose для каждого типа подлежащим завершению.  
  
 Это дает пользователям типа означает, что для явного выполнения детерминированная очистка этих же ресурсов, для которых отвечает метод завершения.  
  
 **X DO NOT** доступ к любой это Завершаемые объекты в ветвь кода метода завершения, так как имеется значительный риск, что они будут уже завершен.  
  
 Например, финализируемые объект А, имеющий ссылку на другой объект завершаемые B нельзя использовать надежно B в виде метода завершения, или наоборот. Методы завершения вызываются в произвольном порядке (хватает слабые гарантии упорядочения критическое завершение).  
  
 Кроме того Имейте в виду, что объекты, хранящиеся в статических переменных будет собрана в определенных точках во время выгрузки домена приложения или при выходе из процесса. Доступ к статическую переменную, которая ссылается на объект завершаемые (или вызов статического метода, который может использовать значения, хранящиеся в статических переменных) не может быть безопасно if <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> возвращает значение true.  
  
 **✓ DO** сделать ваш `Finalize` метод, защищенный.  
  
 Разработчики C#, C++ и VB.NET не обязательно волноваться об этом, так как компиляторы позволяют применить это правило.  
  
 **X DO NOT** escape позволяют исключения из метода завершения логики, за исключением критических системных сбоев.  
  
 Если исключение из метода завершения, среда CLR будет завершать процесс работы весь процесс (начиная с .NET Framework версии 2.0), другие методы завершения, предотвращая выполнение и ресурсы от освобождения, контролируемым образом.  
  
 **✓ CONSIDER** Создание и использование критических завершению объект (тип с типом иерархии, которая содержит <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>) для ситуаций, в которых есть метод завершения абсолютно необходимо выполнить даже в случае выгрузки домена приложения принудительного и поток прерывает выполнение.  
  
 *Фрагменты: © Корпорация Майкрософт (Microsoft Corporation), 2005, 2009. Все права защищены.*  
  
 *Перепечатано с разрешения Pearson Education, Inc. из книги [Инфраструктура программных проектов. Соглашения, идиомы и шаблоны для многократно используемых библиотек .NET (2-е издание)](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619), авторы: Кржиштоф Цвалина (Krzysztof Cwalina) и Брэд Абрамс (Brad Abrams). Книга опубликована 22 октября 2008 г. издательством Addison-Wesley Professional в рамках серии, посвященной разработке для Microsoft Windows.*  
  
## <a name="see-also"></a>См. также

- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>  
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>  
- [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)  
- [Обычные шаблоны разработки](../../../docs/standard/design-guidelines/common-design-patterns.md)  
- [Сборка мусора](../../../docs/standard/garbage-collection/index.md)
