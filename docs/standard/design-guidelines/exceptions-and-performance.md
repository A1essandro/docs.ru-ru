---
title: "Исключения и производительность"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- tester-doer pattern
- TryParse pattern
- exceptions, throwing
- exceptions, performance
- throwing exceptions, performance
ms.assetid: 3ad6aad9-08e6-4232-b336-0e301f2493e6
caps.latest.revision: "12"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 9c2d7cfcb228c492d2adbe614d0ed88a3b02bb68
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="exceptions-and-performance"></a>Исключения и производительность
Одна из распространенных проблем, связанных с исключениями установлено, если они используются для кода, который регулярно завершается с ошибкой, производительность реализации неприемлемо. Это обоснованное предположение. При создании исключения члена, ее производительность может быть порядков медленнее. Тем не менее можно добиться оптимальной производительности, предназначенных только для исключение рекомендации, которые запрещено использовать коды ошибок. Два шаблона, описанные в этом разделе касаются способов это сделать.  
  
 **X не** использование кодов ошибок из-за проблемы, что исключения могут негативно повлиять на производительность.  
  
 Чтобы повысить производительность, можно использовать шаблон Tester-Doer или шаблоне синтаксического анализа Try, описанные в следующих двух разделах.  
  
## <a name="tester-doer-pattern"></a>Шаблон Tester-Doer  
 Иногда производительность члена исключения можно повысить, разбив на два элемента. Давайте рассмотрим <xref:System.Collections.Generic.ICollection%601.Add%2A> метод <xref:System.Collections.Generic.ICollection%601> интерфейса.  
  
```  
ICollection<int> numbers = ...   
numbers.Add(1);  
```  
  
 Метод `Add` создает исключение, если коллекция доступна только для чтения. Это может вызвать проблемы производительности в сценариях, где метод должен завершиться ошибкой; часто. Один из способов устранения проблемы заключается в проверке ли коллекция доступна для записи, прежде чем пытаться добавить значение.  
  
```  
ICollection<int> numbers = ...   
...  
if(!numbers.IsReadOnly){  
    numbers.Add(1);  
}  
```  
  
 Элемент, используемый для проверки того, в данном примере которого является свойство `IsReadOnly`, называется тест-инженер. Элемент, использованный для выполнения потенциально возникло исключение операции `Add` метод в нашем примере называется doer.  
  
 **✓ Попробуйте** шаблон Tester-Doer для членов, которые могут вызвать исключения общие сценарии, чтобы избежать проблем с производительностью связанных с исключениями.  
  
## <a name="try-parse-pattern"></a>Шаблон синтаксического анализа try  
 Для API-интерфейсов важна высокая производительность следует использовать шаблон еще быстрее, чем шаблон Tester-Doer, описанные в предыдущем разделе. Шаблон полезна корректировка имя члена, чтобы четко определенный тест случае часть семантику члена. Например <xref:System.DateTime> определяет <xref:System.DateTime.Parse%2A> метод, который вызывает исключение, если происходит сбой синтаксического анализа строки. Он также определяет соответствующий <xref:System.DateTime.TryParse%2A> метод, который пытается выполнить синтаксический анализ, но возвращает значение false, если синтаксический анализ завершается неудачно и возвращает результат успешного синтаксического анализа с помощью `out` параметра.  
  
```  
public struct DateTime {  
    public static DateTime Parse(string dateTime){   
        ...   
    }  
    public static bool TryParse(string dateTime, out DateTime result){  
        ...  
    }  
}  
```  
  
 При использовании этого шаблона, важно определить функциональные возможности попробуйте в strict условия. При сбое члена по любой причине, кроме try четко определенный элемент по-прежнему должно быть соответствующее исключение.  
  
 **✓ Попробуйте** синтаксического анализа Try шаблон для членов, которые могут вызвать исключения общие сценарии, чтобы избежать проблем с производительностью связанных с исключениями.  
  
 **✓ СДЕЛАТЬ** использовать префикс «Try» и логический тип возвращаемого значения для методов реализации данного шаблона.  
  
 **✓ СДЕЛАТЬ** предоставляют член исключения для каждого элемента, используя шаблон синтаксического анализа Try.  
  
 *Фрагменты © 2005, 2009 корпорации Майкрософт. Все права защищены.*  
  
 *Перепечатываются разрешении Пирсона для образовательных учреждений, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2-е издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс, опубликованные 22 октября 2008 г., Addison-Wesley Professional в составе ряда разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также  
 [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)  
 [Правила разработки исключений](../../../docs/standard/design-guidelines/exceptions.md)
