---
title: "Разработка параметров | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
  - "CSharp"
  - "C++"
  - "jsharp"
helpviewer_keywords: 
  - "рекомендации по разработке членов [платформа .NET Framework] Параметры"
  - "члены [платформа .NET Framework] Параметры"
  - "имена [платформа .NET Framework] Параметры"
  - "параметры, рекомендации по проектированию"
  - "зарезервированные параметры"
ms.assetid: 3f33bf46-4a7b-43b3-bb78-1ffebe0dcfa6
caps.latest.revision: 11
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 11
---
# Разработка параметров
В этом разделе приведены общие рекомендации по разработке параметра, включая разделы с рекомендации по проверке аргументов. Кроме того, обратитесь к рекомендациям, приведенным в [Именование параметров](../../../docs/standard/design-guidelines/naming-parameters.md).  
  
 **✓ сделать** использовать бы производный тип параметра, который предоставляет функциональные возможности, необходимые для элемента.  
  
 Например предположим, что требуется разработать метод, который перечисляет коллекцию и выводит на консоль каждого элемента. Такой метод должен принимать <xref:System.Collections.IEnumerable> как параметр, не <xref:System.Collections.ArrayList> или <xref:System.Collections.IList>, например.  
  
 **X не** использовать зарезервированные параметры.  
  
 При необходимости дополнительные входные данные для члена в одной из будущих версий могут добавляться новые перегрузки.  
  
 **X не** общедоступна методов, которые принимают указатели, массивы указателей или многомерных массивов в качестве параметров.  
  
 Указатели и многомерные массивы являются довольно сложно использовать правильно. Почти во всех случаях интерфейсы API могут изменено таким образом, чтобы избежать создания этих типов в качестве параметров.  
  
 **✓ сделать** поместить все `out` все значения, следующие параметры и `ref` параметров \(за исключением массивов параметров\), даже если это приводит к возникновению несогласованности параметров перегрузки в \(см. [Перегрузка членов](../../../docs/standard/design-guidelines/member-overloading.md)\).  
  
 `out` Параметров можно рассматривать как очень возвращаемые значения и сгруппировать их метод подпись становится проще для понимания.  
  
 **✓ сделать** быть согласованы в именовании параметров при перегрузке членов или реализации интерфейсов.  
  
 Это лучше взаимодействует связи между методами.  
  
### Выбор между Enum и параметрами типа Boolean  
 **✓ сделать** использовать перечисления, если член будет иметь два или более логических параметра.  
  
 **X не** используйте логические значения, если вы абсолютно уверены, что никогда не возникнет необходимость более двух значений.  
  
 Перечисления предоставляют некоторый запас будущих сложения значений, но следует иметь в виду все аспекты Добавление значения перечисления, которые описаны в [Разработка перечислений](../../../docs/standard/design-guidelines/enum.md).  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** с помощью логических значений для параметров конструктора, которые действительно два значения состояния и просто используются для инициализации свойства типа Boolean.  
  
### Проверка аргументов  
 **✓ сделать** проверить аргументы, передаваемые открытый, защищенный или явно реализованным членам. Исключение <xref:System.ArgumentException?displayProperty=fullName>, или одного из его подклассов, если проверка завершается с ошибкой.  
  
 Обратите внимание, что в действительности проверка не обязательно в самой открытого или защищенного члена. Это может быть на более низком уровне в подпрограмме некоторые закрытым или внутренним. Основным здесь является то, что конечным пользователям предоставляется всей области проверки аргументов.  
  
 **✓ сделать** исключение <xref:System.ArgumentNullException> Если передается значение null аргумента и элемент не поддерживает аргументами null.  
  
 **✓ сделать** проверки параметров enum.  
  
 Не предполагайте, что аргументы enum будет находиться в диапазоне, определяемых перечислением. Среда CLR позволяет преобразовать любое целочисленное значение в значение перечисления, даже если значения не определены в перечислении.  
  
 **X не** использовать <xref:System.Enum.IsDefined%2A?displayProperty=fullName> диапазона перечисления проверяет.  
  
 **✓ сделать** Имейте в виду, что изменяемые аргументы могли измениться после они были проверены.  
  
 Если элемент является влияет на безопасность, вы, рекомендуется создать копию, а затем проверить и обработать аргумент.  
  
### Передача параметров  
 С точки зрения конструктора framework есть три основные группы параметров: параметры, по значению `ref` параметров, и `out` параметров.  
  
 Когда аргумент передается через параметр по значению, член получает копию фактический аргумент, передаваемый в. Если аргумент является типом значения, копия аргумента помещается в стек. Если аргумент имеет ссылочный тип, копия ссылки помещается в стек. Наиболее популярных языков CLR, например C\#, VB.NET и C\+\+, по умолчанию для передачи параметров по значению.  
  
 Если аргумент, переданный через `ref` параметр, член получает ссылку на фактический аргумент, передаваемый в. Если аргумент является типом значения, ссылка на аргумент помещается в стек. Если аргумент имеет ссылочный тип, ссылка на ссылку на помещается в стек.`Ref` параметры могут использоваться для разрешения элемента для изменения аргументов, переданных вызывающей стороной.  
  
 `Out` параметры аналогичны `ref` параметров, некоторые небольшие различия. Параметр вначале считается неназначенным и не удается прочитать в тексте элемента перед его присваиванием некоторое значение. Кроме того параметр должен быть назначен некоторое значение перед возвратом элемента.  
  
 **ИЗБЕЖАТЬ X** с помощью `out` или `ref` Параметры.  
  
 С помощью `out` или `ref` параметров требуется опыт работы с указателями, понимание отличия между типами значения и ссылочными типами и умение работать с методами с несколькими возвращаемыми значениями. Кроме того, разница между `out` и `ref` Параметры далеко не все понимают. Архитекторы Framework проектирование для широкого использования, не следует ожидать пользователям разрабатывающим `out` или `ref` Параметры.  
  
 **X не** передачи ссылочных типов по ссылке.  
  
 Существует несколько исключений для правила, например метод, который может использоваться для замены ссылок.  
  
### Члены с переменным числом параметров  
 Благодаря параметру массива выражаются члены, которые могут принимать переменное число аргументов. Например <xref:System.String> предоставляет следующий метод:  
  
```  
public class String {  
    public static string Format(string format, object[] parameters);  
}  
```  
  
 Пользователь может затем вызвать <xref:System.String.Format%2A?displayProperty=fullName> метод следующим образом:  
  
 `String.Format("File {0} not found in {1}",new object[]{filename,directory});`  
  
 Добавление ключевого слова params C\# к параметру массива изменяется параметр к параметру массива так называемые params и предоставляет ярлык для создания временного массива.  
  
```  
public class String {  
    public static string Format(string format, params object[] parameters);  
}  
```  
  
 Это позволяет вызывать метод, передав массив элементов непосредственно в списке аргументов.  
  
 `String.Format("File {0} not found in {1}",filename,directory);`  
  
 Обратите внимание, что ключевое слово params могут быть добавлены только в качестве последнего параметра в списке параметров.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** Добавление ключевого слова params к параметрам массива, если ожидается, что конечные пользователи будут передавать массивы с небольшим числом элементов. Если ожидается, что множество элементов будут передаваться в общих сценариев, пользователи, вероятно, не будет передавать эти встроенные элементы в любом случае, и ключевого слова params не требуется.  
  
 **ИЗБЕЖАТЬ X** использование массивов params, если вызывающий объект почти всегда бы входных данных уже в массиве.  
  
 Например члены с параметрами массивов байтов бы почти никогда не вызываться передачи отдельных байтов. По этой причине параметры массива байтов в .NET Framework следует использовать ключевое слово params.  
  
 **X не** используйте массивы params, если массив изменен членом, принимающим массив параметр params.  
  
 Из\-за того, что многие компилятор преобразует аргументы в элемент во временный массив во время вызова массив может быть временным объектом, и они будут утеряны все изменения в массив.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** с помощью ключевого слова params в простой перегрузке, даже если более сложная перегрузка не может использовать его.  
  
 Спросите себя, если пользователи ценят, наличие массив params в одной перегрузке, даже если это не было всех перегруженных версий.  
  
 **✓ сделать** попытайтесь Упорядочить параметры, чтобы сделать возможным использование ключевого слова params.  
  
 **✓ Рассмотрите ВОЗМОЖНОСТЬ** предусматривать особые перегрузки и ветви кода для вызовов с небольшим числом аргументов в API очень важна высокая производительность.  
  
 Это позволяет избежать создания массива объектов при вызове API с небольшим количеством аргументов. Имена параметров образуют единственном параметра массива и добавление числовой суффикс.  
  
 Следует только для этого, если будет в особой папке весь код, не только создания массива и вызов более общего метода.  
  
 **✓ сделать** Имейте в виду, значение null может быть передана в качестве аргумента массив params.  
  
 Следует проверить, что массив не является null перед обработкой.  
  
 **X не** использовать `varargs` методы, также известное как кнопку с многоточием.  
  
 Некоторых языков CLR, например C\+\+, поддерживает альтернативный соглашение для передачи списки параметров переменных называется `varargs` методы. Соглашение должно не используется в платформах, так как он не является CLS\-совместимым.  
  
### Параметры\-указатели  
 В общем случае указатели не должны отображаться в общую контактную зону framework хорошо спроектированной управляемого кода. В большинстве случаев, должны инкапсулироваться указатели. Однако в некоторых случаях указатели необходимы из соображений совместимости, и с использованием указателей в таких случаях подходит.  
  
 **✓ сделать** предоставляют альтернативный для любого элемента, который принимает указатель в качестве аргумента, так как указатели не являются CLS\-совместимыми.  
  
 **ИЗБЕЖАТЬ X** затратного контроля аргументов указатель аргументов.  
  
 **✓ сделать** соглашениям распространенных указателей при разработке членов с указателями.  
  
 Например нет необходимости для передачи начальный индекс, потому что для достижения такого же результата можно использовать простые расчеты с указателями.  
  
 *Частей © 2005, 2009 корпорации Microsoft. Все права защищены.*  
  
 *Воспроизведены разрешении Пирсон образования, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для повторного использования библиотеки .NET, второе издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс опубликованы 22 октября 2008 г., издательство Addison\-Wesley Professional как часть цикла разработки Microsoft Windows.*  
  
## См. также  
 [Рекомендации по разработке членов](../../../docs/standard/design-guidelines/member.md)   
 [Рекомендации по проектированию Framework](../../../docs/standard/design-guidelines/index.md)