---
title: "Рекомендации по использованию коллекций"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
caps.latest.revision: "4"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 62205e6bea39214383f6a653d719c0285f374a9f
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/23/2017
---
# <a name="guidelines-for-collections"></a>Рекомендации по использованию коллекций
Любой тип, разработанные специально для использования группы объектов, содержащих некоторыми общими характеристиками можно рассматривать как коллекцию. Почти всегда это подходит для таких типов, для реализации <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>, поэтому в этом разделе мы только рассмотрите возможность реализации одного или обоих этих интерфейсов подлежащих типов коллекций.  
  
 **X не** использования слабо типизированных коллекций в открытых интерфейсах API.  
  
 Тип все возвращаемые значения и параметры, представляющие элементы коллекции должны быть типа точное элемента, не одному из его базовых типов (это относится только к открытым членам коллекции).  
  
 **X не** использовать <xref:System.Collections.ArrayList> или <xref:System.Collections.Generic.List%601> в открытых интерфейсах API.  
  
 Эти типы — это структуры данных, которые предназначены для использования в внутренней реализации, а не в открытых интерфейсах API. `List<T>`оптимизирован для питания за счет cleanness API-интерфейсов и гибкости и производительности. Например, если возвращается `List<T>`, можно не никогда не будет получать уведомления, когда клиентский код изменяет коллекцию. Кроме того `List<T>` предоставляет большое количество элементов, таких как <xref:System.Collections.Generic.List%601.BinarySearch%2A>, который не полезны или применимо во многих сценариях. Следующих двух разделах описаны типы (абстракций) разработан специально для использования в открытых интерфейсах API.  
  
 **X не** использовать `Hashtable` или `Dictionary<TKey,TValue>` в открытых интерфейсах API.  
  
 Эти типы являются предназначены для использования в реализации внутренней структуры данных. Следует использовать открытые API <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, или пользовательский тип, реализующий одно или оба из этих интерфейсов.  
  
 **X не** использовать <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, или любого другого типа, который реализует один из этих интерфейсов, за исключением того, как тип возвращаемого значения `GetEnumerator` метод.  
  
 Возврат перечислители из методов, отличный от типов `GetEnumerator` не может использоваться с `foreach` инструкции.  
  
 **X не** реализовывать `IEnumerator<T>` и `IEnumerable<T>` на тот же тип. Это же правило применяется для неуниверсальных интерфейсов `IEnumerator` и `IEnumerable`.  
  
## <a name="collection-parameters"></a>Параметры сбора  
 **✓ СДЕЛАТЬ** использовать возможные специализированные наименее тип в качестве типа параметра. Большинство членов получение коллекций, как использовать параметры `IEnumerable<T>` интерфейса.  
  
 **X ИЗБЕГАЙТЕ** с помощью <xref:System.Collections.Generic.ICollection%601> или <xref:System.Collections.ICollection> как параметр только для доступа к `Count` свойство.  
  
 Вместо этого рассмотрите возможность использования `IEnumerable<T>` или `IEnumerable` и динамически проверки, реализует ли объект `ICollection<T>` или `ICollection`.  
  
## <a name="collection-properties-and-return-values"></a>Свойства коллекции и возвращаемые значения  
 **X не** предоставляют настраиваемые коллекции свойств.  
  
 Пользователи могут заменить содержимое коллекции, сначала очисткой коллекции, а затем добавьте новое содержимое. Если замена всей коллекции это очень распространенный сценарий, следует рассмотреть возможность создания `AddRange` метод в коллекции.  
  
 **СДЕЛАТЬ ✓** использовать `Collection<T>` или подкласс `Collection<T>` для свойства или возвращаемого значения представления коллекции для чтения и записи.  
  
 Если `Collection<T>` не соответствует требованиям некоторых (например, коллекции не должен реализовывать <xref:System.Collections.IList>), использовать пользовательскую коллекцию, реализовав `IEnumerable<T>`, `ICollection<T>`, или <xref:System.Collections.Generic.IList%601>.  
  
 **СДЕЛАТЬ ✓** использовать <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, подкласс `ReadOnlyCollection<T>`, или, в редких случаях `IEnumerable<T>` для свойства или возвращаемого значения представления коллекции только для чтения.  
  
 Как правило, предпочтительно использовать `ReadOnlyCollection<T>`. Если он не соответствует требованиям некоторых (например, коллекции не должен реализовывать `IList`), использовать пользовательскую коллекцию, реализовав `IEnumerable<T>`, `ICollection<T>`, или `IList<T>`. При реализации пользовательской коллекции только для чтения, следует реализовать `ICollection<T>.ReadOnly` возвращает значение false.  
  
 В случаях, когда вы убедитесь, что единственный случай, когда-нибудь потребуется поддерживать прямой итерации, можно просто использовать `IEnumerable<T>`.  
  
 **✓ Попробуйте** с использованием подклассов универсальных коллекций базовый вместо использования коллекций.  
  
 Это позволяет для более понятные имена и добавления вспомогательные методы, которые не присутствуют на базового типа коллекции. Это особенно относится к API высокого уровня.  
  
 **✓ Попробуйте** возврат подкласс `Collection<T>` или `ReadOnlyCollection<T>` из очень часто используемые методы и свойства.  
  
 Это сделает его можно добавить вспомогательные методы или изменить реализацию коллекции в будущем.  
  
 **✓ Попробуйте** с помощью является коллекцией с ключом, если элементы, хранящихся в коллекции имеют уникальные ключи (имена, идентификаторы и т. д.). С ключом коллекции — это коллекции, которые могут быть индексированы по целым и ключ и обычно реализуются путем наследования от `KeyedCollection<TKey,TItem>`.  
  
 Коллекции с ключом обычно требуют больше ресурсов памяти и не должен использоваться, если нагрузка на память перевешивает преимущества ключи.  
  
 **X не** возвращать значения null из свойства коллекции или методами, возвращающими коллекции. Возвращает пустую коллекцию, или пустой массив.  
  
 Общее правило — следует null и пустые (без элементов) коллекции или массивы обрабатываются одинаково.  
  
### <a name="snapshots-versus-live-collections"></a>Моментальные снимки и динамической коллекций  
 Коллекции, представляющий состояние в определенный момент во времени называются моментальный снимок коллекции. Например коллекция, содержащая строки, возвращаемые из запроса к базе данных будет моментального снимка. Коллекции, которые всегда представляют текущее состояние, называются динамической коллекций. Например, коллекцию `ComboBox` элементов — это динамическая коллекция.  
  
 **X не** возвращают коллекции моментального снимка из свойств. Свойства должны возвращать динамической коллекций.  
  
 Методы получения свойств должны быть очень простая операции. Возвращение моментального снимка требует создания копии внутренней коллекции в операцией O(n).  
  
 **СДЕЛАТЬ ✓** использовать моментальный снимок коллекции или активной `IEnumerable<T>` (или его подтипов) для представления коллекций, которые являются volatile (т. е., можно изменить без явного изменения коллекции).  
  
 Как правило все коллекции, представляющий общий ресурс (например, файлы в каталоге) являются переменными. Такие коллекции — это очень сложно или невозможно реализовать как динамической коллекции, если реализация не просто последовательным перечислителя.  
  
## <a name="choosing-between-arrays-and-collections"></a>Выбор между массивы и коллекции  
 **✓ СДЕЛАТЬ** предпочтение коллекций и массивы.  
  
 Коллекции обеспечивают больший контроль над содержимым, могут изменяться со временем и удобным. Кроме того использование массивов для только для чтения сценариев рекомендуется, так как чрезмерно высокой стоимости для клонирования массива. Удобство использования исследования показали, что некоторым разработчикам удобнее работать с помощью интерфейсов API на основе коллекций.  
  
 Тем не менее если вы разрабатываете низкоуровневые интерфейсы API, возможно, лучше было бы использовать для чтения и записи сценариев массивы. Массивы имеют меньший объем памяти, помогает уменьшить рабочее множество, и доступ к элементам в массиве выполняется быстрее, поскольку он оптимизирован средой выполнения.  
  
 **✓ Попробуйте** использование массивов в API нижнего уровня к минимуму потребление памяти и повышения производительности.  
  
 **✓ СДЕЛАТЬ** использовать байтовые массивы вместо коллекции байтов.  
  
 **X не** используйте массивы для свойств, если свойство будет иметь для возврата нового массива (например, копия внутреннего массива) каждый раз, вызывается метод считывания свойства.  
  
## <a name="implementing-custom-collections"></a>Реализация пользовательских коллекций  
 **✓ Попробуйте** наследование от `Collection<T>`, `ReadOnlyCollection<T>`, или `KeyedCollection<TKey,TItem>` при разработке новых семейств сайтов.  
  
 **СДЕЛАТЬ ✓** реализации `IEnumerable<T>` при разработке новых семейств сайтов. Рассмотрите возможность реализации `ICollection<T>` или даже `IList<T>` где имеет смысл.  
  
 При реализации такой пользовательские коллекции, соответствуют шаблону API, заданные в `Collection<T>` и `ReadOnlyCollection<T>` как можно точнее. Таким образом следует явным образом реализовывать те же элементы, имена параметров, как эти две коллекции назовите их и т. д.  
  
 **✓ Попробуйте** реализация интерфейсов неуниверсальных коллекций (`IList` и `ICollection`) если коллекции часто передается в API-интерфейсы используя эти интерфейсы в качестве входных данных.  
  
 **X ИЗБЕГАЙТЕ** реализация интерфейсов коллекций в типах сложных API-интерфейсами, не относящуюся к концепцию коллекции.  
  
 **X не** наследовать от неуниверсальных коллекций базовый, такие как `CollectionBase`. Используйте `Collection<T>`, `ReadOnlyCollection<T>`, и `KeyedCollection<TKey,TItem>` вместо него.  
  
### <a name="naming-custom-collections"></a>Об именах пользовательских коллекций  
 Коллекции (типы, реализующие `IEnumerable`) создаются в основном по двум причинам: (1), чтобы создать новую структуру данных с помощью операций, связанных с структуры и часто различаются по быстродействию чем существующие структуры данных (например, <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>) и (2) для создания специализированных коллекции для хранения конкретного набора элементов (например, <xref:System.Collections.Specialized.StringCollection>). Структуры данных, наиболее часто используются в внутренней реализации приложения и библиотеки. Специализированные коллекции — это главным образом для доступа в API-интерфейсы (в качестве свойства и параметры типа).  
  
 **СДЕЛАТЬ ✓** используйте суффикс «Словарь» в именах реализации абстракций `IDictionary` или `IDictionary<TKey,TValue>`.  
  
 **СДЕЛАТЬ ✓** используйте суффикс «Коллекция» в именах типы, реализующие `IEnumerable` (или один из его потомков) и представляет список элементов.  
  
 **✓ СДЕЛАТЬ** использовать имя структуры соответствующие данные для пользовательских структур данных.  
  
 **X ИЗБЕГАЙТЕ** использовать любые суффиксы, подразумевая конкретной реализации, такие как «LinkedList» или «Хэш-таблица», в именах абстракций коллекции.  
  
 **✓ Попробуйте** префикса имен коллекций с именем типа элемента. Например, коллекция хранения элементов типа `Address` (реализации `IEnumerable<Address>`) должен быть назван `AddressCollection`. Если тип элемента — это интерфейс, «I» префикс элемента типа может быть опущено. Таким образом, коллекция <xref:System.IDisposable> элементов может быть вызван `DisposableCollection`.  
  
 **✓ Попробуйте** с помощью префикса «ReadOnly» в именах коллекций только для чтения, если соответствующую ему коллекцию для записи могут быть добавлены или уже существует в структуре.  
  
 Например, следует вызывать только для чтения коллекцию строк `ReadOnlyStringCollection`.  
  
 *Фрагменты © 2005, 2009 корпорации Майкрософт. Все права защищены.*  
  
 *Перепечатываются разрешении Пирсона для образовательных учреждений, Inc. из [Framework рекомендации по проектированию: условные обозначения, стили и шаблоны для библиотеки .NET для повторного использования, 2-е издание](http://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina и Брэд Абрамс, опубликованные 22 октября 2008 г., Addison-Wesley Professional в составе ряда разработки Microsoft Windows.*  
  
## <a name="see-also"></a>См. также  
 [Рекомендации по проектированию на основе Framework](../../../docs/standard/design-guidelines/index.md)  
 [Правила использования](../../../docs/standard/design-guidelines/usage-guidelines.md)
