---
title: "Potential Pitfalls in Data and Task Parallelism | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "parallel programming, pitfalls"
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
caps.latest.revision: 14
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 14
---
# Potential Pitfalls in Data and Task Parallelism
Во многих случаях метод <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> и метод <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName> могут предоставить значительные улучшения производительности по сравнению с последовательными циклами.  Однако параллельное выполнение циклов повышает сложность, что может привести к проблемам, которые в последовательном коде встречаются не так часто или не встречаются вовсе.  В этом разделе перечислены некоторые рекомендации по тому, чего следует избегать при написании параллельных циклов.  
  
## Пример медленной параллельной обработки  
 В отдельных случаях параллельный цикл может выполняться медленнее, чем его последовательный эквивалент.  Основное эмпирическое правило заключается в том, что параллельные циклы, которые содержат несколько итераций и быстрых пользовательских делегатов, скорее всего сильно не увеличат скорость.  Однако поскольку на производительность оказывает влияние множество факторов, рекомендуется всегда оценивать фактические результаты.  
  
## Нежелательная запись в адреса общей памяти  
 В последовательном коде нередко выполняется чтение из статических переменных или полей класса либо запись в них.  Однако при каждом параллельном обращении к таким переменным в нескольких потоках есть большая вероятность состояния гонки.  Несмотря на то что для синхронизации доступа к переменной можно использовать блокировки, затраты ресурсов на синхронизацию могут снизить производительность.  Поэтому рекомендуется избегать или хотя бы ограничивать доступ к общему состоянию в параллельном цикле, насколько это возможно.  Лучший способ сделать это — перегрузка метода <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=fullName> и метода <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=fullName>, которые используют переменную <xref:System.Threading.ThreadLocal%601?displayProperty=fullName> для хранения локального состояния потока при выполнении цикла.  Дополнительные сведения см. в разделах [How to: Write a Parallel.For Loop with Thread\-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) и [How to: Write a Parallel.ForEach Loop with Thread\-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-thread-local-variables.md).  
  
## Нежелательность излишней параллелизации  
 Использование параллельных циклов приводит к чрезмерным затратам ресурсов на разделение исходной коллекции и синхронизацию рабочих потоков.  Преимущества параллелизации значительно ограничиваются количеством процессоров в компьютере.  При выполнении нескольких потоков, ограниченных по скорости вычислений, на одном процессоре скорость не увеличивается.  Таким образом, необходимо избегать использования излишней параллелизации цикла.  
  
 Наиболее общим сценарием, при котором может возникнуть излишний параллелизм, являются вложенные циклы.  Во многих случаях лучше выполнить параллелизацию только внешнего цикла, за исключением ситуаций когда применяются одно или несколько следующих условий.  
  
-   Известно, что внутренний цикл выполняется в течение длительного времени.  
  
-   Для каждого заказа требуются большие затраты компьютерных ресурсов. \(Для операции, представленной в примере, не требуется больших затрат ресурсов.\)  
  
-   Известно, что целевая система имеет достаточно процессоров для обработки потоков, которые возникнут в результате параллелизации запроса в `cust.Orders`.  
  
 Во всех случаях наилучшим способом определения оптимальной формы запроса является тестирование и измерение.  
  
## Нежелательные вызовы потокоопасных методов  
 Запись в потокоопасные методы экземпляра из параллельного цикла может привести к повреждению данных, которое может остаться незамеченным в программе.  Это также может привести к возникновению исключений.  В следующем примере несколько потоков предпримут попытку одновременного вызова метода <xref:System.IO.FileStream.WriteByte%2A?displayProperty=fullName>, что не поддерживается классом.  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## Ограничение вызовов потокобезопасных методов  
 Большинство статических методов в платформе .NET Framework потокобезопасны и могут вызываться из нескольких потоков одновременно.  Однако даже в таких случаях действующая синхронизация может привести к значительному замедлению в запросе.  
  
> [!NOTE]
>  Это можно проверить самостоятельно, вставив несколько вызовов метода <xref:System.Console.WriteLine%2A> в запросы.  Хотя этот метод используется в примерах документации в демонстрационных целях, не используйте его в параллельных циклах без крайней необходимости.  
  
## Проблемы, связанные со сходством потоков  
 Некоторые технологии, например, COM\-взаимодействие для компонентов однопотокового подразделения \(STA\), Windows Forms и Windows Presentation Foundation \(WPF\), накладывают ограничения на сходство потоков, согласно которым код должен выполняться в определенном потоке.  Например, в Windows Forms и WPF элемент управления доступен только в потоке, в котором он был создан.  Например, это означает, что нельзя обновить элемент управления "Список" из параллельного цикла, если не настроить планировщик потоков для планирования работы только в потоке пользовательского интерфейса.  Для получения дополнительной информации см. [How to: Schedule Work on the User Interface \(UI\) Thread](../Topic/How%20to:%20Schedule%20Work%20on%20the%20User%20Interface%20\(UI\)%20Thread.md).  
  
## Будьте внимательны при ожидании в делегатах, которые вызываются с помощью Parallel.Invoke  
 В определенных условиях библиотека параллельных задач будет встраивать задачу, это означает, что она выполняется в задаче в потоке, который выполняется в данный момент. \(Дополнительные сведения см. в разделе [Task Schedulers](../Topic/Task%20Schedulers.md).\) В определенных случаях оптимизация производительности может привести к блокировке.  Например, две задачи могут выполнять одинаковый код делегата, который сигнализирует при наступлении события, а затем ожидает сигнала от другой задачи.  Если вторая задача встроена в тот же поток, что и первая задача, и первая задача переходит в состояние ожидания, вторая задача никогда не сможет сигнализировать о своем событии.  Для предупреждения таких ситуаций можно указать время ожидания в операции ожидания, либо использовать явные конструкторы потоков, чтобы убедиться, что одна задача не может блокировать другую.  
  
## Не следует полагать, что итерации ForEach, For и ForAll всегда выполняются параллельно  
 Важно помнить, что отдельные итерации в цикле метода<xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> или <xref:System.Linq.ParallelEnumerable.ForAll%2A> могут выполняться параллельно, однако это не обязательно.  Поэтому не следует создавать код, правильность выполнения которого возможна только при параллельном выполнении итераций или при выполнении итераций в определенной последовательности.  Например, велика вероятность взаимоблокировки следующего кода.  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 В этом примере одна итерация задает событие, а все остальные итерации ожидают его.  Ни одна из ожидающих итераций не может завершиться раньше, чем завершится итерация, задавшая событие.  Однако возможно, что ожидающие итерации блокируют все потоки, используемые для выполнения параллельного цикла, до того как будет выполнена итерация, задавшая событие.  Это приводит к взаимоблокировке — задающая событие итерация никогда не будет выполнена, а ожидающие итерации никогда не активизируются.  
  
 В частности, выполнение одной итерации в параллельном цикле никогда не должно зависеть от выполнения другой итерации цикла.  Если в параллельном цикле итерации будут запланированы к выполнению последовательно, но в обратном порядке, произойдет взаимоблокировка.  
  
## Избегайте выполнения параллельных циклов в потоке пользовательского интерфейса  
 Важно сохранять состояние оклика для пользовательского интерфейса приложения.  Если операция содержит достаточный объем работы, который может стать основанием для параллелизма, то она не должна выполняться в потоке пользовательского интерфейса.  Вместо этого его следует разгрузить, чтобы операция выполнялась в фоновом потоке.  Например, если необходимо использовать параллельный цикл для вычисления некоторых данных, которые затем должны быть показаны в элементе управления пользовательского интерфейса, необходимо рассмотреть возможность выполнения цикла в экземпляре задачи, а не непосредственно в обработчике событий пользовательского интерфейса.  Только после того, как завершится основная вычислительная задача, следует маршалировать обновление пользовательского интерфейса назад в поток пользовательского интерфейса.  
  
 Если принято решение выполнять параллельный цикл в потоке пользовательского интерфейса, будьте внимательны и предупреждайте обновление элементов управления пользовательского интерфейса из цикла.  Попытка обновления элементов управления пользовательского интерфейса из параллельного цикла, который выполняется в потоке пользовательского интерфейса, может привести к нарушению состояния, исключениям, задержке обновлений, в зависимости от того, как вызывается обновление пользовательского интерфейса.  В следующем примере параллельный цикл блокирует поток пользовательского интерфейса, в котором выполняется, до завершения всех итераций.  Однако если итерация цикла выполняется в фоновом потоке \(например, как может это делать метод <xref:System.Threading.Tasks.Parallel.For%2A>\), вызов Invoke приводит отправке сообщения в поток пользовательского интерфейса и блокировке для ожидания обработки этого сообщения.  Так как поток пользовательского интерфейса заблокирован, выполняя метод <xref:System.Threading.Tasks.Parallel.For%2A>, сообщение никогда не будет обработано и поток пользовательского интерфейса будет находиться в состоянии взаимоблокировки.  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 Следующий пример показывает, как предупредить взаимоблокировку с помощью выполнения цикла внутри экземпляра задачи.  Поток пользовательского интерфейса не блокируется циклом и сообщение может быть обработано.  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## См. также  
 [Parallel Programming](../../../docs/standard/parallel-programming/index.md)   
 [Potential Pitfalls with PLINQ](../../../docs/standard/parallel-programming/potential-pitfalls-with-plinq.md)   
 [Шаблоны параллельного программирования: понимание и применение шаблонов параллельного программирования на платформе .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=185142)