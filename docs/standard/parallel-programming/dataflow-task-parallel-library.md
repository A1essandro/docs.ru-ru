---
title: "Поток данных (библиотека параллельных задач) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Библиотека параллельных задач, потоки данных"
  - "библиотека потоков данных TPL"
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Поток данных (библиотека параллельных задач)
<a name="top"></a>Библиотека параллельных задач (TPL) предоставляет компоненты потока данных, чтобы повысить надежность приложений с поддержкой параллелизма. Эти компоненты потока данных вместе называются *библиотека потоков данных TPL*. Эта модель потоков данных поддерживает программирование на основе субъектов путем обеспечения внутрипроцессной передачи сообщений для недетализированного потока данных и задач по конвейеризации. Компоненты потоков данных строятся на типах и инфраструктуре планирования TPL и интегрированы с языковой поддержкой асинхронного программирования в C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] и F#. Эти компоненты потоков данных полезны при наличии нескольких операций, которые должны асинхронно взаимодействовать друг с другом, или при необходимости обрабатывать данные по мере того, как они становятся доступными. Например, рассмотрим приложение, которое обрабатывает данные, поступающие с веб-камеры. С помощью модели потока данных приложение может обрабатывать кадры, как только они становятся доступными. Если приложение повышает качество изображений на кадрах, например, выполняя коррекцию освещенности или красных глаз, созданием *конвейера* компонентов потока данных. Каждый этап конвейера может использовать функциональность с более грубым параллелизмом, например функцию, предоставляемую библиотекой TPL, для преобразования изображения.  
  
 В этом документе содержатся общие сведения о библиотеке потоков данных TPL. Здесь описывается модель программирования, предопределенные типы блоков потоков данных и способы настройки блоков потоков данных для соответствия требованиям вашего приложения.  
  
> [!TIP]
>  Библиотека потоков данных TPL (<xref:System.Threading.Tasks.Dataflow?displayProperty=fullName> пространства имен) не поставляется с [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Установка <xref:System.Threading.Tasks.Dataflow> пространства имен, откройте проект в [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], выберите **управление пакетами NuGet** из меню проекта и поиск в сети `Microsoft.Tpl.Dataflow` пакета.  
  
 Этот документ содержит следующие разделы.  
  
-   [Модель программирования](#model)  
  
-   [Типы стандартных блоков потоков данных](#predefined_types)  
  
-   [Настройка поведения блоков потоков данных](#behavior)  
  
-   [Пользовательские блоки потоков данных](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Модель программирования  
 Библиотека потоков данных TPL обеспечивает основу для передачи сообщений и параллелизации приложений, создающих большую нагрузку на ЦПУ и ввод-вывод, которые имеют высокую пропускную способность и низкую задержку. Она также предоставляет явный контроль над тем, как данные буферизуются и перемещаются по системе. Чтобы лучше понять модель программирования потоков данных, рассмотрим приложение, асинхронно загружающее изображения с диска и создающее из них композитное изображение. Традиционные модели программирования обычно требуют использования обратных вызовов и объектов синхронизации, например блокировок, для координации задач и доступа к общим данным. С помощью модели программирования потоков данных можно создавать объекты потоков данных, которые обрабатывают изображения по мере считывания их с диска. В модели потоков данных объявляется, как обрабатываются данные, когда они становятся доступными, а также объявляются любые зависимости между данными. Поскольку среда выполнения управляет зависимостями между данными, часто можно избежать необходимости синхронизировать доступ к общим данным. Кроме того, поскольку планирование в среде выполнения основано на асинхронном прибытии данных, поток данных может увеличить пропускную способность и ускорить время ответа, эффективно управляя лежащими в основе потоками. Пример, использующий модель программирования потоков данных для реализации обработки изображений в приложении Windows Forms см. в разделе [Пошаговое руководство: использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Источники и целевые блоки  
 Библиотека потоков данных TPL состоит из *блоков потока данных*, который представляют собой структуры данных, буфер и обрабатывающие данные. В TPL определено три типа блоков потоков данных: *блоков источника*, *целевые блоки*, и *блоки передачи*. Блок источника выступает в качестве источника данных, из которого можно считать данные. Целевой блок выступает в качестве получателя данных, в который можно писать. Блок передачи действует и как блок источника, и как целевой блок: из него можно читать и в него можно писать. TPL определяет <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=fullName> интерфейс для представления источников, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=fullName> для представления целевых объектов, и <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=fullName> для представления передающих.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> наследует от <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, и <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</TInput, TOutput>  
  
 Библиотека потоков данных TPL предоставляет несколько типов блоков предопределенных потоков данных, которые реализуют <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, и <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> интерфейсы.\</TInput, TOutput> Эти типы блоков потоков данных описаны в данном документе в разделе [предопределенные типы блоков потоков данных](#predefined_types).  
  
### <a name="connecting-blocks"></a>Соединение блоков  
 Можно подключить блоки потока данных для создания *конвейеров*, которые являются линейными последовательностями блоков потока данных или *сети*, являющихся графами блоков потоков данных. Конвейер является одним из видов сетей. Конвейеры или сети асинхронно распространяют исходные данные целевым объектам, когда данные становятся доступны. <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> метод связывает блок потока данных источника и целевой блок. Источник может быть связан с несколькими целевыми объектами или не связан ни с одним; целевые объекты могут иметь связь с несколькими источниками или не иметь связей. Можно добавлять или удалять блоки потока данных из конвейера или сети одновременно. Предопределенные типы блоков потоков данных отвечают за все аспекты потокобезопасности установки и удаления связей.  
  
 Например, блоки потоков данных соединяются в базовый конвейер, см. [Пошаговое руководство: создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Например, блоки потоков данных формируют более сложную сеть, в разделе [Пошаговое руководство: использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Пример удаляет связь целевого источника после источник отправляет целевому сообщение в разделе [Практическое руководство: удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Фильтрация  
 При вызове <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> метод для связывания источника к целевому объекту, можно указать делегат, который определяет, принимает или отклоняет сообщение, на основе значения этого сообщения целевой блок. Механизм фильтрации позволяет гарантировать, что блок потока данных будет получать только определенные значения. Для большинства стандартных типов блока потока данных, если блок источника подключен к нескольким целевым блокам, когда один из целевых блоков отвергает сообщение, это сообщение отправляется следующему целевому объекту. Порядок, в котором источник отправляет сообщения целевым объектам, определяется источником и может различаться в зависимости от типа источника. Большинство типов блоков источников перестают отправлять сообщение после того, как один из целевых объектов его принимает. Единственным исключением из этого правила является <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> класс, который предлагает каждое сообщение всем целевым объектам, даже если некоторые из целевых объектов отклоняют это сообщение. Пример использования фильтрации для обработки только определенных сообщений см. в разделе [Пошаговое руководство: использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Поскольку все стандартные типы блоков потоков данных источника гарантируют, что сообщения передаются в том порядке, в каком они поступают, каждое сообщение должно быть считано из блока источника, чтобы блок источника мог обработать следующее сообщение. Поэтому при использовании фильтрации для подключения нескольких целевых объектов к источнику, убедитесь, что хотя бы один целевой блок получит все сообщения. В противном случае в приложении может возникнуть взаимоблокировка.  
  
### <a name="message-passing"></a>Передача сообщений  
 Модель программирования потоков данных связана с понятием *передачи сообщений*, где независимые компоненты программы взаимодействуют друг с другом посредством отправки сообщений. Один из способов передавать сообщения между компонентами приложения является вызов <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> и <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=fullName> методы для отправки сообщений целевого потока данных блоки (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> работает синхронно; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> работает асинхронно) и <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, и <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> для получения сообщений от блоков источника. Можно объединять эти методы с конвейерами потоков данных или сетями, отправляя входные данные в ведущий узел (целевой блок) и принимая выходные данные из терминального узла конвейера или терминальных узлов сети (один или несколько блоков источника). Можно также использовать <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> метод для чтения данных из первого из имеющихся источников, которые имеются данные и выполнять действия над этими данными.  
  
 Блоки источника предлагают данные целевым блокам путем вызова <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=fullName> метод. Целевой блок отвечает на предложенное сообщение одним из трех способов: он может принять сообщение, отклонить сообщение или отложить сообщение. Если целевой объект принимает сообщение, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает метод <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Если целевой объект отклоняет сообщение, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает метод <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Если целевой объект сообщает, что он больше не получает сообщения из источника, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Стандартные типы блоков источника не предлагают связанным целевым объектам сообщения после получения такого значения, и они автоматически удаляют связи с этим целевым объектом.  
  
 Когда целевой блок откладывает сообщение для последующего использования, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> возвращает метод <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Целевой блок, откладывающий сообщения может в дальнейшем вызвать <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=fullName> метод, чтобы попытаться зарезервировать предложенное сообщение. На этом этапе сообщение либо по-прежнему доступно и может быть использовано целевым блоком, либо было принято другим целевым объектом. Когда целевой блок позже требует сообщение или больше не нуждается в сообщении, он вызывает <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> или <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> метода, соответственно. Резервирование сообщений обычно используется типами блоков потоков данных, которые работают в нежадном режиме. Нежадный режим описан далее в этом документе. Вместо резервирования отложенного сообщения целевой блок может также использовать <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> метод, чтобы попытаться напрямую использовать отложенное сообщение.  
  
### <a name="dataflow-block-completion"></a>Завершение блока потока данных  
 Блоки потоков данных также поддерживают понятие *завершения*. Блок потока данных, находящийся в состоянии завершения, не будет далее выполнять никакой работы. Каждый блок потока данных имеет связанный <xref:System.Threading.Tasks.Task?displayProperty=fullName> объектом, известным как *завершения задачи*, который представляет состояние завершения блока. Поскольку можно дождаться <xref:System.Threading.Tasks.Task> объекта до конца, с помощью задачи завершения, можно отложить для одного или нескольких терминальных узлов потоков данных сети для завершения. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> интерфейс определяет <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> метод, который уведомляет блок потока данных запроса для его завершения, и <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> свойство, возвращающее задачу завершения для блока потока данных. Оба <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> и <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> наследуют <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> интерфейса.  
  
 Существует два способа определить, завершился ли блок потока данных без ошибки, с одной или несколькими ошибками или был отменен. Первый способ — вызвать <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> метод для завершения задачи в `try` - `catch` блока (`Try` - `Catch` в Visual Basic). В следующем примере создается <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> объект, который вызывает <xref:System.ArgumentOutOfRangeException> если входное значение меньше нуля. <xref:System.AggregateException> возникает, когда в этом примере вызывается <xref:System.Threading.Tasks.Task.Wait%2A> для задачи завершения. <xref:System.ArgumentOutOfRangeException> осуществляется с помощью <xref:System.AggregateException.InnerExceptions%2A> свойство <xref:System.AggregateException> объекта.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 В этом примере показан случай, в котором необработанное исключение передается в делегат блока выполнения потока данных. Рекомендуется обрабатывать исключения в телах таких блоков. Однако, если возможности сделать это нет, блок ведет себя, как если бы он был отменен, и не обрабатывает входящие сообщения.  
  
 Если блок потока данных отменяется явно, <xref:System.AggregateException> объект содержит <xref:System.OperationCanceledException> в <xref:System.AggregateException.InnerExceptions%2A> свойство. Дополнительные сведения об отмене потока данных см. далее в этом документе в разделе "Активирование отмены".  
  
 Второй способ определить состояние завершения блока потока данных — использовать продолжение задачи завершения или использовать асинхронные функции языка C# и Visual Basic, чтобы асинхронно ожидать завершения задачи. Делегат, который предоставляется <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> принимает <xref:System.Threading.Tasks.Task> объект, представляющий предшествующую задачу. В случае использования <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> свойство, делегат для продолжения принимает саму задачу завершения. Следующий пример похож на предыдущий, за исключением того, что он также использует <xref:System.Threading.Tasks.Task.ContinueWith%2A> метод для создания задачи завершения, выводящей состояния общей операции потока данных.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 Можно также использовать свойства например <xref:System.Threading.Tasks.Task.IsCanceled%2A> в теле задачи продолжения, чтобы определить дополнительные сведения о состоянии выполнения блока потока данных. Дополнительные сведения о задачах продолжения и как они связаны с отменой и обработкой ошибок см. в разделе [создание цепочки задач с помощью задач продолжения](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [отмены задачи](../../../docs/standard/parallel-programming/task-cancellation.md), [обработка исключений](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), и [NIB: как: обработка исключений, вызванных задачами](http://msdn.microsoft.com/ru-ru/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[go to top](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Предопределенные типы блоков потоков данных  
 Библиотека потоков данных TPL предоставляет несколько предопределенных типов блоков потоков данных. Эти типы делятся на три категории: *блоки буферизации*, *блоки выполнения*, и *блоки группировки*. В следующих подразделах описаны типы блоков, составляющие эти категории.  
  
### <a name="buffering-blocks"></a>Блоки буферизации  
 Блоки буферизации хранят данные для их использования объектами-потребителями данных. Библиотека потоков данных TPL предоставляет три типа блоков буферизации: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=fullName>, и <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=fullName>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> класс представляет структуру общего назначения асинхронного обмена сообщениями. В этом классе хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO), в которую могут записывать данные несколько источников и из которой могут читать данные несколько целевых объектов. Если целевой объект получает сообщение от <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> объекта, это сообщение удаляется из очереди сообщений. Таким образом несмотря на то что <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> объект может иметь несколько целевых объектов, только один целевой объект получит каждое сообщение. <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> класс полезен, если требуется передать несколько сообщений другому компоненту, и этот компонент должен получить каждое сообщение.  
  
 Следующий пример отправляет несколько <xref:System.Int32> значения <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> объекта, затем считывает эти значения считываются из этого объекта.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Полный пример, демонстрирующий запись и чтение сообщений из <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> объекта см. в разделе [как: записи и чтения сообщения из блока потока данных](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> класс полезен, когда необходимо передать несколько сообщений другому компоненту, но этому компоненту нужно только самое последнее значение. Этот класс также может оказаться полезным при необходимости широковещательной передачи сообщения нескольким компонентам.  
  
 Следующий простой пример сообщения <xref:System.Double> значение <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> объекта, а затем считывается значение обратно из объекта несколько раз. Поскольку значения не удаляются из <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> объекты после их прочтения, то же значение доступно каждый раз.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Полный пример, демонстрирующий использование <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> передачи сообщения нескольким целевым блокам, см. [Практическое руководство: указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> напоминает класс <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> класса, за исключением того, что <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> объектов могут быть записаны только один раз. Можно представить себе <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> как аналог C# [readonly](../Topic/readonly%20\(C%23%20Reference\).md) ([ReadOnly](../Topic/ReadOnly%20\(Visual%20Basic\).md) в [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) ключевое слово, за исключением того, что <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> становится неизменяемым после того, он получает значение, а не во время создания. Как <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> класса, когда целевой объект получает сообщение от <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> объекта, это сообщение не удаляется из этого объекта. Поэтому копию сообщения могут получить несколько целевых объектов. <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> класс полезен, когда требуется передать только первое из нескольких сообщений.  
  
 Следующий пример отправляет несколько <xref:System.String> значения <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> объект, а затем это значение считывается обратно из этого объекта. Поскольку <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> объектов могут быть записаны один раз, после <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> объект получает сообщение, он отклоняет последующие сообщения.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Полный пример, демонстрирующий использование <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> для получения значения первой завершенной операции, в разделе [Практическое руководство: удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Блоки выполнения  
 Блоки выполнения вызывают предоставленный пользователем делегат для каждого элемента полученных данных. Библиотека потоков данных TPL предоставляет три типа блоков выполнения: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=fullName>, и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=fullName>.\</TInput, TOutput> \</TInput, TOutput>  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> класса — целевой блок, который вызывает делегат при получении данных. Представьте <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> как делегат, который выполняется асинхронно, когда данные становятся доступными. Делегат, который предоставляется <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> объект может иметь тип <xref:System.Action> или `System.Func\<TInput, Task>`. При использовании <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> объекта с <xref:System.Action>, обработка каждого входного элемента считается завершенной, когда возвращается делегат. При использовании <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> объекта с `System.Func\<TInput, Task>`, обработка каждого входного элемента считается завершенной, только если возвращаемый <xref:System.Threading.Tasks.Task> объект завершается. С помощью этих двух механизмов, можно использовать <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> для синхронной и асинхронной обработки каждого входного элемента.  
  
 Следующий пример отправляет несколько <xref:System.Int32> значения <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> объекта. <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> выводит эти значения на консоль. Затем в этом примере производится установка блока в завершенное состояние, и происходит ожидание завершения всех задач потока данных.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Полные примеры, демонстрирующие способы использования делегатов с <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> см. в разделе [как: выполнять действия при получении данных потоков блок данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> напоминает класс <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> класса, за исключением того, что он работает как источник и как адресат.\</TInput, TOutput> Делегат, передаваемый <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> объект возвращает значение типа `TOutput`.</TInput, TOutput> Делегат, который предоставляется <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> объект может иметь тип `System.Func<TInput, TOutput>` или `System.Func<TInput, Task>`.\</TInput, TOutput> При использовании <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> объекта с `System.Func\<TInput, TOutput>`, обработка каждого входного элемента считается завершенной, когда возвращается делегат.</TInput, TOutput> При использовании <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> объект, используемый с `System.Func<TInput, Task<TOutput>>`, обработка каждого входного элемента считается завершенной, только если возвращаемый <xref:System.Threading.Tasks.Task> объект завершается.\</TInput, TOutput> Как и в <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, с помощью этих двух механизмов, можно использовать <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> для синхронной и асинхронной обработки каждого входного элемента.\</TInput, TOutput>  
  
 Следующий пример создает <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> объект, который вычисляет квадратный корень из введенного.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> принимает <xref:System.Int32> значения в качестве входных данных и выдает <xref:System.Double> значения как выходной.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Полные примеры, которые использует <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> в сети блоков потока данных, которая выполняет обработку изображений в приложении Windows Forms, в разделе [Пошаговое руководство: использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).\</TInput, TOutput>  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> напоминает класс <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> класса, за исключением того, что <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> создает ноль или более выходных значений каждого входного значения, а не только одного значения для каждого входного значения.</TInput, TOutput> </TInput, TOutput> </TInput, TOutput> Делегат, который предоставляется <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объект может иметь тип `System.Func<TInput, IEnumerable<TOutput>>` или `type System.Func<TInput, Task<IEnumerable<TOutput>>>`.\</TInput, TOutput> При использовании <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объекта с `System.Func<TInput, IEnumerable<TOutput>>`, обработка каждого входного элемента считается завершенной, когда возвращается делегат.</TInput, TOutput> При использовании <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объекта с `System.Func<TInput, Task<IEnumerable<TOutput>>>`, обработка каждого входного элемента считается завершенной, только если возвращаемый `System.Threading.Tasks.Task<IEnumerable<TOutput>>` объект завершается.\</TInput, TOutput>  
  
 Следующий пример создает <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объекта, который разделяет строки на отдельные цепочки символов.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> принимает <xref:System.String> значения в качестве входных данных и выдает <xref:System.Char> значения как выходной.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Полные примеры, использующие <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> для создания нескольких независимых выходных значений для каждого входного элемента в конвейере потока данных, в разделе [Пошаговое руководство: создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).\</TInput, TOutput>  
  
#### <a name="degree-of-parallelism"></a>Степень параллелизма  
 Каждый <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объекта буферизует входные сообщения, пока блок не будет готов их обработать.</TInput, TOutput> </TInput, TOutput> По умолчанию эти классы обрабатывают сообщения в том порядке, в котором они поступают, по одному. Можно также указать степень параллелизма для включения <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объектов для одновременной обработки нескольких сообщений.\</TInput, TOutput> \</TInput, TOutput> Дополнительные сведения о параллельном выполнении см. в разделе "Определение степени параллелизма" далее в этом документе. Пример, задает степень параллелизма для включения обработки блоком потока данных обрабатывать более одного сообщения одновременно, в разделе [Практическое руководство: Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Сводка по типам делегатов  
 Следующей таблице перечислены типы делегатов, которые можно предоставить <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> объектов.\</TInput, TOutput> \</TInput, TOutput> В этой таблице также указано, работает ли делегат данного типа синхронно или асинхронно.  
  
|Тип|Синхронный тип делегата|Асинхронный тип делегата|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602></TInput, TOutput>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602></TInput, TOutput>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 Можно также использовать лямбда-выражения при работе с типами блоков выполнения. Пример, демонстрирующий способ использования лямбда-выражения с блоком выполнения см. в разделе [как: выполнять действия при получении данных потоков блок данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Группирующие блоки  
 Группирующие блоки объединяют данные из одного или более источников с различными ограничениями. Библиотека потоков данных TPL предоставляет три типа блоков объединения: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.\</T1, T2> \</T1, T2>  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> класс объединяет наборы входных данных, которые называются пакетами, в массивы выходных данных. Укажите размер каждого пакета при создании <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объекта. Когда <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> Получает указанное число входных элементов, он асинхронно передает массив, содержащий эти элементы. Если <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объекта установлено в состояние завершения, но не содержит достаточно элементов для формирования пакета, он передает конечный массив, который содержит оставшиеся входные элементы.  
  
 <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> класс работает либо *жадный* или *нежадном* режим. В жадном режиме, используемом по умолчанию <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> принимает каждое сообщение, он предоставляется и передает массив получив указанное число элементов. В нежадном режиме <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> откладывает все входящие сообщения, пока достаточное количество источников предложит сообщения блоку для формирования пакета. Жадный режим обычно работает быстрее, чем нежадный режим, поскольку он требует меньше дополнительной нагрузки для обработки. Однако можно использовать нежадный режим, если необходимо координировать получение от нескольких источников атомарным образом. Укажите нежадного режима, задав <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> для `False` в `dataflowBlockOptions` параметр в <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> конструктор.  
  
 Следующий пример отправляет несколько <xref:System.Int32> значения <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объекту, содержащему десять элементов в пакете. Для обеспечения передачи всех значений из <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, в этом примере вызывается <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> метод. <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> метода задает <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объекта в состояние завершения и, следовательно, <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> объект передает все оставшиеся элементы в качестве последнего пакета.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Полный пример, использующий <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> для повышения эффективности операций вставки в базу данных, в разделе [Пошаговое руководство: с помощью BatchBlock и BatchedJoinBlock повышение эффективности](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> классы собирают входные элементы и распространяют <xref:System.Tuple%602?displayProperty=fullName> или <xref:System.Tuple%603?displayProperty=fullName> объекты, содержащие эти элементы.\</T1, T2, T3> \</T1, T2> \</T1, T2, T3> \</T1, T2> <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> классы не наследуют от <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</T1, T2, T3> </T1, T2> Вместо этого они предоставляют свойства <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, которые реализуют <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Как <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> работают в жадном, либо в нежадном режиме.</T1, T2, T3> </T1, T2> В жадном режиме, используемом по умолчанию <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> или <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> принимает каждое сообщение, он предоставляется и распространяет кортеж после каждого из его целевых объектов получает по крайней мере одно сообщение.</T1, T2, T3> </T1, T2> В нежадном режиме <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> или <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> откладывает все входящие сообщения, пока все целевые объекты будут предложены данные, необходимые для создания кортежа.\</T1, T2, T3> \</T1, T2> В этот момент блок использует протокол двухфазной фиксации для атомарного извлечения всех необходимых элементов из источника. Эта задержка дает возможность другой сущности в это же время получать эти данные, что позволяет системе в целом продолжать работу.  
  
 Следующий пример демонстрирует случай, в котором <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> требует нескольких элементов данных для вычисления значения.</T1, T2, T3> В этом примере создается <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> объекта, который требует два <xref:System.Int32> значения и <xref:System.Char> значение для выполнения арифметической операции.\</T1, T2, T3>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Полный пример, использующий <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> объектов в нежадном режиме для совместного использования ресурсов, в разделе [Практическое руководство: использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).\</T1, T2>  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> классы собирают пакеты входных элементов и распространяют `System.Tuple(IList(T1), IList(T2))` или `System.Tuple(IList(T1), IList(T2), IList(T3))` объекты, содержащие эти элементы.\</T1, T2, T3> \</T1, T2> Представьте <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> как сочетание <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> и <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</T1, T2> </T1, T2> Укажите размер каждого пакета при создании <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> объекта.\</T1, T2> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> также предоставляет свойства, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> и <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, которые реализуют <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</T1, T2> Если указанное число входных элементов получено от всех целевых объектов, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> асинхронно распространяет `System.Tuple(IList(T1), IList(T2))` объект, содержащий эти элементы.\</T1, T2>  
  
 Следующий пример создает <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> объект, содержащий результаты, <xref:System.Int32> значения и ошибки, которые <xref:System.Exception> объектов.</T1, T2> В этом примере выполняется несколько операций, результаты записываются в <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> свойства, а ошибки — <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> свойства из <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> объекта.\</T1, T2> Поскольку число успешных и неудачных операций не известно заранее, <xref:System.Collections.Generic.IList%601> объектов позволяют каждому целевому объекту получать ноль или более значений.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Полный пример, использующий <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> для захвата результатов и любые исключения, возникающие при чтении из базы данных, в разделе [Пошаговое руководство: с помощью BatchBlock и BatchedJoinBlock повышение эффективности](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).\</T1, T2>  
  
 [[go to top](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Настройка поведения блоков потоков данных  
 Можно включить дополнительные параметры, предоставляя <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName> конструктору типов блоков потока данных. Эти параметры управляют таким поведением, как у планировщика, который управляет основной задачей и степенью параллелизма. <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> также содержит производные типы, которые задают поведение, характерное для некоторых типов блоков потока данных. В следующей таблице перечислено, какие типы параметров связаны с каждым из типов блоков потоков данных.  
  
|Тип блока потока данных|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> типа|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Следующие разделы предоставляют дополнительные сведения о важных типах потока данных блок параметров, доступных через <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=fullName>, и <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=fullName> классы.  
  
### <a name="specifying-the-task-scheduler"></a>Определение планировщика заданий  
 Все стандартные блоки потоков данных используют механизм планирования задач TPL для выполнения таких действий, как передача данных целевому объекту, получение данных из источника и выполнение определенных пользователем делегатов, когда данные становятся доступны. <xref:System.Threading.Tasks.TaskScheduler> представляет абстрактный класс, представляющий планировщик задач, который ставит задачи на потоки. Планировщик задач по умолчанию <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, использует <xref:System.Threading.ThreadPool> класса для создания очереди и выполнения работы. Планировщик заданий по умолчанию можно переопределить, задав <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> свойства при создании объекта блока потока данных.  
  
 Если один и тот же планировщик заданий управляет несколькими блоками потока данных, он может применять к ним определенные политики. Например, если несколько блоков потока данных каждый настроен для отдельного планировщика заданий одного <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> объекта, вся работа, выполняемая в этих блоках, сериализуется. Аналогично Если эти блоки настроены для параллельного планировщика заданий одного <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> объекта и этот планировщик настроен максимальный уровень параллелизма, вся работа из этих блоков ограничивается заданным числом одновременных операций. Пример, использующий <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> класса, чтобы позволить операциям чтения выполняться параллельно, а также операций записи исключать выполнение всех остальных операций, в разделе [Практическое руководство: указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Дополнительные сведения о планировщике заданий в TPL см. в разделе <xref:System.Threading.Tasks.TaskScheduler> разделе, посвященном классу.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Определение степени параллелизма  
 По умолчанию три типа блоков выполнения, предоставляемых библиотекой потоков данных, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, обрабатывают одно сообщение за раз.\</TInput, TOutput> \</TInput, TOutput> Эти типы блоков потоков данных также обрабатывают сообщения в порядке их поступления. Чтобы включить эти блоки потока данных для одновременной обработки сообщений, задайте <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=fullName> свойства при создании объекта блока потока данных.  
  
 Значение по умолчанию <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> 1, который гарантирует, что блок потока данных обрабатывает одно сообщение за раз. Присвоение этому свойству значения более 1 активирует обработку блоком потока данных нескольких сообщений одновременно. Присвоение этому свойству значения <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName> позволяет основному планировщику задач управлять максимальной степенью параллелизма.  
  
> [!IMPORTANT]
>  При максимальной степени параллелизма, составляющей больше 1, несколько сообщений обрабатываются одновременно, и поэтому сообщения не могут обрабатываться в порядке их получения. Тем не менее порядок, в котором сообщения выводятся из блока, будет верным.  
  
 Поскольку <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> свойства представляет максимальную степень параллелизма, блок потока данных может выполняться с меньшей степенью параллелизма, чем задано. Блок потока данных может использовать меньшую степень параллелизма для удовлетворения функциональных требований или при нехватке доступных системных ресурсов. Блок потока данных никогда не выбирает степень параллелизма больше заданной.  
  
 Значение <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> свойство уникально для каждого объекта блока потока данных. Например, если для четырех объектов блока потока данных задана 1 как максимальная степень параллелизма, все четыре объекта блока потока данных потенциально могут выполняться параллельно.  
  
 Пример, который задает максимальную степень параллелизма для предоставления возможности параллельного выполнения продолжительных операций, в разделе [Практическое руководство: Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Определение количества сообщений на задачу  
 Предопределенные типы блоков потока данных используют задачи для обработки нескольких входных элементов. Это позволяет минимизировать число объектов задачи, необходимых для обработки данных, из-за чего приложения выполняются более эффективно. Однако если задачи из одного набора блоков потока данных обрабатывают данные, задачи из других блоков потока данных быть вынуждены ожидать в течение времени, необходимого для обработки данных, добавляя сообщения в очередь. Чтобы обеспечить улучшенное распределение ресурсов между задачами потока данных, задайте <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> свойство. Когда <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> равен <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName>, который используется по умолчанию, задача, используемая блоком потока данных обрабатывает столько сообщений доступны. Когда <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> задано значение, отличное от <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, блок потока данных обрабатывает не больше этого количества сообщений на <xref:System.Threading.Tasks.Task> объекта. Хотя Настройка <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> свойство может улучшить распределение ресурсов между задачами, это может привести в системе, для создания дополнительных задач, чем это необходимо, что может снизить производительность.  
  
### <a name="enabling-cancellation"></a>Включение отмены  
 TPL предоставляет механизм, который позволяет задачам координировать отмены согласованным образом. Чтобы включить блоки потока данных участвовать в механизме отмены, задайте <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> свойство. При этом <xref:System.Threading.CancellationToken> объекта установлено в состояние отмены, все блоки потока данных, которые отслеживают этот маркер завершат выполнение текущего элемента, но не начнут обрабатывать последующие элементы. Эти блоки потока данных также очищают все буферизованные сообщения, прекращают подключения ко всем блокам источников и целевых объектов, и переходят в состояние отмены. Путем перехода в состояние отмены <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> имеет свойство <xref:System.Threading.Tasks.Task.Status%2A> свойству <xref:System.Threading.Tasks.TaskStatus>, если возникло исключение во время обработки. В этом случае <xref:System.Threading.Tasks.Task.Status%2A> равен <xref:System.Threading.Tasks.TaskStatus>.  
  
 Пример, демонстрирующий способ использования отмены в приложении Windows Forms см. в разделе [Практическое руководство: Отмена блока потока данных](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Дополнительные сведения об отмене в TPL см. в разделе [отмены задачи](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Определение жадного и нежадного поведения  
 Несколько группирующих типов блоков потока данных могут работать либо *жадный* или *нежадном* режим. По умолчанию стандартные типы блоков потоков данных работают в жадном режиме.  
  
 Для соединения блоков типов, таких как <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, жадный режим означает, что блок сразу принимает данные, даже если соответствующие данные для объединения еще не доступен.</T1, T2> Нежадный режим означает, что блок откладывает все входящие сообщения до тех пор, пока сообщение не будет доступно на каждом из его целевых объектов для завершения объединения. Если любое из отложенных сообщений больше недоступно, блоки соединения освобождают все отложенные сообщения и перезапускают процесс. Для <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> классов жадный и нежадный аналогичен, за исключением того, что в нежадном режиме <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> откладывает все входящие сообщения, пока достаточно доступны из различных источников для заполнения пакета.  
  
 Чтобы указать нежадного режима для блока потока данных, задайте <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> в `False`. Пример, демонстрирующий способ использования нежадного режима для включения нескольких блоков соединения для более эффективного совместного использования источника данных см. в разделе [Практическое руководство: использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[go to top](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Пользовательские блоки потоков данных  
 Хотя библиотека потоков данных TPL предоставляет множество стандартных типов блоков, можно создавать дополнительные типы блоков, которые выполняют устанавливаемые пользователем функции. Реализуйте <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> или <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> взаимодействует напрямую или использовать <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> метод для построения сложных блоков, которые инкапсулируют поведение существующих типов блоков.\</TInput, TOutput> Примеры, демонстрирующие способы реализации функциональности блоков потока данных пользовательского см. [Пошаговое руководство: Создание пользовательского типа блока потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[go to top](#top)]  
  
## <a name="related-topics"></a>Связанные разделы  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Практическое руководство: писать и читать сообщения из блока потока данных](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Показано, как писать и читать сообщения из <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> объекта.|  
|[Практическое руководство: реализации шаблона производитель получатель потока данных](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Здесь приводится описания способов использования модели потока данных для реализации шаблона производитель-потребитель, где производитель отправляет сообщения в блок потока данных, а потребитель считывает сообщения из этого блока.|  
|[Практическое руководство: выполнение действий при получении данных блоком потоков данных](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Описание способов предоставления делегатов типам блоков выполнения потока данных, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, и <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.\</TInput, TOutput> \</TInput, TOutput>|  
|[Пошаговое руководство: Создание конвейера потока данных](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Здесь приводится способ создания конвейера потока данных, который загружает текст из Интернета и выполняет над ним операции.|  
|[Практическое руководство: удаление связей с блоками потоков данных](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Демонстрируется использование <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> способ отсоединения целевого блока от источника после как источник отправил сообщение целевому объекту.|  
|[Пошаговое руководство: Использование потока данных в приложении Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Здесь демонстрируется, как создавать сеть блоков потока данных, которые выполняют обработку изображений в приложении Windows Forms.|  
|[Практическое руководство: Отмена блока потока данных](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Здесь демонстрируется способ использования отмены в приложении Windows Forms.|  
|[Практическое руководство: использование JoinBlock для чтения данных из нескольких источников](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Описание способов использования <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> класса для выполнения операции, когда данные недоступны из нескольких источников и способов использования нежадного режима для включения нескольких блоков соединения для более эффективного совместного использования источника данных.\</T1, T2>|  
|[Практическое руководство: Указание степени параллелизма в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Описывает, как задать <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> свойства, чтобы позволить блоку выполнения потока данных обрабатывать более одного сообщения одновременно.|  
|[Практическое руководство: указание планировщика задач в блоке потока данных](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Здесь демонстрируется, как связать определенный планировщик задач при использовании потока данных в приложении.|  
|[Пошаговое руководство: Использование для повышения эффективности BatchBlock и BatchedJoinBlock](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Описывает использование <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> вставки класса для повышения эффективности базы данных операций и использование <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> класс для записи результатов и любые исключения, возникающие при чтении из базы данных.\</T1, T2>|  
|[Пошаговое руководство: Создание потока данных пользовательского типа блока](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Здесь приводятся два способа создания типа блока потока данных, который реализует пользовательские функции.|  
|[Библиотека параллельных задач (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Здесь приводится описание TPL — библиотеки, упрощающей параллельное и одновременное программирование в приложениях [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|