---
title: "Пользовательские разделители для PLINQ и TPL"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="8af95-102">Пользовательские разделители для PLINQ и TPL</span><span class="sxs-lookup"><span data-stu-id="8af95-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="8af95-103">Распараллеливании операции над источником данных, одним из основных шагов является *секции* источника на несколько секций, могут получать несколько потоков одновременно.</span><span class="sxs-lookup"><span data-stu-id="8af95-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="8af95-104">PLINQ и библиотеке параллельных задач (TPL) предоставляют модули разделения по умолчанию, которые работают прозрачно при написании параллельного запроса или <xref:System.Threading.Tasks.Parallel.ForEach%2A> цикла.</span><span class="sxs-lookup"><span data-stu-id="8af95-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="8af95-105">Для более сложных сценариев можно подключить собственный модуль разделения.</span><span class="sxs-lookup"><span data-stu-id="8af95-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="8af95-106">Типы разделения</span><span class="sxs-lookup"><span data-stu-id="8af95-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="8af95-107">Существует много способов разделения источника данных.</span><span class="sxs-lookup"><span data-stu-id="8af95-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="8af95-108">В наиболее эффективный подходах совместно работают несколько потоков процесса исходной последовательности, а не физического разделения источника на несколько подпоследовательностей.</span><span class="sxs-lookup"><span data-stu-id="8af95-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="8af95-109">Для массивов и других индексированных источников, таких как <xref:System.Collections.IList> коллекций, где длина известен заранее, *диапазонам* является простым типом разделения.</span><span class="sxs-lookup"><span data-stu-id="8af95-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="8af95-110">Каждый поток получает уникальные индексы начала и конца, поэтому для обработки диапазона источника без перезаписи или перезаписи другим потоком.</span><span class="sxs-lookup"><span data-stu-id="8af95-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="8af95-111">Только нагрузка, вызванная диапазонам, служат началом процесса создания диапазонов; После этого требуется никакой дополнительной синхронизации.</span><span class="sxs-lookup"><span data-stu-id="8af95-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="8af95-112">Таким образом он может предоставлять хорошую производительность при условии, что рабочая нагрузка распределяется равномерно.</span><span class="sxs-lookup"><span data-stu-id="8af95-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="8af95-113">Диапазонам недостаток заключается в том, если один поток завершает рано, он не может помочь завершают свою работу других потоков.</span><span class="sxs-lookup"><span data-stu-id="8af95-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="8af95-114">Для связанных списков и других коллекций, длина которого не известен, можно использовать *разделение по блокам*.</span><span class="sxs-lookup"><span data-stu-id="8af95-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="8af95-115">В разделение по блокам, каждый поток или задачу в параллельном цикле или запрос использует некоторое количество исходных элементов в одном блоке, обрабатывает их и затем возвращается к извлечению дополнительных элементов.</span><span class="sxs-lookup"><span data-stu-id="8af95-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="8af95-116">Модуль разделения гарантирует распределение всех элементов и что нет повторяющихся значений.</span><span class="sxs-lookup"><span data-stu-id="8af95-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="8af95-117">Фрагмент может быть любого размера.</span><span class="sxs-lookup"><span data-stu-id="8af95-117">A chunk may be any size.</span></span> <span data-ttu-id="8af95-118">Например, модуль разделения, представленный в [как: реализация динамических разделов](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) создает блоки, содержащие только один элемент.</span><span class="sxs-lookup"><span data-stu-id="8af95-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="8af95-119">При условии, что блоки не слишком велик, этот тип секционирования по своей природе балансировки нагрузки, так как назначение элементов потокам не предопределено.</span><span class="sxs-lookup"><span data-stu-id="8af95-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="8af95-120">Тем не менее разделитель трудозатрат, синхронизация каждый раз необходимо получить другой фрагмент данных потока.</span><span class="sxs-lookup"><span data-stu-id="8af95-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="8af95-121">Объем синхронизации в этих случаях обратно пропорционально размеру блоков.</span><span class="sxs-lookup"><span data-stu-id="8af95-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="8af95-122">В общем случае диапазонам выполняется только быстрее, если время выполнения делегата малого до среднего и источник имеет большое количество элементов и трудозатраты каждой секции, примерно равно.</span><span class="sxs-lookup"><span data-stu-id="8af95-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="8af95-123">Разделение по блокам таким образом обычно происходят быстрее, в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="8af95-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="8af95-124">В источниках с небольшим числом элементов или длительным временем выполнения делегата производительность блоков и диапазонам то примерно равно.</span><span class="sxs-lookup"><span data-stu-id="8af95-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="8af95-125">Модули разделения TPL также поддерживает динамическое количество разделов.</span><span class="sxs-lookup"><span data-stu-id="8af95-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="8af95-126">Это означает, что можно создать разделы на лету, например, если <xref:System.Threading.Tasks.Parallel.ForEach%2A> цикла вызывает новую задачу.</span><span class="sxs-lookup"><span data-stu-id="8af95-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="8af95-127">Эта функция позволяет модулю разделения масштабироваться вместе с циклом.</span><span class="sxs-lookup"><span data-stu-id="8af95-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="8af95-128">Динамические модули разделения также являются по своей природе балансировки нагрузки.</span><span class="sxs-lookup"><span data-stu-id="8af95-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="8af95-129">При создании пользовательского модуля разделения, необходимо поддерживать динамическое секционирование, чтобы можно было использовать в <xref:System.Threading.Tasks.Parallel.ForEach%2A> цикла.</span><span class="sxs-lookup"><span data-stu-id="8af95-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="8af95-130">Настройка разделители для PLINQ балансировки нагрузки</span><span class="sxs-lookup"><span data-stu-id="8af95-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="8af95-131">Некоторые перегрузки <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> позволяют создать разделения для массива или <xref:System.Collections.IList> источника и укажите, является ли он предпринять попытку распределения рабочей нагрузки между потоками.</span><span class="sxs-lookup"><span data-stu-id="8af95-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="8af95-132">При настройке балансировки нагрузки разделитель используется разделение по блокам и элементы передаются в каждый раздел небольшими фрагментами по запросу.</span><span class="sxs-lookup"><span data-stu-id="8af95-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="8af95-133">Такой подход гарантирует, что все разделы будут содержать элементы для обработки, пока весь цикл или завершения запроса.</span><span class="sxs-lookup"><span data-stu-id="8af95-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="8af95-134">Дополнительные перегрузка может использоваться для балансировки нагрузки структурировать любого <xref:System.Collections.IEnumerable> источника.</span><span class="sxs-lookup"><span data-stu-id="8af95-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="8af95-135">Как правило балансировки нагрузки требует, чтобы относительно часто запрашивали элементы из модуля разделения разделы.</span><span class="sxs-lookup"><span data-stu-id="8af95-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="8af95-136">Напротив модуль разделения, осуществляющий статическое разделение можно назначить элементы каждого модуля разделения за один раз, используя диапазон или разделение по блокам.</span><span class="sxs-lookup"><span data-stu-id="8af95-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="8af95-137">Это требует меньше ресурсов, чем для распределения нагрузки, но может занять больше времени, если один поток обрабатывает значительно сложнее, чем другие.</span><span class="sxs-lookup"><span data-stu-id="8af95-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="8af95-138">По умолчанию при передаче IList или массив, PLINQ всегда использует диапазонам без балансировки нагрузки.</span><span class="sxs-lookup"><span data-stu-id="8af95-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="8af95-139">Чтобы включить балансировку нагрузки для PLINQ, используйте `Partitioner.Create` метод, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="8af95-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="8af95-140">Лучший способ определения ли использовать нагрузки Балансировка в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения операций при типичных нагрузках и конфигурациях компьютера.</span><span class="sxs-lookup"><span data-stu-id="8af95-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="8af95-141">Например статическое разделение может обеспечить значительное ускорение на компьютере для многоядерных процессоров с небольшим количеством ядер, но он может привести к замедлению на компьютерах, имеющих относительно большим количеством ядер.</span><span class="sxs-lookup"><span data-stu-id="8af95-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="8af95-142">В следующей таблице перечислены доступные перегрузки <xref:System.Collections.Concurrent.Partitioner.Create%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="8af95-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="8af95-143">Эти разделители не только для использования только с PLINQ или <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="8af95-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="8af95-144">Они также могут использоваться с любой пользовательской параллельной конструкции.</span><span class="sxs-lookup"><span data-stu-id="8af95-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="8af95-145">Перегрузка</span><span class="sxs-lookup"><span data-stu-id="8af95-145">Overload</span></span>|<span data-ttu-id="8af95-146">Использует распределение нагрузки</span><span class="sxs-lookup"><span data-stu-id="8af95-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="8af95-147">Всегда</span><span class="sxs-lookup"><span data-stu-id="8af95-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="8af95-148">Если логический аргумент имеет значение true</span><span class="sxs-lookup"><span data-stu-id="8af95-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="8af95-149">Если логический аргумент имеет значение true</span><span class="sxs-lookup"><span data-stu-id="8af95-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="8af95-150">Никогда</span><span class="sxs-lookup"><span data-stu-id="8af95-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="8af95-151">Никогда</span><span class="sxs-lookup"><span data-stu-id="8af95-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="8af95-152">Никогда</span><span class="sxs-lookup"><span data-stu-id="8af95-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="8af95-153">Никогда</span><span class="sxs-lookup"><span data-stu-id="8af95-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="8af95-154">Настройка разделители статический диапазон для Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="8af95-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="8af95-155">В <xref:System.Threading.Tasks.Parallel.For%2A> цикла, тело цикла предоставляется методу в качестве делегата.</span><span class="sxs-lookup"><span data-stu-id="8af95-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="8af95-156">Затраты ресурсов при вызове делегата посвящен таким же, как вызов виртуального метода.</span><span class="sxs-lookup"><span data-stu-id="8af95-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="8af95-157">В некоторых сценариях может быть достаточно мал, затраты на вызов делегата в каждой итерации цикла становится значительные тела параллельного цикла.</span><span class="sxs-lookup"><span data-stu-id="8af95-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="8af95-158">В такой ситуации, можно использовать один из <xref:System.Collections.Concurrent.Partitioner.Create%2A> перегрузок, чтобы создать <xref:System.Collections.Generic.IEnumerable%601> секций диапазона по элементам источника.</span><span class="sxs-lookup"><span data-stu-id="8af95-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="8af95-159">Затем можно передать в этой коллекции диапазонов, которые <xref:System.Threading.Tasks.Parallel.ForEach%2A> , тело которого состоит из обычного метода `for` цикла.</span><span class="sxs-lookup"><span data-stu-id="8af95-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="8af95-160">Преимущество этого подхода является то, что делегат затраты ресурсов на вызов только один раз в диапазоне, а не один раз для каждого элемента.</span><span class="sxs-lookup"><span data-stu-id="8af95-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="8af95-161">В следующем примере показан базовый шаблон.</span><span class="sxs-lookup"><span data-stu-id="8af95-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="8af95-162">Каждый поток цикла получает свой собственный <xref:System.Tuple%602> , содержащий начальное и конечное значения индекса указанного поддиапазона.</span><span class="sxs-lookup"><span data-stu-id="8af95-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="8af95-163">Внутренний `for` цикл использует `fromInclusive` и `toExclusive` значения для перебора массива или <xref:System.Collections.IList> напрямую.</span><span class="sxs-lookup"><span data-stu-id="8af95-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="8af95-164">Один из <xref:System.Collections.Concurrent.Partitioner.Create%2A> перегрузки позволяет указать размер секций и секций.</span><span class="sxs-lookup"><span data-stu-id="8af95-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="8af95-165">Эта перегрузка может использоваться в сценариях, где обработку каждого элемента, даже один вызов виртуального метода на один элемент оказывает значительное влияние на производительность низкий.</span><span class="sxs-lookup"><span data-stu-id="8af95-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="8af95-166">Пользовательские разделители</span><span class="sxs-lookup"><span data-stu-id="8af95-166">Custom Partitioners</span></span>  
 <span data-ttu-id="8af95-167">В некоторых случаях его может быть оправдан или даже необходимо реализовать собственный модуль разделения.</span><span class="sxs-lookup"><span data-stu-id="8af95-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="8af95-168">Например может потребоваться настраиваемый класс коллекции, можно разделить более эффективно, чем значение по умолчанию разделители можно на основе сведений из внутренней структуре класса.</span><span class="sxs-lookup"><span data-stu-id="8af95-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="8af95-169">Или можно создать секции диапазона различных размеров в зависимости от сведений о том, как время, необходимое на обработку элементов, расположенных в разных местах исходной коллекции.</span><span class="sxs-lookup"><span data-stu-id="8af95-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="8af95-170">Чтобы создать базовый пользовательский модуль разделения, наследуйте класс от <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> и переопределить виртуальные методы, как описано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8af95-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="8af95-171">Этот метод вызывается основным потоком один раз и возвращает IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="8af95-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="8af95-172">Каждый рабочий поток цикла или запроса можно вызвать `GetEnumerator` в списке, чтобы получить <xref:System.Collections.Generic.IEnumerator%601> из отдельного раздела.</span><span class="sxs-lookup"><span data-stu-id="8af95-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="8af95-173">Вернуть `true` при реализации <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, в противном случае `false`.</span><span class="sxs-lookup"><span data-stu-id="8af95-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="8af95-174">Если <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> — `true`, этот метод может вызываться при необходимости вместо <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="8af95-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="8af95-175">Если результаты должны быть сортируемого или требуется индексный доступ в элементы, являются производными от <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> и переопределять его виртуальные методы, как описано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8af95-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="8af95-176">Этот метод вызывается основным потоком один раз и возвращает `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="8af95-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="8af95-177">Каждый рабочий поток цикла или запроса можно вызвать `GetEnumerator` в списке, чтобы получить <xref:System.Collections.Generic.IEnumerator%601> из отдельного раздела.</span><span class="sxs-lookup"><span data-stu-id="8af95-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="8af95-178">Вернуть `true` при реализации <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; в противном случае — значение false.</span><span class="sxs-lookup"><span data-stu-id="8af95-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="8af95-179">Как правило, это просто вызывает <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="8af95-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="8af95-180">Если <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> — `true`, этот метод может вызываться при необходимости вместо <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="8af95-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="8af95-181">В следующей таблице приведены дополнительные сведения о том, как три вида балансировки нагрузки реализуйте разделители <xref:System.Collections.Concurrent.OrderablePartitioner%601> класса.</span><span class="sxs-lookup"><span data-stu-id="8af95-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="8af95-182">Метод или свойство</span><span class="sxs-lookup"><span data-stu-id="8af95-182">Method/Property</span></span>|<span data-ttu-id="8af95-183">IList / массив без балансировки нагрузки</span><span class="sxs-lookup"><span data-stu-id="8af95-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="8af95-184">IList / массив с балансировкой нагрузки</span><span class="sxs-lookup"><span data-stu-id="8af95-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="8af95-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="8af95-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="8af95-186">Использует диапазонам</span><span class="sxs-lookup"><span data-stu-id="8af95-186">Uses range partitioning</span></span>|<span data-ttu-id="8af95-187">Использует разделение по блокам оптимизированное для списков с указанным partitionCount</span><span class="sxs-lookup"><span data-stu-id="8af95-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="8af95-188">Использует разделение по блокам посредством создания статического количества секций.</span><span class="sxs-lookup"><span data-stu-id="8af95-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="8af95-189">Выдает неподдерживаемое исключение</span><span class="sxs-lookup"><span data-stu-id="8af95-189">Throws not-supported exception</span></span>|<span data-ttu-id="8af95-190">Использует разделение по блокам для списков и динамических разделов</span><span class="sxs-lookup"><span data-stu-id="8af95-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="8af95-191">Использует разделение по блокам посредством создания динамического количества секций.</span><span class="sxs-lookup"><span data-stu-id="8af95-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="8af95-192">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-192">Returns `true`</span></span>|<span data-ttu-id="8af95-193">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-193">Returns `true`</span></span>|<span data-ttu-id="8af95-194">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="8af95-195">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-195">Returns `true`</span></span>|<span data-ttu-id="8af95-196">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="8af95-196">Returns `false`</span></span>|<span data-ttu-id="8af95-197">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="8af95-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="8af95-198">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-198">Returns `true`</span></span>|<span data-ttu-id="8af95-199">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-199">Returns `true`</span></span>|<span data-ttu-id="8af95-200">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="8af95-201">Возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="8af95-201">Returns `false`</span></span>|<span data-ttu-id="8af95-202">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-202">Returns `true`</span></span>|<span data-ttu-id="8af95-203">Возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="8af95-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="8af95-204">Динамические разделы</span><span class="sxs-lookup"><span data-stu-id="8af95-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="8af95-205">Если предполагается разделитель для использования в <xref:System.Threading.Tasks.Parallel.ForEach%2A> метод, необходимо будет вернуть динамических несколько секций.</span><span class="sxs-lookup"><span data-stu-id="8af95-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="8af95-206">Это означает, что разделитель можно задать перечислитель для новой секции по требованию в любое время при выполнении цикла.</span><span class="sxs-lookup"><span data-stu-id="8af95-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="8af95-207">По сути каждый раз, когда цикл добавляет новую параллельную задачу, он запрашивает новый раздел для этой задачи.</span><span class="sxs-lookup"><span data-stu-id="8af95-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="8af95-208">Если требуется, чтобы данные должны быть упорядоченными, являются производными от <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> , чтобы каждому элементу в каждой секции, присваивается уникальный индекс.</span><span class="sxs-lookup"><span data-stu-id="8af95-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="8af95-209">Дополнительные сведения и пример см. в разделе [как: реализация динамических разделов](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="8af95-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="8af95-210">Контракт для модулей разделения</span><span class="sxs-lookup"><span data-stu-id="8af95-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="8af95-211">При реализации пользовательского модуля разделения, придерживайтесь следующих правил для обеспечения правильного взаимодействия с PLINQ и <xref:System.Threading.Tasks.Parallel.ForEach%2A> в TPL:</span><span class="sxs-lookup"><span data-stu-id="8af95-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="8af95-212">Если <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> вызывается с аргументом нулю или меньше для `partitionsCount`, исключение <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="8af95-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="8af95-213">Несмотря на то, что PLINQ и TPL никогда не передают `partitionCount` равно 0, тем не менее рекомендуется предотвратить возможность.</span><span class="sxs-lookup"><span data-stu-id="8af95-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="8af95-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>и <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> всегда должны возвращать `partitionsCount` число секций.</span><span class="sxs-lookup"><span data-stu-id="8af95-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="8af95-215">Если разделитель не хватает данных и не удается создать запрошенный столько секций, метод должен возвращать пустой перечислитель для каждого из остальных разделов.</span><span class="sxs-lookup"><span data-stu-id="8af95-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="8af95-216">В противном случае вызывает исключение PLINQ и TPL <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="8af95-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="8af95-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, и <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> никогда не должны возвращать `null` (`Nothing` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8af95-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="8af95-218">Если они есть, PLINQ и библиотеке параллельных задач вызывает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="8af95-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="8af95-219">Методы, возвращающие разделы, всегда должны возвращать секции, которые можно полностью и однозначно перечислить источник данных.</span><span class="sxs-lookup"><span data-stu-id="8af95-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="8af95-220">Должна существовать дублирующихся в источнике данных или пропущенные элементы, если только специально конструктора модуля разделения.</span><span class="sxs-lookup"><span data-stu-id="8af95-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="8af95-221">Если это правило не соблюдены, может быть нарушен порядок выходных данных.</span><span class="sxs-lookup"><span data-stu-id="8af95-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="8af95-222">Следующие логические получатели всегда должны точно возвращать следующие значения, чтобы не нарушать порядок выходных данных:</span><span class="sxs-lookup"><span data-stu-id="8af95-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="8af95-223">`KeysOrderedInEachPartition`: Каждый раздел возвращает элементы с увеличением ключа индексов.</span><span class="sxs-lookup"><span data-stu-id="8af95-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="8af95-224">`KeysOrderedAcrossPartitions`: Для всех секций, которые возвращаются индексы ключа секции *я* выше, чем индексы ключа секции *я*-1.</span><span class="sxs-lookup"><span data-stu-id="8af95-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="8af95-225">`KeysNormalized`: Все индексы ключа монотонно без промежутков, начиная с нуля.</span><span class="sxs-lookup"><span data-stu-id="8af95-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="8af95-226">Все индексы должны быть уникальными.</span><span class="sxs-lookup"><span data-stu-id="8af95-226">All indices must be unique.</span></span> <span data-ttu-id="8af95-227">Не может быть повторяющиеся индексы.</span><span class="sxs-lookup"><span data-stu-id="8af95-227">There may not be duplicate indices.</span></span> <span data-ttu-id="8af95-228">Если это правило не соблюдены, может быть нарушен порядок выходных данных.</span><span class="sxs-lookup"><span data-stu-id="8af95-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="8af95-229">Все индексы должны быть неотрицательными.</span><span class="sxs-lookup"><span data-stu-id="8af95-229">All indices must be nonnegative.</span></span> <span data-ttu-id="8af95-230">Если это правило не соблюдены, PLINQ и TPL могут вызывать исключения.</span><span class="sxs-lookup"><span data-stu-id="8af95-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8af95-231">См. также</span><span class="sxs-lookup"><span data-stu-id="8af95-231">See Also</span></span>  
 [<span data-ttu-id="8af95-232">Параллельное программирование</span><span class="sxs-lookup"><span data-stu-id="8af95-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="8af95-233">Практическое руководство. Реализация динамических секций</span><span class="sxs-lookup"><span data-stu-id="8af95-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="8af95-234">Практическое руководство. Реализация разделителя для статического секционирования</span><span class="sxs-lookup"><span data-stu-id="8af95-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
