---
title: "Общее представление об ускорении выполнения в PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="157a8-102">Общее представление об ускорении выполнения в PLINQ</span><span class="sxs-lookup"><span data-stu-id="157a8-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="157a8-103">Основной PLINQ предназначена для ускорения выполнения LINQ to Objects, запросы, выполнив делегатов запроса в параллельном режиме на компьютерах с многоядерными процессорами.</span><span class="sxs-lookup"><span data-stu-id="157a8-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="157a8-104">PLINQ выше, после обработки каждого элемента в исходной коллекции независимых без общего состояния, связанные с отдельными делегатами.</span><span class="sxs-lookup"><span data-stu-id="157a8-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="157a8-105">Такие операции являются общими в LINQ to Objects и PLINQ и часто называются «*параллельными*", так как они легко предоставляются для планирования в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="157a8-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="157a8-106">Однако не все запросы полностью состоят из таких параллельных операций. в большинстве случаев когда запрос включает некоторые операторы, либо не может выполняться параллельно, или замедляют параллельное выполнение.</span><span class="sxs-lookup"><span data-stu-id="157a8-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="157a8-107">И даже с запросами, которые полностью являются параллельными, PLINQ должен по-прежнему разделять источники данных и планировать работу с потоками и обычно слияния результатов при завершении запроса.</span><span class="sxs-lookup"><span data-stu-id="157a8-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="157a8-108">Добавьте все эти операции вычислительную стоимость параллелизации. Эти затраты на добавление параллелизма называются *издержки*.</span><span class="sxs-lookup"><span data-stu-id="157a8-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="157a8-109">Для достижения оптимальной производительности в запросе PLINQ, предназначена для частей, которые являются параллельными и свести к минимуму частей, которые требуют издержек.</span><span class="sxs-lookup"><span data-stu-id="157a8-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="157a8-110">Эта статья содержит сведения, которые помогут вам создавать запросы PLINQ, которые являются наиболее эффективны при этом предоставляют правильные результаты.</span><span class="sxs-lookup"><span data-stu-id="157a8-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="157a8-111">Факторы, влияющие на производительность запросов PLINQ</span><span class="sxs-lookup"><span data-stu-id="157a8-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="157a8-112">В следующих разделах перечисляются некоторые из наиболее важных факторов, оказывают влияние на производительность параллельных запросов.</span><span class="sxs-lookup"><span data-stu-id="157a8-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="157a8-113">Это общие инструкции, которые сами по себе недостаточно для предсказания производительности запросов во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="157a8-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="157a8-114">Как всегда важно Измерьте фактическую производительность определенных запросов на компьютерах с различными представленных конфигураций и нагрузок.</span><span class="sxs-lookup"><span data-stu-id="157a8-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="157a8-115">Вычислительная стоимость общей работы.</span><span class="sxs-lookup"><span data-stu-id="157a8-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="157a8-116">Для достижения увеличения скорости запроса PLINQ должен иметь достаточный объем параллельных операций для компенсации издержек.</span><span class="sxs-lookup"><span data-stu-id="157a8-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="157a8-117">Работа может быть выражен как вычислительная стоимость каждого делегата, умноженное на количество элементов в исходной коллекции.</span><span class="sxs-lookup"><span data-stu-id="157a8-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="157a8-118">Предположим, что операция может выполняться параллельно, требующими большего количества вычислений дорогих больше, параллельной.</span><span class="sxs-lookup"><span data-stu-id="157a8-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="157a8-119">Например если функция принимает для выполнения одной миллисекунды, последовательный запрос, более 1000 элементами потребует одной секунды для выполнения этой операции, в то время как параллельный запрос на компьютере с четырьмя ядрами может потребоваться только 250 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="157a8-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="157a8-120">Это дает ускорение на 750 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="157a8-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="157a8-121">Если функция требует одной секунды на выполнение каждого элемента, то ускорение будет равно 750 секундам.</span><span class="sxs-lookup"><span data-stu-id="157a8-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="157a8-122">Если делегат является весьма затратным, PLINQ может предложить значительное увеличение скорости с помощью только несколько элементов в исходной коллекции.</span><span class="sxs-lookup"><span data-stu-id="157a8-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="157a8-123">И наоборот, небольшие исходные коллекции с простыми делегатами обычно не являются хорошими кандидатами для PLINQ.</span><span class="sxs-lookup"><span data-stu-id="157a8-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="157a8-124">В следующем примере queryA, скорее всего, является хорошим кандидатом для PLINQ, при условии, что его функция Select содержит большой объем работы.</span><span class="sxs-lookup"><span data-stu-id="157a8-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="157a8-125">queryB скорее всего, не является хорошим кандидатом, так как не достаточный объем работы в инструкции Select, и затрат на параллелизацию будет перенесено большинство или все ускорение.</span><span class="sxs-lookup"><span data-stu-id="157a8-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="157a8-126">Число ядер в системе (степень параллелизма).</span><span class="sxs-lookup"><span data-stu-id="157a8-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="157a8-127">Эта точка находится является очевидным следствием в предыдущем разделе, запросы, которые являются параллельными выполняться быстрее, на компьютерах с больше ядер, поскольку можно разделить работу между несколько параллельных потоков.</span><span class="sxs-lookup"><span data-stu-id="157a8-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="157a8-128">Общий объем ускорение работы зависит от того, какой процент общей работы запрос параллельно.</span><span class="sxs-lookup"><span data-stu-id="157a8-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="157a8-129">Однако не следует предполагать, что все запросы будут выполняться дважды в качестве файлов на компьютере с восемью ядрами как четыре основных компьютер.</span><span class="sxs-lookup"><span data-stu-id="157a8-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="157a8-130">При настройке запросов для достижения оптимальной производительности, важно оценивать фактические результаты на компьютерах с различным количеством ядер.</span><span class="sxs-lookup"><span data-stu-id="157a8-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="157a8-131">Эта точка относится к пункту #1: требуются большие наборы данных, чтобы воспользоваться преимуществами больших вычислительных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="157a8-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="157a8-132">Количество и тип операции.</span><span class="sxs-lookup"><span data-stu-id="157a8-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="157a8-133">Язык PLINQ предоставляет оператор AsOrdered для ситуаций, в которых необходимо поддерживать порядок элементов в исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="157a8-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="157a8-134">Затраты, связанные с порядком, однако эти расходы обычно невелики.</span><span class="sxs-lookup"><span data-stu-id="157a8-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="157a8-135">Аналогично операции GroupBy и соединение требует затрат.</span><span class="sxs-lookup"><span data-stu-id="157a8-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="157a8-136">PLINQ работает лучше, когда оно выполняется для обработки элементов в исходной коллекции в любом порядке и передается следующему оператору как только они готовы.</span><span class="sxs-lookup"><span data-stu-id="157a8-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="157a8-137">Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="157a8-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="157a8-138">Форма выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="157a8-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="157a8-139">При сохранении результатов запроса путем вызова ToArray или ToList результатов из всех параллельных потоков должны быть объединены в одну структуру данных.</span><span class="sxs-lookup"><span data-stu-id="157a8-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="157a8-140">Это включает в себя неизбежным вычислительным затратам.</span><span class="sxs-lookup"><span data-stu-id="157a8-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="157a8-141">Аналогично при итерации результатов с помощью цикла foreach (For Each в Visual Basic), результаты из рабочих потоков должны быть сериализованы в поток-перечислитель.</span><span class="sxs-lookup"><span data-stu-id="157a8-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="157a8-142">Но если необходимо просто для выполнения некоторых операций на основе результатов из каждого потока, можно использовать метод ForAll для выполнения этой работы в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="157a8-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="157a8-143">Тип параметров слияния.</span><span class="sxs-lookup"><span data-stu-id="157a8-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="157a8-144">PLINQ можно настроить либо буферизацию выходных данных и создания его в виде фрагментов или все сразу после весь результирующий набор имеет создания, или настроить на поток отдельных результатов они создаются.</span><span class="sxs-lookup"><span data-stu-id="157a8-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="157a8-145">Первый вариант уменьшает общее время выполнения, а последний приводит к уменьшению задержки между полученными элементами.</span><span class="sxs-lookup"><span data-stu-id="157a8-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="157a8-146">Хотя параметры слияния, которые не всегда оказывают значительное влияние на общую производительность запроса, могут повлиять субъективную производительность, так как они управляют, сколько времени пользователь должен подождать, чтобы увидеть результаты.</span><span class="sxs-lookup"><span data-stu-id="157a8-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="157a8-147">Дополнительные сведения см. в разделе [Параметры слияние в PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="157a8-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="157a8-148">Тип секционирования.</span><span class="sxs-lookup"><span data-stu-id="157a8-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="157a8-149">В некоторых случаях запрос PLINQ по индексируемой исходной коллекции может привести к несбалансированности рабочей нагрузки.</span><span class="sxs-lookup"><span data-stu-id="157a8-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="157a8-150">В этом случае можно увеличить производительность запросов, создав пользовательский разделитель.</span><span class="sxs-lookup"><span data-stu-id="157a8-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="157a8-151">Дополнительные сведения см. в разделе [Пользовательские разделители для PLINQ и TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="157a8-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="157a8-152">Когда PLINQ выбирает последовательный режим</span><span class="sxs-lookup"><span data-stu-id="157a8-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="157a8-153">PLINQ всегда будет предпринята попытка выполнения запроса, по крайней мере так же быстро, как запрос будет выполняться последовательно.</span><span class="sxs-lookup"><span data-stu-id="157a8-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="157a8-154">Несмотря на то, что PLINQ не выглядит как вычислительных ресурсов пользовательских делегатов, или размер источника входных данных, поиск определенных запросов «фигуры».</span><span class="sxs-lookup"><span data-stu-id="157a8-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="157a8-155">В частности он ищет операторы запроса или сочетание операторов, обычно вызывает запроса выполняются медленнее в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="157a8-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="157a8-156">При нахождении таких форм PLINQ по умолчанию будет использоваться последовательный режим.</span><span class="sxs-lookup"><span data-stu-id="157a8-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="157a8-157">Однако после оценки производительности конкретного запроса, может выясниться, что он фактически выполняется быстрее в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="157a8-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="157a8-158">В таких случаях можно использовать <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> флаг через <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> метод для указания PLINQ для параллельного выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="157a8-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="157a8-159">Дополнительные сведения см. в разделе [Практическое руководство. Указание режима выполнения в PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="157a8-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="157a8-160">В следующем списке описываются формы запросов, которые PLINQ по умолчанию будет выполнять в последовательном режиме:</span><span class="sxs-lookup"><span data-stu-id="157a8-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="157a8-161">Запросы, содержащие инструкции Select, индексированный Where, индексированный SelectMany или ElementAt после оператора упорядочивания или фильтрации, который удаляет или переупорядочивает исходные индексы.</span><span class="sxs-lookup"><span data-stu-id="157a8-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="157a8-162">Запросы, содержащие Take, TakeWhile, Skip, SkipWhile-оператор и где индексы в исходной последовательности не находятся в исходном порядке.</span><span class="sxs-lookup"><span data-stu-id="157a8-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="157a8-163">Запросы, которые содержат Zip или SequenceEquals, за исключением случаев, когда один из источников данных содержит изначально упорядоченный индекс, а другой источник данных можно проиндексировать (например, массив или IList(T)).</span><span class="sxs-lookup"><span data-stu-id="157a8-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="157a8-164">Запросы, которые содержат Concat, если он не применяется к индексируемым источникам данных.</span><span class="sxs-lookup"><span data-stu-id="157a8-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="157a8-165">Запросы, содержащие обратить, если применяется к индексируемым источникам данных.</span><span class="sxs-lookup"><span data-stu-id="157a8-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="157a8-166">См. также</span><span class="sxs-lookup"><span data-stu-id="157a8-166">See Also</span></span>  
 [<span data-ttu-id="157a8-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="157a8-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
