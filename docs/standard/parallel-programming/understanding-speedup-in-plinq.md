---
title: "Общее представление об ускорении выполнения в PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a>Общее представление об ускорении выполнения в PLINQ
Основной PLINQ предназначена для ускорения выполнения LINQ to Objects, запросы, выполнив делегатов запроса в параллельном режиме на компьютерах с многоядерными процессорами. PLINQ выше, после обработки каждого элемента в исходной коллекции независимых без общего состояния, связанные с отдельными делегатами. Такие операции являются общими в LINQ to Objects и PLINQ и часто называются «*параллельными*", так как они легко предоставляются для планирования в нескольких потоках. Однако не все запросы полностью состоят из таких параллельных операций. в большинстве случаев когда запрос включает некоторые операторы, либо не может выполняться параллельно, или замедляют параллельное выполнение. И даже с запросами, которые полностью являются параллельными, PLINQ должен по-прежнему разделять источники данных и планировать работу с потоками и обычно слияния результатов при завершении запроса. Добавьте все эти операции вычислительную стоимость параллелизации. Эти затраты на добавление параллелизма называются *издержки*. Для достижения оптимальной производительности в запросе PLINQ, предназначена для частей, которые являются параллельными и свести к минимуму частей, которые требуют издержек. Эта статья содержит сведения, которые помогут вам создавать запросы PLINQ, которые являются наиболее эффективны при этом предоставляют правильные результаты.  
  
## <a name="factors-that-impact-plinq-query-performance"></a>Факторы, влияющие на производительность запросов PLINQ  
 В следующих разделах перечисляются некоторые из наиболее важных факторов, оказывают влияние на производительность параллельных запросов. Это общие инструкции, которые сами по себе недостаточно для предсказания производительности запросов во всех случаях. Как всегда важно Измерьте фактическую производительность определенных запросов на компьютерах с различными представленных конфигураций и нагрузок.  
  
1.  Вычислительная стоимость общей работы.  
  
     Для достижения увеличения скорости запроса PLINQ должен иметь достаточный объем параллельных операций для компенсации издержек. Работа может быть выражен как вычислительная стоимость каждого делегата, умноженное на количество элементов в исходной коллекции. Предположим, что операция может выполняться параллельно, требующими большего количества вычислений дорогих больше, параллельной. Например если функция принимает для выполнения одной миллисекунды, последовательный запрос, более 1000 элементами потребует одной секунды для выполнения этой операции, в то время как параллельный запрос на компьютере с четырьмя ядрами может потребоваться только 250 миллисекунд. Это дает ускорение на 750 миллисекунд. Если функция требует одной секунды на выполнение каждого элемента, то ускорение будет равно 750 секундам. Если делегат является весьма затратным, PLINQ может предложить значительное увеличение скорости с помощью только несколько элементов в исходной коллекции. И наоборот, небольшие исходные коллекции с простыми делегатами обычно не являются хорошими кандидатами для PLINQ.  
  
     В следующем примере queryA, скорее всего, является хорошим кандидатом для PLINQ, при условии, что его функция Select содержит большой объем работы. queryB скорее всего, не является хорошим кандидатом, так как не достаточный объем работы в инструкции Select, и затрат на параллелизацию будет перенесено большинство или все ускорение.  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  Число ядер в системе (степень параллелизма).  
  
     Эта точка находится является очевидным следствием в предыдущем разделе, запросы, которые являются параллельными выполняться быстрее, на компьютерах с больше ядер, поскольку можно разделить работу между несколько параллельных потоков. Общий объем ускорение работы зависит от того, какой процент общей работы запрос параллельно. Однако не следует предполагать, что все запросы будут выполняться дважды в качестве файлов на компьютере с восемью ядрами как четыре основных компьютер. При настройке запросов для достижения оптимальной производительности, важно оценивать фактические результаты на компьютерах с различным количеством ядер. Эта точка относится к пункту #1: требуются большие наборы данных, чтобы воспользоваться преимуществами больших вычислительных ресурсов.  
  
3.  Количество и тип операции.  
  
     Язык PLINQ предоставляет оператор AsOrdered для ситуаций, в которых необходимо поддерживать порядок элементов в исходной последовательности. Затраты, связанные с порядком, однако эти расходы обычно невелики. Аналогично операции GroupBy и соединение требует затрат. PLINQ работает лучше, когда оно выполняется для обработки элементов в исходной коллекции в любом порядке и передается следующему оператору как только они готовы. Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
4.  Форма выполнения запроса.  
  
     При сохранении результатов запроса путем вызова ToArray или ToList результатов из всех параллельных потоков должны быть объединены в одну структуру данных. Это включает в себя неизбежным вычислительным затратам. Аналогично при итерации результатов с помощью цикла foreach (For Each в Visual Basic), результаты из рабочих потоков должны быть сериализованы в поток-перечислитель. Но если необходимо просто для выполнения некоторых операций на основе результатов из каждого потока, можно использовать метод ForAll для выполнения этой работы в нескольких потоках.  
  
5.  Тип параметров слияния.  
  
     PLINQ можно настроить либо буферизацию выходных данных и создания его в виде фрагментов или все сразу после весь результирующий набор имеет создания, или настроить на поток отдельных результатов они создаются. Первый вариант уменьшает общее время выполнения, а последний приводит к уменьшению задержки между полученными элементами.  Хотя параметры слияния, которые не всегда оказывают значительное влияние на общую производительность запроса, могут повлиять субъективную производительность, так как они управляют, сколько времени пользователь должен подождать, чтобы увидеть результаты. Дополнительные сведения см. в разделе [Параметры слияние в PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).  
  
6.  Тип секционирования.  
  
     В некоторых случаях запрос PLINQ по индексируемой исходной коллекции может привести к несбалансированности рабочей нагрузки. В этом случае можно увеличить производительность запросов, создав пользовательский разделитель. Дополнительные сведения см. в разделе [Пользовательские разделители для PLINQ и TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
## <a name="when-plinq-chooses-sequential-mode"></a>Когда PLINQ выбирает последовательный режим  
 PLINQ всегда будет предпринята попытка выполнения запроса, по крайней мере так же быстро, как запрос будет выполняться последовательно. Несмотря на то, что PLINQ не выглядит как вычислительных ресурсов пользовательских делегатов, или размер источника входных данных, поиск определенных запросов «фигуры». В частности он ищет операторы запроса или сочетание операторов, обычно вызывает запроса выполняются медленнее в параллельном режиме. При нахождении таких форм PLINQ по умолчанию будет использоваться последовательный режим.  
  
 Однако после оценки производительности конкретного запроса, может выясниться, что он фактически выполняется быстрее в параллельном режиме. В таких случаях можно использовать <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> флаг через <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> метод для указания PLINQ для параллельного выполнения запроса. Дополнительные сведения см. в разделе [Практическое руководство. Указание режима выполнения в PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  
  
 В следующем списке описываются формы запросов, которые PLINQ по умолчанию будет выполнять в последовательном режиме:  
  
-   Запросы, содержащие инструкции Select, индексированный Where, индексированный SelectMany или ElementAt после оператора упорядочивания или фильтрации, который удаляет или переупорядочивает исходные индексы.  
  
-   Запросы, содержащие Take, TakeWhile, Skip, SkipWhile-оператор и где индексы в исходной последовательности не находятся в исходном порядке.  
  
-   Запросы, которые содержат Zip или SequenceEquals, за исключением случаев, когда один из источников данных содержит изначально упорядоченный индекс, а другой источник данных можно проиндексировать (например, массив или IList(T)).  
  
-   Запросы, которые содержат Concat, если он не применяется к индексируемым источникам данных.  
  
-   Запросы, содержащие обратить, если применяется к индексируемым источникам данных.  
  
## <a name="see-also"></a>См. также  
 [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
