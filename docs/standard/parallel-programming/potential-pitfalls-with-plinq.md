---
title: "Потенциальные ошибки, связанные с PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, pitfalls
ms.assetid: 75a38b55-4bc4-488a-87d5-89dbdbdc76a2
caps.latest.revision: "13"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: f7c971d2c039e6441669108e966eba472819fde5
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="potential-pitfalls-with-plinq"></a>Потенциальные ошибки, связанные с PLINQ
Во многих случаях PLINQ может обеспечить значительное повышение производительности через последовательный запросами LINQ to Objects. Тем не менее параллельное выполнение запросов повышает сложность, что может привести к проблемам, которые применяются не так часто или вообще не встречаются в последовательном коде. В этом разделе перечислены некоторые рекомендации, чтобы избежать при написании запросов PLINQ.  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a>Не считайте, что параллельные процессы всегда быстрее.  
 Иногда параллелизация приводит запроса PLINQ будет работать медленнее, чем его LINQ в эквивалент объектов. Основные правило является запросов, содержащих несколько исходных элементов и быстрых пользовательских делегатов скорее всего, ускорение намного. Тем не менее поскольку множество факторов, влияющих на производительность, рекомендуется оценивать фактические результаты, прежде чем решить, следует ли использовать PLINQ. Дополнительные сведения см. в разделе [Общее представление об ускорении выполнения в PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).  
  
## <a name="avoid-writing-to-shared-memory-locations"></a>Избегайте размещения в общей памяти.  
 В последовательном коде для чтения и записи часто используются статические переменные и поля классов. Но всякий раз, когда к таким переменным обращаются сразу несколько потоков, может возникать состояние гонки. Несмотря на то что для синхронизации доступа к переменной можно использовать блокировки, связанные с нею затраты ресурсов могут снизить производительность. Таким образом рекомендуется избегать, или по крайней мере ограничить доступ к общему состоянию в запросе PLINQ максимальной.  
  
## <a name="avoid-over-parallelization"></a>Избегайте излишней параллелизации.  
 С помощью `AsParallel` оператора, при этом накладных расходов секционирование исходной коллекции и синхронизацию рабочих потоков. Преимущества параллелизации также ограничивает число процессоров на компьютере. Выполнение сразу нескольких потоков с большим количеством вычислений на одном и том же процессоре не повысит производительность. Таким образом необходимо избегать использования излишней параллелизации запроса.  
  
 Наиболее распространенный сценарий, в которой излишней параллелизации может возникнуть полезно во вложенных запросах, как показано в следующем фрагменте.  
  
 [!code-csharp[PLINQ#20](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#20)]
 [!code-vb[PLINQ#20](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#20)]  
  
 В этом случае лучше всего параллелизации только внешний источник данных (клиенты), если одно или несколько из следующих условий:  
  
-   Внутренний источник (cust. Заказы) не очень много.  
  
-   С каждым заказом вы выполняете дорогостоящие вычисления. (Операция, показанная в примере, не является дорогостоящей.)  
  
-   Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса в `cust.Orders`.  
  
 В любом случае лучший способ определения оптимальной формы запроса — это проверка и измерение. Дополнительные сведения см. в разделе [как: измерения производительности запросов PLINQ](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a>Избегайте вызова методов, небезопасных для потоков.  
 Запись методов экземпляра не многопоточное из PLINQ запроса может привести к повреждению данных, которое может или не может оставаться незамеченным в программе. Кроме того, она может вызывать исключения. В следующем примере несколько потоков предпримут попытку вызвать `Filestream.Write` метод одновременно, который не поддерживается классом.  
  
```vb  
Dim fs As FileStream = File.OpenWrite(…)  
a.Where(...).OrderBy(...).Select(...).ForAll(Sub(x) fs.Write(x))  
```  
  
```csharp  
FileStream fs = File.OpenWrite(...);  
a.Where(...).OrderBy(...).Select(...).ForAll(x => fs.Write(x));  
```  
  
## <a name="limit-calls-to-thread-safe-methods"></a>Ограничение вызовов потокобезопасных методов  
 Большинство статических методов на платформе .NET Framework безопасны для потоков и могут вызываться из нескольких потоков одновременно. Но даже в этих случаях соответствующая синхронизация может значительно замедлить запрос.  
  
> [!NOTE]
>  Можно проверить это самостоятельно, вставив несколько вызовов <xref:System.Console.WriteLine%2A> в запросах. Хотя этот метод используется в примерах документации в демонстрационных целях, не используйте его в запросах PLINQ.  
  
## <a name="avoid-unnecessary-ordering-operations"></a>Избежать ненужных операций упорядочения  
 Если PLINQ выполняет запрос параллельно, он делит исходной последовательности на секции, которые могут выполняться одновременно в нескольких потоках. По умолчанию порядок обработки этих частей и доставки результатов не является прогнозируемым (за исключением операторы, такие как `OrderBy`). Можно указать PLINQ сохранить порядок любой исходной последовательности, но это оказывает негативное влияние на производительность. По возможности рекомендуется структурировать запросы, чтобы они не следует полагаться на сохранение порядка. Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
## <a name="prefer-forall-to-foreach-when-it-is-possible"></a>Предпочитаете ForAll ForEach. Если это возможно  
 Несмотря на то, что PLINQ выполняет запрос в нескольких потоках, если используются результаты в `foreach` цикла (`For Each` в Visual Basic), то результаты запроса необходимо возвращать в один поток и обращаться к ним последовательно с помощью перечислителя. В некоторых случаях это неизбежно. Тем не менее, при возможности используйте `ForAll` метод, чтобы каждому потоку выводить собственные результаты, например, путем написания для потокобезопасных коллекций, такие как <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>.  
  
 Такая же проблема распространяется на <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>. Другими словами, вариант `source.AsParallel().Where().ForAll(...)` должен быть более предпочтительным, чем  
  
 `Parallel.ForEach(source.AsParallel().Where(), ...)`.  
  
## <a name="be-aware-of-thread-affinity-issues"></a>Помните о проблемах сходства потоков.  
 Некоторые технологии, например COM-взаимодействие для компонентов однопотокового подразделения (STA), Windows Forms и Windows Presentation Foundation (WPF), накладывают ограничения на сходство потоков, требующие, чтобы код выполнялся в определенном потоке. Например, и в Windows Forms, и в WPF элемент управления может быть доступен только в том потоке, в котором он был создан. При попытке получить доступ к общему состоянию элемента управления Windows Forms в запросе PLINQ, вызывает исключение при выполнении в отладчике. (Этот параметр можно отключить.) Однако если запрос обрабатывается в потоке пользовательского интерфейса, можно вызвать элемент управления, `foreach` в результате цикл, который перечисляет запрос, поскольку этот код выполняется только в одном потоке.  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a>Не считайте, что итерации операторов ForEach, For и ForAll всегда выполняются параллельно.  
 Важно помнить, что отдельные итерации в <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> или <xref:System.Linq.ParallelEnumerable.ForAll%2A> цикл мая, но не для параллельного выполнения. В связи с этим старайтесь не писать код, который будет зависеть от правильности параллельного выполнения итераций или от выполнения итераций в определенном порядке.  
  
 Например, этот код может вызвать взаимоблокировку:  
  
```vb  
Dim mre = New ManualResetEventSlim()  
    Enumerable.Range(0, ProcessorCount * 100).AsParallel().ForAll(Sub(j)   
  
                                                     If j = Environment.ProcessorCount Then  
  
                                                         Console.WriteLine("Set on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j)  
                                                         mre.Set()  
  
                                                     Else  
  
                                                         Console.WriteLine("Waiting on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j)  
                                                         mre.Wait()  
                                                     End If  
    End Sub) ' deadlocks  
```  
  
```csharp  
ManualResetEventSlim mre = new ManualResetEventSlim();  
            Enumerable.Range(0, ProcessorCount * 100).AsParallel().ForAll((j) =>  
            {  
                if (j == Environment.ProcessorCount)  
                {  
                    Console.WriteLine("Set on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j);  
                    mre.Set();  
                }  
                else  
                {  
                    Console.WriteLine("Waiting on {0} with value of {1}", Thread.CurrentThread.ManagedThreadId, j);  
                    mre.Wait();  
                }  
            }); //deadlocks  
```  
  
 В этом примере одна итерация задает событие, а все остальные его ожидают. Ни одна из ожидающих итераций не может быть завершена, пока не завершится итерация, задающая событие. При этом ожидающие итерации способны заблокировать все потоки, которые используются для выполнения параллельного цикла, прежде чем будет выполнена итерация, задающая событие. Это приведет к взаимоблокировке — итерация, задающая событие, никогда не будет выполнена, а ожидающие итерации никогда не активизируются.  
  
 Таким образом, для выполнения работы необходимо, чтобы ни одна итерация параллельного цикла не ожидала другой итерации цикла. Если параллельный цикл решит запланировать итерации последовательно, но в обратном порядке, может возникнуть взаимоблокировка.  
  
## <a name="see-also"></a>См. также  
 [Parallel LINQ (PLINQ)](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
