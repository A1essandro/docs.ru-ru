---
title: "Преимущества использования потокобезопасных коллекций | Документация Майкрософт"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
caps.latest.revision: 9
author: mairaw
ms.author: mairaw
manager: wpickett
translationtype: Human Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 87898a4a6ba3d3ef4c53fd1c6b8f94ff353f10e4
ms.lasthandoff: 04/18/2017

---
# <a name="when-to-use-a-thread-safe-collection"></a>Преимущества использования потокобезопасных коллекций
В [!INCLUDE[net_v40_long](../../../../includes/net-v40-long-md.md)] представлено пять новых типов коллекций, специально разработанных для поддержки многопотоковых операций добавления и удаления. Для достижения потокобезопасности эти новые типы используют различные типы эффективных механизмов синхронизации с блокировкой и без блокировки. Синхронизация добавляет к операции издержки. Значения издержек зависят от используемого типа синхронизации, выполняемого типа операции и других факторов, например количества потоков, которые одновременно пытаются получить доступ к коллекции.  
  
 В некоторых сценариях издержки синхронизации незначительны и позволяют многопотоковым вариантам выполняться значительно быстрее и обеспечивают лучшую масштабируемость, чем в случае потоконебезопасного эквивалента при защите с помощью внешней блокировки. В других сценариях издержки могут вызвать ситуацию, когда потокобезопасный вариант выполняется и масштабируется примерно так же и даже более медленно, чем потоконебезопасная версия типа с внешней блокировкой.  
  
 В следующих подразделах приводятся общие рекомендации по использованию потокобезопасной коллекции и потоконебезопасного эквивалента, который содержит заданную пользователем блокировку для операций чтения и записи. Так как производительность может зависеть от множества факторов, рекомендации нехарактерны и необязательно являются допустимыми во всех обстоятельствах. Если производительность имеет важное значение, то лучшим способом для определения используемого типа коллекции является измерение производительности на основе обычной конфигурации компьютера и нагрузке. В данном документе используются следующие термины.  
  
 *Чистый сценарий "производитель — потребитель"*  
 Все заданные потоки либо добавляют элементы, либо удаляют их, но не то и другое одновременно.  
  
 *Смешанный сценарий "производитель — потребитель"*  
 Все заданные потоки как добавляют элементы, так и удаляют их.  
  
 *Ускорение*  
 Ускорение производительности алгоритма одного типа относительно другого типа в рамках одного сценария.  
  
 *Масштабируемость*  
 Увеличение в производительности, которое пропорционально числу ядер в компьютере. Масштабируемый алгоритм выполняется быстрее на компьютере, у которого восемь ядер, чем на компьютере, у которого два ядра.  
  
## <a name="concurrentqueuet-vs-queuet"></a>ConcurrentQueue(T) и Queue(T)  
 В чистых сценариях "производитель — потребитель", когда время обработки каждого элемента очень мало (несколько инструкций), класс <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=fullName> может предложить незначительный рост производительности по сравнению с классом <xref:System.Collections.Generic.Queue%601?displayProperty=fullName>, который содержит внешнюю блокировку. В этом сценарии класс <xref:System.Collections.Concurrent.ConcurrentQueue%601> выполняется лучше, когда один выделенный поток помещается в очередь, а другой выделенный поток удаляется из нее. Если не применить это правило, на компьютерах с несколькими ядрами класс <xref:System.Collections.Generic.Queue%601> может выполняться даже немного быстрее, чем <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Когда время обработки составляет 500 или больше FLOPS (операций с плавающей запятой), правило двух потоков не применяется к классу <xref:System.Collections.Concurrent.ConcurrentQueue%601>, который имеет очень хорошую масштабируемость. Класс <xref:System.Collections.Generic.Queue%601> не очень хорошо масштабируется в этом сценарии.  
  
 В смешанных сценариях "производитель — потребитель" при очень малом времени обработки класс <xref:System.Collections.Generic.Queue%601>, который содержит внешнюю блокировку, масштабируется лучше, чем класс <xref:System.Collections.Concurrent.ConcurrentQueue%601>. Но если время обработки приблизительно равно 500 FLOPS или более, класс <xref:System.Collections.Concurrent.ConcurrentQueue%601> масштабируется лучше.  
  
## <a name="concurrentstack-vs-stack"></a>ConcurrentStack и Стек  
 В чистых сценариях "производитель — потребитель", когда время обработки каждого элемента очень мало, классы <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=fullName> и <xref:System.Collections.Generic.Stack%601?displayProperty=fullName> (который имеет внешнюю блокировку), вероятно, будут выполняться одинаково с одним выделенным потоком для добавления и одним выделенным потоком для извлечения. Но по мере увеличения числа потоков оба типа замедляют работу из-за увеличения числа конфликтных ситуаций, и класс <xref:System.Collections.Generic.Stack%601> может работать лучше, чем класс <xref:System.Collections.Concurrent.ConcurrentStack%601>. Если время обработки имеет значение приблизительно равное 500 FLOPS и выше, то оба типа масштабируются примерно одинаково.  
  
 В смешанных сценариях "производитель — производитель" <xref:System.Collections.Concurrent.ConcurrentStack%601> работает быстрее как при небольших, так и при больших рабочих нагрузках.  
  
 Использование классов <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> и <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> может значительно сократить время доступа.  
  
## <a name="concurrentdictionary-vs-dictionary"></a>ConcurrentDictionary и Словарь  
 Как правило, рекомендуется использовать класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=fullName> в любом сценарии, в котором выполняются операции добавления и обновления ключей и значений одновременно из множества потоков. В сценариях, которые включают частые операции обновления и относительно редкие операции чтения, класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602> обычно обеспечивает немного лучшую производительность. В сценариях, которые включают много операций чтения и много операций обновления, класс <xref:System.Collections.Concurrent.ConcurrentDictionary%602> обычно работает значительно быстрее на компьютерах с любым числом ядер.  
  
 В сценариях, которые включают частые обновления, можно увеличить степень параллелизма в классе <xref:System.Collections.Concurrent.ConcurrentDictionary%602> и затем провести измерение, чтобы увидеть, увеличилась ли производительность на компьютерах с многоядерными процессорами. При изменении уровня параллелизма исключите, насколько это возможно, глобальные операции.  
  
 Если выполняются только операции чтения ключа или значений, класс <xref:System.Collections.Generic.Dictionary%602> работает быстрее, так как если словарь не изменяется каким-либо потоком, синхронизация не требуется.  
  
## <a name="concurrentbag"></a>ConcurrentBag  
 В чистых сценариях "производитель — потребитель" класс <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=fullName>, вероятно, будет выполняться медленнее, чем другие типы параллельных коллекций.  
  
 В смешанных сценариях "производитель — потребитель" класс <xref:System.Collections.Concurrent.ConcurrentBag%601> в общем случае имеет большее ускорение и большую масштабируемость, чем все остальные типы параллельных коллекций как при больших, так и при небольших рабочих нагрузках.  
  
## <a name="blockingcollection"></a>BlockingCollection  
 Если требуются семантики границ и блокировок, класс <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=fullName>, вероятно, будет выполняться быстрее, чем все другие пользовательские реализации. Он также поддерживает гибкую обработку исключений и операций отмены, перечисления.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Collections.Concurrent?displayProperty=fullName>   
 [Потокобезопасные коллекции](../../../../docs/standard/collections/thread-safe/index.md)   
 [Параллельное программирование](../../../../docs/standard/parallel-programming/index.md)
