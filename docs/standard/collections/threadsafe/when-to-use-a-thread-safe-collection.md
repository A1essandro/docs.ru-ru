---
title: "Преимущества использования потокобезопасных коллекций"
description: "Преимущества использования потокобезопасных коллекций"
keywords: .NET, .NET Core
author: mairaw
manager: wpickett
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: a2a42d44-f6a5-4f16-9000-026221d66349
translationtype: Human Translation
ms.sourcegitcommit: e07788926a995b41571be276379ad9285747951d
ms.openlocfilehash: 74f421a5badd9f2c7bf10fa1dfdf98161bba2ce8

---

# <a name="when-to-use-a-threadsafe-collection"></a>Преимущества использования потокобезопасных коллекций

Коллекции типов `ConcurrentQueue`, `ConcurrentStack`, `ConcurrentDictionary`, `ConcurrentBag` и `BlockingCollection` специально разработаны для поддержки многопотоковых операций добавления и удаления. Для достижения потокобезопасности эти новые типы используют различные типы эффективных механизмов синхронизации с блокировкой и без блокировки. Синхронизация добавляет к операции издержки. Значения издержек зависят от используемого типа синхронизации, выполняемого типа операции и других факторов, например количества потоков, которые одновременно пытаются получить доступ к коллекции.

В некоторых сценариях издержки синхронизации незначительны и позволяют многопотоковым вариантам выполняться значительно быстрее и обеспечивают лучшую масштабируемость, чем в случае потоконебезопасного эквивалента при защите с помощью внешней блокировки. В других сценариях издержки могут вызвать ситуацию, когда потокобезопасный вариант выполняется и масштабируется примерно так же и даже более медленно, чем потоконебезопасная версия типа с внешней блокировкой.

В следующих подразделах приводятся общие рекомендации по использованию потокобезопасной коллекции и потоконебезопасного эквивалента, который содержит заданную пользователем блокировку для операций чтения и записи. Так как производительность может зависеть от множества факторов, рекомендации нехарактерны и необязательно являются допустимыми во всех обстоятельствах. Если производительность имеет важное значение, то лучшим способом для определения используемого типа коллекции является измерение производительности на основе обычной конфигурации компьютера и нагрузке. В данном документе используются следующие термины.

*Чистый сценарий "производитель-получатель"*. Все заданные потоки либо добавляют элементы, либо удаляют их, но не то и другое вместе.

*Смешанный сценарий "производитель-получатель"*. Все заданные потоки добавляют элементы или удаляют их.

*Ускорение*. Ускорение производительности алгоритма одного типа относительно другого типа в этом же сценарии.

*Масштабируемость*. Увеличение в производительности, которое пропорционально количеству ядер в компьютере. Масштабируемый алгоритм выполняется быстрее на компьютере, у которого восемь ядер, чем на компьютере, у которого два ядра.

## <a name="concurrentqueuelttgt-vs-queuelttgt"></a>ConcurrentQueue&lt;T&gt; и Queue&lt;T&gt;

В чистых сценариях "производитель-получатель", когда время обработки каждого элемента очень мало (несколько инструкций), класс [System.Collections.Concurrent.ConcurrentQueue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1) может предложить незначительный рост производительности по сравнению с классом [System.Collections.Generic.Queue&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Queue-1), который содержит внешнюю блокировку. В этом сценарии класс `ConcurrentQueue<T>` выполняется лучше, когда один выделенный поток помещается в очередь, а другой выделенный поток удаляется из очереди. Если это правило не применяется, класс `Queue<T>` может даже выполняться немного быстрее, чем класс `ConcurrentQueue<T>` на компьютерах с многоядерными процессорами. 

Когда время обработки составляет 500 FLOPS (операций с плавающей запятой) или больше, то правило двух потоков не применяется к классу `ConcurrentQueue<T>`, который имеет очень хорошую масштабируемость. `Queue<T>` в этой ситуации не обладает хорошей масштабируемостью.

В смешанных сценариях "производитель-получатель", когда время обработки очень мало, класс `Queue<T>`, который имеет внешнюю блокировку, масштабируется лучше, чем класс`ConcurrentQueue<T>`. Однако, если время обработки имеет значение приблизительно равное 500 FLOPS и выше, то класс `ConcurrentQueue<T>` масштабируется лучше.

## <a name="concurrentstack-vs-stack"></a>ConcurrentStack и Стек

В чистых сценариях "производитель-получатель", когда время обработки каждого элемента очень мало, класс [System.Collections.Concurrent.ConcurrentStack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1) и класс [System.Collections.Generic.Stack&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Stack-1), который имеет внешнюю блокировку, вероятно, будут выполняться одинаково с одним выделенным потоком на добавление и одним выделенным потоком на извлечение. Однако по мере увеличения числа потоков производительность снижается у обоих типов, так как увеличивается число конфликтных ситуаций, и класс `Stack<T>` может выполняться лучше, чем класс `ConcurrentStack<T>`. Если время обработки имеет значение приблизительно равное 500 FLOPS и выше, то оба типа масштабируются примерно одинаково. 

В смешанных сценариях "производитель-получатель" класс `ConcurrentStack<T>` имеет большее ускорение для небольших и больших рабочих нагрузок.

Использование методов `PushRange` и `TryPopRange` может значительно снизить время доступа.

## <a name="concurrentdictionary-vs-dictionary"></a>ConcurrentDictionary и Словарь

Как правило, рекомендуется использовать класс [System.Collections.Concurrent.ConcurrentDictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentDictionary-2) в любом сценарии, в котором выполняется добавление и обновление ключей и значений одновременно из множества потоков. В сценариях, которые включают частные операции обновления и относительно редкие операции чтения, класс `ConcurrentDictionary<TKey, TValue>`, в общем случае, обеспечивает немного лучшую производительность. В сценариях, которые включают частные операции чтения и относительно редкие операции обновления, класс `ConcurrentDictionary<TKey, TValue>`, в общем случае, имеет значительно большее ускорение на компьютерах с многоядерными процессорами.

В сценариях, которые включают частые обновления, можно увеличить степень параллелизма в классе `ConcurrentDictionary<TKey, TValue>` и затем провести оценку, чтобы увидеть, увеличилась ли производительность на компьютерах с многоядерными процессорами. При изменении уровня параллелизма исключите, насколько это возможно, глобальные операции.

Если выполняются только операции чтения ключа или значений, класс [System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.Dictionary-2) имеет большее ускорение, так как если словарь не изменяется каким-либо потоком, то синхронизация не требуется.

## <a name="concurrentbag"></a>ConcurrentBag

В чистых сценариях "производитель-получатель" класс [System.Collections.Concurrent.ConcurrentBag&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1), вероятно, будет выполняться более медленно, чем один из типов параллельных коллекций.

В смешанных сценариях "производитель-получатель" класс `ConcurrentBag<T>` в общем случае имеет большее ускорение и большую масштабируемость, чем все остальные типы параллельных коллекций для небольших и больших рабочих нагрузок.

## <a name="blockingcollection"></a>BlockingCollection

Если требуются семантики границ и блокировок, класс [System.Collections.Concurrent.BlockingCollection&lt;T&gt;](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1), вероятно, будет выполняться быстрее, чем все другие пользовательские реализации. Он также поддерживает гибкую обработку исключений и операций отмены, перечисления.

## <a name="see-also"></a>См. также

[System.Collections.Concurrent](https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent)

[Потокобезопасные коллекции](index.md)



<!--HONumber=Nov16_HO1-->


