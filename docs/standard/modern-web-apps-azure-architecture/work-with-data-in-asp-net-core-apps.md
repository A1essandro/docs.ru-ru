---
title: "Работа с данными в приложениях ASP.NET Core"
description: "Архитектора современных веб-приложений с помощью ASP.NET Core и Azure | Работа с данными в среде asp"
author: ardalis
ms.author: wiwagn
ms.date: 10/07/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: bcb8f7bbfa83db9c86cd1278a89750b9f02061d9
ms.sourcegitcommit: 6f49c973f62855ffd6c4a322903e7dd50c5c1b50
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2017
---
# <a name="working-with-data-in-aspnet-core-apps"></a>Работа с данными в приложениях ASP.NET Core

> «Данные ценное вещь и будут сохраняться дольше, чем самих систем.»

Тим Бернерса ли

## <a name="summary"></a>Сводка

Доступ к данным является важной частью почти любого приложения программного обеспечения. ASP.NET Core поддерживает разнообразные параметры доступа к данным, включая Entity Framework Core (а также Entity Framework 6), а также может работать с любой платформы .NET framework доступа к данным. Выбор, из которых доступ к данным инфраструктуре использовать зависит от потребностей приложения. Абстрагирование варианты из проектов ApplicationCore и пользовательского интерфейса и инкапсуляции деталей реализации инфраструктуры, помогает в построении слабосвязанной, тестируемыми программного обеспечения.

## <a name="entity-framework-core-for-relational-databases"></a>Entity Framework Core (для реляционных баз данных)

При написании нового приложения ASP.NET Core, которое требуется для работы с реляционными данными основного Entity Framework (EF ядро) является рекомендуемым способом для вашего приложения, на доступ к данным. EF лежит объектно реляционного сопоставления (O/надежный обмен Сообщениями), которая позволяет разработчикам .NET для сохранения объектов из источника данных. Это устраняет потребность в большую часть кода доступа к данным, которые разработчикам обычно приходится писать. Как ASP.NET Core EF Core был переписан с нуля и обеспечивает поддержку модульных кросс платформенных приложений. Добавление приложения как пакет NuGet, настроить их запуска и запрос через внедрения зависимостей, везде, где он нужен.

Чтобы использовать EF ядра базы данных SQL Server, выполните следующую команду CLI dotnet:

DotNet добавить пакет Microsoft.EntityFrameworkCore.SqlServer

Чтобы добавить поддержку для источника данных InMemory для тестирования:

DotNet добавить пакет Microsoft.EntityFrameworkCore.InMemory

### <a name="the-dbcontext"></a>Класс DbContext

Для работы с основными EF требуется подкласс DbContext. Этот класс содержит свойства, представляющие сущности, которые приложение будет работать с коллекциями. Пример eShopOnWeb включает CatalogContext с коллекциями элементов, торговые марки и типы:

```csharp
public class CatalogContext : DbContext
{
    public CatalogContext(DbContextOptions<CatalogContext> options) : base(options)
    {

    }

    public DbSet<CatalogItem> CatalogItems { get; set; }

    public DbSet<CatalogBrand> CatalogBrands { get; set; }

    public DbSet<CatalogType> CatalogTypes { get; set; }
}
```

Ваш DbContext должен иметь конструктор, принимающий DbContextOptions и передать этот аргумент конструктора базового класса DbContext. Обратите внимание, что если в приложении имеется только один DbContext, можно передать экземпляр DbContextOptions, но при наличии более одного необходимо использовать универсальный DbContextOptions<T> типа, передавая ему в типе DbContext как универсального параметра.

### <a name="configuring-ef-core"></a>Настройка основных EF

В приложении ASP.NET Core будет обычно настраивается в методе ConfigureServices EF Core. EF Core использует DbContextOptionsBuilder, которая поддерживает несколько методов расширения полезны для упрощения его конфигурации. Чтобы настроить CatalogContext использовать базу данных SQL Server со строкой соединения, определенные в конфигурации, необходимо добавить следующий код в ConfigureServices:

```csharp
services.AddDbContext<CatalogContext>(options => options.UseSqlServer (Configuration.GetConnectionString("DefaultConnection")));
```

Чтобы использовать базу данных в памяти:

```csharp
services.AddDbContext<CatalogContext>(options =>
    options.UseInMemoryDatabase());
```

После установки основных компонентов EF, дочерний тип DbContext, созданные и настройки ее в ConfigureServices вы готовы использовать EF Core. Вы можете запросить экземпляр типа DbContext в любой службе, в зависимости от необходимости и приступить к работе с сохраненного сущностей с помощью LINQ, как если бы они просто в коллекции. Основные EF не преобразования выражения LINQ в SQL-запросы для хранения и извлечения данных.

Вы увидите запросы EF Core выполняется путем настройки ведения журнала и обеспечение его уровень равен по крайней мере сведения, как показано на рисунке 8-1.

![](./media/image8-1.png)

Рис. 8-1 Core EF ведение журнала запросов на консоль

### <a name="fetching-and-storing-data"></a>Извлечение и сохранение данных

Для получения данных из основных компонентов EF, доступ к соответствующему свойству и использовать LINQ для фильтрации результирующего. Также можно использовать LINQ для выполнения проекции, преобразования результата из одного типа в другой. Следующий пример может извлечь CatalogBrands, упорядоченные по имени, отфильтрованные по их свойства Enabled и проецируются типа SelectListItem:

```csharp
var brandItems = await _context.CatalogBrands
    .Where(b => b.Enabled)
    .OrderBy(b => b.Name)
    .Select(b => new SelectListItem {
        Value = b.Id, Text = b.Name })
    .ToListAsync();
```

Очень важно в приведенном выше примере, чтобы добавить вызов ToListAsync, чтобы выполнить запрос немедленно. В противном случае инструкция будет назначать тип IQueryable<SelectListItem> для brandItems, который не будет выполняться до выполнения перечисления. Есть свои преимущества и недостатки, чтобы возвращать результаты IQueryable из методов. Она позволяет ранее EF основные конструкции быть изменен, но можно также приводят к ошибкам, возникающие только во время выполнения, если операции добавляются в запрос, который EF Core не удается преобразовать запрос. Обычно безопаснее для передачи все фильтры в метод, получение доступа к данным и возврата резервное коллекции в памяти (например, список<T>) в результате.

EF ядра отслеживает изменения на сущности, которые извлекаются из хранилища сохраняемости. Чтобы сохранить изменения Отслеживаемая сущность, просто вызовите метод SaveChanges ликвидацию, убедившись, что это тот же экземпляр DbContext, который был использован для получения сущности. Добавление и удаление сущностей — непосредственно на соответствующее свойство DbSet, снова с помощью вызова SaveChanges для выполнения команд базы данных. В следующем примере показано добавление, обновление и удаление сущностей из хранилища сохраняемости.

```csharp
// create
var newBrand = new CatalogBrand() { Brand = "Acme" };
_context.Add(newBrand);
await _context.SaveChangesAsync();

// read and update
var existingBrand = _context.CatalogBrands.Find(1);
existingBrand.Brand = "Updated Brand";
await _context.SaveChangesAsync();

// read and delete (alternate Find syntax)
var brandToDelete = _context.Find<CatalogBrand>(2);
_context.CatalogBrands.Remove(brandToDelete);
await _context.SaveChangesAsync();
```

EF Core поддерживает как синхронные, так и асинхронные методы для получения и сохранения. В веб-приложений рекомендуется использовать шаблон async/await с асинхронными методами, чтобы потоки веб-сервера не блокируются при ожидании завершения операций доступа к данным.

### <a name="fetching-related-data"></a>Извлечение связанных данных

Когда EF Core извлекает сущности, он заполняет все свойства, которые хранятся непосредственно с этой сущностью в базе данных. Свойства навигации, таких как списки связанных сущностей не заполнены и, возможно, их значение равно null. Это гарантирует, что основные EF не извлекает больше данных, чем требуется, что особенно важно для веб-приложений, которые необходимо быстро обрабатывать запросы и возвращать ответы эффективное. Для включения связей с сущности, используя *упреждающую*, укажите свойства с помощью метода расширения Include в запросе, как показано:

```csharp
// .Include requires using Microsoft.EntityFrameworkCore
var brandsWithItems = await _context.CatalogBrands
    .Include(b => b.Items)
    .ToListAsync();
```

Можно включить несколько связей, и может также включать вложенные связи с помощью ThenInclude. EF Core будет выполнить один запрос для получения результирующего набора сущностей.

Загрузка связанных данных другой вариант — использовать *явная загрузка*. Явная загрузка позволяет загрузить дополнительные данные в сущность, которая уже было получено. Когда речь заходит о отдельный запрос к базе данных, не рекомендуется для веб-приложений, которые следует свести к минимуму количество базы данных циклов приема-передачи внесены по запросу.

*Отложенная загрузка* — это компонент, который автоматически загружает связанные данные, как оно ссылается приложение. В настоящее время не поддерживается ядром EF, но как с явная загрузка его следует обычно отключить для веб-приложений.

### <a name="resilient-connections"></a>Отказоустойчивое подключений

Внешние ресурсы, такие как базы данных SQL, иногда могут быть недоступны. В случаях временной недоступности приложения могут использовать логику повторных попыток, чтобы избежать возникновения исключения. Этот метод часто называют *устойчивость подключений*. Можно реализовать вашей [собственные повторить с экспоненциально растущим](https://docs.microsoft.com/azure/architecture/patterns/retry) прием, пытаясь этом с экспоненциально увеличивающейся время ожидания, пока не будет достигнуто максимальное число повторных попыток. Этот метод выполняет тот факт, что облачные ресурсы периодически недоступен в течение короткого времени, что привело к сбою некоторых запросов.

Для баз данных SQL Azure Entity Framework Core уже предоставляет логику устойчивости и повторите попытку подключения внутренней базы данных. Однако необходимо включить стратегия выполнения Entity Framework для каждого соединения DbContext, если должны быть устойчивыми EF основных подключений.

Для экземпляра приведенный ниже код на уровне ядра EF соединения позволяет отказоустойчивой соединения SQL, выполняется повторная попытка добавления при сбое соединения.

```csharp
// Startup.cs from any ASP.NET Core Web API
public class Startup
{
    public IServiceProvider ConfigureServices(IServiceCollection services)
    {
        //...
        services.AddDbContext<OrderingContext>(options =>
        {
            options.UseSqlServer(Configuration["ConnectionString"],
            sqlServerOptionsAction: sqlOptions =>
        {
            sqlOptions.EnableRetryOnFailure(
            maxRetryCount: 5,
            maxRetryDelay: TimeSpan.FromSeconds(30), 
            errorNumbersToAdd: null); 
        });
    });
}
//...
```

  #### <a name="execution-strategies-and-explicit-transactions-using-begintransaction-and-multiple-dbcontexts"></a>Выполнение стратегии и явные транзакции, используя BeginTransaction и несколько DbContexts 
  
  После включения повторных попыток подключений EF Core каждой операции, выполненные с помощью EF Core становится повторимый операции. Каждый запрос и каждый вызов команды SaveChanges в случае временного сбоя будет повторена как единое целое.
  
  Тем не менее, если код инициирует транзакцию, используя BeginTransaction, вы определяете собственную группу операций, которые должны рассматриваться как единое целое, весь код внутри транзакции выполнен откат в случае сбоя. При попытке выполнения этой транзакции, при использовании стратегия выполнения EF (политику повтора) и включать несколько SaveChanges из нескольких DbContexts в нем вы увидите исключение следующим образом.

System.InvalidOperationException: Настроенная стратегия выполнения «SqlServerRetryingExecutionStrategy» не поддерживает транзакции, инициированной пользователем. Используйте возвращенный «DbContext.Database.CreateExecutionStrategy()» стратегии выполнения для выполнения всех операций в транзакции как единое возможностью повторной попытки.

Решением является вызвать стратегия выполнения EF отражающее все делегатом, который должен выполняться вручную. В случае временного сбоя стратегия выполнения будет снова вызвать делегата. Следующий код показывает, как реализовать этот подход:

```csharp
// Use of an EF Core resiliency strategy when using multiple DbContexts
// within an explicit transaction
// See:
// https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency
var strategy = _catalogContext.Database.CreateExecutionStrategy(); 
await strategy.ExecuteAsync(async () =>
{
    // Achieving atomicity between original Catalog database operation and the
    // IntegrationEventLog thanks to a local transaction
    using (var transaction = _catalogContext.Database.BeginTransaction())
    {
        _catalogContext.CatalogItems.Update(catalogItem);
        await _catalogContext.SaveChangesAsync();
        
        // Save to EventLog only if product price changed
        if (raiseProductPriceChangedEvent)
        await _integrationEventLogService.SaveEventAsync(priceChangedEvent);
        transaction.Commit();
    }
});
```

— Первый DbContext \_catalogContext, а второй — DbContext находится в пределах \_integrationEventLogService объекта. Наконец фиксации, будет указано действие выполнить несколько DbContexts и с помощью EF стратегия выполнения.

> ### <a name="references--entity-framework-core"></a>Ссылки — Entity Framework Core
> - **EF базовые документы**  
> <https://docs.Microsoft.com/EF/>
> - **EF ядром: Связанные данные**  
> <https://docs.Microsoft.com/EF/Core/querying/RELATED-Data>
> - **Избегайте отложенную загрузку сущностей в приложениях ASPNET**  
> <http://ardalis.com/avoid-Lazy-Loading-Entities-in-ASP-NET-Applications>

## <a name="ef-core-or-micro-orm"></a>EF Core или микро ORM?

Пока EF Core отлично подходит для управления сохраняемости и в большинстве случаев инкапсулирует сведения о базе данных от разработчиков приложения, не является единственным вариантом. Другой вариант с открытым исходным кодом — [Dapper](https://github.com/StackExchange/Dapper), так называемые микро ORM. Микро ORM является упрощенным, менее полнофункциональное средство для сопоставления объектов структуры данных. В случае Dapper его макет целей акцент на производительность, вместо полностью инкапсуляции базового отправляет запрос используется для извлечения и обновления данных. Так как он не абстрактного SQL от разработчика, Dapper «ближе к металл» и позволяет разработчику писать точное запросов, которые они хотят использовать для заданных данных получить доступ к операции.

Ядро EF имеет два важных функций, которые он предоставляет, который отделяет его от Dapper, но также добавить к снижению его производительности. Во-первых, перевод из выражения LINQ в SQL. Кэшируются этих переводов, но тем не менее имеется дополнительная нагрузка в их выполнения в первый раз. Второе — отслеживание изменений для сущности (при этом могут создаваться инструкций update эффективный). Это поведение можно отключить для конкретных запросов с использованием модуля AsNotTracking. EF Core также приводит к возникновению ошибки SQL-запросов, которые обычно являются очень эффективно и в любом случае оптимальным с точки зрения производительности, но если необходимы точный контроль над точное запросов для выполнения, можно передать в пользовательских SQL (или выполнения хранимой процедуры) с помощью EF Базовая, слишком. В этом случае Dapper по-прежнему превышает производительность EF Core, но лишь незначительно. Некоторые данные производительности в нее могут статьи MSDN 2016 представляется Джули Лерман [Dapper, Entity Framework и гибридные приложения](https://msdn.microsoft.com/magazine/mt703432.aspx). Тестовые данные производительности для различных методов доступа к данным можно найти на [Dapper сайта](https://github.com/StackExchange/Dapper).

Чтобы увидеть, как синтаксис Dapper зависит от основных EF, рассмотрим эти две версии тот же метод для извлечения списка элементов.

```csharp
// EF Core
private readonly CatalogContext _context;
public async Task<IEnumerable<CatalogType>> GetCatalogTypes()
{
    return await _context.CatalogTypes.ToListAsync();
}

// Dapper
private readonly SqlConnection _conn;
public async Task<IEnumerable<CatalogType>> GetCatalogTypesWithDapper()
{
    return await _conn.QueryAsync<CatalogType>("SELECT * FROM CatalogType");
}
```

Если необходимы для создания более сложных графов объектов с Dapper, необходимо написать связанные запросы самостоятельно (в отличие от Добавление метода Include, как и в основной EF). Эта возможность поддерживается через разнообразные синтаксисов, включая называемую Multi сопоставление, позволяет сопоставить отдельных строк на несколько сопоставленных объектов. Например имеется класс Post со свойством владельца типа пользователя, следующий запрос SQL вернет все необходимые данные:

```sql
select * from #Posts p
left join \#Users u on u.Id = p.OwnerId
Order by p.Id
```

Каждой возвращаемой строке включает данные пользователя и Post. Так как данные пользователя должны быть присоединены к данные Post через свойство владельца, используются следующие функции:

```csharp
(post, user) => { post.Owner = user; return post; }
```

Полный листинг кода для возврата коллекции записей с их владельца, свойство заполняется данными пользователя будет выглядеть так:

```csharp
var sql = @"select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id";
var data = connection.Query<Post, User, Post>(sql,
(post, user) => { post.Owner = user; return post;});
```

Так как он предоставляет меньше инкапсуляции, Dapper требует разработчикам Дополнительные сведения о их хранения, как выполнить запрос он эффективно и написать дополнительный код для извлечения их. При изменении модели, а не просто создание новой миграции (другой функцией EF Core) и/или обновление сведений о сопоставлении в одном месте в DbContext, каждый запрос, это повлияет на необходимо обновить. Эти запросы имеют не гарантирует времени компиляции, поэтому они могут разрываться во время выполнения в ответ на изменения, для модели или базы данных, позволяя быстро обнаружить ошибки. Обмен эти варианты Dapper обеспечивает очень высокую производительность.

Для большинства приложений и большинство части практически все приложения основные EF предлагает приемлемой производительности. Таким образом его преимущества производительности разработчика, скорее всего перевешивают затраты на его производительности. Для запросов, которые могут использовать преимущества кэширования, фактически имеющегося запроса может быть выполнена только маленький процент времени, делая относительно небольшой запрос бессмысленными различия в производительности.

## <a name="sql-or-nosql"></a>SQL или отличные от SQL

В большинстве случаев реляционных баз данных, как SQL Server подчиненную marketplace для хранения постоянных данных, но они не являются единственным решением. Баз данных NoSQL, таких как [MongoDB](https://www.mongodb.com/what-is-mongodb) реализует другой подход для хранения объектов. Вместо того чтобы сопоставление объектов и таблиц и строк, другой вариант — для сериализации всего графа объекта и сохранить результат. Преимущества этого подхода по крайней мере первоначально, простоты и производительности. Наверняка проще хранить один сериализованный объект с ключом, чем Чтобы разбить объект на множество таблиц со связями и update и строки, которые могли измениться с момента последнего объекта, полученные из базы данных. Аналогично получения и десериализации объекта из хранилища на основе ключей обычно намного быстрее и проще, чем сложные соединения или несколько запросов к базе данных необходимо полностью создать один и тот же объект из реляционной базы данных. Отсутствие блокировки или транзакции и фиксированную схему также делает очень хорошо оптимизируются для масштабирования на многих компьютерах поддержки очень больших наборов данных баз данных NoSQL.

С другой стороны базах данных NoSQL (как обычно они называются) имеет свои недостатки. Реляционные базы данных позволяет обеспечивать согласованность и избежать дублирования данных нормализации. Это уменьшает общий размер базы данных и гарантирует, что обновления для общих данных будут доступны немедленно во всей базе данных. В реляционной базе данных адрес может ссылаться таблица таблица Country по Идентификатору, таким образом, если название страны или были изменены, записи адресов получают преимущества от обновления без сами необходимости в обновлении. Тем не менее в базе данных NoSQL, адрес и его связанные страны могут быть сериализованы в процессе хранимых объектов. Обновление название страны потребуется таких объектов, необходимо обновить, а не одной строки. Реляционные базы данных также может гарантировать реляционной целостности путем применения правил, например внешние ключи. Баз данных NoSQL обычно имеют такие ограничения на использование данных.

Другой сложность базы данных приходится иметь дело с NoSQL — управление версиями. При изменении свойств объекта, он может невозможно десериализовать из предыдущих версий, которые были сохранены. Таким образом все существующие объекты, имеющие сериализованная (предыдущая) версия объекта необходимо обновить для обеспечения соответствия новой схемы. Это не принципиально отличается от реляционной базы данных, где иногда изменения схемы требуется обновление скриптов, или сопоставление обновления. Однако количество записей, которые необходимо изменить, чаще всего гораздо больше подход NoSQL, так как имеется несколько дублирования данных.

Это возможно в базах данных NoSQL для хранения нескольких версий объектов, что-нибудь Фиксированная схема реляционной базы данных обычно не поддерживают. Однако в этом случае код вашего приложения будет должны учитывать наличие предыдущей версии объектов, дополнительные сложности.

Баз данных NoSQL обычно не выполняют [ACID](http://en.wikipedia.org/wiki/ACID), что означает, что они имеют преимущества производительности и масштабируемости реляционных баз данных. Они подходят для очень больших наборов данных и объекты, которые не подходят для хранения в структурах нормализованной таблицы. Нет причин почему одно приложение не может использовать преимущества обоих реляционных и базах данных NoSQL, используя каждый там, где это наиболее подходящий.

## <a name="azure-documentdb"></a>Azure DocumentDB

Azure DocumentDB является полностью управляемая служба баз данных NoSQL предоставляет хранилище данных на основе облака без схемы. DocumentDB, созданную для быстрого и прогнозируемую производительность, высокий уровень доступности, гибкого масштабирования и глобального распространения. Несмотря на то, что базы данных NoSQL, разработчики могут использовать знакомый, широкие возможности запросов SQL по данным JSON. Все ресурсы в DocumentDB хранятся в виде документов JSON. Ресурсами как *элементы*, который, документы, содержащие метаданные, и *веб-каналы*, которые представляют собой коллекции элементов. Рис. 8-2 показана связь между различных ресурсов DocumentDB.


![Иерархические связи между ресурсами в DocumentDB, базы данных NoSQL JSON](./media/image8-2.png)

**Рис. 8-2.** Организация ресурсов DocumentDB.

Язык запросов DocumentDB — это простой и эффективный интерфейс для выполнения запросов к документам JSON. Язык поддерживает подмножество ANSI SQL-грамматику и добавляет тесная интеграция объект JavaScript, массивов, конструирование объекта и вызова функции.

**Ссылки — DocumentDB**

-   DocumentDB Introduction\
    <https://docs.Microsoft.com/Azure/documentdb/documentdb-Introduction>

## <a name="other-persistence-options"></a>Другие параметры сохраняемости

В дополнение к реляционным и варианты хранилищ NoSQL приложения ASP.NET Core можно использовать для хранения различных форматов данных и файлов в виде облачных, масштабируемые хранилища Azure. Хранилище Azure — высокой степенью масштабируемости, чтобы вы могли начать out хранения небольших объемов данных и масштаб до сохранения сотнями или терабайт, если это необходимо приложению. Хранилище Azure поддерживает четыре типа данных:

-   Хранилище больших двоичных объектов для неструктурированных текстовых или двоичных хранилища, также называют хранения объектов.

-   Хранилище таблиц для структурированные наборы данных, доступны через ключей строк.

-   Очереди хранилища для надежного обмена сообщениями на основе очереди.

-   Хранилище файлов для доступа к общему файлу между виртуальными машинами Azure и локальными приложениями.

**Ссылки — хранилища Azure**

-   Introduction\ хранилища Azure
    <https://docs.Microsoft.com/Azure/Storage/Storage-Introduction>

## <a name="caching"></a>Кэширование

В веб-приложениях следует выполнить каждого веб-запроса в максимально короткий срок. Для этого можно ограничить число внешних вызовов, который сервер должен принимать для выполнения запроса. Кэширование предполагает сохранение копии данных на сервере (или другого хранилища данных, то есть более легко можно запросить от источника данных). Веб-приложений и особенно не SPA традиционной веб-приложений, потребуется выполнить сборку и весь пользовательский интерфейс, с каждым запросом. Часто это подразумевает, что многие из тех же запросах базы данных, несколько раз из одного пользователя запроса к следующему. В большинстве случаев эти данные изменений редко, практически не существует причин для постоянно запроса из базы данных. ASP.NET Core поддерживает кэширование ответов для кэширования всей страницы и кэширование данных, которая поддерживает более детального поведение кэширования.

При реализации кэширования, нужно иметь в виду Разделение областей ответственности. Избегайте реализации логики кэширования в вашей логики доступа к данным или в пользовательском интерфейсе. Вместо этого инкапсуляции кэширования в собственные классы и использовать конфигурацию управлять ее работой. Следует открыть или закрытое и принципы персональной ответственности и упростит управление использование кэша в приложении по мере его роста.

### <a name="aspnet-core-response-caching"></a>Кэширование ответов ASP.NET Core

ASP.NET Core поддерживает два уровня кэширование ответов. Первый уровень не кэширует ничего на сервере, но добавляет заголовки HTTP, которые указывают для клиентов и прокси-серверами для кэширования ответов. Это реализуется путем добавления атрибута ResponseCache отдельных контроллеров или действий:

```csharp
    [ResponseCache(Duration = 60)]
    public IActionResult Contact()
    { }
    
    ViewData["Message"] = "Your contact page.";
    return View();
}

The above example will result in the following header being added to the response, instructing clients to cache the result for up to 60 seconds.

Cache-Control: public,max-age=60

In order to add server-side in-memory caching to the application, you must reference the Microsoft.AspNetCore.ResponseCaching NuGet package, and then add the Response Caching middleware. This middleware is configured in both ConfigureServices and Configure in Startup:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddResponseCaching();
}

public void Configure(IApplicationBuilder app)
{
    app.UseResponseCaching();
}
```

По промежуточного слоя кэширования ответа автоматически кэширует ответы на основе набора условий, которые можно настроить. По умолчанию только 200 (ОК) ответы, запрашиваемой через методы GET или HEAD, кэшируются. Кроме того, запросы должен иметь ответ с Cache-Control: открытого заголовка и не может включать заголовки для авторизации или Set-Cookie. В разделе [полный перечень кэширования условия, используемые по промежуточного слоя кэширование ответов](https://docs.microsoft.com/aspnet/core/performance/caching/middleware#conditions-for-caching).

### <a name="data-caching"></a>Кэширование данных

Вместо (или в дополнение к) кэширование полного веб-откликов, можно кэшировать результаты отдельных запросов. Для этого можно использовать в кэширование памяти на веб-сервере или использовать [распределенного кэша](https://docs.microsoft.com/aspnet/core/performance/caching/distributed). В этом разделе будет показано, как реализовать в кэширование памяти.

Добавить поддержку для памяти (или распределенные) кэширования в ConfigureServices:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMemoryCache();
    services.AddMvc();
}
```

Не забудьте добавить пакет Microsoft.Extensions.Caching.Memory NuGet.

После добавления службы, где требуется доступ к кэшу вы запрашиваете IMemoryCache через внедрения зависимостей. В этом примере CachedCatalogService используется шаблон разработки прокси-сервера (или Decorator), предоставляя альтернативной реализации ICatalogService, который управляет доступом к (или добавляет поведение) CatalogService базовой реализации.

```csharp
public class CachedCatalogService : ICatalogService
{
    private readonly IMemoryCache _cache;
    private readonly CatalogService _catalogService;
    private static readonly string _brandsKey = "brands";
    private static readonly string _typesKey = "types";
    private static readonly string _itemsKeyTemplate = "items-{0}-{1}-{2}-{3}";
    private static readonly TimeSpan _defaultCacheDuration = TimeSpan.FromSeconds(30);
    public CachedCatalogService(IMemoryCache cache,
    CatalogService catalogService)
    {
        _cache = cache;
        _catalogService = catalogService;
    }
    
    public async Task<IEnumerable<SelectListItem>> GetBrands()
    {
        return await _cache.GetOrCreateAsync(_brandsKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetBrands();
        });
    }
    
    public async Task<Catalog> GetCatalogItems(int pageIndex, int itemsPage, int? brandID, int? typeId)
    {
        string cacheKey = String.Format(_itemsKeyTemplate, pageIndex, itemsPage, brandID, typeId);
        return await _cache.GetOrCreateAsync(cacheKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetCatalogItems(pageIndex, itemsPage, brandID, typeId);
        });
    }
    
    public async Task<IEnumerable<SelectListItem>> GetTypes()
    {
        return await _cache.GetOrCreateAsync(_typesKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetTypes();
        });
    }
}
```

Чтобы настроить приложение, чтобы использовать кэшированная версия службы, но по-прежнему позволяет службе для получения экземпляра CatalogService ему в конструкторе, необходимо добавить следующие в ConfigureServices:

```csharp
services.AddMemoryCache();
services.AddScoped<ICatalogService, CachedCatalogService>();
services.AddScoped<CatalogService>();
```

Это место вызовы базы данных для выборки данных каталога будут выполняться только один раз в минуту, а не при каждом запросе. В зависимости от трафика на узел это может иметь очень значительное влияние на количество запросов, выполняемых в базу данных и среднее время загрузки страницы на домашнюю страницу, которая в настоящее время зависит от всех трех запросов, предоставляемых этой службой.

Проблема, которая возникает, когда кэширование реализуется — *устаревшие данные* — то есть данные, изменившиеся в источнике, но устаревшая версия остается в кэше. Простой способ устранения этой проблемы — использовать небольшой продолжительность хранения в кэше, так как работающее приложение нет ограниченная дополнительное преимущество расширение длину хранения данных в кэше. Например, рассмотрим страницы, которая делает запрос одной базы данных и запрашивается 10 раз в секунду. Если эта страница кэшируется в течение одной минуты, приведет к число запросов к базе данных в минуту, выполненных для удаления из 600 сокращения 99.8% 1. Если вместо этого длительность кэширования были внесены в один час, Общее уменьшение будет 99.997%, но теперь вероятность и потенциально возраст устаревшие данные и значительно увеличился.

Другой подход заключается упреждающего удаление записей кэша, при обновлении данных, содержащихся в них. Можно удалить любой отдельной операции, если известен его ключ:

```csharp
_cache.Remove(cacheKey);
```

Если ваше приложение предоставляет функциональность для обновления записей, которые он кэширует, можно удалить соответствующие записи кэша в коде, который выполняет обновления. Иногда может быть много разных записей, которые зависят от определенного набора данных. В этом случае может оказаться полезным создать зависимости между записей кэша, с помощью CancellationChangeToken. С CancellationChangeToken может истечь нескольких записей кэша за один раз при отмене токена.

```csharp
// configure CancellationToken and add entry to cache
var cts = new CancellationTokenSource();
_cache.Set("cts", cts);
_cache.Set(cacheKey,
itemToCache,
new CancellationChangeToken(cts.Token));

// elsewhere, expire the cache by cancelling the token\
_cache.Get<CancellationTokenSource>("cts").Cancel();
```

>[!div class="step-by-step"]
[Предыдущие] (develop-asp-net-core-mvc-apps.md) [Далее] (test-asp-net-core-mvc-apps.md)
