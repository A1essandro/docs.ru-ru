---
title: "Архитектурные принципы"
description: "Архитектора современных веб-приложений с помощью ASP.NET Core и Azure | Архитектурные принципы"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bdb215d64253fb7d22ae2c5648030336850006b5
ms.sourcegitcommit: f28752eab00d2bd97e971542c0f49ce63cfbc239
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2018
---
# <a name="architectural-principles"></a>Архитектурные принципы

> «При построители зданий программистов способом написал программы, а затем первый woodpecker, поставляемой вместе бы уничтожить цивилизации.»  
> _\- Такого Weinberg_

## <a name="summary"></a>Сводка

Следует архитектуры и разработки программных решений с поддерживаемый. Принципы, описанные в этом разделе поможет узнать сторону архитектурные решения, которые приведут к чистой, поддерживаемого приложения. Как правило эти принципы поможет направлении построения приложений из отдельных компонентов, которые тесно не связана с другими частями приложения, но вместо взаимодействуют через явные интерфейсы или систем обмена сообщениями.

## <a name="common-design-principles"></a>Общие принципы проектирования

### <a name="separation-of-concerns"></a>Разделение областей ответственности

Руководящие участник, при разработке **значимость**. Этот принцип утверждает программного обеспечения должны быть разделены основании виды работ, выполняемых. Например рассмотрим приложение, включает логику для определения внимания элементов, отображаемых для пользователя и определенным образом, чтобы сделать их более заметными, который форматирует такие элементы. Поведение, ответственность за выбор элементов для форматирования должен храниться отдельно от поведения, отвечает за форматирование элементов, поскольку это отдельные проблемы, которые связаны друг с другом только по случайному совпадению.

С точки зрения архитектуры приложения можно создавать логически следовать этот принцип, разделив основное поведение бизнес логики инфраструктуры и пользовательского интерфейса. В идеальном случае бизнес-правил и логике должен находиться в отдельном проекте, который не следует полагаться на другие проекты в приложении. Это гарантирует, что бизнес-модели упрощает тестирование и могут изменяться без тесно связана с сведения о реализации нижнего уровня. Разделение задач — ключа следует учитывать за использование слоев в архитектурах приложений.

### <a name="encapsulation"></a>Инкапсуляция

Разные части приложения следует использовать **инкапсуляции** для изолирования их из других частей приложения. Компоненты приложения и слои следует можно настроить их внутренней реализации без нарушения их участники совместной работы, до тех пор, пока не нарушены внешних контракты. Правильное использование инкапсуляции позволит сделать слабосвязанную и модульности при Дизайн приложения, так как объекты и пакеты можно заменить альтернативных реализаций до тех пор, пока сохраняется тот же интерфейс.

В классах инкапсуляция достигается путем ограничения за пределами доступ к внутреннее состояние класса. Если внешнего субъекта хочет изменять состояние объекта, оно должно делать это через четко определенный функцию (или метод задания свойства), вместо того чтобы использовать прямой доступ к закрытое состояние объекта. Аналогичным образом компонентов приложения и самих приложений следует предоставлять четко определенными интерфейсами для их участники совместной работы для использования, не допуская свое состояние изменить непосредственно. Это освобождает внутренней разработки приложения со временем не беспокоиться, что делать так нарушат участникам совместной работы, при условии, что поддерживаются открытые контракты.

### <a name="dependency-inversion"></a>Инверсия зависимостей.

Направление зависимости в приложении должно быть в направлении абстракция, а не сведения о реализации. Большинство приложений записываются таким образом, что во время компиляции зависимостей передает в направлении выполнения. Это позволяет создать диаграмму прямых зависимостей. То есть если модуль A вызывает функцию в модуле B, которые вызывает функцию в модуле C, а затем по желанию A времени компиляции зависят от B, который будет зависеть C, как показано на рисунке 4-1.

![](./media/image4-1.png)

**Рис. 4-1.** Граф прямой зависимости.

Применение принципом инверсии зависимостей позволяет объект для вызова методов для абстракции, который реализует B, благодаря чему для A вызову B во время выполнения, но в B, чтобы он зависел от интерфейса управляет типа во время компиляции (таким образом, *Инверсия* Обычно во время компиляции зависимость). Во время выполнения поток выполнения программы не меняется, но введении интерфейсы означает, что разные реализации этих интерфейсов можно без труда подключить.

![](./media/image4-2.png)

**Рис. 4-2.** Граф зависимостей инвертированный.

**Инверсия зависимостей** является ключевой частью построение слабо связанных приложений, так как сведения о реализации могут записываться зависят от и реализовать абстрактные классы более высокого уровня, а не наоборот. В результате приложения в результате более тестируемых модульной и простым в обслуживании. Практика *внедрения зависимостей* стало возможным в соответствии с принципом инверсии зависимостей.

### <a name="explicit-dependencies"></a>Явные зависимости

**Методы и классы, явно должна требовать любые совместно объекты, которые им необходимы для правильной работы.** Конструкторы класса дают возможность классах, чтобы определить задачи, которые необходимы для правильной и быть в допустимом состоянии. Если определить классы, которые могут составить и именем, но которой будет работать должным образом Если некоторые компоненты глобальной или инфраструктуры, эти классы *недобросовестных* с их клиентами. Конструктор контракт указывает, что клиента, который его достаточно указанного действия (возможно ничего, если класс только с помощью конструктора по умолчанию), но затем во время выполнения, оказывается объект действительно необходимо что-нибудь другое.

Следуя принцип явные зависимости, классы и методы, честными с их клиентами о требуемых для своей работы. Это делает код более самодокументируемыми и программирования контрактов более понятным, поскольку пользователям будет поставлено доверия, при условии, что они предоставляют ресурсов, необходимых в виде метода или будет вести себя параметров конструктора, объекты, которые при работе с правильно во время выполнения.

### <a name="single-responsibility"></a>Ответственность за один

Принцип персональной ответственности применяется к объектно ориентированный проект, но может также рассматриваться как архитектуры принцип аналогичен Разделение областей ответственности. В нем сообщается, что объекты должны иметь только один ответственность, и что они должны иметь одну из причин для изменения. В частности единственный случай, в котором необходимо изменить объект — если способом, в котором он выполняет свою ответственность один должен быть обновлен. Этот принцип позволяет создавать более слабая и модульной системы после многих видов новое поведение может быть реализован как новые классы, а не путем добавления дополнительных ответственность за существующих классов. Добавление новых классов всегда является более безопасным, чем изменение существующих классов, так как код не еще зависит от новых классов.

В приложении монолитные можно применить один ответственности на высоком уровне со слоями в приложении. Ответственность за представления должно оставаться в проект пользовательского интерфейса, во время доступа к данным ответственности должен располагаться в пределах проекта инфраструктуры. Бизнес-логика должна храниться в основной проект приложения, где можно легко проверить и могут изменяться независимо от других ответственности.

Когда этот принцип применяется к архитектуре приложения и уделить логической конечной точки, вы получаете микрослужбами. Данного микрослужбу должны иметь один ответственности. Если необходимо расширить поведение системы лучше обычно можно сделать, добавив дополнительные микрослужбами, а не путем добавления ответственности с существующим элементом.

[Дополнительные сведения об архитектуре микрослужбами](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a>Не повторять самостоятельно (ТОНЕРА)

Приложения следует избегать указания поведения, связанные с определенной понятие в нескольких местах, как это часто источника ошибок. На некотором этапе изменение в требованиях потребуется изменить это поведение и вероятность того, хотя бы один экземпляр поведения не удастся обновить приведет к непредсказуемому поведению системы.

Вместо дублирования логики, инкапсулировать в конструкции программирования. Сделайте эту конструирования единого центра через это поведение, и у других частей приложения, которое требует использования этого поведения новую конструкцию.

> [!NOTE]
> Избегайте поведение, которое только по случайному совпадению повторяющиеся привязки друг с другом. Например только потому, что две константы оба имеют одинаковое значение, это не означает должны иметь только один константа при ссылках логически они на разные вещи.

### <a name="persistence-ignorance"></a>Пропуск сохраняемости

**Пропуск сохраняемости** (PI) ссылается на типы, которые должны быть сохранены, но не влияет на выбор технологии сохраняемости, код. Такие типы в .NET, иногда называются старые объекты CLR (POCO), так как они не обязательно должны наследовать от определенного базового класса или реализовывал определенный интерфейс. Пропуск сохраняемости полезен, так как при этом же бизнес-модели должна быть сохранена в несколькими способами, предлагая дополнительную гибкость в приложение. Варианты сохранения могут измениться с течением времени, из одной базы данных технологии в другую, или Дополнительные формы сохраняемости могут быть необходимы, помимо независимо от приложения к работе с (например, использование кэша Redis или Azure DocumentDb в дополнение к реляционная база данных).

Некоторые примеры нарушение этого принципа.

-   Обязательный базовый класс

-   Реализация требуемому интерфейсу

-   Классы, отвечает за сохранение сами (например, шаблон активной записи)

-   Обязательный конструктор по умолчанию

-   Свойства, требующие virtual-ключевое слово

-   Обязательные атрибуты конкретного сохраняемости

Требование, что классы имеют любые из перечисленных выше функций и поведения добавляет связь между типы, которые должны быть сохранены и Выбор технологии сохраняемости, что усложняет внедрить новые стратегии доступа к данным в будущем.

### <a name="bounded-contexts"></a>Предельная контексты

**Ограниченная контексты** — это центральный шаблоны в сей конструктора. Они позволяют выполняемой сложности в больших приложениях или организации, разбив его на отдельные основные модули. Каждый модуль концептуальной то представляет контекст, который отделяется от других контекстах (таким образом, разграничиваются) и могут изменяться независимо. Каждой связанной контекста в идеале должно быть свободно выбирать свои собственные имена для понятия внутри него и должны иметь монопольный доступ к собственное хранилище сохраняемости.

Как минимум отдельные веб-приложений следует стремиться к быть собственный ограниченной контекст с их собственных хранилище сохраняемости для своей бизнес-модели, а не общий доступ к базе данных с другими приложениями. Взаимодействие между контекстами ограниченной происходит через программные интерфейсы, а не через общую базу данных, что позволяет бизнес-логики и события, чтобы занять поместите в ответ на изменения, выполняемые. Тесно связанный контексты карты с микрослужбами, в которой также в идеале реализуются как свои собственные отдельных ограниченной контекстов.

> ### <a name="references--modern-web-applications"></a>Ссылки — современных веб-приложений
> - Разделение областей ответственности  
> <http://deviq.com/separation-of-concerns/>
> - **Encapsulation** <http://deviq.com/encapsulation/>
> - **Принципом инверсии зависимостей**  
> <http://deviq.com/dependency-inversion-principle/>
> - **Принцип явных зависимостей**  
> <http://deviq.com/explicit-dependencies-principle/>
> - **Не повторять самостоятельно**  
> <http://deviq.com/don-t-repeat-yourself/>
> - Пропуск сохраняемости  
> <http://deviq.com/persistence-ignorance/>
> - **Предельная контекста**  
> <https://martinfowler.com/bliki/BoundedContext.html>

> [!div class="step-by-step"]
[Предыдущие] (choose-between-traditional-web-and-single-page-apps.md) [Далее] (общий веб приложения architectures.md)
