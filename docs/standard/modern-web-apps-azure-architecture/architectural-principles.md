---
title: "Архитектурные принципы"
description: "Архитектора современных веб-приложений с помощью ASP.NET Core и Azure | Архитектурные принципы"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 20524c8aa0e64fd40a1a4a6811063557f74074d2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
#<a name="architectural-principles"></a><span data-ttu-id="83c8d-103">Архитектурные принципы</span><span class="sxs-lookup"><span data-stu-id="83c8d-103">Architectural Principles</span></span>

> <span data-ttu-id="83c8d-104">«При построители зданий программистов способом написал программы, а затем первый woodpecker, поставляемой вместе бы уничтожить цивилизации.»</span><span class="sxs-lookup"><span data-stu-id="83c8d-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="83c8d-105">_\-Такого Weinberg_</span><span class="sxs-lookup"><span data-stu-id="83c8d-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="83c8d-106">Сводка</span><span class="sxs-lookup"><span data-stu-id="83c8d-106">Summary</span></span>

<span data-ttu-id="83c8d-107">Следует архитектуры и разработки программных решений с поддерживаемый.</span><span class="sxs-lookup"><span data-stu-id="83c8d-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="83c8d-108">Принципы, описанные в этом разделе поможет узнать сторону архитектурные решения, которые приведут к чистой, поддерживаемого приложения.</span><span class="sxs-lookup"><span data-stu-id="83c8d-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="83c8d-109">Как правило эти принципы поможет направлении построения приложений из отдельных компонентов, которые тесно не связана с другими частями приложения, но вместо взаимодействуют через явные интерфейсы или систем обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="83c8d-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="83c8d-110">Общие принципы проектирования</span><span class="sxs-lookup"><span data-stu-id="83c8d-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="83c8d-111">Разделение областей ответственности</span><span class="sxs-lookup"><span data-stu-id="83c8d-111">Separation of Concerns</span></span>

<span data-ttu-id="83c8d-112">Руководящие участник, при разработке **значимость**.</span><span class="sxs-lookup"><span data-stu-id="83c8d-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="83c8d-113">Этот принцип утверждает программного обеспечения должны быть разделены основании виды работ, выполняемых.</span><span class="sxs-lookup"><span data-stu-id="83c8d-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="83c8d-114">Например рассмотрим приложение, включает логику для определения внимания элементов, отображаемых для пользователя и определенным образом, чтобы сделать их более заметными, который форматирует такие элементы.</span><span class="sxs-lookup"><span data-stu-id="83c8d-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="83c8d-115">Поведение, ответственность за выбор элементов для форматирования должен храниться отдельно от поведения, отвечает за форматирование элементов, поскольку это отдельные проблемы, которые связаны друг с другом только по случайному совпадению.</span><span class="sxs-lookup"><span data-stu-id="83c8d-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="83c8d-116">С точки зрения архитектуры приложения можно создавать логически следовать этот принцип, разделив основное поведение бизнес логики инфраструктуры и пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="83c8d-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="83c8d-117">В идеальном случае бизнес-правил и логике должен находиться в отдельном проекте, который не следует полагаться на другие проекты в приложении.</span><span class="sxs-lookup"><span data-stu-id="83c8d-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="83c8d-118">Это гарантирует, что бизнес-модели упрощает тестирование и могут изменяться без тесно связана с сведения о реализации нижнего уровня.</span><span class="sxs-lookup"><span data-stu-id="83c8d-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="83c8d-119">Разделение задач — ключа следует учитывать за использование слоев в архитектурах приложений.</span><span class="sxs-lookup"><span data-stu-id="83c8d-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="83c8d-120">Инкапсуляция</span><span class="sxs-lookup"><span data-stu-id="83c8d-120">Encapsulation</span></span>

<span data-ttu-id="83c8d-121">Разные части приложения следует использовать **инкапсуляции** для изолирования их из других частей приложения.</span><span class="sxs-lookup"><span data-stu-id="83c8d-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="83c8d-122">Компоненты приложения и слои следует можно настроить их внутренней реализации без нарушения их участники совместной работы, до тех пор, пока не нарушены внешних контракты.</span><span class="sxs-lookup"><span data-stu-id="83c8d-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="83c8d-123">Правильное использование инкапсуляции позволит сделать слабосвязанную и модульности при Дизайн приложения, так как объекты и пакеты можно заменить альтернативных реализаций до тех пор, пока сохраняется тот же интерфейс.</span><span class="sxs-lookup"><span data-stu-id="83c8d-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="83c8d-124">В классах инкапсуляция достигается путем ограничения за пределами доступ к внутреннее состояние класса.</span><span class="sxs-lookup"><span data-stu-id="83c8d-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="83c8d-125">Если внешнего субъекта хочет изменять состояние объекта, оно должно делать это через четко определенный функцию (или метод задания свойства), вместо того чтобы использовать прямой доступ к закрытое состояние объекта.</span><span class="sxs-lookup"><span data-stu-id="83c8d-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="83c8d-126">Аналогичным образом компонентов приложения и самих приложений следует предоставлять четко определенными интерфейсами для их участники совместной работы для использования, не допуская свое состояние изменить непосредственно.</span><span class="sxs-lookup"><span data-stu-id="83c8d-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="83c8d-127">Это освобождает внутренней разработки приложения со временем не беспокоиться, что делать так нарушат участникам совместной работы, при условии, что поддерживаются открытые контракты.</span><span class="sxs-lookup"><span data-stu-id="83c8d-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="83c8d-128">Инверсия зависимостей.</span><span class="sxs-lookup"><span data-stu-id="83c8d-128">Dependency Inversion</span></span>

<span data-ttu-id="83c8d-129">Направление зависимости в приложении должно быть в направлении абстракция, а не сведения о реализации.</span><span class="sxs-lookup"><span data-stu-id="83c8d-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="83c8d-130">Большинство приложений записываются таким образом, что во время компиляции зависимостей передает в направлении выполнения.</span><span class="sxs-lookup"><span data-stu-id="83c8d-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="83c8d-131">Это позволяет создать диаграмму прямых зависимостей.</span><span class="sxs-lookup"><span data-stu-id="83c8d-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="83c8d-132">То есть если модуль A вызывает функцию в модуле B, которые вызывает функцию в модуле C, а затем по желанию A времени компиляции зависят от B, который будет зависеть C, как показано на рисунке 4-1.</span><span class="sxs-lookup"><span data-stu-id="83c8d-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="83c8d-133">**Рис. 4-1.**</span><span class="sxs-lookup"><span data-stu-id="83c8d-133">**Figure 4-1.**</span></span> <span data-ttu-id="83c8d-134">Граф прямой зависимости.</span><span class="sxs-lookup"><span data-stu-id="83c8d-134">Direct dependency graph.</span></span>

<span data-ttu-id="83c8d-135">Применение принципом инверсии зависимостей позволяет объект для вызова методов для абстракции, который реализует B, благодаря чему для A вызову B во время выполнения, но в B, чтобы он зависел от интерфейса управляет типа во время компиляции (таким образом, *Инверсия* Обычно во время компиляции зависимость).</span><span class="sxs-lookup"><span data-stu-id="83c8d-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="83c8d-136">Во время выполнения поток выполнения программы не меняется, но введении интерфейсы означает, что разные реализации этих интерфейсов можно без труда подключить.</span><span class="sxs-lookup"><span data-stu-id="83c8d-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="83c8d-137">**Рис. 4-2.**</span><span class="sxs-lookup"><span data-stu-id="83c8d-137">**Figure 4-2.**</span></span> <span data-ttu-id="83c8d-138">Граф зависимостей инвертированный.</span><span class="sxs-lookup"><span data-stu-id="83c8d-138">Inverted dependency graph.</span></span>

<span data-ttu-id="83c8d-139">**Инверсия зависимостей** является ключевой частью построение слабо связанных приложений, так как сведения о реализации могут записываться зависят от и реализовать абстрактные классы более высокого уровня, а не наоборот.</span><span class="sxs-lookup"><span data-stu-id="83c8d-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="83c8d-140">В результате приложения в результате более тестируемых модульной и простым в обслуживании.</span><span class="sxs-lookup"><span data-stu-id="83c8d-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="83c8d-141">Практика *внедрения зависимостей* стало возможным в соответствии с принципом инверсии зависимостей.</span><span class="sxs-lookup"><span data-stu-id="83c8d-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="83c8d-142">Явные зависимости</span><span class="sxs-lookup"><span data-stu-id="83c8d-142">Explicit Dependencies</span></span>

<span data-ttu-id="83c8d-143">**Методы и классы, явно должна требовать любые совместно объекты, которые им необходимы для правильной работы.**</span><span class="sxs-lookup"><span data-stu-id="83c8d-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="83c8d-144">Конструкторы класса дают возможность классах, чтобы определить задачи, которые необходимы для правильной и быть в допустимом состоянии.</span><span class="sxs-lookup"><span data-stu-id="83c8d-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="83c8d-145">Если определить классы, которые могут составить и именем, но которой будет работать должным образом Если некоторые компоненты глобальной или инфраструктуры, эти классы *недобросовестных* с их клиентами.</span><span class="sxs-lookup"><span data-stu-id="83c8d-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="83c8d-146">Конструктор контракт указывает, что клиента, который его достаточно указанного действия (возможно ничего, если класс только с помощью конструктора по умолчанию), но затем во время выполнения, оказывается объект действительно необходимо что-нибудь другое.</span><span class="sxs-lookup"><span data-stu-id="83c8d-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="83c8d-147">Следуя принцип явные зависимости, классы и методы, честными с их клиентами о требуемых для своей работы.</span><span class="sxs-lookup"><span data-stu-id="83c8d-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="83c8d-148">Это делает код более самодокументируемыми и программирования контрактов более понятным, поскольку пользователям будет поставлено доверия, при условии, что они предоставляют ресурсов, необходимых в виде метода или будет вести себя параметров конструктора, объекты, которые при работе с правильно во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="83c8d-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="83c8d-149">Ответственность за один</span><span class="sxs-lookup"><span data-stu-id="83c8d-149">Single Responsibility</span></span>

<span data-ttu-id="83c8d-150">Принцип персональной ответственности применяется к объектно ориентированный проект, но может также рассматриваться как архитектуры принцип аналогичен Разделение областей ответственности.</span><span class="sxs-lookup"><span data-stu-id="83c8d-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="83c8d-151">В нем сообщается, что объекты должны иметь только один ответственность, и что они должны иметь одну из причин для изменения.</span><span class="sxs-lookup"><span data-stu-id="83c8d-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="83c8d-152">В частности единственный случай, в котором необходимо изменить объект — если способом, в котором он выполняет свою ответственность один должен быть обновлен.</span><span class="sxs-lookup"><span data-stu-id="83c8d-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="83c8d-153">Этот принцип позволяет создавать более слабая и модульной системы после многих видов новое поведение может быть реализован как новые классы, а не путем добавления дополнительных ответственность за существующих классов.</span><span class="sxs-lookup"><span data-stu-id="83c8d-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="83c8d-154">Добавление новых классов всегда является более безопасным, чем изменение существующих классов, так как код не еще зависит от новых классов.</span><span class="sxs-lookup"><span data-stu-id="83c8d-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="83c8d-155">В приложении монолитные можно применить один ответственности на высоком уровне со слоями в приложении.</span><span class="sxs-lookup"><span data-stu-id="83c8d-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="83c8d-156">Ответственность за представления должно оставаться в проект пользовательского интерфейса, во время доступа к данным ответственности должен располагаться в пределах проекта инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="83c8d-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="83c8d-157">Бизнес-логика должна храниться в основной проект приложения, где можно легко проверить и могут изменяться независимо от других ответственности.</span><span class="sxs-lookup"><span data-stu-id="83c8d-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="83c8d-158">Когда этот принцип применяется к архитектуре приложения и уделить логической конечной точки, вы получаете микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="83c8d-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="83c8d-159">Данного микрослужбу должны иметь один ответственности.</span><span class="sxs-lookup"><span data-stu-id="83c8d-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="83c8d-160">Если необходимо расширить поведение системы лучше обычно можно сделать, добавив дополнительные микрослужбами, а не путем добавления ответственности с существующим элементом.</span><span class="sxs-lookup"><span data-stu-id="83c8d-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="83c8d-161">Дополнительные сведения об архитектуре микрослужбами</span><span class="sxs-lookup"><span data-stu-id="83c8d-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="83c8d-162">Не повторять самостоятельно (ТОНЕРА)</span><span class="sxs-lookup"><span data-stu-id="83c8d-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="83c8d-163">Приложения следует избегать указания поведения, связанные с определенной понятие в нескольких местах, как это часто источника ошибок.</span><span class="sxs-lookup"><span data-stu-id="83c8d-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="83c8d-164">На некотором этапе изменение в требованиях потребуется изменить это поведение и вероятность того, хотя бы один экземпляр поведения не удастся обновить приведет к непредсказуемому поведению системы.</span><span class="sxs-lookup"><span data-stu-id="83c8d-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="83c8d-165">Вместо дублирования логики, инкапсулировать в конструкции программирования.</span><span class="sxs-lookup"><span data-stu-id="83c8d-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="83c8d-166">Сделайте эту конструирования единого центра через это поведение, и у других частей приложения, которое требует использования этого поведения новую конструкцию.</span><span class="sxs-lookup"><span data-stu-id="83c8d-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="83c8d-167">Избегайте поведение, которое только по случайному совпадению повторяющиеся привязки друг с другом.</span><span class="sxs-lookup"><span data-stu-id="83c8d-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="83c8d-168">Например только потому, что две константы оба имеют одинаковое значение, это не означает должны иметь только один константа при ссылках логически они на разные вещи.</span><span class="sxs-lookup"><span data-stu-id="83c8d-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="83c8d-169">Пропуск сохраняемости</span><span class="sxs-lookup"><span data-stu-id="83c8d-169">Persistence Ignorance</span></span>

<span data-ttu-id="83c8d-170">**Пропуск сохраняемости** (PI) ссылается на типы, которые должны быть сохранены, но не влияет на выбор технологии сохраняемости, код.</span><span class="sxs-lookup"><span data-stu-id="83c8d-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="83c8d-171">Такие типы в .NET, иногда называются старые объекты CLR (POCO), так как они не обязательно должны наследовать от определенного базового класса или реализовывал определенный интерфейс.</span><span class="sxs-lookup"><span data-stu-id="83c8d-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="83c8d-172">Пропуск сохраняемости полезен, так как при этом же бизнес-модели должна быть сохранена в несколькими способами, предлагая дополнительную гибкость в приложение.</span><span class="sxs-lookup"><span data-stu-id="83c8d-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="83c8d-173">Варианты сохранения могут измениться с течением времени, из одной базы данных технологии в другую, или Дополнительные формы сохраняемости могут быть необходимы, помимо независимо от приложения к работе с (например, использование кэша Redis или Azure DocumentDb в дополнение к реляционная база данных).</span><span class="sxs-lookup"><span data-stu-id="83c8d-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="83c8d-174">Некоторые примеры нарушение этого принципа.</span><span class="sxs-lookup"><span data-stu-id="83c8d-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="83c8d-175">Обязательный базовый класс</span><span class="sxs-lookup"><span data-stu-id="83c8d-175">A required base class</span></span>

-   <span data-ttu-id="83c8d-176">Реализация требуемому интерфейсу</span><span class="sxs-lookup"><span data-stu-id="83c8d-176">A required interface implementation</span></span>

-   <span data-ttu-id="83c8d-177">Классы, отвечает за сохранение сами (например, шаблон активной записи)</span><span class="sxs-lookup"><span data-stu-id="83c8d-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="83c8d-178">Обязательный конструктор по умолчанию</span><span class="sxs-lookup"><span data-stu-id="83c8d-178">Required default constructor</span></span>

-   <span data-ttu-id="83c8d-179">Свойства, требующие virtual-ключевое слово</span><span class="sxs-lookup"><span data-stu-id="83c8d-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="83c8d-180">Обязательные атрибуты конкретного сохраняемости</span><span class="sxs-lookup"><span data-stu-id="83c8d-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="83c8d-181">Требование, что классы имеют любые из перечисленных выше функций и поведения добавляет связь между типы, которые должны быть сохранены и Выбор технологии сохраняемости, что усложняет внедрить новые стратегии доступа к данным в будущем.</span><span class="sxs-lookup"><span data-stu-id="83c8d-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="83c8d-182">Предельная контексты</span><span class="sxs-lookup"><span data-stu-id="83c8d-182">Bounded Contexts</span></span>

<span data-ttu-id="83c8d-183">**Ограниченная контексты** — это центральный шаблоны в сей конструктора.</span><span class="sxs-lookup"><span data-stu-id="83c8d-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="83c8d-184">Они позволяют выполняемой сложности в больших приложениях или организации, разбив его на отдельные основные модули.</span><span class="sxs-lookup"><span data-stu-id="83c8d-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="83c8d-185">Каждый модуль концептуальной то представляет контекст, который отделяется от других контекстах (таким образом, разграничиваются) и могут изменяться независимо.</span><span class="sxs-lookup"><span data-stu-id="83c8d-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="83c8d-186">Каждой связанной контекста в идеале должно быть свободно выбирать свои собственные имена для понятия внутри него и должны иметь монопольный доступ к собственное хранилище сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="83c8d-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="83c8d-187">Как минимум отдельные веб-приложений следует стремиться к быть собственный ограниченной контекст с их собственных хранилище сохраняемости для своей бизнес-модели, а не общий доступ к базе данных с другими приложениями.</span><span class="sxs-lookup"><span data-stu-id="83c8d-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="83c8d-188">Взаимодействие между контекстами ограниченной происходит через программные интерфейсы, а не через общую базу данных, что позволяет бизнес-логики и события, чтобы занять поместите в ответ на изменения, выполняемые.</span><span class="sxs-lookup"><span data-stu-id="83c8d-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="83c8d-189">Тесно связанный контексты карты с микрослужбами, в которой также в идеале реализуются как свои собственные отдельных ограниченной контекстов.</span><span class="sxs-lookup"><span data-stu-id="83c8d-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="83c8d-190">Ссылки — современных веб-приложений</span><span class="sxs-lookup"><span data-stu-id="83c8d-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="83c8d-191">**Разделение областей ответственности**</span><span class="sxs-lookup"><span data-stu-id="83c8d-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="83c8d-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="83c8d-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="83c8d-193">**Инкапсуляция** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="83c8d-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="83c8d-194">**Принципом инверсии зависимостей**</span><span class="sxs-lookup"><span data-stu-id="83c8d-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="83c8d-195"><http://deviq.com/dependency-Inversion-Principle/></span><span class="sxs-lookup"><span data-stu-id="83c8d-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="83c8d-196">**Принцип явные зависимости**</span><span class="sxs-lookup"><span data-stu-id="83c8d-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="83c8d-197"><http://deviq.com/Explicit-DEPENDENCIES-Principle/></span><span class="sxs-lookup"><span data-stu-id="83c8d-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="83c8d-198">**Не повторять самостоятельно**</span><span class="sxs-lookup"><span data-stu-id="83c8d-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="83c8d-199"><http://deviq.com/Don-t-Repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="83c8d-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="83c8d-200">**Пропуск сохраняемости**</span><span class="sxs-lookup"><span data-stu-id="83c8d-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="83c8d-201"><http://deviq.com/Persistence-Ignorance/></span><span class="sxs-lookup"><span data-stu-id="83c8d-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="83c8d-202">**Предельная контекста**</span><span class="sxs-lookup"><span data-stu-id="83c8d-202">**Bounded Context**</span></span>  
> <span data-ttu-id="83c8d-203"><https://martinfowler.com/bliki/BoundedContext.HTML></span><span class="sxs-lookup"><span data-stu-id="83c8d-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="83c8d-204">[Предыдущие] (choose-between-traditional-web-and-single-page-apps.md) [Далее] (общий веб приложения architectures.md)</span><span class="sxs-lookup"><span data-stu-id="83c8d-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>
