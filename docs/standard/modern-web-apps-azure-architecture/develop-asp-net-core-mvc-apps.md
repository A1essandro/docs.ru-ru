---
title: "Разработка приложений MVC ASP.NET Core"
description: "Архитектора современных веб-приложений с помощью ASP.NET Core и Azure | Разработка приложений MVC ASP.NET Core"
author: ardalis
ms.author: wiwagn
ms.date: 10/07/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 54e7ed6fff9ac709e411d0ac1e345c63fd753201
ms.sourcegitcommit: 43c656811dd38a66a6672084c65d10c0cbbf2015
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2017
---
# <a name="develop-aspnet-core-mvc-apps"></a>Разработка приложений MVC ASP.NET Core

> «Важно не получается в первый раз. Важно жизненно получается в последний раз.»  
> _-Эндрю слежения и Дэвид Thomas_

## <a name="summary"></a>Сводка

ASP.NET Core — это кросс платформенных, открытая платформа для создания современных оптимизированными для облака веб-приложений. Приложения ASP.NET Core — это упрощенный и модульной со встроенной поддержкой для внедрения зависимости, включение в больше возможностей тестирования и сопровождения. В сочетании с MVC, который поддерживает построение современных веб-API в дополнение к приложения на основе представления, ASP.NET Core — это мощный платформа, для создания веб-приложений корпоративного.

## <a name="mapping-requests-to-responses"></a>Сопоставление запросов для ответов

Сущность приложения ASP.NET Core назначают входящие запросы для исходящих ответов. На низком уровне это делается с помощью по промежуточного слоя и простых приложений ASP.NET Core и микрослужбами может состоять только из пользовательских по промежуточного слоя. При использовании ASP.NET MVC основных компонентов, можно работать несколько более высокого уровня, подхода на основе *маршруты*, *контроллеров*, и *действия*. Каждый входящий запрос сравнивается с таблицу маршрутизации для приложения, и при обнаружении подходящего маршрута для обработки запроса вызывается связанный метод действия (принадлежащих контроллера). При обнаружении подходящего маршрута, вызывается обработчик ошибок (в данном случае, возвращая результат не найдено).

Приложения MVC ASP.NET Core можно использовать обычные маршрутов и маршрутов с атрибутами. Обычные маршруты были определены в коде, указав маршрутизации *соглашения* с помощью синтаксиса, как в приведенном ниже примере:

```csharp
app.UseMvc(routes =>;
{
    routes.MapRoute("default","{controller=Home}/{action=Index}/{id?}");
});
```

В этом примере маршрут с именем «default» добавлена в таблицу маршрутизации. Он определяет шаблон маршрута с заполнителями для *контроллера*, *действия*, и *идентификатор*. Заполнители контроллера и действия имеют значения по умолчанию («Home» и «Индекс», соответственно), и заполнитель идентификатора является необязательным (посредством «?» применяемый к нему). Согласно правилам для определенных здесь состояний, которые должны соответствовать первой части запроса, имя контроллера, вторая часть для этого действия, и затем при необходимости третья часть будет представлять параметр id. Обычные маршруты обычно определяются в одном месте для приложения, такие как Настройка метода в класс Startup.

Атрибут маршруты, применяется непосредственно к контроллерам и действия, а не указан глобально. Это преимущество становятся гораздо более доступными при вы просматриваете конкретного метода, но означает, что сведения о маршрутизации не будет содержаться в одном месте в приложении. Маршруты атрибута вы можно легко указать несколько маршрутов для выполнения данного действия, а также объединять маршруты между контроллеров и действий. Пример:

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")] // Combines to define the route template "Home"
    [Route("Index")] // Combines to define route template "Home/Index"
    [Route("/")] // Does not combine, defines the route template ""
    public IActionResult Index() {}
```

Маршруты могут быть заданы в [HttpGet] и похожими атрибутами, устраняя необходимость добавить отделения [маршрута\] атрибуты. Маршруты атрибута также можно использовать токены для уменьшения необходимость повторения имена контроллер или действие, как показано ниже:

```csharp
[Route("[controller\]")]
public class ProductsController : Controller
{
    [Route("")] // Matches 'Products'
    [Route("Index")] // Matches 'Products/Index'
    public IActionResult Index()
}
```

После указанного запроса было сопоставлено с маршрутом, но перед действием будет вызван, будет выполнять ASP.NET Core MVC [привязки модели](https://docs.microsoft.com/aspnet/core/mvc/models/model-binding) и [проверка модели](https://docs.microsoft.com/aspnet/core/mvc/models/validation) в запросе. Привязка модели отвечает за преобразование входящих HTTP-данных в типы .NET, определяются как параметры метода действия для вызова. Например если метод действия требуется параметр id int, привязки модели будет пытаться предоставить этот параметр со значением параметра предоставляется как часть запроса. Чтобы сделать это, привязки модели выполняет поиск значения в отправленной формы, значения в сам маршрут и значения строки запроса. Предположим, что найдено значение идентификатора, он преобразуется в целое перед передачей в метод действия.

После привязки модели, но перед вызовом метода действия выполняется проверка модели. Проверка модели использует необязательные атрибуты типа модели и помогут обеспечить соответствие определенным требованиям данных объект заданной модели. Некоторые значения могут быть указаны как необходимые или ограниченные длины или числовой диапазон, и т. д. Если указаны атрибуты проверки, но модель не соответствует их требованиям, свойство ModelState.IsValid будет иметь значение false и набор сбойных правил проверки будет доступен для отправки клиенту, выполняющего запрос.

При использовании проверки модели следует убедиться, что всегда модели выполняется проверка допустимости перед выполнением любые изменения состояния команды, чтобы убедиться, что приложение не повреждены, недопустимые данные. Можно использовать [фильтра](https://docs.microsoft.com/aspnet/core/mvc/controllers/filters) позволяет избежать необходимости, чтобы добавить код для этого в каждом действии. Фильтры MVC ASP.NET Core позволяют перехватывающего группы запросов, таким образом, можно применять на основе целевого общую политики и проблемы пересечения. Фильтры могут применяться для отдельных действий, всего контроллеров или для приложения.

Для веб-API ASP.NET Core MVC поддерживает [ *содержимого согласования*](https://docs.microsoft.com/aspnet/core/mvc/models/formatting), разрешение запросов указать, как следует форматировать ответов. На основании заголовки, предоставляемые в запросе, действия, возвращая данные форматирования ответа в XML, JSON или другом поддерживаемом формате. Эта функция обеспечивает такой же API для использования с различными данными требования к формату несколькими клиентами.

> ### <a name="references--mapping-requests-to-responses"></a>Ссылки — сопоставление запросов для ответов
> - **Маршрутизация в действиях контроллера**
> <https://docs.microsoft.com/aspnet/core/mvc/controllers/routing>
> - **Привязки модели** https://docs.microsoft.com/aspnet/core/mvc/models/model-binding
> - **Проверка модели**
> <https://docs.microsoft.com/aspnet/core/mvc/models/validation>
> - **Фильтры** https://docs.microsoft.com/aspnet/core/mvc/controllers/filters

## <a name="working-with-dependencies"></a>Работа с зависимостями

ASP.NET Core имеет встроенную поддержку и внутренним образом использует подход, называемый [внедрения зависимостей](https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection). Внедрение зависимостей — это методика, которая обеспечивает слабую связь между разными частями приложения. Свободную привязку является предпочтительным, так как он позволяет упростить для изоляции частей приложения, что для тестирования или замены. Кроме того, он менее вероятно, что изменение в одной части приложения будет иметь непредвиденного влияния где-либо еще в приложении. Внедрение зависимостей на основании принципом инверсии зависимостей и часто является достижение принцип открытый/закрытый ключ. При оценке, как приложение работает с зависимостями, учтите, что [статических напечатанными](http://deviq.com/static-cling/) вонь от кода и запоминать aphorism "[новый связующего](http://ardalis.com/new-is-glue).»

Статические напечатанными происходит, когда ваши классы вызывать статические методы или доступ статических свойств, которые имеют побочные эффекты или зависимости от инфраструктуры. Например если у вас есть метод, который вызывает статический метод, который в свою очередь выполняет запись в базу данных, метод тесно связана с базы данных. Все, что разрывы, вызывающих метод базы данных приведет к разрыву метод. Тестирование таких методов — это трудные, поскольку такие тесты необходимы коммерческих имитации библиотеки для макета вызывает статический, либо можно протестировать с тестовую базу данных на месте. Статические вызовы, которые не являются любые зависимость от инфраструктуры, особенно тех, которые не полностью поддерживает состояние, допустимы для вызова и не влияют на соединения или пригодности для тестирования (помимо взаимозависимость код в сам вызов статических).

Многие разработчики понимаете риски статических напечатанными и глобальное состояние, но будет по-прежнему тесно связать свой код для определенных реализаций через прямое создание экземпляров. «Новый связующего» должен быть напоминание такое объединение, а не общие condemnation использование ключевое слово new. Так же, как с помощью вызовов статических методов, новые экземпляры типов, которые не имеют внешних зависимостей обычно не тесно привязать к сведения о реализации кода или затруднить тестирования. Однако каждый раз, когда создается экземпляр класса, просто короткий промежуток времени следует учитывать ли смысл в коде этого конкретного экземпляра в определенном месте или было бы изменить оформление запрашивать этот экземпляр в качестве зависимости.

### <a name="declare-your-dependencies"></a>Объявите зависимостей

ASP.NET Core строится с методы и классы объявите их зависимости, запросив их как аргументы. Приложения ASP.NET обычно настраиваются в классе запуска, который в свою очередь, настроена поддержка внедрения зависимостей в нескольких точках. Если при запуске класс имеет конструктор, его можно запросить через конструктор, следующим образом:

```csharp
public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
        .SetBasePath(env.ContentRootPath)
        .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
        .AddJsonFile(\$"appsettings.{env.EnvironmentName}.json", optional: true);
    }
}
```

Класс Startup представляет интерес, в том, что явный тип требования для него отсутствуют. Он не наследуется от базового класса специальные запуска, а также реализовать любой определенный интерфейс. Ему можно присвоить конструктор, или нет и указать необходимое количество параметров в конструкторе требуется. При запуске веб-узла, настроенному для вашего приложения, он будет вызывать при запуске класса, который вы указано, что для использования и будет использовать внедрения зависимостей для заполнения все зависимости, необходимые для запуска класса. Конечно Если параметры, которые не настроены в контейнере службы, используемые ASP.NET Core запроса, будет вызвано исключение, но при условии, что вы будете использовать зависимости контейнера известны, можно запросить любым способом.

При создании экземпляра запуска внедрения зависимостей встроены в приложения ASP.NET Core с самого начала. Он еще не класса начальной. Можно также запросить зависимостей в метод конфигурации:

```csharp
public void Configure(IApplicationBuilder app,
    IHostingEnvironment env,
    ILoggerFactory loggerFactory)
{

}
```

Метод ConfigureServices является исключением из этого поведения; она должна принимать только один параметр типа IServiceCollection. Он не потребуются для поддержки внедрения зависимостей, так как с одной стороны он отвечает за добавление объектов в контейнере службы, а с другой, он имеет доступ ко всем службам, настроенных через параметр IServiceCollection. Таким образом можно работать с зависимостями, определенным в коллекции служб ASP.NET Core в каждой части класса запуска, запросив необходимые службы, как параметр или при работе с IServiceCollection в ConfigureServices.

> [!NOTE]
> Если требуется обеспечить доступность в класс запуска определенных служб, их можно настроить с помощью WebHostBuilder и его ConfigureServices метода.

Класс запуска — это модель для требуемой структуре других частей приложения ASP.NET Core из контроллеров с по промежуточного слоя, чтобы фильтры для собственных служб. В каждом случае необходимо следовать [явные зависимости принцип](http://deviq.com/explicit-dependencies-principle/), запрашивающего зависимостей, а не непосредственно их создание и использование внедрения зависимостей во всем приложении. Будьте внимательны из где и как можно непосредственно создать экземпляр реализации, особенно службы и объекты, которые работают с инфраструктурой или иметь побочные эффекты. Предпочтение работе с абстрактные классы определены в основные приложения и переданных в качестве аргументов для жесткого задания ссылки на типы конкретной реализации.

## <a name="structuring-the-application"></a>Структурирование приложения

Монолитные приложения обычно имеют одну точку входа. В случае веб-приложения ASP.NET Core точка входа будет веб-проекта ASP.NET Core. Тем не менее, это не означает, что решение должно состоять из одного проекта. Полезно разбить приложение в различные слои, чтобы выполнить разделение областей ответственности. После разбитого на слои, бывает полезно выходит за пределы папки для проектов, которые могут помочь добиться улучшенную инкапсуляцию разделения. Для достижения этих целей с приложением ASP.NET Core лучшим подходом является разновидностью чистой архитектуры, описанных в главе 5. Следующий подход решение приложения будет состоять из отдельных библиотек для пользовательского интерфейса, инфраструктуры и ApplicationCore.

Помимо этих проектах отдельных тестовых проектов включены также (тестирование рассматривается в главе 9).

Объектная модель приложения и интерфейсы должны размещаться в проекте ApplicationCore. Этот проект будет содержать как можно меньшее число зависимостей можно и другие проекты в решении будет ссылаться на него. Бизнес-сущности, которые необходимо сохранить определенные в проекте ApplicationCore, как службы, которые непосредственно не зависящие от инфраструктуры.

Особенности реализации, например, как выполняется сохраняемости или как уведомления могут отправляться пользователю, хранятся в проекте инфраструктуры. Этот проект будет ссылаться на пакеты зависит от реализации, такие как Entity Framework Core, но не должны предоставлять подробные сведения об этих реализаций вне проекта. Репозиториев и службы инфраструктуры, которые должны реализовывать интерфейсы, определенные в проекте ApplicationCore и его реализация сохраняемости отвечают за получение и сохранение сущностей, определенных в ApplicationCore.

Сам проект ASP.NET Core несет ответственность за любые проблемы уровня пользовательского интерфейса, но не должно содержать сведения о компании логики или инфраструктуры. На самом деле в идеальном случае его не следует даже имеют зависимость от проекта инфраструктуры, который поможет обеспечить успешную случайно введен никакой зависимости между двумя проектами. Это можно сделать с помощью сторонних DI контейнера как StructureMap, который позволяет определить правила DI реестра классов в каждом проекте.

Другой подход к отделение приложения от конкретной реализации является микрослужбами вызов приложения, может быть развернут в отдельные контейнеры Docker. Это обеспечивает улучшенное разделение о проблемах и отделение, чем использование DI между двумя проектами, но также имеет дополнительные сложности.

### <a name="feature-organization"></a>Функция организации

По умолчанию приложения ASP.NET Core организовывать их структуру папок для включения контроллеров, представлений и часто ViewModels. Код на стороне клиента для поддержки этих структур серверные отдельно обычно хранится в папке wwwroot. Однако крупных приложений могут возникнуть проблемы с этой организации, поскольку часто работать на любой данной функции требуется переходе между этими папками. Это возвращает более сложность по мере роста числа файлы и вложенные папки из каждой папки приведет к значительные возможности прокрутки с помощью обозревателя решений. Одно из решений этой проблемы является для организации кода приложения с *функция* вместо по тип файла. Этот стиль организации обычно называется папки функций или компонентов фрагментов (см. также: [вертикальные срезы](http://deviq.com/vertical-slices/)).

ASP.NET Core MVC поддерживает областей для этой цели. Использование областей, можно создать отдельные наборы контроллеры и представления папок (а также все связанные модели) в каждой папке области. Рис. 7-1 показан пример структуры папок, использование областей.

![](./media/image7-1.png)

Рис. 7-1 Пример области организации

При использовании области, необходимо использовать атрибуты для оформления контроллеры с имя области, к которому они принадлежат:

```csharp
[Area("Catalog")]
public class HomeController
{}
```

Также необходим для добавления поддержки области свои маршруты.

```csharp
app.UseMvc(routes =>
{
    // Areas support
    routes.MapRoute(
    name: "areaRoute",
    template: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
    routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
});
```

Помимо встроенной поддержки для областей также можно использовать собственные структуры папок и соглашения вместо атрибутов и настраиваемых маршрутов. Это позволит иметь папки функций, которые не были включены отдельные папки для представления, контроллеры, т. д., поддержание иерархии плоское и упрощает для просмотра все связанные файлы в одном месте для каждого компонента.

ASP.NET Core использует соглашение о встроенные типы для управления их поведением. Можно изменить или заменить эти соглашения. Например можно создать соглашение, которое автоматически получают имя компонента для данного контроллера, в зависимости от его пространство имен (который обычно связано с папки, в котором расположен контроллер):

```csharp
FeatureConvention : IControllerModelConvention
{
    public void Apply(ControllerModel controller)
    {
        controller.Properties.Add("feature",
        GetFeatureName(controller.ControllerType));
    }

    private string GetFeatureName(TypeInfo controllerType)
    {
        string[] tokens = controllerType.FullName.Split('.');
        if (!tokens.Any(t => t == "Features")) return "";
        string featureName = tokens
        .SkipWhile(t => !t.Equals("features",
        StringComparison.CurrentCultureIgnoreCase))
        .Skip(1)
        .Take(1)
        .FirstOrDefault();
        return featureName;
    }
}
```

Затем указываются это соглашение в качестве альтернативы после добавления поддержки для MVC в ConfigureServices приложение.

```csharp
services.AddMvc(o => o.Conventions.Add(new FeatureConvention()));
```

ASP.NET Core MVC также используется соглашение для поиска представления. Его можно переопределить с помощью пользовательского соглашения, чтобы представления будет находиться в папках функции (с помощью имя функции, предоставляемые FeatureConvention выше). Можно узнать больше об этом подходе и загрузить рабочий образец из статьи MSDN [фрагментов функции для ASP.NET Core MVC](https://msdn.microsoft.com/magazine/mt763233.aspx).

### <a name="cross-cutting-concerns"></a>Проблемы пересечения

По мере роста приложения становится все более важными вынести решении общих задач, чтобы избежать дублирования и поддержания согласованности. Некоторые примеры перекрестными проблемы в приложениях ASP.NET Core, проверки подлинности, правила проверки модели, кэширование вывода и обработки ошибок, хотя и существуют многие другие. ASP.NET Core MVC [фильтры](https://docs.microsoft.com/aspnet/core/mvc/controllers/filters) позволяют выполнять код до или после определенных действий в конвейер обработки запросов. Например фильтр можно запустить до и после привязки модели, до и после действия, или перед и после результата действия. Также можно использовать фильтр авторизации для управления доступом к оставшуюся часть конвейера. Рисунки 7-2 показывает способ запроса выполнения потоков фильтры, если настроен.

![Запрос обрабатывается через фильтры авторизации, фильтры ресурсов, привязки модели, фильтры действий, выполнение действия и преобразование результата действия, фильтры исключений, фильтры результатов и результат выполнения. На способ ожидания запрос только обрабатывается результат фильтры и фильтры ресурсов перед тем как стать ответ, отправляемый клиенту.](./media/image7-2.png)

Выполнение запроса на рис. 7-2 через фильтры и конвейер обработки запросов.

Фильтры обычно реализуются как атрибуты, поэтому их можно применить контроллеров или действий. При добавлении таким образом, указанные на переопределение уровня действия или сборки после фильтров, определенных на уровне контроллера, фильтры какие сами переопределить глобальные фильтры. Например \[маршрута\] атрибут может использоваться для создания маршрутов, контроллеров и действий. Аналогично авторизации можно настроить на уровне контроллера и затем переопределить с помощью отдельных действий, как показано в следующем образце:

```csharp
[Authorize]
public class AccountController : Controller

{
    [AllowAnonymous]
    public async Task<IActionResult> Login() {}
    public async Task<IActionResult> ForgotPassword() {}
}
```

Первый метод, имени входа, использует фильтр AllowAnonymous (атрибут) для переопределения фильтра авторизации на уровне контроллера. Действие забыт пароль (и другие действия в классе, который не имеет атрибута AllowAnonymous) потребуется запрос с проверкой подлинности.

Можно использовать фильтры для исключения дублирования в форме распространенной ошибкой обработки политики для API-интерфейсов. Например типичный политики API является возврат NotFound ответа на запросы, ссылающиеся на ключи, которые не существуют, а ответ неправильный запрос при сбое проверки модели. В следующем примере демонстрируется эти две политики в действии:

```csharp
[HttpPut("{id}")]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    if ((await _authorRepository.ListAsync()).All(a => a.Id != id))
    {
        return NotFound(id);
    }
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    author.Id = id;
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

Запретить использование определенных методов действия для становятся переполнения условного кода следующим образом. Вместо этого опроса политики в фильтры, которые могут применяться по мере необходимости. В этом примере проверки модели, которой должно выполняться каждый раз, когда отправляется команда API, можно заменить следующий атрибут:

```csharp
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(context.ModelState);
        }
    }
}
```

Аналогичным образом фильтр можно использовать для проверки, если запись существует и возвращать код 404, перед выполнением действия, устраняя необходимость выполнения этих проверок при выполнении действия. После бы извлечено из общих соглашений и организованных решения для разделения инфраструктуры кода и бизнес-логики в пользовательском Интерфейсе, должен быть чрезвычайно тонкого свои методы действия MVC:

```csharp
// PUT api/authors/2/5
[HttpPut("{id}")]
[ValidateAuthorExists]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

Дополнительные сведения о реализации фильтры и загрузить рабочий образец из статьи MSDN [фильтров ASP.NET MVC Core реальные World](https://msdn.microsoft.com/magazine/mt767699.aspx).

> ### <a name="references--structuring-applications"></a>Ссылки — структуризации приложений
> - **Области**  
> <https://docs.Microsoft.com/ASPNET/Core/MVC/Controllers/Areas>
> - **MSDN — функция срезов для основных компонентов ASP.NET MVC**
>  <https://msdn.microsoft.com/magazine/mt763233.aspx>
> - **Фильтры**  
> <https://docs.Microsoft.com/ASPNET/Core/MVC/Controllers/filters>
> - **MSDN — фильтры MVC ASP.NET Core реального мира**  
> <https://MSDN.Microsoft.com/magazine/mt767699.aspx>

## <a name="security"></a>Безопасность

Обеспечение безопасности веб-приложений — большой раздел, с множеством факторов. На самом базовом уровне безопасности предполагает, что вы знаете, кто из указанного запроса и затем гарантирует, что этот запрос имеет доступ только к ресурсам, которые следует. Проверка подлинности — это процесс сравнения учетные данные, предоставленные вместе с запросом тем в хранилище доверенных данных, чтобы увидеть, если запрос должны рассматриваться как поступающие от известных сущности. Авторизация является процессом, ограничения доступа к определенным ресурсам, на основе удостоверения пользователя. Третий угроза безопасности обеспечивает защиту запросы от перехвата сторонними производителями, для которых следует [убедитесь, что SSL используется приложением](https://docs.microsoft.com/aspnet/core/security/enforcing-ssl).

### <a name="authentication"></a>Проверка подлинности

Удостоверение ASP.NET Core является система членства, которые можно использовать для поддержки функциональных возможностей входа для приложения. Он имеет поддержку для локальных учетных записей пользователей, а также поддержка поставщика внешнего входа поставщиков, как учетную запись Майкрософт, Twitter, Facebook, Google и многое другое. В дополнение к ASP.NET Core Identity, приложение может использовать проверку подлинности windows или как поставщик удостоверений сторонних [удостоверение сервера](https://github.com/IdentityServer/IdentityServer4).

Удостоверение ASP.NET Core включается в новые шаблоны проектов, если выбран параметр отдельных учетных записей пользователей. Этот шаблон включает поддержку регистрации, имя входа, внешних имен входа, забытые пароли и дополнительные функциональные возможности.

![](./media/image7-3.png)

Рис. 7-3 выберите отдельные учетные записи пользователей идентификацией предварительно настроен.

Поддержка удостоверений настраивается при запуске в ConfigureServices и настроить:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();
    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();
    app.UseIdentity();
    app.UseMvc(routes =>
    {
        routes.MapRoute(
        name: "default",
        template: "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Очень важно, что UseIdentity отображаются перед UseMvc метод конфигурации. При настройке удостоверения в ConfigureServices, вы заметите, что вызов AddDefaultTokenProviders. Это никак не связано с маркерами, которые могут использоваться для защиты веб-соединений, но вместо относится к поставщикам, которые создают запросы, которые могут быть отправлены пользователям с помощью SMS или по электронной почте для них, чтобы подтвердить свою личность.

Дополнительные сведения о [настройки двухфакторной проверки подлинности](https://docs.microsoft.com/aspnet/core/security/authentication/2fa) и [Включение поставщиков внешнего входа](https://docs.microsoft.com/aspnet/core/security/authentication/social/) из официальных документы ASP.NET Core.

### <a name="authorization"></a>Авторизация

Самая простая форма авторизации включает в себя ограничение доступа для анонимных пользователей. Это можно сделать путем применения просто \[авторизовать\] атрибут определенных контроллеров или действий. При использовании ролей атрибут можно дополнительно расширить для ограничения доступа к пользователям, принадлежащим к определенных ролей, как показано:

```csharp
[Authorize(Roles = "HRManager,Finance")]
public class SalaryController : Controller
{

}
```

В этом случае пользователи, принадлежащие роли HRManager или процент (или оба) будет иметь доступ к SalaryController. Требуется пользователь принадлежит нескольким ролям (не в одной из нескольких), можно применить атрибут несколько раз, указав необходимые роли каждый раз.

Укажите определенные наборы ролей, как строки во многих различных контроллеров и действий может привести к нежелательным повторения. Можно настроить политики авторизации, который инкапсулирует правила авторизации, и затем указать политику вместо отдельных ролей при применении \[авторизовать\] атрибута:

```csharp
[Authorize(Policy = "CanViewPrivateReport")]
public IActionResult ExecutiveSalaryReport()
{
    return View();
}
```

С помощью политик таким образом, можно разделить типы действий будет закрыт с конкретными ролями или правила, которые применяются к нему. Позже, при создании новой роли, которая должна иметь доступ к определенным ресурсам, можно просто обновить политику, а не обновлять каждый список ролей на каждый \[авторизовать\] атрибута.

#### <a name="claims"></a>Утверждения

Утверждения — это пары имя-значение, представляющих свойства, прошедшего проверку подлинности пользователя. Например можно хранить как утверждения пользователей сотрудника. Утверждения могут затем использоваться как часть политики авторизации. Можно создать политику, называется «EmployeeOnly», требует наличия заявку под названием «Внутри открывающего», как показано в следующем примере:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddAuthorization(options =>
    {
        options.AddPolicy("EmployeeOnly", policy => policy.RequireClaim("EmployeeNumber"));
    });
}
```

Затем можно использовать эту политику с \[авторизовать\] атрибут, чтобы защитить любой контроллер или действие, как описано выше.

#### <a name="securing-web-apis"></a>Обеспечение безопасности веб-API

Большинство веб-API должен реализовывать системы проверки подлинности на основе маркеров. Маркер проверки подлинности без сохранения состояния и разработаны для масштабируемости. В системе токены проверки подлинности клиент должен сначала пройти проверку подлинности с поставщиком проверки подлинности. В случае успеха клиент выдает маркер, который представляет собой криптографически значимых строку символов. Когда клиенту необходимо отправить запрос к API, он добавляет этот токен как заголовок запроса. Затем сервер проверяет токен, найденный в заголовке запроса до завершения запроса. Рис. 7-4 показан этот процесс.

![TokenAuth](./media/image7-4.png)

**Рис. 7-4.** Токены проверки подлинности для веб-API.

> ### <a name="references--security"></a>Ссылки — безопасности
> - **Обзор документации о безопасности**  
> https://docs.Microsoft.com/ASPNET/Core/Security/
> - **Применение протокола SSL в приложении ASP.NET Core**  
> <https://docs.Microsoft.com/ASPNET/Core/Security/enforcing-SSL>
> - **Общие сведения об Identity**  
> <https://docs.Microsoft.com/ASPNET/Core/Security/Authentication/IDENTITY>
> - **Общие сведения об авторизации**  
> <https://docs.Microsoft.com/ASPNET/Core/Security/Authorization/Introduction>
> - **Проверка подлинности и авторизация для приложений API в службе приложений Azure**  
> <https://docs.Microsoft.com/Azure/App-Service-API/App-Service-API-Authentication>

## <a name="client-communication"></a>Взаимодействие с клиентскими

Помимо пересылкой страницы и отвечает на запросы к данным через веб-API, приложения ASP.NET Core могут взаимодействовать напрямую с подключенными клиентами. Это исходящей связи можно использовать широкий набор технологий транспорта наиболее распространенные выполняется WebSockets. SignalR ASP.NET Core — это библиотека, облегчающий, какие функции обмена данными в режиме реального времени сервер клиент в приложения. SignalR поддерживает широкий набор технологий транспорта, включая WebSockets и выделяет дальней многие детали реализации разработчика.

ASP.NET Core SignalR в настоящее время находится в стадии разработки и будет доступна в следующем выпуске ASP.NET Core. Однако другие [откройте библиотеки исходного WebSockets](https://github.com/radu-matei/websocket-manager) в настоящее время доступны.

Соединения с клиентом в режиме реального времени, ли использование WebSockets напрямую и другие методы полезны в различных сценариях приложений. Ниже приведены некоторые примеры таких ситуаций.

-   Приложения динамической комнаты чата

-   Мониторинг приложений

-   Обновления хода выполнения задания

-   Уведомления

-   Интерактивные формы приложения

При создании связи с клиентами в приложения, обычно существуют два компонента:

-   Диспетчер соединений серверные (концентратора SignalR, WebSocketManager WebSocketHandler)

-   Клиентская библиотека

Клиенты не ограничиваются браузеров — мобильных приложений, консольные приложения и других встроенных приложений может также обмениваться данными с использованием SignalR/WebSockets. Следующая простая программа отображает все содержимое, отправляемое приложения разговора в консоль как часть примера приложения WebSocketManager:

```csharp
public class Program
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();
        _connection.On("receiveMessage", (arguments) =>;
        {
            Console.WriteLine(\$"{arguments\[0\]} said: {arguments\[1\]}");
        });
        Console.ReadLine();
        StopConnectionAsync();
    }
    
    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync("ws://localhost:65110/chat");
    }
    
    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
```

Рассмотрите возможность столкнуться способами, в которых приложения взаимодействуют непосредственно с клиентскими приложениями и рассмотрите возможность ли обмен данными в реальном времени позволяет улучшить пользователя приложения.

> ### <a name="references--client-communication"></a>Ссылки — обмена данными с клиентами
> - **ASP.NET Core SignalR**  
> <https://github.com/ASPNET/SignalR>
> - **Диспетчер WebSocket**  
> https://github.com/radu-matei/WebSocket-Manager

## <a name="domain-driven-design--should-you-apply-it"></a>Домен Driven Design – следует применить ее?

Разработки на основе домена (DDD) является гибкий подход к разработке программного обеспечения, особое внимание уделяется сосредоточиться на *бизнес-среде*. Он помещает серьезный акцент на связь и взаимодействие с expert(s) домена предприятия, можно связать со разработчики, как работает система реального мира. Например при создании системе обработки биржевых руки, специалист домена может быть опытным биржевых брокера. DDD предназначен для больших и сложных бизнес-задач и часто не подходит для приложений, меньшие, более простые, как инвестиции в понимании и моделирования домена не стоит.

При разработке программного обеспечения подходе ддд, команда (включая нетехнических заинтересованных лиц и участников) следует разработать *единый язык* для проблемной области. То есть тот же термин следует использовать для реальных понятие моделируемого, эквивалент программного обеспечения и все структуры, которые могут существовать для сохранения понятие (например, таблицы базы данных). Таким образом, основные понятия, описанные в единый язык должен образуют основу для вашего *модель домена*.

Модель домена состоит из объектов, которые взаимодействуют друг с другом для представления поведение системы. Эти объекты могут делятся на следующие категории:

-   [Сущности](http://deviq.com/entity/), которые представляют объекты с потоком удостоверения. Обычно сущности сохраняются в сохраняемости с помощью ключа, с помощью которого их можно извлечь.

-   [Статистические функции](http://deviq.com/aggregate-pattern/), которые представляют группы объектов, которые следует сохранять как единое целое.

-   [Значение объектов](http://deviq.com/value-object/), которые представляют основные понятия, которые можно сравнивать на основе суммы значений их свойств. Например, DateRange, состоящая из даты начала и окончания.

-   [События домена](https://martinfowler.com/eaaDev/DomainEvent.html), которые представляют происходит в системе вещей, которые представляют интерес в другие части системы.

Обратите внимание, что модель домена DDD следует инкапсулировать сложное поведение в модели. Сущности, в частности, не следует просто коллекции свойств. Модель домена не имеет поведения, а просто представляет состояние системы, он считается [anemic модели](http://deviq.com/anemic-model/), что нежелательно в ддд.

Помимо этих типов модели DDD обычно применяет разнообразные шаблоны:

-   [Репозиторий](http://deviq.com/repository-pattern/), абстракцию сохраняемости сведения.

-   [Фабрика](https://en.wikipedia.org/wiki/Factory_method_pattern), для инкапсуляции создания сложных объектов.

-   События домена для разделения зависимых поведение срабатывания поведение.

-   [Службы](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/), для инкапсуляции сложной поведение и/или сведения о реализации инфраструктуры.

-   [Команда](https://en.wikipedia.org/wiki/Command_pattern), для разделения выполнения команд и выполнении саму команду.

-   [Спецификация](http://deviq.com/specification-pattern/), для инкапсуляции сведения о запросе.

DDD также даются рекомендации по использованию чистой архитектуры, описанные ранее, что обеспечивает слабую связь, инкапсуляцию и кода, которые легко могут быть проверены с помощью модульных тестов.

### <a name="when-should-you-apply-ddd"></a>Когда вы применяете DDD

DDD хорошо подходит для больших приложений с сложности значительные бизнеса (не только о технических). Приложение должно требует знания специалистами в предметной области. Должна существовать значительные возможности в домене самой модели, представляющий бизнес-правил и взаимодействия за пределами просто хранения и получения текущего состояния различных записей из хранилищ данных.

### <a name="when-shouldnt-you-apply-ddd"></a>Когда не следует применять DDD

DDD подразумевает вложений для моделирования, архитектура и взаимодействие, не следует провести для небольших приложений или приложений, которые по сути являются просто CRUD (Создание и чтение, обновление и удаление). Если вы решили подход приложения после ддд, но обнаруживается модель anemic с нет поведения домена, может потребоваться пересмотреть подхода. Приложение не должно DDD либо обратитесь за помощью, рефакторинг для инкапсуляции бизнес-логики в модель домена, а не в вашей базе данных или в пользовательском интерфейсе приложения.

Гибридный подход следует использовать DDD только для области транзакций или более сложные приложения, но не для простой CRUD или частей приложения только для чтения. Для экземпляра не имеют ограничения статистической обработки, если выполняется запрос данных для отображения отчета или чтобы визуализировать данные для панели мониторинга. Это вполне приемлемо, чтобы отдельные, более простые чтения модели для таких требований.

> ### <a name="references--domain-driven-design"></a>Ссылки — разработки на основе домена
> - **DDD на английском (StackOverflow ответов)**  
> <https://StackOverflow.com/questions/1222392/CAN-someone-Explain-Domain-Driven-Design-ddd-in-plain-English-Please/1222488#1222488>

## <a name="deployment"></a>Развертывание

Существуют несколько шагов, участвующих в процессе развертывания приложения ASP.NET Core, независимо от того, где будет размещен. Первым шагом является публикация приложения, это можно сделать с помощью dotnet опубликовать команду CLI. Это будет выполняться компиляция приложения и поместить все файлы, необходимые для запуска приложения в указанной папки. При развертывании из Visual Studio, этот шаг выполняется автоматически. Папки публикации файлы .exe и .dll для приложения и его зависимостей. Автономные приложения также будет содержать версию среды выполнения .NET. Файлы конфигурации, средства статического клиента и представления MVC также входят приложения ASP.NET Core.

Приложения ASP.NET Core являются консольными приложениями, которые должны быть запущены при загрузке сервера и перезапускается, если приложения (или сервера) аварийно завершает работу. Диспетчер процессов можно использовать для автоматизации этого процесса. Наиболее распространенные менеджеров процесса ASP.NET Core являются Nginx и Apache на IIS и Linux или службы Windows в Windows.

Кроме диспетчер процессов размещенных на веб-сервере Kestrel приложений ASP.NET Core необходимо использовать обратного прокси-сервера. Обратный прокси-сервер получает запросы HTTP из Интернета и пересылает их Kestrel после некоторой предварительной обработки. Обратного прокси-серверов Укажите уровень безопасности для приложения и необходимые для развертываний edge (открытый для трафика из Интернета). Kestrel является относительно новым и еще не обеспечивают защиту от определенных атак. Kestrel также не поддерживает размещение нескольких приложений на один и тот же порт, поэтому такие методы, как заголовки узлов не может использоваться с ним для параллельного размещения нескольких приложений на тот же порт и IP-адрес.

![Kestrel для Интернета](./media/image7-5.png)

Рис ASP.NET, размещенных в Kestrel за обратного прокси-сервера

Другой сценарий, в котором обратного прокси-сервера может оказаться полезным является защита нескольких приложений с помощью SSL или HTTPS. В этом случае только обратного прокси-сервера необходимо иметь SSL настроен. Обмен данными между обратного прокси-сервера и Kestrel может выполняться по протоколу HTTP, как показано на рисунке 7-6.

![](./media/image7-6.png)

Рис ASP.NET, размещенных за защитой HTTPS обратного прокси-сервер с

Для размещения приложения ASP.NET Core в контейнере Docker, который затем может быть размещена локально или развертывания в Azure для размещения облачной является более популярным подходом. Контейнер Docker могут содержать код приложения, запущенного на Kestrel и будет разворачиваться за обратного прокси-сервера, как показано выше.

Если вы используете приложение в Azure, можно использовать как выделенное виртуальное устройство шлюза приложения Microsoft Azure для предоставления нескольких служб. Помимо выступает в качестве обратного прокси-сервера для отдельных приложений, шлюз приложений также предлагает следующие возможности:

-   Балансировки нагрузки HTTP

-   Разгрузка SSL (SSL только для Интернета)

-   Сквозная SSL

-   Маршрутизация несколькими сайтами (консолидировать до 20 узлов на один шлюз приложения)

-   Брандмауэр веб-приложения

-   Поддержка WebSocket

-   Дополнительной диагностики

*Дополнительные сведения о параметрах развертывания Azure в главе 10.*

> ### <a name="references--deployment"></a>Ссылки — развертывания
> - **Размещение и общие сведения о развертывании**  
> <https://docs.Microsoft.com/ASPNET/Core/Publishing/>
> - **Когда следует использовать Kestrel с обратного прокси-сервера**  
> <https://docs.Microsoft.com/ASPNET/Core/Fundamentals/Servers/kestrel#When-to-Use-kestrel-with-a-Reverse-Proxy>
> - **Узел приложения ASP.NET Core в Docker**  
> <https://docs.Microsoft.com/ASPNET/Core/Publishing/docker>
> - **Знакомство с приложением шлюза приложения Azure**  
> <https://docs.Microsoft.com/Azure/Application-Gateway/Application-Gateway-Introduction>

>[!div class="step-by-step"]
[Предыдущие] (Общие клиент стороны web-technologies.md) [Далее] (work-with-data-in-asp-net-core-apps.md)
