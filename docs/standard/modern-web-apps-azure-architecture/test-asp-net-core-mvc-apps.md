---
title: Тестирование приложений MVC ASP.NET Core
description: Разработка современных веб-приложений с помощью ASP.NET Core и Azure | Тестирование приложений MVC ASP.NET Core
author: ardalis
ms.author: wiwagn
ms.date: 10/08/2017
ms.openlocfilehash: b22e0e109144b4abd04cd4199cfdec244d8fa7af
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106506"
---
# <a name="test-aspnet-core-mvc-apps"></a>Тестирование приложений MVC ASP.NET Core

> _"Если вы не хотите выполнять модульное тестирование своего продукта, ваши заказчики также вряд ли захотят делать это"._
>  _-Аноним-_

## <a name="summary"></a>Сводка

В ответ на изменения в программном обеспечении любой сложности могут возникать самые непредвиденные ошибки. Соответственно, после внесения изменений для любых приложений, за исключением самых простых или наименее важных, необходимо проводить тестирование. Тестирование вручную является самым медленным, наименее надежным и наиболее дорогим способом проверить программное обеспечение. К сожалению, если возможность тестирования не заложена в приложение на этапе проектирования, это может быть единственный доступный способ. Приложения, при написании которых соблюдались изложенные в главе X архитектурные принципы, а также приложения ASP.NET Core поддерживают автоматические интеграционные и функциональные тесты.

## <a name="kinds-of-automated-tests"></a>Виды автоматических тестов

Существует множество различных автоматических тестов приложений. Самым простым низкоуровневым подходом является модульное тестирование. Чуть выше уровнем располагаются интеграционные и функциональные тесты. В этом документе не описываются другие виды тестирования, в том числе тесты пользовательского интерфейса, нагрузочные тесты и тесты на принятие сборки.

### <a name="unit-tests"></a>Модульные тесты

В рамках модульного теста проверяется отдельная часть логики вашего приложения. Проще описать те возможности, которые не реализует модульное тестирование. Модульный тест не позволяет проверить работу кода с зависимостями или инфраструктурой, для чего предназначены интеграционные тесты. Модульный тест не позволяет проверить платформу, на которой написан код. Если возникают ошибки такого рода, следует отправить соответствующий отчет и написать код для обходного решения проблемы. Модульный тест выполняется полностью в памяти и внутри процесса. Он не взаимодействует с файловой системой, сетью или базой данных. Модульные тесты предназначены исключительно для тестирования кода.

Поскольку модульные тесты проверяют только один блок кода без каких-либо внешних зависимостей, они должны выполняться предельно быстро. Таким образом, набор из нескольких сотен модульных тестов может быть выполнен буквально за пару секунд. Модульные тесты следует выполнять как можно чаще, в идеальном случае перед каждой отправкой в общий репозиторий системы управления версиями и в обязательном порядке перед каждой автоматизированной сборкой на сервере сборки.

### <a name="integration-tests"></a>Интеграционные тесты

Несмотря на рекомендации по инкапсуляции кода, который взаимодействует с такими инфраструктурами, как базы данных и файловые системы, в некоторых случаях такой код все же используется и требует тестирования. Кроме того, вам необходимо проверить корректность взаимодействия между слоями вашего кода после того, как будут полностью разрешены все зависимости приложения. Для этой цели используются интеграционные тесты. Интеграционные тесты выполняются дольше и требуют более тщательной настройки по сравнению с модульными, поскольку они часто полагаются на внешние зависимости и инфраструктуры. В связи с этим по возможности не следует проверять с помощью интеграционных тестов то, что может быть проверено посредством модульных тестов. Если конкретный сценарий можно проверить с помощью модульного теста, необходимо сделать именно так. Если это невозможно, тогда попробуйте прибегнуть к интеграционному тестированию.

Процедуры настройки и уничтожения интеграционных тестов обычно гораздо более сложны по сравнению с модульными тестами. Например, после выполнения интеграционного теста в отношении реальной базы данных необходимо предусмотреть способ возврата базы в известное состояние, которое было до начала тестирования. С развитием новых тестов, добавляемых в схему рабочей базы данных, возрастает размер и степень сложности таких тестовых скриптов. Во многих крупных системах практически нецелесообразно выполнять полный набор интеграционных тестов на рабочих станциях разработчиков перед возвратом изменений в общую систему управления версиями. В таких случаях интеграционные тесты могут выполняться на сервере сборки.

Класс реализации LocalFileImageService реализует логику получения и возврата байтов файла изображения из конкретной папки по заданному идентификатору:

```csharp
public class LocalFileImageService : IImageService
{
    private readonly IHostingEnvironment _env;
    public LocalFileImageService(IHostingEnvironment env)
    {
        _env = env;
    }
    public byte[] GetImageBytesById(int id)
    {
        try
        {
            var contentRoot = _env.ContentRootPath + "//Pics";
            var path = Path.Combine(contentRoot, id + ".png");
            return File.ReadAllBytes(path);
        }
        catch (FileNotFoundException ex)
        {
            throw new CatalogImageMissingException(ex);
        }
    }
}
```

### <a name="functional-tests"></a>Функциональные тесты

Интеграционные тесты позволяют проверить корректность совместной работы нескольких компонентов системы с точки зрения разработчика. В отличие от них, функциональные тесты позволяют проверить соответствие системы требованиям с точки зрения пользователя. В следующей цитате приводится наглядная аналогия, позволяющая сравнить функциональные и модульные тесты:

> "Разработку системы уже не раз сравнивали с возведением дома. И хотя это не совсем корректно, на базе этой аналогии мы можем понять разницу между модульным и функциональным тестированием. Модульное тестирование похоже на посещение строительной площадки инспектором. Он проверяет различные внутренние системы дома, его фундамент, несущие конструкции, электрические и сантехнические сети, а также множество других компонентов. Таким образом, инспектор проверяет (тестирует) безопасность всех частей дома и их соответствие строительным нормам. В этом контексте функциональные тесты можно сравнить с визитом владельца дома. Он справедливо полагает, что все внутренние системы были проверены инспектором и, соответственно, функционируют в соответствии с предназначением. Сам же владелец при этом будет сосредоточен на том, чтобы проверить, насколько комфортно ему будет жить в новом доме. Он будет проверять внешний вид дома, размер его комнат, соответствие дома потребностям семьи и даже то, не будет ли его в дальнейшем беспокоить утренний свет, попадающий в окна. Таким образом, владелец дома проводит функциональное тестирование своего жилища. Важно понимать, что он делает это с точки зрения пользователя. Инспектор осуществляет модульное тестирование. Иными словами, он проверяет дом с точки зрения строителя".

Источник: [Сравнение модульного и функционального тестирования](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)

Мне очень нравится следующее выражение: "Как разработчики мы совершаем две главных ошибки: мы создаем вещи неправильно и мы создаем неправильные вещи". С помощью модульных тестов мы можем убедиться в том, что создаем вещи правильно. Функциональное тестирование позволяет проверить, что мы создаем правильные вещи.

Поскольку функциональные тесты выполняются на уровне системы, для них может потребоваться определенная степень автоматизации пользовательского интерфейса. Как и интеграционные тесты, они обычно имеют дело с определенного вида тестовой инфраструктурой. Это делает их еще более медленными и нестабильными по сравнению с модульными и интеграционными тестами. Поэтому необходимо использовать ровно столько функциональных тестов, сколько нужно для того, чтобы гарантировать функционирование системы в соответствии с требованиями пользователя.

### <a name="testing-pyramid"></a>Пирамида тестирования

Мартин Фаулер (Martin Fowler) описал пирамиду тестирования, пример которой показан на рис. 9-1.

![](./media/image9-1.png)

Рис. 9-1. Пирамида тестирования

Уровни пирамиды и их относительный размер описывают различные виды тестов и их количество, необходимое для проверки приложения. Как видно из рисунка, в качестве фундамента рекомендуется брать большое количество модульных тестов, поверх которого проводится меньшее число интеграционных тестов. Венчает же пирамиду малочисленный уровень функциональных тестов. В идеале каждый уровень должен содержать только те тесты, которые невозможно выполнить надлежащим образом на более низком уровне. При выборе теста, который будет выполняться в каждом конкретном сценарии, помните о пирамиде тестирования.

### <a name="what-to-test"></a>Что следует проверить

Разработчики, не имеющие достаточного опыта в написании автоматических тестов, часто сталкиваются с проблемой выбора того, что следует проверять. Для начала рекомендуется проверить условную логику. Везде, где у вас используется метод, поведение которого изменяется в зависимости от значения условного выражения (if-else, switch и т. д.), следует проводить хотя бы пару тестов, проверяющих корректность поведения при различных условиях. Если в коде используются условия ошибки, следует написать как минимум один тест для безошибочного прохождения кода и хотя бы один для выполнения кода с ошибками или нетипичными результатами. Это позволит проверить корректность работы приложения при возникновении ошибок. Наконец, попробуйте сосредоточиться на том, что может пойти не по сценарию, и не зацикливайтесь на таких показателях, как объем протестированного кода. Тем не менее в большинстве случаев рекомендуется протестировать как можно больший объем кода. И все же часто лучше потратить больше времени на написание нескольких тестов для сложного критически важного метода, чем многократно проверять автоматические свойства только для того, чтобы увеличить объем протестированного кода.

## <a name="organizing-test-projects"></a>Упорядочение тестовых проектов

Вы можете упорядочивать тестовые проекты так, как это удобно вам. В качестве общей рекомендации можно посоветовать разделять тесты по виду (модульные, интеграционные) и по тому, что они проверяют (проект, пространство имен). Будут ли для этого применяться папки в рамках одного тестового проекта или потребуется несколько тестовых проектов, зависит от структуры решения. Работать с одним проектом проще, однако для крупных проектов с множеством тестов или для удобства выполнения различных наборов тестов вы можете использовать несколько тестовых проектов. Многие команды упорядочивают тестовые проекты на основе проверяемых проектов. В этом случае для приложений с достаточно большим числом проектов может получиться слишком много тестовых проектов, особенно если для каждого из них осуществляется разбиение по виду теста. В качестве компромисса можно использовать подход с одним проектом для каждого вида теста для каждого приложения. В этом случае проверяемые проекты и классы будут определяться с помощью папок внутри тестовых проектов.

Типовой подход предполагает размещение проектов приложения в папке src, а тестовых проектов — в параллельной папке tests. Если это покажется вам более удобным, вы можете создать соответствующие папки решений в Visual Studio.

![](./media/image9-2.png)

Рис. 9-2. Упорядочение тестов для решения

Вы можете использовать любую предпочитаемую платформу тестирования. Эффективным решением является платформа xUnit, на которой пишутся все тесты для ASP.NET Core и EF Core. Вы можете добавить тестовый проект xUnit в Visual Studio, используя показанный на рис. 9-3 шаблон или через интерфейс командной строки с помощью команды dotnet new xunit.

![](./media/image9-3.png)

Рис. 9-3. Добавление тестового проекта xUnit в Visual Studio

### <a name="test-naming"></a>Присвоение имен тестам

Тестам следует присваивать единообразные имена, которые указывают на выполняемые ими задачи. Я могу порекомендовать успешно проверенный на практике подход, при котором имена тестовых классов задаются на основе проверяемого ими класса и метода. В этом случае получается множество небольших тестовых классов, однако можно легко определить, для чего предназначен каждый из них. Таким образом, имена тестовых классов определяют проверяемый класс и метод. С помощью имени тестового метода можно указать, какое поведение он проверяет. Это имя должно определять ожидаемое поведение, а также любые принимаемые входные данные и допущения. Примеры имен тестов:

- CatalogControllerGetImage.CallsImageServiceWithId

- CatalogControllerGetImage.LogsWarningGivenImageMissingException

- CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess

- CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException

В качестве варианта можно добавить в конец имени тестового класса слово "Should" (Должен) и слегка изменить формулировку:

- CatalogControllerGetImage**Should**.**Call**ImageServiceWithId

- CatalogControllerGetImage**Should**.**Log**WarningGivenImageMissingException

Некоторые разработчики считают второй подход более понятным, несмотря на более длинные имена. В любом случае постарайтесь выбрать соглашение об именовании, которое позволит легко определять поведение теста. Благодаря этому в случае неудачного завершения одного или нескольких тестов вы сможете легко определить, что именно не удалось сделать. Не рекомендуется присваивать тестам слишком размытые имена, например ControllerTests.Test1, поскольку по ним вы не сможете определить, на что указывают результаты теста.

Если вы используете одно из описываемых выше соглашений об именовании, в результате чего получаете множество небольших тестовых классов, рекомендуется упорядочить тесты по папкам и пространствам имен. На рис. 9-4 показан возможный подход к упорядочению тестов по папкам в рамках нескольких тестовых проектов.

![](./media/image9-4.png)

**Рис. 9-4.** Упорядочение тестовых классов по папкам на основе проверяемых классов.

Безусловно, если конкретный класс приложения содержит много проверяемых методов (и, соответственно, много тестовых классов), может быть удобно поместить их в папку, соответствующую классу приложения. Такой подход аналогичен упорядочению обычных файлов в папках. Если в папке, содержащей множество файлов, присутствует больше трех или четырех связанных файлов, их зачастую рекомендуется перенести в отдельную вложенную папку.

## <a name="unit-testing-aspnet-core-apps"></a>Модульное тестирование приложений ASP.NET Core

В грамотно спроектированном приложении ASP.NET Core большая часть сложных функций и бизнес-логики инкапсулируется в бизнес-сущностях и различных службах. Таким образом, само приложение MVC ASP.NET Core со всеми его контроллерами, фильтрами, моделями представлений и представлениями должно требовать минимального количества модульных тестов. Большая часть функционала конкретного действия выполняется за пределами самого метода действия. Модульные тесты не позволяют эффективно проверить корректность маршрутизации или глобальной обработки ошибок. Кроме того, модульное тестирование не позволяет проверить какие-либо фильтры, в том числе применяемые для подтверждения, проверки подлинности и авторизации. Без этих источников реакции на события большинство методов действия будут иметь небольшой размер, поскольку они делегируют основную часть выполняемых задач службам, которые могут быть протестированы независимо от использующего их контроллера.

В некоторых случаях, чтобы провести модульное тестирование кода, требуется выполнить его рефакторинг. Зачастую для этого требуется определить абстракции и использовать внедрение зависимостей для доступа к абстракции в коде, который требуется протестировать, вместо того, чтобы писать код непосредственно для работы с инфраструктурой. Например, рассмотрим простой метод действия для показа изображений:

```csharp
[HttpGet("[controller]/pic/{id}")]
public IActionResult GetImage(int id)
{
    var contentRoot = _env.ContentRootPath + "//Pics";
    var path = Path.Combine(contentRoot, id + ".png");
    Byte[] b = System.IO.File.ReadAllBytes(path);
    return File(b, "image/png");
}
```

Модульное тестирование этого метода затруднено из-за наличия прямой зависимости от System.IO.File, который используется для чтения из файловой системы. Вы можете проверить корректность поведения этого метода, однако для тестирования работы с реальными файлами вам потребуются интеграционные тесты. Следует отметить, что вы не сможете протестировать маршрут этого метода. О том, как можно сделать это, вы узнаете вскоре из описания функционального теста.

Что следует проверять, если вы не можете напрямую протестировать поведение файловой системы или маршрут с помощью модульного теста? После рефакторинга, который позволит провести модульное тестирование, вы можете заметить отсутствие некоторых тестовых случаев и функционального поведения, например обработки ошибок. Что делает метод в том случае, если файл не найден? Что он должен делать в такой ситуации? В этом примере после рефакторинга метод будет выглядеть следующим образом:

```csharp
[HttpGet("[controller]/pic/{id}")\]
public IActionResult GetImage(int id)
{
    byte[] imageBytes;
    try
    {
        imageBytes = _imageService.GetImageBytesById(id);
    }
    catch (CatalogImageMissingException ex)
    {
        _logger.LogWarning($"No image found for id: {id}");
        return NotFound();
    }
    return File(imageBytes, "image/png");
}
```

В качестве зависимостей внедряются \_logger и \_imageService. После этого вы можете проверить, что в \_imageService передается тот же идентификатор, который был передан в метод действия, а полученное число байтов возвращается в FileResult. Также вы можете проверить правильность ведения журнала ошибок, то есть регистрацию результата NotFound в случае отсутствия изображения, поскольку это поведение можно отнести к важным функциям приложения (то есть это не просто временный код, который разработчик добавляет для диагностики проблем). Реальная логика файла вынесена в отдельную службу реализации и дополнена таким образом, чтобы возвращать специфичное для приложения исключение в том случае, если файл не найден. Эту реализацию можно проверить отдельно с помощью интеграционного теста.

## <a name="integration-testing-aspnet-core-apps"></a>Интеграционное тестирование приложений ASP.NET Core

Эта служба использует интерфейс IHostingEnvironment, так же, как было в коде CatalogController до того, как он был вынесен в отдельную службу посредством рефакторинга. Поскольку интерфейс IHostingEnvironment использовался только в этом коде контроллера, эта зависимость была удалена из конструктора CatalogController.

Чтобы проверить корректность работы этой службы, вам необходимо создать известный тестовый файл изображения и убедиться, что служба возвращает его при вводе соответствующих данных. Обратите внимание, что не следует использовать макеты объектов для поведения, которое вы хотите проверить (в этом случае считывание из файловой системы). Тем не менее макеты объектов по-прежнему могут быть полезны при настройке интеграционных тестов. В этом случае вы можете создать макет IHostingEnvironment таким образом, чтобы его атрибут ContentRootPath указывал на папку, которая будет использоваться для тестового изображения. Полностью рабочий класс интеграционного теста показан здесь:

```csharp
public class LocalFileImageServiceGetImageBytesById
{
    private byte[] _testBytes = new byte[] { 0x01, 0x02, 0x03 };
    private readonly Mock<IHostingEnvironment> _mockEnvironment = new Mock<IHostingEnvironment>();
    private int _testImageId = 123;
    private string _testFileName = "123.png";
    public LocalFileImageServiceGetImageBytesById()
    {
        // create folder if necessary
        Directory.CreateDirectory(Path.Combine(GetFileDirectory(), "Pics"));
        string filePath = GetFilePath(_testFileName);
        System.IO.File.WriteAllBytes(filePath, _testBytes);
        _mockEnvironment.SetupGet<string>(m => m.ContentRootPath).Returns(GetFileDirectory());
    }
    private string GetFilePath(string fileName)
    {
        return Path.Combine(GetFileDirectory(), "Pics", fileName);
        }
            private string GetFileDirectory()
        {
            var location = System.Reflection.Assembly.GetEntryAssembly().Location;
            return Path.GetDirectoryName(location);
        }

        [Fact]
        public void ReturnsFileContentResultGivenValidId()
        {
            var fileService = new LocalFileImageService(_mockEnvironment.Object);
            var result = fileService.GetImageBytesById(_testImageId);
            Assert.Equal(_testBytes, result);
        }
    }
```

> [!NOTE]
> Этот тест сам по себе очень прост: основная часть кода настраивает систему для создания инфраструктуры тестирования (в этом случае создается файл, который будет считываться с диска). Это характерно для интеграционных тестов, которые зачастую требуют более тщательной настройки по сравнению с модульными тестами.

## <a name="functional-testing-aspnet-core-apps"></a>Функциональное тестирование приложений ASP.NET Core

Для удобства функционального тестирования приложений ASP.NET Core используется класс TestServer. Настройка TestServer осуществляется с помощью WebHostBuilder так же, как и в обычном случае для приложения. WebHostBuilder необходимо настроить так же, как реальный хост вашего приложения, однако при необходимости вы можете изменять любые его аспекты, чтобы упростить тестирование. В большинстве случаев для тестирования можно использовать один и тот же TestServer, поэтому вы можете инкапсулировать его в повторно используемый метод (например, в базовый класс):

```csharp
public abstract class BaseWebTest
{
    protected readonly HttpClient _client;
    protected string _contentRoot;

    public BaseWebTest()
    {
        _client = GetClient();
    }

    protected HttpClient GetClient()
    {
        var startupAssembly = typeof(Startup).GetTypeInfo().Assembly;
        _contentRoot = GetProjectPath("src", startupAssembly);
        var builder = new WebHostBuilder()
        .UseContentRoot(_contentRoot)
        .UseStartup<Startup>();
        var server = new TestServer(builder);
        var client = server.CreateClient();
        return client;
    }
}
```

Метод GetProjectPath просто возвращает физический путь к веб-проекту (скачивание примера решения). В этом случае WebHostBuilder задает корень содержимого для веб-приложения и ссылку на тот же класс Startup, который используется реальным веб-приложением. Для работы с TestServer и отправки запросов к нему вы можете использовать стандартный тип System.Net.HttpClient. TestServer содержит полезный метод CreateClient, который предоставляет предварительно настроенный клиент, готовый для выполнения запросов к приложению, выполняемому на TestServer. Этот клиент (для приведенного выше базового теста задан защищенный элемент \_client) используется при написании функциональных тестов для приложения ASP.NET Core:

```csharp
public class CatalogControllerGetImage : BaseWebTest
{
    [Fact]
    public async Task ReturnsFileContentResultGivenValidId()
    {
        var testFilePath = Path.Combine(_contentRoot, "pics//1.png");
        var expectedFileBytes = File.ReadAllBytes(testFilePath);
        var response = await _client.GetAsync("/catalog/pic/1");
        response.EnsureSuccessStatusCode();
        var streamResponse = await response.Content.ReadAsStreamAsync();
        byte[] byteResult;
        using (var ms = new MemoryStream())
        {
            streamResponse.CopyTo(ms);
            byteResult = ms.ToArray();
        }
        Assert.Equal(expectedFileBytes, byteResult);
    }
}
```

Этот функциональный тест выполняет полный стек приложения MVC ASP.NET Core, включая все существующие фильтры, связыватели, ПО промежуточного слоя и т. д. Он проверяет, что указанный маршрут ("/catalog/pic/1") возвращает ожидаемый массив байтов для файла, расположенного в известном месте. Для этого не настраивается реальный веб-сервер, что позволяет избежать большинства недостатков, связанных с тестированием на реальном веб-сервере (например, проблем с настройкой брандмауэра). Функциональные тесты, выполняемые в отношении TestServer, как правило, медленнее интеграционных и модульных тестов, однако значительно быстрее тестов, которые проводятся по сети с использованием тестового веб-сервера.

>[!div class="step-by-step"]
[Назад](work-with-data-in-asp-net-core-apps.md)
[Вперед](development-process-for-azure.md)
