---
title: Тестирование приложений MVC ASP.NET Core
description: Разработка современных веб-приложений с помощью ASP.NET Core и Azure | Тестирование приложений MVC ASP.NET Core
author: ardalis
ms.author: wiwagn
ms.date: 10/08/2017
ms.openlocfilehash: 7b4bcb1c39ddbbc104820558532b03bc9341804e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
---
# <a name="test-aspnet-core-mvc-apps"></a><span data-ttu-id="36079-103">Тестирование приложений MVC ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="36079-103">Test ASP.NET Core MVC Apps</span></span>

> <span data-ttu-id="36079-104">_"Если вы не хотите выполнять модульное тестирование своего продукта, ваши заказчики также вряд ли захотят делать это"._</span><span class="sxs-lookup"><span data-stu-id="36079-104">_"If you don't like unit testing your product, most likely your customers won't like to test it, either."_</span></span>
> <span data-ttu-id="36079-105">_-Аноним-</span><span class="sxs-lookup"><span data-stu-id="36079-105">_- Anonymous-</span></span>

## <a name="summary"></a><span data-ttu-id="36079-106">Сводка</span><span class="sxs-lookup"><span data-stu-id="36079-106">Summary</span></span>

<span data-ttu-id="36079-107">В ответ на изменения в программном обеспечении любой сложности могут возникать самые непредвиденные ошибки.</span><span class="sxs-lookup"><span data-stu-id="36079-107">Software of any complexity can fail in unexpected ways in response to changes.</span></span> <span data-ttu-id="36079-108">Соответственно, после внесения изменений для любых приложений, за исключением самых простых или наименее важных, необходимо проводить тестирование.</span><span class="sxs-lookup"><span data-stu-id="36079-108">Thus, testing after making changes is required for all but the most trivial (or least critical) applications.</span></span> <span data-ttu-id="36079-109">Тестирование вручную является самым медленным, наименее надежным и наиболее дорогим способом проверить программное обеспечение.</span><span class="sxs-lookup"><span data-stu-id="36079-109">Manual testing is the slowest, least reliable, most expensive way to test software.</span></span> <span data-ttu-id="36079-110">К сожалению, если возможность тестирования не заложена в приложение на этапе проектирования, это может быть единственный доступный способ.</span><span class="sxs-lookup"><span data-stu-id="36079-110">Unfortunately, if applications are not designed to be testable, it can be the only means available.</span></span> <span data-ttu-id="36079-111">Приложения, при написании которых соблюдались изложенные в главе X архитектурные принципы, а также приложения ASP.NET Core поддерживают автоматические интеграционные и функциональные тесты.</span><span class="sxs-lookup"><span data-stu-id="36079-111">Applications written following the architectural principles laid out in chapter X should be unit testable, and ASP.NET Core applications support automated integration and functional testing as well.</span></span>

## <a name="kinds-of-automated-tests"></a><span data-ttu-id="36079-112">Виды автоматических тестов</span><span class="sxs-lookup"><span data-stu-id="36079-112">Kinds of Automated Tests</span></span>

<span data-ttu-id="36079-113">Существует множество различных автоматических тестов приложений.</span><span class="sxs-lookup"><span data-stu-id="36079-113">There are many kinds of automated tests for software applications.</span></span> <span data-ttu-id="36079-114">Самым простым низкоуровневым подходом является модульное тестирование.</span><span class="sxs-lookup"><span data-stu-id="36079-114">The simplest, lowest level test is the unit test.</span></span> <span data-ttu-id="36079-115">Чуть выше уровнем располагаются интеграционные и функциональные тесты.</span><span class="sxs-lookup"><span data-stu-id="36079-115">At a slightly higher level there are integration tests and functional tests.</span></span> <span data-ttu-id="36079-116">В этом документе не описываются другие виды тестирования, в том числе тесты пользовательского интерфейса, нагрузочные тесты и тесты на принятие сборки.</span><span class="sxs-lookup"><span data-stu-id="36079-116">Other kinds of tests, like UI tests, load tests, stress tests, and smoke tests, are beyond the scope of this document.</span></span>

### <a name="unit-tests"></a><span data-ttu-id="36079-117">Модульные тесты</span><span class="sxs-lookup"><span data-stu-id="36079-117">Unit Tests</span></span>

<span data-ttu-id="36079-118">В рамках модульного теста проверяется отдельная часть логики вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="36079-118">A unit test tests a single part of your application's logic.</span></span> <span data-ttu-id="36079-119">Проще описать те возможности, которые не реализует модульное тестирование.</span><span class="sxs-lookup"><span data-stu-id="36079-119">One can further describe it by listing some of the things that it isn't.</span></span> <span data-ttu-id="36079-120">Модульный тест не позволяет проверить работу кода с зависимостями или инфраструктурой, для чего предназначены интеграционные тесты.</span><span class="sxs-lookup"><span data-stu-id="36079-120">A unit test doesn't test how your code works with dependencies or infrastructure – that's what integration tests are for.</span></span> <span data-ttu-id="36079-121">Модульный тест не позволяет проверить платформу, на которой написан код. Если возникают ошибки такого рода, следует отправить соответствующий отчет и написать код для обходного решения проблемы.</span><span class="sxs-lookup"><span data-stu-id="36079-121">A unit test doesn't test the framework your code is written on – you should assume it works or, if you find it doesn't, file a bug and code a workaround.</span></span> <span data-ttu-id="36079-122">Модульный тест выполняется полностью в памяти и внутри процесса.</span><span class="sxs-lookup"><span data-stu-id="36079-122">A unit test runs completely in memory and in process.</span></span> <span data-ttu-id="36079-123">Он не взаимодействует с файловой системой, сетью или базой данных.</span><span class="sxs-lookup"><span data-stu-id="36079-123">It doesn't communicate with the file system, the network, or a database.</span></span> <span data-ttu-id="36079-124">Модульные тесты предназначены исключительно для тестирования кода.</span><span class="sxs-lookup"><span data-stu-id="36079-124">Unit tests should only test your code.</span></span>

<span data-ttu-id="36079-125">Поскольку модульные тесты проверяют только один блок кода без каких-либо внешних зависимостей, они должны выполняться предельно быстро.</span><span class="sxs-lookup"><span data-stu-id="36079-125">Unit tests, by virtue of the fact that they test only a single unit of your code, with no external dependencies, should execute extremely quickly.</span></span> <span data-ttu-id="36079-126">Таким образом, набор из нескольких сотен модульных тестов может быть выполнен буквально за пару секунд.</span><span class="sxs-lookup"><span data-stu-id="36079-126">Thus, you should be able to run test suites of hundreds of unit tests in a few seconds.</span></span> <span data-ttu-id="36079-127">Модульные тесты следует выполнять как можно чаще, в идеальном случае перед каждой отправкой в общий репозиторий системы управления версиями и в обязательном порядке перед каждой автоматизированной сборкой на сервере сборки.</span><span class="sxs-lookup"><span data-stu-id="36079-127">Run them frequently, ideally before every push to a shared source control repository, and certainly with every automated build on your build server.</span></span>

### <a name="integration-tests"></a><span data-ttu-id="36079-128">Интеграционные тесты</span><span class="sxs-lookup"><span data-stu-id="36079-128">Integration Tests</span></span>

<span data-ttu-id="36079-129">Несмотря на рекомендации по инкапсуляции кода, который взаимодействует с такими инфраструктурами, как базы данных и файловые системы, в некоторых случаях такой код все же используется и требует тестирования.</span><span class="sxs-lookup"><span data-stu-id="36079-129">Although it's a good idea to encapsulate your code that interacts with infrastructure like databases and file systems, you will still have some of that code, and you will probably want to test it.</span></span> <span data-ttu-id="36079-130">Кроме того, вам необходимо проверить корректность взаимодействия между слоями вашего кода после того, как будут полностью разрешены все зависимости приложения.</span><span class="sxs-lookup"><span data-stu-id="36079-130">Additionally, you should verify that your code's layers interact as you expect when your application's dependencies are fully resolved.</span></span> <span data-ttu-id="36079-131">Для этой цели используются интеграционные тесты.</span><span class="sxs-lookup"><span data-stu-id="36079-131">This is the responsibility of integration tests.</span></span> <span data-ttu-id="36079-132">Интеграционные тесты выполняются дольше и требуют более тщательной настройки по сравнению с модульными, поскольку они часто полагаются на внешние зависимости и инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="36079-132">Integration tests tend to be slower and more difficult to set up than unit tests, because they often depend on external dependencies and infrastructure.</span></span> <span data-ttu-id="36079-133">В связи с этим по возможности не следует проверять с помощью интеграционных тестов то, что может быть проверено посредством модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="36079-133">Thus, you should avoid testing things that could be tests with unit tests in integration tests.</span></span> <span data-ttu-id="36079-134">Если конкретный сценарий можно проверить с помощью модульного теста, необходимо сделать именно так.</span><span class="sxs-lookup"><span data-stu-id="36079-134">If you can test a given scenario with a unit test, you should test it with a unit test.</span></span> <span data-ttu-id="36079-135">Если это невозможно, тогда попробуйте прибегнуть к интеграционному тестированию.</span><span class="sxs-lookup"><span data-stu-id="36079-135">If you can't, then consider using an integration test.</span></span>

<span data-ttu-id="36079-136">Процедуры настройки и уничтожения интеграционных тестов обычно гораздо более сложны по сравнению с модульными тестами.</span><span class="sxs-lookup"><span data-stu-id="36079-136">Integration tests will often have more complex setup and teardown procedures than unit tests.</span></span> <span data-ttu-id="36079-137">Например, после выполнения интеграционного теста в отношении реальной базы данных необходимо предусмотреть способ возврата базы в известное состояние, которое было до начала тестирования.</span><span class="sxs-lookup"><span data-stu-id="36079-137">For example, an integration test that goes against an actual database will need a way to return the database to a known state before each test run.</span></span> <span data-ttu-id="36079-138">С развитием новых тестов, добавляемых в схему рабочей базы данных, возрастает размер и степень сложности таких тестовых скриптов.</span><span class="sxs-lookup"><span data-stu-id="36079-138">As new tests are added and the production database schema evolves, these test scripts will tend to grow in size and complexity.</span></span> <span data-ttu-id="36079-139">Во многих крупных системах практически нецелесообразно выполнять полный набор интеграционных тестов на рабочих станциях разработчиков перед возвратом изменений в общую систему управления версиями.</span><span class="sxs-lookup"><span data-stu-id="36079-139">In many large systems, it is impractical to run full suites of integration tests on developer workstations before checking in changes to shared source control.</span></span> <span data-ttu-id="36079-140">В таких случаях интеграционные тесты могут выполняться на сервере сборки.</span><span class="sxs-lookup"><span data-stu-id="36079-140">In these cases, integration tests may be run on a build server.</span></span>

<span data-ttu-id="36079-141">Класс реализации LocalFileImageService реализует логику получения и возврата байтов файла изображения из конкретной папки по заданному идентификатору:</span><span class="sxs-lookup"><span data-stu-id="36079-141">The LocalFileImageService implementation class implements the logic for fetching and returning the bytes of an image file from a particular folder given an id:</span></span>

```cs
public class LocalFileImageService : IImageService
{
    private readonly IHostingEnvironment _env;
    public LocalFileImageService(IHostingEnvironment env)
    {
        _env = env;
    }
    public byte[] GetImageBytesById(int id)
    {
        try
        {
            var contentRoot = _env.ContentRootPath + "//Pics";
            var path = Path.Combine(contentRoot, id + ".png");
            return File.ReadAllBytes(path);
```

### <a name="functional-tests"></a><span data-ttu-id="36079-142">Функциональные тесты</span><span class="sxs-lookup"><span data-stu-id="36079-142">Functional Tests</span></span>

<span data-ttu-id="36079-143">Интеграционные тесты позволяют проверить корректность совместной работы нескольких компонентов системы с точки зрения разработчика.</span><span class="sxs-lookup"><span data-stu-id="36079-143">Integration tests are written from the perspective of the developer, to verify that some components of the system work correctly together.</span></span> <span data-ttu-id="36079-144">В отличие от них, функциональные тесты позволяют проверить соответствие системы требованиям с точки зрения пользователя.</span><span class="sxs-lookup"><span data-stu-id="36079-144">Functional tests are written from the perspective of the user, and verify the correctness of the system based on its requirements.</span></span> <span data-ttu-id="36079-145">В следующей цитате приводится наглядная аналогия, позволяющая сравнить функциональные и модульные тесты:</span><span class="sxs-lookup"><span data-stu-id="36079-145">The following excerpt offers a useful analogy for how to think about functional tests, compared to unit tests:</span></span>

> <span data-ttu-id="36079-146">"Разработку системы уже не раз сравнивали с возведением дома.</span><span class="sxs-lookup"><span data-stu-id="36079-146">"Many times the development of a system is likened to the building of a house.</span></span> <span data-ttu-id="36079-147">И хотя это не совсем корректно, на базе этой аналогии мы можем понять разницу между модульным и функциональным тестированием.</span><span class="sxs-lookup"><span data-stu-id="36079-147">While this analogy isn't quite correct, we can extend it for the purposes of understanding the difference between unit and functional tests.</span></span> <span data-ttu-id="36079-148">Модульное тестирование похоже на посещение строительной площадки инспектором.</span><span class="sxs-lookup"><span data-stu-id="36079-148">Unit testing is analogous to a building inspector visiting a house's construction site.</span></span> <span data-ttu-id="36079-149">Он проверяет различные внутренние системы дома, его фундамент, несущие конструкции, электрические и сантехнические сети, а также множество других компонентов.</span><span class="sxs-lookup"><span data-stu-id="36079-149">He is focused on the various internal systems of the house, the foundation, framing, electrical, plumbing, and so on.</span></span> <span data-ttu-id="36079-150">Таким образом, инспектор проверяет (тестирует) безопасность всех частей дома и их соответствие строительным нормам.</span><span class="sxs-lookup"><span data-stu-id="36079-150">He ensures (tests) that the parts of the house will work correctly and safely, that is, meet the building code.</span></span> <span data-ttu-id="36079-151">В этом контексте функциональные тесты можно сравнить с визитом владельца дома.</span><span class="sxs-lookup"><span data-stu-id="36079-151">Functional tests in this scenario are analogous to the homeowner visiting this same construction site.</span></span> <span data-ttu-id="36079-152">Он справедливо полагает, что все внутренние системы были проверены инспектором и, соответственно, функционируют в соответствии с предназначением.</span><span class="sxs-lookup"><span data-stu-id="36079-152">He assumes that the internal systems will behave appropriately, that the building inspector is performing his task.</span></span> <span data-ttu-id="36079-153">Сам же владелец при этом будет сосредоточен на том, чтобы проверить, насколько комфортно ему будет жить в новом доме.</span><span class="sxs-lookup"><span data-stu-id="36079-153">The homeowner is focused on what it will be like to live in this house.</span></span> <span data-ttu-id="36079-154">Он будет проверять внешний вид дома, размер его комнат, соответствие дома потребностям семьи и даже то, не будет ли его в дальнейшем беспокоить утренний свет, попадающий в окна.</span><span class="sxs-lookup"><span data-stu-id="36079-154">He is concerned with how the house looks, are the various rooms a comfortable size, does the house fit the family's needs, are the windows in a good spot to catch the morning sun.</span></span> <span data-ttu-id="36079-155">Таким образом, владелец дома проводит функциональное тестирование своего жилища.</span><span class="sxs-lookup"><span data-stu-id="36079-155">The homeowner is performing functional tests on the house.</span></span> <span data-ttu-id="36079-156">Важно понимать, что он делает это с точки зрения пользователя.</span><span class="sxs-lookup"><span data-stu-id="36079-156">He has the user's perspective.</span></span> <span data-ttu-id="36079-157">Инспектор осуществляет модульное тестирование.</span><span class="sxs-lookup"><span data-stu-id="36079-157">The building inspector is performing unit tests on the house.</span></span> <span data-ttu-id="36079-158">Иными словами, он проверяет дом с точки зрения строителя".</span><span class="sxs-lookup"><span data-stu-id="36079-158">He has the builder's perspective."</span></span>

<span data-ttu-id="36079-159">Источник: [Сравнение модульного и функционального тестирования](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)</span><span class="sxs-lookup"><span data-stu-id="36079-159">Source: [Unit Testing versus Functional Tests](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)</span></span>

<span data-ttu-id="36079-160">Мне очень нравится следующее выражение: "Как разработчики мы совершаем две главных ошибки: мы создаем вещи неправильно и мы создаем неправильные вещи".</span><span class="sxs-lookup"><span data-stu-id="36079-160">I'm fond of saying "As developers, we fail in two ways: we build the thing wrong, or we build the wrong thing."</span></span> <span data-ttu-id="36079-161">С помощью модульных тестов мы можем убедиться в том, что создаем вещи правильно. Функциональное тестирование позволяет проверить, что мы создаем правильные вещи.</span><span class="sxs-lookup"><span data-stu-id="36079-161">Unit tests ensure you are building the thing right; functional tests ensure you are building the right thing.</span></span>

<span data-ttu-id="36079-162">Поскольку функциональные тесты выполняются на уровне системы, для них может потребоваться определенная степень автоматизации пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="36079-162">Since functional tests operate at the system level, they may require some degree of UI automation.</span></span> <span data-ttu-id="36079-163">Как и интеграционные тесты, они обычно имеют дело с определенного вида тестовой инфраструктурой.</span><span class="sxs-lookup"><span data-stu-id="36079-163">Like integration tests, they usually work with some kind of test infrastructure as well.</span></span> <span data-ttu-id="36079-164">Это делает их еще более медленными и нестабильными по сравнению с модульными и интеграционными тестами.</span><span class="sxs-lookup"><span data-stu-id="36079-164">This makes them slower and more brittle than unit and integration tests.</span></span> <span data-ttu-id="36079-165">Поэтому необходимо использовать ровно столько функциональных тестов, сколько нужно для того, чтобы гарантировать функционирование системы в соответствии с требованиями пользователя.</span><span class="sxs-lookup"><span data-stu-id="36079-165">You should have only as many functional tests as you need to be confident the system is behaving as users expect.</span></span>

### <a name="testing-pyramid"></a><span data-ttu-id="36079-166">Пирамида тестирования</span><span class="sxs-lookup"><span data-stu-id="36079-166">Testing Pyramid</span></span>

<span data-ttu-id="36079-167">Мартин Фаулер (Martin Fowler) описал пирамиду тестирования, пример которой показан на рис. 9-1.</span><span class="sxs-lookup"><span data-stu-id="36079-167">Martin Fowler wrote about the testing pyramid, an example of which is shown in Figure 9-1.</span></span>

![](./media/image9-1.png)

<span data-ttu-id="36079-168">Рис. 9-1. Пирамида тестирования</span><span class="sxs-lookup"><span data-stu-id="36079-168">Figure 9-1 Testing Pyramid</span></span>

<span data-ttu-id="36079-169">Уровни пирамиды и их относительный размер описывают различные виды тестов и их количество, необходимое для проверки приложения.</span><span class="sxs-lookup"><span data-stu-id="36079-169">The different layers of the pyramid, and their relative sizes, represent different kinds of tests and how many you should write for your application.</span></span> <span data-ttu-id="36079-170">Как видно из рисунка, в качестве фундамента рекомендуется брать большое количество модульных тестов, поверх которого проводится меньшее число интеграционных тестов. Венчает же пирамиду малочисленный уровень функциональных тестов.</span><span class="sxs-lookup"><span data-stu-id="36079-170">As you can see, the recommendation is to have a large base of unit tests, supported by a smaller layer of integration tests, with an even smaller layer of functional tests.</span></span> <span data-ttu-id="36079-171">В идеале каждый уровень должен содержать только те тесты, которые невозможно выполнить надлежащим образом на более низком уровне.</span><span class="sxs-lookup"><span data-stu-id="36079-171">Each layer should ideally only have tests in it that cannot be performed adequately at a lower layer.</span></span> <span data-ttu-id="36079-172">При выборе теста, который будет выполняться в каждом конкретном сценарии, помните о пирамиде тестирования.</span><span class="sxs-lookup"><span data-stu-id="36079-172">Keep the testing pyramid in mind when you are trying to decide which kind of test you need for a particular scenario.</span></span>

### <a name="what-to-test"></a><span data-ttu-id="36079-173">Что следует проверить</span><span class="sxs-lookup"><span data-stu-id="36079-173">What to Test</span></span>

<span data-ttu-id="36079-174">Разработчики, не имеющие достаточного опыта в написании автоматических тестов, часто сталкиваются с проблемой выбора того, что следует проверять.</span><span class="sxs-lookup"><span data-stu-id="36079-174">A common problem for developers who are inexperienced with writing automated tests is coming up with what to test.</span></span> <span data-ttu-id="36079-175">Для начала рекомендуется проверить условную логику.</span><span class="sxs-lookup"><span data-stu-id="36079-175">A good starting point is to test conditional logic.</span></span> <span data-ttu-id="36079-176">Везде, где у вас используется метод, поведение которого изменяется в зависимости от значения условного выражения (if-else, switch и т. д.), следует проводить хотя бы пару тестов, проверяющих корректность поведения при различных условиях.</span><span class="sxs-lookup"><span data-stu-id="36079-176">Anywhere you have a method with behavior that changes based on a conditional statement (if-else, switch, etc.), you should be able to come up at least a couple of tests that confirm the correct behavior for certain conditions.</span></span> <span data-ttu-id="36079-177">Если в коде используются условия ошибки, следует написать как минимум один тест для безошибочного прохождения кода и хотя бы один для выполнения кода с ошибками или нетипичными результатами. Это позволит проверить корректность работы приложения при возникновении ошибок.</span><span class="sxs-lookup"><span data-stu-id="36079-177">If your code has error conditions, it's good to write at least one test for the "happy path" through the code (with no errors), and at least one test for the "sad path" (with errors or atypical results) to confirm your application behaves as expected in the face of errors.</span></span> <span data-ttu-id="36079-178">Наконец, попробуйте сосредоточиться на том, что может пойти не по сценарию, и не зацикливайтесь на таких показателях, как объем протестированного кода.</span><span class="sxs-lookup"><span data-stu-id="36079-178">Finally, try to focus on testing things that can fail, rather than focusing on metrics like code coverage.</span></span> <span data-ttu-id="36079-179">Тем не менее в большинстве случаев рекомендуется протестировать как можно больший объем кода.</span><span class="sxs-lookup"><span data-stu-id="36079-179">More code coverage is better than less, generally.</span></span> <span data-ttu-id="36079-180">И все же часто лучше потратить больше времени на написание нескольких тестов для сложного критически важного метода, чем многократно проверять автоматические свойства только для того, чтобы увеличить объем протестированного кода.</span><span class="sxs-lookup"><span data-stu-id="36079-180">However, writing a few more tests of a very complex and business-critical method is usually a better use of time than writing tests for auto-properties just to improve test code coverage metrics.</span></span>

## <a name="organizing-test-projects"></a><span data-ttu-id="36079-181">Упорядочение тестовых проектов</span><span class="sxs-lookup"><span data-stu-id="36079-181">Organizing Test Projects</span></span>

<span data-ttu-id="36079-182">Вы можете упорядочивать тестовые проекты так, как это удобно вам.</span><span class="sxs-lookup"><span data-stu-id="36079-182">Test projects can be organized however works best for you.</span></span> <span data-ttu-id="36079-183">В качестве общей рекомендации можно посоветовать разделять тесты по виду (модульные, интеграционные) и по тому, что они проверяют (проект, пространство имен).</span><span class="sxs-lookup"><span data-stu-id="36079-183">It's a good idea to separate tests by type (unit test, integration test) and by what they are testing (by project, by namespace).</span></span> <span data-ttu-id="36079-184">Будут ли для этого применяться папки в рамках одного тестового проекта или потребуется несколько тестовых проектов, зависит от структуры решения.</span><span class="sxs-lookup"><span data-stu-id="36079-184">Whether this separation consists of folders within a single test project, or multiple test projects, is a design decision.</span></span> <span data-ttu-id="36079-185">Работать с одним проектом проще, однако для крупных проектов с множеством тестов или для удобства выполнения различных наборов тестов вы можете использовать несколько тестовых проектов.</span><span class="sxs-lookup"><span data-stu-id="36079-185">One project is simplest, but for large projects with many tests, or in order to more easily run different sets of tests, you might want to have several different test projects.</span></span> <span data-ttu-id="36079-186">Многие команды упорядочивают тестовые проекты на основе проверяемых проектов. В этом случае для приложений с достаточно большим числом проектов может получиться слишком много тестовых проектов, особенно если для каждого из них осуществляется разбиение по виду теста.</span><span class="sxs-lookup"><span data-stu-id="36079-186">Many teams organize test projects based on the project they are testing, which for applications with more than a few projects can result in a large number of test projects, especially if you still break these down according to what kind of tests are in each project.</span></span> <span data-ttu-id="36079-187">В качестве компромисса можно использовать подход с одним проектом для каждого вида теста для каждого приложения. В этом случае проверяемые проекты и классы будут определяться с помощью папок внутри тестовых проектов.</span><span class="sxs-lookup"><span data-stu-id="36079-187">A compromise approach is to have one project per kind of test, per application, with folders inside the test projects to indicate the project (and class) being tested.</span></span>

<span data-ttu-id="36079-188">Типовой подход предполагает размещение проектов приложения в папке src, а тестовых проектов — в параллельной папке tests.</span><span class="sxs-lookup"><span data-stu-id="36079-188">A common approach is to organize the application projects under a ‘src' folder, and the application's test projects under a parallel ‘tests' folder.</span></span> <span data-ttu-id="36079-189">Если это покажется вам более удобным, вы можете создать соответствующие папки решений в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="36079-189">You can create matching solution folders in Visual Studio, if you find this organization useful.</span></span>

![](./media/image9-2.png)

<span data-ttu-id="36079-190">Рис. 9-2. Упорядочение тестов для решения</span><span class="sxs-lookup"><span data-stu-id="36079-190">Figure 9-2 Test organization in your solution</span></span>

<span data-ttu-id="36079-191">Вы можете использовать любую предпочитаемую платформу тестирования.</span><span class="sxs-lookup"><span data-stu-id="36079-191">You can use whichever test framework you prefer.</span></span> <span data-ttu-id="36079-192">Эффективным решением является платформа xUnit, на которой пишутся все тесты для ASP.NET Core и EF Core.</span><span class="sxs-lookup"><span data-stu-id="36079-192">The xUnit framework works well and is what all of the ASP.NET Core and EF Core tests are written in.</span></span> <span data-ttu-id="36079-193">Вы можете добавить тестовый проект xUnit в Visual Studio, используя показанный на рис. 9-3 шаблон или через интерфейс командной строки с помощью команды dotnet new xunit.</span><span class="sxs-lookup"><span data-stu-id="36079-193">You can add an xUnit test project in Visual Studio using the template shown in Figure 9-3, or from the CLI using dotnet new xunit.</span></span>

![](./media/image9-3.png)

<span data-ttu-id="36079-194">Рис. 9-3. Добавление тестового проекта xUnit в Visual Studio</span><span class="sxs-lookup"><span data-stu-id="36079-194">Figure 9-3 Add an xUnit Test Project in Visual Studio</span></span>

### <a name="test-naming"></a><span data-ttu-id="36079-195">Присвоение имен тестам</span><span class="sxs-lookup"><span data-stu-id="36079-195">Test Naming</span></span>

<span data-ttu-id="36079-196">Тестам следует присваивать единообразные имена, которые указывают на выполняемые ими задачи.</span><span class="sxs-lookup"><span data-stu-id="36079-196">You should name your tests in a consistent fashion, with names that indicate what each test does.</span></span> <span data-ttu-id="36079-197">Я могу порекомендовать успешно проверенный на практике подход, при котором имена тестовых классов задаются на основе проверяемого ими класса и метода.</span><span class="sxs-lookup"><span data-stu-id="36079-197">One approach I've had great success with is to name test classes according to the class and method they are testing.</span></span> <span data-ttu-id="36079-198">В этом случае получается множество небольших тестовых классов, однако можно легко определить, для чего предназначен каждый из них.</span><span class="sxs-lookup"><span data-stu-id="36079-198">This results in many small test classes, but it makes it extremely clear what each test is responsible for.</span></span> <span data-ttu-id="36079-199">Таким образом, имена тестовых классов определяют проверяемый класс и метод. С помощью имени тестового метода можно указать, какое поведение он проверяет.</span><span class="sxs-lookup"><span data-stu-id="36079-199">With the test class name set up to identify the class and method to be tested, the test method name can be used to specify the behavior being tested.</span></span> <span data-ttu-id="36079-200">Это имя должно определять ожидаемое поведение, а также любые принимаемые входные данные и допущения.</span><span class="sxs-lookup"><span data-stu-id="36079-200">This should include the expected behavior and any inputs or assumptions that should yield this behavior.</span></span> <span data-ttu-id="36079-201">Примеры имен тестов:</span><span class="sxs-lookup"><span data-stu-id="36079-201">Some example test names:</span></span>

-   <span data-ttu-id="36079-202">CatalogControllerGetImage.CallsImageServiceWithId</span><span class="sxs-lookup"><span data-stu-id="36079-202">CatalogControllerGetImage.CallsImageServiceWithId</span></span>

-   <span data-ttu-id="36079-203">CatalogControllerGetImage.LogsWarningGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="36079-203">CatalogControllerGetImage.LogsWarningGivenImageMissingException</span></span>

-   <span data-ttu-id="36079-204">CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess</span><span class="sxs-lookup"><span data-stu-id="36079-204">CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess</span></span>

-   <span data-ttu-id="36079-205">CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="36079-205">CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException</span></span>

<span data-ttu-id="36079-206">В качестве варианта можно добавить в конец имени тестового класса слово "Should" (Должен) и слегка изменить формулировку:</span><span class="sxs-lookup"><span data-stu-id="36079-206">A variation of this approach ends each test class name with "Should" and modifies the tense slightly:</span></span>

-   <span data-ttu-id="36079-207">CatalogControllerGetImage**Should**.**Call**ImageServiceWithId</span><span class="sxs-lookup"><span data-stu-id="36079-207">CatalogControllerGetImage**Should**.**Call**ImageServiceWithId</span></span>

-   <span data-ttu-id="36079-208">CatalogControllerGetImage**Should**.**Log**WarningGivenImageMissingException</span><span class="sxs-lookup"><span data-stu-id="36079-208">CatalogControllerGetImage**Should**.**Log**WarningGivenImageMissingException</span></span>

<span data-ttu-id="36079-209">Некоторые разработчики считают второй подход более понятным, несмотря на более длинные имена.</span><span class="sxs-lookup"><span data-stu-id="36079-209">Some teams find the second naming approach clearer, though slightly more verbose.</span></span> <span data-ttu-id="36079-210">В любом случае постарайтесь выбрать соглашение об именовании, которое позволит легко определять поведение теста. Благодаря этому в случае неудачного завершения одного или нескольких тестов вы сможете легко определить, что именно не удалось сделать.</span><span class="sxs-lookup"><span data-stu-id="36079-210">In any case, try to use a naming convention that provides insight into test behavior, so that when one or more tests fail, it's obvious from their names what cases have failed.</span></span> <span data-ttu-id="36079-211">Не рекомендуется присваивать тестам слишком размытые имена, например ControllerTests.Test1, поскольку по ним вы не сможете определить, на что указывают результаты теста.</span><span class="sxs-lookup"><span data-stu-id="36079-211">Avoid naming you tests vaguely, such as ControllerTests.Test1, as these offer no value when you see them in test results.</span></span>

<span data-ttu-id="36079-212">Если вы используете одно из описываемых выше соглашений об именовании, в результате чего получаете множество небольших тестовых классов, рекомендуется упорядочить тесты по папкам и пространствам имен.</span><span class="sxs-lookup"><span data-stu-id="36079-212">If you follow a naming convention like the one above that produces many small test classes, it's a good idea to further organize your tests using folders and namespaces.</span></span> <span data-ttu-id="36079-213">На рис. 9-4 показан возможный подход к упорядочению тестов по папкам в рамках нескольких тестовых проектов.</span><span class="sxs-lookup"><span data-stu-id="36079-213">Figure 9-4 shows one approach to organizing tests by folder within several test projects.</span></span>

![](./media/image9-4.png)

<span data-ttu-id="36079-214">**Рис. 9-4.**</span><span class="sxs-lookup"><span data-stu-id="36079-214">**Figure 9-4.**</span></span> <span data-ttu-id="36079-215">Упорядочение тестовых классов по папкам на основе проверяемых классов.</span><span class="sxs-lookup"><span data-stu-id="36079-215">Organizing test classes by folder based on class being tested.</span></span>

<span data-ttu-id="36079-216">Безусловно, если конкретный класс приложения содержит много проверяемых методов (и, соответственно, много тестовых классов), может быть удобно поместить их в папку, соответствующую классу приложения.</span><span class="sxs-lookup"><span data-stu-id="36079-216">Of course, if a particular application class has many methods being tested (and thus many test classes), it may make sense to place these in a folder corresponding to the application class.</span></span> <span data-ttu-id="36079-217">Такой подход аналогичен упорядочению обычных файлов в папках.</span><span class="sxs-lookup"><span data-stu-id="36079-217">This organization is no different than how you might organize files into folders elsewhere.</span></span> <span data-ttu-id="36079-218">Если в папке, содержащей множество файлов, присутствует больше трех или четырех связанных файлов, их зачастую рекомендуется перенести в отдельную вложенную папку.</span><span class="sxs-lookup"><span data-stu-id="36079-218">If you have more than three or four related files in a folder containing many other files, it's often helpful to move them into their own subfolder.</span></span>

## <a name="unit-testing-aspnet-core-apps"></a><span data-ttu-id="36079-219">Модульное тестирование приложений ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="36079-219">Unit Testing ASP.NET Core Apps</span></span>

<span data-ttu-id="36079-220">В грамотно спроектированном приложении ASP.NET Core большая часть сложных функций и бизнес-логики инкапсулируется в бизнес-сущностях и различных службах.</span><span class="sxs-lookup"><span data-stu-id="36079-220">In a well-designed ASP.NET Core application, most of the complexity and business logic will be encapsulated in business entities and a variety of services.</span></span> <span data-ttu-id="36079-221">Таким образом, само приложение MVC ASP.NET Core со всеми его контроллерами, фильтрами, моделями представлений и представлениями должно требовать минимального количества модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="36079-221">The ASP.NET Core MVC app itself, with its controllers, filters, viewmodels, and views, should require very few unit tests.</span></span> <span data-ttu-id="36079-222">Большая часть функционала конкретного действия выполняется за пределами самого метода действия.</span><span class="sxs-lookup"><span data-stu-id="36079-222">Much of the functionality of a given action lies outside the action method itself.</span></span> <span data-ttu-id="36079-223">Модульные тесты не позволяют эффективно проверить корректность маршрутизации или глобальной обработки ошибок.</span><span class="sxs-lookup"><span data-stu-id="36079-223">Testing whether routing works correctly, or global error handling, cannot be done effectively with a unit test.</span></span> <span data-ttu-id="36079-224">Кроме того, модульное тестирование не позволяет проверить какие-либо фильтры, в том числе применяемые для подтверждения, проверки подлинности и авторизации.</span><span class="sxs-lookup"><span data-stu-id="36079-224">Likewise, any filters, including model validation and authentication and authorization filters, cannot be unit tested.</span></span> <span data-ttu-id="36079-225">Без этих источников реакции на события большинство методов действия будут иметь небольшой размер, поскольку они делегируют основную часть выполняемых задач службам, которые могут быть протестированы независимо от использующего их контроллера.</span><span class="sxs-lookup"><span data-stu-id="36079-225">Without these sources of behavior, most action methods should be trivially small, delegating the bulk of their work to services that can be tested independent of the controller that uses them.</span></span>

<span data-ttu-id="36079-226">В некоторых случаях, чтобы провести модульное тестирование кода, требуется выполнить его рефакторинг.</span><span class="sxs-lookup"><span data-stu-id="36079-226">Sometimes you'll need to refactor your code in order to unit test it.</span></span> <span data-ttu-id="36079-227">Зачастую для этого требуется определить абстракции и использовать внедрение зависимостей для доступа к абстракции в коде, который требуется протестировать, вместо того, чтобы писать код непосредственно для работы с инфраструктурой.</span><span class="sxs-lookup"><span data-stu-id="36079-227">Frequently this involves identifying abstractions and using dependency injection to access the abstraction in the code you'd like to test, rather than coding directly against infrastructure.</span></span> <span data-ttu-id="36079-228">Например, рассмотрим простой метод действия для показа изображений:</span><span class="sxs-lookup"><span data-stu-id="36079-228">For example, consider this simple action method for displaying images:</span></span>

```cs
[HttpGet("[controller]/pic/{id}")]
public IActionResult GetImage(int id)
{
    var contentRoot = _env.ContentRootPath + "//Pics";
    var path = Path.Combine(contentRoot, id + ".png");
    Byte[] b = System.IO.File.ReadAllBytes(path);
    return File(b, "image/png");
}
```

<span data-ttu-id="36079-229">Модульное тестирование этого метода затруднено из-за наличия прямой зависимости от System.IO.File, который используется для чтения из файловой системы.</span><span class="sxs-lookup"><span data-stu-id="36079-229">Unit testing this method is made difficult by its direct dependency on System.IO.File, which it uses to read from the file system.</span></span> <span data-ttu-id="36079-230">Вы можете проверить корректность поведения этого метода, однако для тестирования работы с реальными файлами вам потребуются интеграционные тесты.</span><span class="sxs-lookup"><span data-stu-id="36079-230">You can test this behavior to ensure it works as expected, but doing so with real files is an integration test.</span></span> <span data-ttu-id="36079-231">Следует отметить, что вы не сможете протестировать маршрут этого метода. О том, как можно сделать это, вы узнаете вскоре из описания функционального теста.</span><span class="sxs-lookup"><span data-stu-id="36079-231">It's worth noting you can't test this method's route – you'll see how to do this with a functional test shortly.</span></span>

<span data-ttu-id="36079-232">Что следует проверять, если вы не можете напрямую протестировать поведение файловой системы или маршрут с помощью модульного теста?</span><span class="sxs-lookup"><span data-stu-id="36079-232">If you can't unit test the file system behavior directly, and you can't test the route, what is there to test?</span></span> <span data-ttu-id="36079-233">После рефакторинга, который позволит провести модульное тестирование, вы можете заметить отсутствие некоторых тестовых случаев и функционального поведения, например обработки ошибок.</span><span class="sxs-lookup"><span data-stu-id="36079-233">Well, after refactoring to make unit testing possible, you may discover some test cases and missing behavior, such as error handling.</span></span> <span data-ttu-id="36079-234">Что делает метод в том случае, если файл не найден?</span><span class="sxs-lookup"><span data-stu-id="36079-234">What does the method do when a file isn't found?</span></span> <span data-ttu-id="36079-235">Что он должен делать в такой ситуации?</span><span class="sxs-lookup"><span data-stu-id="36079-235">What should it do?</span></span> <span data-ttu-id="36079-236">В этом примере после рефакторинга метод будет выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="36079-236">In this example, the refactored method looks like this:</span></span>

```cs
[HttpGet("[controller]/pic/{id}")\]
public IActionResult GetImage(int id)
{
    byte[] imageBytes;
    try
    {
        imageBytes = _imageService.GetImageBytesById(id);
    }
    catch (CatalogImageMissingException ex)
    {
        _logger.LogWarning($"No image found for id: {id}");
        return NotFound();
    }
    return File(imageBytes, "image/png");
}
```

<span data-ttu-id="36079-237">В качестве зависимостей внедряются \_logger и \_imageService.</span><span class="sxs-lookup"><span data-stu-id="36079-237">The \_logger and \_imageService are both injected as dependencies.</span></span> <span data-ttu-id="36079-238">После этого вы можете проверить, что в \_imageService передается тот же идентификатор, который был передан в метод действия, а полученное число байтов возвращается в FileResult.</span><span class="sxs-lookup"><span data-stu-id="36079-238">Now you can test that the same id that is passed to the action method is passed to the \_imageService, and that the resulting bytes are returned as part of the FileResult.</span></span> <span data-ttu-id="36079-239">Также вы можете проверить правильность ведения журнала ошибок, то есть регистрацию результата NotFound в случае отсутствия изображения, поскольку это поведение можно отнести к важным функциям приложения (то есть это не просто временный код, который разработчик добавляет для диагностики проблем).</span><span class="sxs-lookup"><span data-stu-id="36079-239">You can also test that error logging is happening as expected, and that a NotFound result is returned if the image is missing, assuming this is important application behavior (that is, not just temporary code the developer added to diagnose an issue).</span></span> <span data-ttu-id="36079-240">Реальная логика файла вынесена в отдельную службу реализации и дополнена таким образом, чтобы возвращать специфичное для приложения исключение в том случае, если файл не найден.</span><span class="sxs-lookup"><span data-stu-id="36079-240">The actual file logic has moved into a separate implementation service, and has been augmented to return an application-specific exception for the case of a missing file.</span></span> <span data-ttu-id="36079-241">Эту реализацию можно проверить отдельно с помощью интеграционного теста.</span><span class="sxs-lookup"><span data-stu-id="36079-241">You can test this implementation independently, using an integration test.</span></span>

## <a name="integration-testing-aspnet-core-apps"></a><span data-ttu-id="36079-242">Интеграционное тестирование приложений ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="36079-242">Integration Testing ASP.NET Core Apps</span></span>

```cs
    }
        catch (FileNotFoundException ex)
        {
            throw new CatalogImageMissingException(ex);
        }
    }
}
```

<span data-ttu-id="36079-243">Эта служба использует интерфейс IHostingEnvironment, так же, как было в коде CatalogController до того, как он был вынесен в отдельную службу посредством рефакторинга.</span><span class="sxs-lookup"><span data-stu-id="36079-243">This service uses the IHostingEnvironment, just as the CatalogController code did before it was refactored into a separate service.</span></span> <span data-ttu-id="36079-244">Поскольку интерфейс IHostingEnvironment использовался только в этом коде контроллера, эта зависимость была удалена из конструктора CatalogController.</span><span class="sxs-lookup"><span data-stu-id="36079-244">Since this was the only code in the controller that used IHostingEnvironment, that dependency was removed from CatalogController's constructor.</span></span>

<span data-ttu-id="36079-245">Чтобы проверить корректность работы этой службы, вам необходимо создать известный тестовый файл изображения и убедиться, что служба возвращает его при вводе соответствующих данных.</span><span class="sxs-lookup"><span data-stu-id="36079-245">To test that this service works correctly, you need to create a known test image file and verify that the service returns it given a specific input.</span></span> <span data-ttu-id="36079-246">Обратите внимание, что не следует использовать макеты объектов для поведения, которое вы хотите проверить (в этом случае считывание из файловой системы).</span><span class="sxs-lookup"><span data-stu-id="36079-246">You should take care not to use mock objects on the behavior you actually want to test (in this case, reading from the file system).</span></span> <span data-ttu-id="36079-247">Тем не менее макеты объектов по-прежнему могут быть полезны при настройке интеграционных тестов.</span><span class="sxs-lookup"><span data-stu-id="36079-247">However, mock objects may still be useful to set up integration tests.</span></span> <span data-ttu-id="36079-248">В этом случае вы можете создать макет IHostingEnvironment таким образом, чтобы его атрибут ContentRootPath указывал на папку, которая будет использоваться для тестового изображения.</span><span class="sxs-lookup"><span data-stu-id="36079-248">In this case, you can mock IHostingEnvironment so that its ContentRootPath points to the folder you're going to use for your test image.</span></span> <span data-ttu-id="36079-249">Полностью рабочий класс интеграционного теста показан здесь:</span><span class="sxs-lookup"><span data-stu-id="36079-249">The complete working integration test class is shown here:</span></span>

```cs
public class LocalFileImageServiceGetImageBytesById
{
    private byte[] _testBytes = new byte[] { 0x01, 0x02, 0x03 };
    private readonly Mock<IHostingEnvironment> _mockEnvironment = new Mock<IHostingEnvironment>();
    private int _testImageId = 123;
    private string _testFileName = "123.png";
    public LocalFileImageServiceGetImageBytesById()
    {
        // create folder if necessary
        Directory.CreateDirectory(Path.Combine(GetFileDirectory(), "Pics"));
        string filePath = GetFilePath(_testFileName);
        System.IO.File.WriteAllBytes(filePath, _testBytes);
        _mockEnvironment.SetupGet<string>(m => m.ContentRootPath).Returns(GetFileDirectory());
    }
    private string GetFilePath(string fileName)
    {
        return Path.Combine(GetFileDirectory(), "Pics", fileName);
        }
            private string GetFileDirectory()
        {
            var location = System.Reflection.Assembly.GetEntryAssembly().Location;
            return Path.GetDirectoryName(location);
        }

        [Fact]
        public void ReturnsFileContentResultGivenValidId()
        {
            var fileService = new LocalFileImageService(_mockEnvironment.Object);
            var result = fileService.GetImageBytesById(_testImageId);
            Assert.Equal(_testBytes, result);
        }
    }
```

> [!NOTE]
> <span data-ttu-id="36079-250">Этот тест сам по себе очень прост: основная часть кода настраивает систему для создания инфраструктуры тестирования (в этом случае создается файл, который будет считываться с диска).</span><span class="sxs-lookup"><span data-stu-id="36079-250">that the test itself is very simple – the bulk of the code is necessary to configure the system and create the testing infrastructure (in this case, an actual file to be read from disk).</span></span> <span data-ttu-id="36079-251">Это характерно для интеграционных тестов, которые зачастую требуют более тщательной настройки по сравнению с модульными тестами.</span><span class="sxs-lookup"><span data-stu-id="36079-251">This is typical for integration tests, which often require more complex setup work than unit tests.</span></span>

## <a name="functional-testing-aspnet-core-apps"></a><span data-ttu-id="36079-252">Функциональное тестирование приложений ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="36079-252">Functional Testing ASP.NET Core Apps</span></span>

<span data-ttu-id="36079-253">Для удобства функционального тестирования приложений ASP.NET Core используется класс TestServer.</span><span class="sxs-lookup"><span data-stu-id="36079-253">For ASP.NET Core applications, the TestServer class makes functional tests fairly easy to write.</span></span> <span data-ttu-id="36079-254">Настройка TestServer осуществляется с помощью WebHostBuilder так же, как и в обычном случае для приложения.</span><span class="sxs-lookup"><span data-stu-id="36079-254">You configure a TestServer using a WebHostBuilder, just as you normally do for your application.</span></span> <span data-ttu-id="36079-255">WebHostBuilder необходимо настроить так же, как реальный хост вашего приложения, однако при необходимости вы можете изменять любые его аспекты, чтобы упростить тестирование.</span><span class="sxs-lookup"><span data-stu-id="36079-255">This WebHostBuilder should be configured just like your application's real host, but you can modify any aspects of it that make testing easier.</span></span> <span data-ttu-id="36079-256">В большинстве случаев для тестирования можно использовать один и тот же TestServer, поэтому вы можете инкапсулировать его в повторно используемый метод (например, в базовый класс):</span><span class="sxs-lookup"><span data-stu-id="36079-256">Most of the time, you'll reuse the same TestServer for many test cases, so you can encapsulate it in a reusable method (perhaps in a base class):</span></span>

```cs
public abstract class BaseWebTest
{
    protected readonly HttpClient _client;
    protected string _contentRoot;

    public BaseWebTest()
    {
        _client = GetClient();
    }
    
    protected HttpClient GetClient()
    {
        var startupAssembly = typeof(Startup).GetTypeInfo().Assembly;
        _contentRoot = GetProjectPath("src", startupAssembly);
        var builder = new WebHostBuilder()
        .UseContentRoot(_contentRoot)
        .UseStartup&lt;Startup&gt;();
        var server = new TestServer(builder);
        var client = server.CreateClient();
        return client;
    }
}
```

<span data-ttu-id="36079-257">Метод GetProjectPath просто возвращает физический путь к веб-проекту (скачивание примера решения).</span><span class="sxs-lookup"><span data-stu-id="36079-257">The GetProjectPath method simply returns the physical path to the web project (download sample solution).</span></span> <span data-ttu-id="36079-258">В этом случае WebHostBuilder задает корень содержимого для веб-приложения и ссылку на тот же класс Startup, который используется реальным веб-приложением.</span><span class="sxs-lookup"><span data-stu-id="36079-258">The WebHostBuilder in this case simply specifies where the content root for the web application is, and references the same Startup class the real web application uses.</span></span> <span data-ttu-id="36079-259">Для работы с TestServer и отправки запросов к нему вы можете использовать стандартный тип System.Net.HttpClient.</span><span class="sxs-lookup"><span data-stu-id="36079-259">To work with the TestServer, you use the standard System.Net.HttpClient type to make requests to it.</span></span> <span data-ttu-id="36079-260">TestServer содержит полезный метод CreateClient, который предоставляет предварительно настроенный клиент, готовый для выполнения запросов к приложению, выполняемому на TestServer.</span><span class="sxs-lookup"><span data-stu-id="36079-260">TestServer exposes a helpful CreateClient method that provides a pre-configured client that is ready to make requests to the application running on the TestServer.</span></span> <span data-ttu-id="36079-261">Этот клиент (для приведенного выше базового теста задан защищенный элемент \_client) используется при написании функциональных тестов для приложения ASP.NET Core:</span><span class="sxs-lookup"><span data-stu-id="36079-261">You use this client (set to the protected \_client member on the base test above) when writing functional tests for your ASP.NET Core application:</span></span>

```cs
public class CatalogControllerGetImage : BaseWebTest
{
    [Fact]
    public async Task ReturnsFileContentResultGivenValidId()
    {
        var testFilePath = Path.Combine(_contentRoot, "pics//1.png");
        var expectedFileBytes = File.ReadAllBytes(testFilePath);
        var response = await _client.GetAsync("/catalog/pic/1");
        response.EnsureSuccessStatusCode();
        var streamResponse = await response.Content.ReadAsStreamAsync();
        byte[] byteResult;
        using (var ms = new MemoryStream())
        {
            streamResponse.CopyTo(ms);
            byteResult = ms.ToArray();
        }
        Assert.Equal(expectedFileBytes, byteResult);
    }
}
```

<span data-ttu-id="36079-262">Этот функциональный тест выполняет полный стек приложения MVC ASP.NET Core, включая все существующие фильтры, связыватели, ПО промежуточного слоя и т. д.</span><span class="sxs-lookup"><span data-stu-id="36079-262">This functional test exercises the full ASP.NET Core MVC application stack, including all middleware, filters, binders, etc. that may be in place.</span></span> <span data-ttu-id="36079-263">Он проверяет, что указанный маршрут ("/catalog/pic/1") возвращает ожидаемый массив байтов для файла, расположенного в известном месте.</span><span class="sxs-lookup"><span data-stu-id="36079-263">It verifies that a given route ("/catalog/pic/1") returns the expected byte array for a file in a known location.</span></span> <span data-ttu-id="36079-264">Для этого не настраивается реальный веб-сервер, что позволяет избежать большинства недостатков, связанных с тестированием на реальном веб-сервере (например, проблем с настройкой брандмауэра).</span><span class="sxs-lookup"><span data-stu-id="36079-264">It does so without setting up a real web server, and so avoids much of the brittleness that using a real web server for testing can experience (for example, problems with firewall settings).</span></span> <span data-ttu-id="36079-265">Функциональные тесты, выполняемые в отношении TestServer, как правило, медленнее интеграционных и модульных тестов, однако значительно быстрее тестов, которые проводятся по сети с использованием тестового веб-сервера.</span><span class="sxs-lookup"><span data-stu-id="36079-265">Functional tests that run against TestServer are usually slower than integration and unit tests, but are much faster than tests that would run over the network to a test web server.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="36079-266">[Назад] (work-with-data-in-asp-net-core-apps.md) [Далее] (development-process-for-azure.md)</span><span class="sxs-lookup"><span data-stu-id="36079-266">[Previous] (work-with-data-in-asp-net-core-apps.md) [Next] (development-process-for-azure.md)</span></span>
