---
title: "ASP.NET Core тестирования приложения MVC"
description: "Архитектора современных веб-приложений с помощью ASP.NET Core и Azure | ASP.NET Core тестирования приложения MVC"
author: ardalis
ms.author: wiwagn
ms.date: 10/08/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 4611ffa8334e124946e849306d3281b695830eb1
ms.sourcegitcommit: bbde43da655ae7bea1977f7af7345eb87bd7fd5f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2017
---
# <a name="test-aspnet-core-mvc-apps"></a>ASP.NET Core тестирования приложения MVC

> _«Если вас не устраивает модульное тестирование продукта, скорее всего клиентов не будет, например для тестирования, либо.»_
> _ - Анонимный -

## <a name="summary"></a>Сводка

Программное обеспечение любой сложности может произойти непредвиденный сбой в ответ на изменения. Таким образом проверка после внесения изменений является обязательным для всех, кроме самых стандартных (или наименьшей важности) приложения. Тестирование вручную является самым медленным, наиболее ресурсоемких бы надежный способ для тестирования программного обеспечения. К сожалению Если приложения не предназначены для тестирования, может быть единственный имеющийся. Приложения, написанные следующие архитектурные принципы располагаются в главе X должен модульного тестирования и приложения ASP.NET Core поддерживают автоматизированной интеграции и функционального тестирования также.

## <a name="kinds-of-automated-tests"></a>Виды автоматических тестов

Существует множество видов автоматических тестов для приложений. Самая простая, нижнего уровня тест — модульный тест. Немного более высокого уровня, тесты интеграции и функциональных тестов. Другие виды тесты как тесты пользовательского интерфейса, нагрузочные тесты, нагрузочные тесты и тесты состояния выходят за рамки данного документа.

### <a name="unit-tests"></a>Модульные тесты

Модульный тест проверяет определенной части логики приложения. Один дополнительные можно описать, указав ряд особенностей, которые не. Модульный тест не проверяет, как ваш код работает с зависимостей или инфраструктурой — проверяет, какие интеграции предназначены для. Модульный тест не проверка код написан на инфраструктуре: он работает или, если его найти не, зарегистрировать ошибку и кода для решения этой проблемы следует считать. Модульный тест выполняется полностью в памяти и в процессе. Он не взаимодействуют с файловой системы, сети или базы данных. Модульные тесты следует тестировать только в коде.

Очень быстро выполнять модульные тесты, благодаря тому, что они проверяют только единый блок кода, без внешних зависимостей. Таким образом можно выполнять наборы тестов из сотен модульных тестов в течение нескольких секунд. Выполните их как правило, в идеале перед каждой отправкой в репозитории управления общим источником, а наверняка каждые автоматизированной сборки на сервере сборки.

### <a name="integration-tests"></a>Интеграционные тесты

Несмотря на то, что это хороший способ инкапсуляции кода, взаимодействующая с инфраструктурой как файловых систем и баз данных, по-прежнему будет иметь некоторый код, и, возможно, необходимо проверить его. Кроме того необходимо проверить, кода и слои взаимодействующих должным образом при зависимостей приложения будут полностью устранены. Это отвечает интеграционные тесты. Интеграционные тесты обычно работать медленнее и сложнее в настройке, чем модульные тесты, так как они часто используют внешние зависимости и инфраструктуры. Таким образом следует избегать тестирования, которые могут тестов с помощью модульных тестов в тесты интеграции. Если данного сценария можно проверить с помощью модульного теста, следует проверить его с модульным тестом. Если это невозможно, рассмотрите возможность использования интеграционного теста.

Интеграционные тесты часто сталкиваются с более сложные установки и удаления процедуры, чем модульные тесты. Например интеграционного теста, который переходит к реальной базе данных потребуется способ возвращения базы данных в ее начальное состояние каждого тестового запуска. Мере добавляются новые тесты схему рабочей базы данных, эти сценарии постепенно увеличиваться в размере и сложности тестирования. Во многих системах больших оказывается нецелесообразным для выполнения полной наборы тестов интеграции на рабочих станциях разработчика перед возвратом изменений в общих систему управления версиями. В этих случаях интеграционные тесты могут выполняться на сервере сборки.

Класс реализации LocalFileImageService реализует логику для получения и возврат байт файла изображения из определенной папке присвоен идентификационный номер:

```cs
public class LocalFileImageService : IImageService
{
    private readonly IHostingEnvironment _env;
    public LocalFileImageService(IHostingEnvironment env)
    {
        _env = env;
    }
    public byte[] GetImageBytesById(int id)
    {
        try
        {
            var contentRoot = _env.ContentRootPath + "//Pics";
            var path = Path.Combine(contentRoot, id + ".png");
            return File.ReadAllBytes(path);
```

### <a name="functional-tests"></a>Функциональных тестов

Интеграционные тесты записываются с точки зрения разработчика, чтобы убедиться, что некоторые компоненты системы могут работать неправильно вместе. Функциональных тестов записываются с точки зрения пользователя и проверьте правильность системы, в зависимости от его требованиям. Следующий фрагмент предлагает Полезная аналогия для как можно рассматривать функциональных тестов, по сравнению с модульными тестами.

> «Много раз разработки системы приравнены к построение дома. Хотя эта аналогия не совсем правильно, мы можем расширить для понимания разницу между модульных и функциональных тестов. Модульное тестирование является аналогом построение инспектора, узле конструкции дома. Он предназначен для различных внутренних систем из дома, основой кадрирования, тока, коммуникации и т. д. Он обеспечивает (тестов), части дома будет работать неправильно и безопасно, то есть, соответствуют построение кода. Функциональных тестов в этом сценарии аналогичны подсветкой, этот же узле построения. Он предполагается, внутренних систем будет работать надлежащим образом, построение инспектор выполняет свою задачу. Подсветкой основное внимание уделено каким он будет как находящегося в этом дома. Он отвечает за внешний вид дома, различных комнаты научились размер, дома под нужды семейства, — это окна, в подходящее место для перехвата sun утра. Подсветкой выполняет функциональных тестов на дома. У него есть точки зрения пользователя. Построение инспектор выполняет модульные тесты для дома. Он содержит построитель перспективы».

Источник: [модульное тестирование и функциональных тестов](http://www.softwaretestingtricks.com/2007/01/unit-testing-versus-functional-tests.html)

Я хочу шрифта говоря» как разработчики отказа двумя способами: мы создаем самое неправильный или мы создаем неверный.» Модульные тесты убедитесь, что вы создаете очередь вправо; функциональных тестов убедитесь, что вы создаете правильно.

Поскольку функциональные тесты работают на уровне системы, могут потребоваться некоторые степень автоматизации пользовательского интерфейса. Как интеграционных тестов они обычно работают с каким-либо инфраструктуры тестирования также. Это делает их медленнее и еще более нестабильным, чем интеграции и модульные тесты. Необходимо иметь только столько функциональных тестов быть уверенным, как пользователи ожидают, что поведение системы.

### <a name="testing-pyramid"></a>Тестирование Пирамидальная

Martin Fowler написал о тестирования пирамиды, пример которой показан на рисунке 9-1.

![](./media/image9-1.png)

На рисунке 9-1 тестирование Пирамидальная

Различные уровни пирамиды и их относительные размеры представляют различные виды тестов и сколько необходимо для написания приложения. Как видите, рекомендуется иметь большой базы модульных тестов, поддерживаемых слой меньшего размера интеграционные тесты с собой еще меньше уровень функциональных тестов. Каждый слой следует в идеале только содержать тесты, не может быть выполнена должным образом на нижнем уровне. Имейте в виду тестирования пирамиды, когда вы пытаетесь решить, какая теста нужна для того или иного сценария.

### <a name="what-to-test"></a>Что делать в тест

Распространенной проблемой для разработчиков, которые имеют достаточного опыта работы с создание автоматических тестов тут какие для проверки. Хорошей отправной точкой является тестирование условной логики. В любом месте, что у вас есть метод с поведением, изменения на основании условный оператор (if-else, переключение, т. д.), можно начать работу по крайней мере несколько тестов, подтверждающие правильное поведение для определенных условий. Если код содержит ошибки, рекомендуется записи хотя бы один тест для «довольны пути» через код (завершилась без ошибок) и по крайней мере один тест для «жаль, что путь» (с ошибками или нетипичные результаты), чтобы убедиться, что приложение работает должным образом при возникновении ошибки. Наконец попробуйте сосредоточиться на тестирование вещей, которые могут вызвать сбой, а не уделять все внимание такие показатели, как объем протестированного кода. Обычно лучше, чем меньше, больше покрытия кода. Однако написание несколько дополнительных тестов очень сложными и важных метода обычно является лучше использовать времени, чем написание тестов для автосвойства только для улучшения метрики покрытия кода теста.

## <a name="organizing-test-projects"></a>Упорядочение тестовых проектов

Тестовые проекты могут быть упорядочены, однако работает наилучшим образом для вас. Это хороший способ разделения тесты по типу (модульный тест, тест интеграции) и что они предназначены для проверки (по проекту, пространством имен). Является ли такое разделение состоит из папок, содержащихся в одном проекте тестов или нескольких тестовых проектов является решение. Один проект является простым, но для крупных проектов с помощью много тестов или для упрощения выполнения разных наборах тестов можно иметь несколько различных тестовых проектов. Многие команды Упорядочить тестовые проекты на основе проекта, тестирования, для приложений с более чем несколькими проектами может привести к появлению большого количества тестовых проектов, особенно в том случае, если вы по-прежнему разбить их согласно вида тестов, в каждом проекте. Компрометация подход заключается в один проект каждого вида тестирования каждого приложения с папками в тестовых проектов для указания проекта (и класс) тестируемой.

Наиболее распространенный подход заключается в том, для организации проектов приложений, в папке «src» и тестовые проекты приложения в папке параллельного «тесты». Если вам пригодиться этой организации, можно создать соответствующий папки решений в Visual Studio.

![](./media/image9-2.png)

Рис. 9-2 организации теста в решении

Можно использовать любой платформы тестирования вы предпочитаете. Платформа xUnit работает хорошо и является то, что все тесты ASP.NET Core и EF Core языке. Можно добавить xUnit тестовый проект в Visual Studio с помощью шаблона, показанные на рисунке 9-3, или из CLI с помощью нового xunit dotnet.

![](./media/image9-3.png)

Рис. 9 — 3 добавьте xUnit тестовый проект в Visual Studio

### <a name="test-naming"></a>Именование теста

Имена, указывающие, что делает каждый тест следует присвоить имя тестов согласованным образом. Является одним из подходов было успешно с тестовых классов имя класса и метод, который они предназначены для проверки. Это приведет к много небольших тестовых классов, но упрощает очень понять, что каждый тест отвечает за. С именем класса теста, настройка для идентификации класса и метода, которое необходимо проверить чтобы указать поведение тестируемой можно использовать имя метода теста. Это должен быть ожидаемым поведением и ни входов ни предположения, должны возвращать такое поведение. Некоторые примеры имен тестов:

-   CatalogControllerGetImage.CallsImageServiceWithId

-   CatalogControllerGetImage.LogsWarningGivenImageMissingException

-   CatalogControllerGetImage.ReturnsFileResultWithBytesGivenSuccess

-   CatalogControllerGetImage.ReturnsNotFoundResultGivenImageMissingException

Вариация этого подхода завершает каждым именем класса теста с «Должно» и изменяет немного времени:

-   CatalogControllerGetImage**следует**. **Вызовите**ImageServiceWithId

-   CatalogControllerGetImage**следует**. **Журнал**WarningGivenImageMissingException

Некоторые команды Найти второй именования подход яснее, хотя немного более подробных сведений. В любом случае попробуйте использовать соглашение об именовании, которое обеспечивает представление о поведении тестового, чтобы в случае сбоя одного или нескольких тестов очевидна из их имен, какие варианты произошел сбой. Избегайте именования вы тесты которое отдаленно, такие как ControllerTests.Test1, как они предлагают нет значения, когда они отображаются в результатах теста.

Если следовать соглашение об именовании, как приведенная выше, создает множество небольших тестовых классов, рекомендуется для дальнейшей организации тесты с помощью папок и пространств имен. Рис. 9-4 показывает один из подходов к организация тестов по папкам в нескольких тестовых проектов.

![](./media/image9-4.png)

**Рис. 9-4.** Упорядочение тестовых классов на основе класса тестируемой папке.

Конечно Если класс конкретного приложения имеет множество методов тестируемой (и тем самым число тестовых классов), смысл поместить их в папку, соответствующую класс приложения. Эта организация ничем не отличается от как можно организовать файлы по папкам в другом месте. При наличии более чем на три или четыре связанных файлов в папке, содержащей много файлов, часто бывает полезно переместить их в собственной подпапке.

## <a name="unit-testing-aspnet-core-apps"></a>Тестирование приложений ASP.NET Core единицы

В хорошо спроектированные приложения ASP.NET Core большая часть сложности и бизнес-логики, будет инкапсулирован в бизнес-сущности и различных служб. Приложения ASP.NET MVC ядра, с контроллеров, фильтры, viewmodels и представления, требуется очень мало модульных тестов. Большинство функций данное действие находится за пределами сам метод. Тестирования ли Маршрутизация работает правильно и обработка ошибок глобального, не может выполняться эффективно с модульным тестом. Аналогичным образом любые фильтры, включая проверки модели и проверку подлинности и фильтры авторизации, не может быть модульного тестирования. Без этих источников поведение большинство методов действий обычно невелико элементарно, делегирование большая часть работы до служб, которые можно протестировать независимо от контроллера, который использует их.

Иногда необходимо рефакторинга кода в модульный тест его порядок. Зачастую это включает в себя определение абстракции и с помощью внедрения зависимости, для доступа к абстракции в код, который вы хотите протестировать, а не кодирование непосредственно на инфраструктуру. Например рассмотрим этот метод простое действие для отображения изображения.

```cs
[HttpGet("[controller]/pic/{id}")]
public IActionResult GetImage(int id)
{
    var contentRoot = _env.ContentRootPath + "//Pics";
    var path = Path.Combine(contentRoot, id + ".png");
    Byte[] b = System.IO.File.ReadAllBytes(path);
    return File(b, "image/png");
}
```

Модульное тестирование этого метода усложняла его прямых зависимостей от System.IO.File, который используется для чтения из файловой системы. Вы можете протестировать таким образом, чтобы он работает нужным образом, но это с реальными файлами относится к интеграционному тесту. Стоит отметить невозможно протестировать этот метод маршрута — будет показано, как это сделать с помощью функционального теста чуть ниже.

Если модульный тест поведение файловой системы невозможно напрямую и не может проверить маршрут, что существует для тестирования? Также после рефакторинга, чтобы сделать возможным модульное тестирование, вы можете заметить некоторые тестовые случаи и отсутствует поведения, такие как обработка ошибок. Что делает метод? Если файл не найден Что следует делать? В этом примере рефакторингу метод выглядит следующим образом:

```cs
[HttpGet("[controller]/pic/{id}")\]
public IActionResult GetImage(int id)
{
    byte[] imageBytes;
    try
    {
        imageBytes = _imageService.GetImageBytesById(id);
    }
    catch (CatalogImageMissingException ex)
    {
        _logger.LogWarning($"No image found for id: {id}");
        return NotFound();
    }
    return File(imageBytes, "image/png");
}
```

\_Средства ведения журнала и \_imageService введенного как зависимости. Теперь можно проверить, передается таким же идентификатором, который передается в метод действия \_imageService, и что полученные байты возвращаются как часть FileResult. Также можно проверить, происходит ошибка ведения журнала должным образом и, результат не найдено, возвращается, если изображение отсутствует, при условии, что это поведение важные приложения (то есть, не только временные код разработчика, добавлены диагностику проблем). Логика фактический файл был перемещен в отдельную реализацию службы и были включены для возврата конкретного приложения исключение в случае отсутствующий файл. Можно проверить Эта реализация независимо друг от друга, используя интеграционного теста.

## <a name="integration-testing-aspnet-core-apps"></a>Тестирование приложений ASP.NET Core интеграции

```cs
    }
        catch (FileNotFoundException ex)
        {
            throw new CatalogImageMissingException(ex);
        }
    }
}
```

Эта служба использует IHostingEnvironment так же, как и CatalogController, код был до рефакторинга в отдельной службе. Поскольку она только код в контроллер, который используется IHostingEnvironment зависимость был удален из CatalogController в конструктор.

Чтобы проверить, что эта служба работает правильно, необходимо создать файл образа известных тестирования и убедитесь, что служба возвращает его с учетом определенных входных данных. Следует позаботиться отказаться от использования макетов объектов на поведение, которое фактически необходимо проверить (в данном случае чтение из файловой системы). Однако макетов объектов, по-прежнему можно использовать для настройки интеграции тестов. В этом случае можно макета IHostingEnvironment, чтобы его ContentRootPath указывал на папку, которую вы собираетесь использовать для тестирования изображения. Полный рабочий интеграции тестового класса приведен ниже:

```cs
public class LocalFileImageServiceGetImageBytesById
{
    private byte[] _testBytes = new byte[] { 0x01, 0x02, 0x03 };
    private readonly Mock<IHostingEnvironment> _mockEnvironment = new Mock<IHostingEnvironment>();
    private int _testImageId = 123;
    private string _testFileName = "123.png";
    public LocalFileImageServiceGetImageBytesById()
    {
        // create folder if necessary
        Directory.CreateDirectory(Path.Combine(GetFileDirectory(), "Pics"));
        string filePath = GetFilePath(_testFileName);
        System.IO.File.WriteAllBytes(filePath, _testBytes);
        _mockEnvironment.SetupGet<string>(m => m.ContentRootPath).Returns(GetFileDirectory());
    }
    private string GetFilePath(string fileName)
    {
        return Path.Combine(GetFileDirectory(), "Pics", fileName);
        }
            private string GetFileDirectory()
        {
            var location = System.Reflection.Assembly.GetEntryAssembly().Location;
            return Path.GetDirectoryName(location);
        }

        [Fact]
        public void ReturnsFileContentResultGivenValidId()
        {
            var fileService = new LocalFileImageService(_mockEnvironment.Object);
            var result = fileService.GetImageBytesById(_testImageId);
            Assert.Equal(_testBytes, result);
        }
    }
```

> [!NOTE]
> что сам тест является очень простой большая часть кода необходим для настройки системы и создание инфраструктура тестирования (в данном случае фактический файл для чтения с диска). Это характерно для тестирования интеграции, которые часто требуют установки более сложных действий, чем модульные тесты.

## <a name="functional-testing-aspnet-core-apps"></a>Режим работы тестирование приложений ASP.NET Core

Для приложений ASP.NET Core TestServer класс упрощает функциональных тестов довольно для записи. TestServer, с помощью WebHostBuilder настраивается так же, как обычно для вашего приложения. Это WebHostBuilder должен быть настроен так же, как реальные ведущего приложения, но вы можете изменить все аспекты, которые упростить тестирование. В большинстве случаев, использовать какой-либо же TestServer для количество тестовых случаев, поэтому он может инкапсулировать в повторно используемый метод (возможно, в базовый класс):

```cs
public abstract class BaseWebTest
{
    protected readonly HttpClient _client;
    protected string _contentRoot;

    public BaseWebTest()
    {
        _client = GetClient();
    }
    
    protected HttpClient GetClient()
    {
        var startupAssembly = typeof(Startup).GetTypeInfo().Assembly;
        _contentRoot = GetProjectPath("src", startupAssembly);
        var builder = new WebHostBuilder()
        .UseContentRoot(_contentRoot)
        .UseStartup&lt;Startup&gt;();
        var server = new TestServer(builder);
        var client = server.CreateClient();
        return client;
    }
}
```

Getprojectpath-метод просто возвращает физический путь в веб-проект (Загрузка примера решения). WebHostBuilder в этом случае просто указывает, где — корневой элемент содержимого для веб-приложения, а ссылается на же класс запуска, используемых в реальных веб-приложения. Для работы с TestServer, используется стандартный тип System.Net.HttpClient делать запросы к нему. TestServer предоставляет полезные метод CreateClient, который предоставляет предварительно настроенный клиент, который будет готов для выполнения запросов для приложения, работающего на TestServer. Используйте этот клиент (присвоено защищенный \_участника клиент на базовый тест выше) при записи функциональных тестов для приложения ASP.NET Core:

```cs
public class CatalogControllerGetImage : BaseWebTest
{
    [Fact]
    public async Task ReturnsFileContentResultGivenValidId()
    {
        var testFilePath = Path.Combine(_contentRoot, "pics//1.png");
        var expectedFileBytes = File.ReadAllBytes(testFilePath);
        var response = await _client.GetAsync("/catalog/pic/1");
        response.EnsureSuccessStatusCode();
        var streamResponse = await response.Content.ReadAsStreamAsync();
        byte[] byteResult;
        using (var ms = new MemoryStream())
        {
            streamResponse.CopyTo(ms);
            byteResult = ms.ToArray();
        }
        Assert.Equal(expectedFileBytes, byteResult);
    }
}
```

Это функционального теста выполняет полный стек приложения ASP.NET Core MVC, включая все по промежуточного слоя, фильтры, связыватели, т. д., могут быть выполнены. Проверяет, что данный маршрут («/ каталога и pic-1») возвращает массив байтов, ожидаемый для файла в известном расположении. Выполняется без настройки реальных веб-сервера и поэтому позволяет избежать большую часть хрупкость, использование реальных веб-сервер для тестирования можно столкнуться (например, проблемы с параметрами брандмауэра). Функциональные тесты, выполняемые к TestServer обычно медленнее, чем интеграции и модульные тесты, но выполняется гораздо быстрее, чем тесты, которые будет выполняться по сети к серверу веб-теста.

>[!div class="step-by-step"]
[Предыдущие] (work-with-data-in-asp-net-core-apps.md) [Далее] (разработки процесс для azure.md)
