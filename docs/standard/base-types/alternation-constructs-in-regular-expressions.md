---
title: "Конструкции изменения в регулярных выражениях | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "регулярные выражения .NET Framework, конструкции изменения"
  - "конструкции изменения"
  - "шаблоны альтернативного соответствия"
  - "конструкции, изменение"
  - "сопоставление или/или"
  - "шаблоны альтернативного соответствия"
  - "регулярные выражения, конструкции изменения"
ms.assetid: 071e22e9-fbb0-4ecf-add1-8d2424f9f2d1
caps.latest.revision: 15
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 14
---
# Конструкции изменения в регулярных выражениях
<a name="top"></a> Конструкции изменения модифицируют регулярное выражение, включая сопоставление по принципу «либо\/или» или условное сопоставление. Платформа .NET Framework поддерживает три конструкции изменения.  
  
-   [Сопоставление шаблонов с &#124;](#Either_Or)  
  
-   [Условное сопоставление с \(?\(expression\)yes&#124;no\)](#Conditional_Expr)  
  
-   [Условное сопоставление на основе действительной захватываемой группы.](#Conditional_Group)  
  
<a name="Either_Or"></a>   
## Сопоставление шаблонов с &#124;  
 Можно использовать вертикальную черту \(`|`\) для сопоставления с любым набором шаблонов, где `|` отделяет каждый шаблон.  
  
 Как и класс положительных символов, символ `|` можно использовать для сопоставления с любым количеством отдельных символов. В следующем примере используется класс положительных символов и сопоставление с шаблоном либо\/или с символом `|` для обнаружения в строке всех вхождений слов gray или grey. В этом случае символ `|` создает регулярное выражение, которое является более подробным.  
  
 [!code-csharp[RegularExpressions.Language.Alternation#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation1.cs#1)]
 [!code-vb[RegularExpressions.Language.Alternation#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation1.vb#1)]  
  
 Возможные интерпретации регулярного выражения, использующего символ `|`, `\bgr(a|e)y\b`, показаны в следующей таблице.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`gr`|Соответствует символам gr.|  
|`(a&#124;e)`|Соответствует букве "a" или "e".|  
|`y\b`|Соответствует символу у на границе слова.|  
  
 Символ `|` может также использоваться для выполнения сопоставления или\/либо с несколькими символами или частями выражения, которые могут включать любую комбинацию символьных литералов и элементов языка регулярных выражений. \(Класс символов не предоставляет эту функцию\). В следующем примере символ `|` используется для извлечения либо номера социального страхования США \(SSN\), который представляет собой 9\-значный номер в формате *ццц*\-*цц*\-*цццц* или номер идентификации работодателя США \(EIN\), который состоит из 9 цифр в формате *цц*\-*ццццццц*.  
  
 [!code-csharp[RegularExpressions.Language.Alternation#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation2.cs#2)]
 [!code-vb[RegularExpressions.Language.Alternation#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation2.vb#2)]  
  
 Возможные интерпретации регулярного выражения `\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`(\d{2}-\d{7}&#124;\d{3}-\d{2}-\d{4})`|Сопоставьте любые из следующих значений: два десятичных знака, за которыми следует дефис и еще семь десятичных знаков; или последовательность из трех десятичных знаков, дефиса, двух десятичных знаков, еще одного дефиса и четырех десятичных знаков.|  
|`\d`|Совпадение должно заканчиваться на границе слова.|  
  
 [К началу](#top)  
  
<a name="Conditional_Expr"></a>   
## Условное сопоставление с выражением  
 Этот элемент языка пытается сопоставить один из двух шаблонов в зависимости от того, может ли он сопоставить первоначальный шаблон. Он имеет следующий синтаксис:  
  
 `(?(` *выражение* `)` *да* `|` *нет* `)`  
  
 где *expression* — первый сопоставляемый шаблон, *yes* — шаблон, который необходимо сопоставить, если сопоставлен шаблон *expression*, а *no* — это дополнительный шаблон, который необходимо сопоставить, если *expression* не сопоставлен. Обработчик регулярных выражений рассматривает *expression* как утверждение нулевой ширины, то есть обработчик регулярных выражений не перемещается в потоке входных значений после оценки *expression*. Следовательно, эта конструкция эквивалентна следующему.  
  
 `(?(?=` *выражение* `)` *да* `|` *нет* `)`  
  
 где `(?=`*expression*`)` — это конструкция утверждения нулевой ширины. \(Дополнительные сведения см. в разделе [Конструкции группирования](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).\) Поскольку обработчик регулярных выражений интерпретирует *expression* как привязку \(утверждение нулевой ширины\), *expression* должно представлять собой утверждение нулевой ширины \(дополнительные сведения см. в статье [Привязки](../../../docs/standard/base-types/anchors-in-regular-expressions.md)\) или часть выражения, которая также содержится в *yes*. В противном случае шаблон *yes* сопоставить невозможно.  
  
> [!NOTE]
>  Если *expression* является именованной или нумерованной группой захвата, конструкция чередования интерпретируется как тест захвата. Дополнительные сведения см. в разделе [Условное сопоставление на основе действительной захватываемой группы](#Conditional_Group). Другими словами, обработчик регулярных выражений не пытается сопоставить захваченную часть строки, а вместо этого выполняет проверку на наличие или отсутствие группы.  
  
 Следующий пример является вариантом примера, который отображается в разделе [Сопоставление шаблонов «либо\/или» с &#124;](#Either_Or). Условное сопоставление используется, чтобы определить, являются ли первые три символа после границы слова двумя цифрами и дефисом. Если да, предпринимается попытка сопоставить Идентификационный номер работодателя США \(EIN\). Если нет, предпринимается попытка сопоставить Номер социального страхования США \(SSN\).  
  
 [!code-csharp[RegularExpressions.Language.Alternation#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation3.cs#3)]
 [!code-vb[RegularExpressions.Language.Alternation#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation3.vb#3)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`(?(\d{2}-)`|Определите, состоят ли следующие три символа из двух цифр, за которыми следуют дефис.|  
|`\d{2}-\d{7}`|Если предыдущий шаблон сопоставлен, сопоставьте две цифры с дефисом, за которыми следуют еще семь цифр.|  
|`\d{3}-\d{2}-\d{4}`|Если предыдущий шаблон не сопоставлен, сопоставьте три цифры, дефис, две цифры, еще один дефис и еще четыре цифры.|  
|`\b`|Соответствует границе слова.|  
  
 [К началу](#top)  
  
<a name="Conditional_Group"></a>   
## Условное сопоставление на основе действительной захватываемой группы  
 Этот элемент языка пытается сопоставить один из двух шаблонов, в зависимости от того, соответствует ли он указанной группе записи. Он имеет следующий синтаксис:  
  
 `(?(` *имя* `)` *да* `|` *нет* `)`  
  
 или  
  
 `(?(` *number* `)` *да* `|` *нет* `)`  
  
 где *name* — имя, а *number* — номер захватываемой группы, *yes* — сопоставляемое выражение, если для *name* или *number* имеется соответствие, а *no* — это дополнительное выражение для сопоставления при отсутствии соответствия.  
  
 Если *name* не соответствует имени захватываемой группы, которая используется в шаблоне регулярного выражения, конструкция изменения интерпретируется как проверка выражения, как было описано в предыдущем разделе. Как правило, это означает, что *expression* имеет значение `false`. Если *number* не соответствует нумерованной группе захвата, используемой в шаблоне регулярного выражения, обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  
  
 Следующий пример является вариантом примера, который отображается в разделе [Сопоставление шаблонов «либо\/или» с &#124;](#Either_Or). В нем используется захватываемая группа с именем `n2`, которая состоит из двух цифр и дефиса. Конструкция изменения проверяет, сопоставлена ли эта группа захвата в строке ввода. Если да, конструкция изменения пытается сопоставить последние семь цифр девятизначного Идентификационный номер работодателя США \(EIN\). В противном случае она пытается сопоставить девятизначный Номер социального страхования США \(SSN\).  
  
 [!code-csharp[RegularExpressions.Language.Alternation#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation4.cs#4)]
 [!code-vb[RegularExpressions.Language.Alternation#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation4.vb#4)]  
  
 Возможные интерпретации шаблона регулярного выражения `\b(?<n2>\d{2}-)*(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`(?<n2>\d{2}-)*`|Сопоставьте нулевое или единичное вхождение двух цифр с дефисом. Установка для группы имени `n2`.|  
|`(?(n2)`|Проверка наличия сопоставления `n2` во входной строке.|  
|`)\d{7}`|Если есть сопоставление `n2`, сопоставляются семь десятичных цифр.|  
|`&#124;\d{3}-\d{2}-\d{4}`|Если сопоставления нет `n2`, сопоставляются три десятичных цифры, дефис, две десятичных цифры, еще один дефис и четыре десятичных цифры.|  
|`\b`|Соответствует границе слова.|  
  
 В следующем примере показана вариация этого примера, в котором вместо именованной группы используется нумерованная. Шаблон регулярного выражения выглядит следующим образом: `\b(\d{2}-)*(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`  
  
 [!code-csharp[RegularExpressions.Language.Alternation#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation5.cs#5)]
 [!code-vb[RegularExpressions.Language.Alternation#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation5.vb#5)]  
  
## См. также  
 [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)