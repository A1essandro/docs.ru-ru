---
title: "Кванторы в регулярных выражениях | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "регулярные выражения, квантификаторы"
  - "метасимволы, квантификаторы"
  - "минимальные кванторы сопоставления"
  - "кванторы в регулярных выражениях"
  - "регулярные выражения .NET Framework, квантификаторы"
  - "кванторы"
  - "ленивые кванторы"
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Кванторы в регулярных выражениях
Кванторы определяют количество экземпляров символа, группы или класса символов, которое должно присутствовать во входных данных, чтобы было зафиксировано совпадение.  В следующей таблице перечислены кванторы, поддерживаемые платформой .NET Framework.  
  
|Жадный квантор|Ленивый квантор|Описание|  
|--------------------|---------------------|--------------|  
|`*`|`*?`|Выделить ноль или несколько раз.|  
|`+`|`+?`|Выделить один или несколько.|  
|`?`|`??`|Выделить ноль или один раз.|  
|`{` *n* `}`|`{` *n* `}?`|Выделяет строго *n* раз.|  
|`{` *n* `,}`|`{` *n* `,}?`|Выделяет как минимум *n* раз.|  
|`{` *n* `,` *m* `}`|`{` *n* `,` *m* `}?`|Выделяет от *n* до *m* раз.|  
  
 Количества `n` и `m` являются целочисленными константами.  Обычно кванторы "жадные"; они заставляют обработчик регулярных выражений выделить максимально возможное число вхождений определенного шаблона.  Добавление символа `?` в квантор делает его отложенным; это приводит к тому, что обработчик регулярных выражений пытается искать так мало вхождений, как это возможно.  Полное описание различий между "жадными" и "ленивыми" кванторами см. в разделе [Жадные и ленивые кванторы](#Greedy) далее в этой теме.  
  
> [!IMPORTANT]
>  Квантификаторы вложенности \(например, шаблон регулярного выражения `(a*)*`\) могут увеличить количество сравнений, которые должен выполнять обработчик регулярных выражений, как экспоненциальная функция количества символов во входной строке.  Дополнительные сведения об этом поведении и способах его обхода см. в разделе [Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
## Кванторы регулярных выражений  
 В следующих разделах перечислены кванторы, поддерживаемые регулярными выражениями платформы .NET Framework.  
  
> [!NOTE]
>  Если в шаблоне регулярных выражений встречаются символы \*, \+, ?, { и }, то обработчик регулярных выражений интерпретирует их как кванторы или как часть конструкций кванторов, если только они не включаются в [класс символов](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).  Чтобы они интерпретировались как символы\-литералы за пределами класса символов, необходимо ставить перед ними escape\-символ — обратную косую черту.  Например, строка `\*` в шаблоне регулярного выражения интерпретируется как литеральный символ звездочки \("\*"\).  
  
### Выделить ноль или несколько раз: \*  
 Квантор `*` выделяет предыдущие элементы, повторяющиеся ноль или несколько раз.  Это свойство эквивалентно квантору `{0,}`.  `*` — жадный квантор, отложенным эквивалентом которого является квантор `*?`.  
  
 В следующем примере показано, как использовать это регулярное выражение.  Пять из девяти чисел в исходной строке соответствуют заданному шаблону, четыре числа \(`95`, `929`, `9129` и `9919`\) ему не соответствуют.  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`91*`|Выделяет "9" с последующими символами "1" \(если они есть\).|  
|`9*`|Выделить ноль или больше символов "9\).|  
|`\b`|Конец на границе слова.|  
  
### Выделить один или несколько: \+  
 Квантор `+` выделяет предыдущие элементы, повторяющиеся один или несколько раз.  Этот параметр аналогичен параметру `{1,}`.  `+` — жадный квантор, отложенным эквивалентом которого является квантор `+?`.  
  
 Например, с помощью регулярного выражения `\ban+\w*?\b` осуществляется поиск целых слов, которые начинаются с буквы `a`, за которой следует одна или несколько букв `n`.  В следующем примере показано, как использовать это регулярное выражение.  Регулярное выражение соответствует словам `an`, `annual`, `announcement` и `antique` и не соответствует словам `autumn` и `all`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`an+`|Выделяет "a" с последующими символами "n" один или несколько раз.|  
|`\w*?`|Выделяет буквенный символа минимальное количество раз \(если они есть\).|  
|`\b`|Конец на границе слова.|  
  
### Выделить ноль или один раз: ?  
 Квантор `?` выделяет предыдущие элементы, повторяющиеся ноль или один раз.  Этот параметр аналогичен параметру `{0,1}`.  `?` — жадный квантор, отложенным эквивалентом которого является квантор `??`.  
  
 Например, с помощью регулярного выражения `\ban?\b` осуществляется поиск целых слов, которые начинаются с буквы `a`, за которой следует одна буква `n` или не следует ни одной такой буквы.  Иными словами, предпринимается попытка найти слова `a` и `an`.  В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`an?`|Выделяет "a" с последующими символами "n" \(если они есть\).|  
|`\b`|Конец на границе слова.|  
  
### Выделяет строго n раз: {n}  
 Квантор `{`*n*`}` выделяет предыдущий элемент ровно *n* раз, где *n* — это любое целое число.  `{`*n*`}` — жадный квантор, отложенным эквивалентом которого является квантор `{`*n*`}?`.  
  
 Например, с помощью регулярного выражения `\b\d+\,\d{3}\b` осуществляется поиск границы слова, за которой следует один или более десятичных знаков, еще три десятичных знака и граница слова.  В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\,`|Выделяет символ запятой.|  
|`\d{3}`|Совпадение с тремя десятичными цифрами.|  
|`\b`|Конец на границе слова.|  
  
### Выделяет как минимум n раз: {n,}  
 Квантор `{`*n*`,}` выделяет предыдущий элемент хотя бы *n* раз, где *n* — это любое целое число.  `{`*n*`,}` — жадный квантор, отложенным эквивалентом которого является квантор `{`*n*`}?`.  
  
 Например, с помощью регулярного выражения `\b\d{2,}\b\D+` осуществляется поиск границы слова, за которой следует по крайней мере два десятичных знака, граница слова и знак, не являющийся числом.  В следующем примере показано, как использовать это регулярное выражение.  Регулярное выражение не соответствует фразе `"7 days"`, потому что фраза содержит всего один десятичный знак, но соответствует фразам `"10 weeks and 300 years"`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`\d{2,}`|Выделяет хотя бы две десятичных цифры.|  
|`\b`|Соответствует границе слова.|  
|`\D+`|Выделяет хотя бы одну цифру, не являющуюся десятичной .|  
  
### Выделяет от n до m раз: {n, m}  
 Квантор `{`*n*`,`*m*`}` выделяет предыдущий элемент минимум *n* раз, но не больше *m* раз, где *n* и *m* — целые числа.  `{`*n*`,`*m*`}` — жадный квантор, отложенным эквивалентом которого является квантор `{`*n*`,`*m*`}?`.  
  
 В следующем примере с помощью регулярного выражения `(00\s){2,4}` осуществляется поиск от двух до четырех вхождений двух нулей, за которыми следует пробел.  Обратите внимание, что в конце входной строки имеются пять вхождений этого фрагмента при максимуме в четыре вхождения.  Однако только начало этой части строки \(до пробела и пятой пары нулей\) соответствует шаблону регулярного выражения.  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### Выделить ноль или несколько раз \(ленивое совпадение\): \*?  
 Квантор `*?` совпадает с предыдущим элементом ноль или более раз, но как можно меньшее число раз.  Это ленивый квантор, дополняющий жадный квантор `*`.  
  
 В следующем примере с помощью регулярного выражения `\b\w*?oo\w*?\b` осуществляется поиск всех слов, содержащих строку `oo`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`\w*?`|Соответствует нулю или минимально возможному числу буквенных символов.|  
|`oo`|Выделить строку "oo".|  
|`\w*?`|Соответствует нулю или минимально возможному числу буквенных символов.|  
|`\b`|Завершить на границе слова.|  
  
### Выделить один или несколько раз \(ленивое совпадение\): \+?  
 Квантор `+?` совпадает с предыдущим элементом один или несколько раз, но как можно меньшее число раз.  Это ленивый квантор, дополняющий жадный квантор `+`.  
  
 Например, с помощью регулярного выражения `\b\w+?\b` осуществляется поиск одного или нескольких символов, разделенных границами слов.  В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### Выделить ноль или один раз \(ленивое совпадение\): ??  
 Квантор `??` совпадает с предыдущим элементом 0 или 1 раз, но как можно меньшее число раз.  Это ленивый квантор, дополняющий жадный квантор `?`.  
  
 Например, регулярное выражение `^\s*(System.)??Console.Write(Line)??\(??` пытается сопоставить строки "Console.Write" или "Console.WriteLine".  Строка может также включать System. перед Console, за ней может следовать открывающая скобка.  Искомый текст должен находиться в начале строки, хотя перед ним может стоять пробел.  В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`^`|Выделить начало входного потока.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`(System.)??`|Выделить ноль или одно вхождение строки "System.".|  
|`Console.Write`|Соответствует строке "Console.Write".|  
|`(Line)??`|Выделить ноль или одно вхождение строки "Line".|  
|`\(??`|Выделить ноль или одно вхождение открывающей скобки.|  
  
### Выделяет строго n раз \(ленивое совпадение\): {n}?  
 Квантор `{`*n*`}?` выделяет предыдущий элемент ровно `n` раз, где *n* — это любое целое число.  Это ленивый квантор, дополняющий жадный квантор `{`*n*`}+`.  
  
 В следующем примере регулярное выражение `\b(\w{3,}?\.){2}?\w{3,}?\b` используется для определения адреса веб\-сайта.  Обратите внимание, что есть совпадение с www.microsoft.com и msdn.microsoft.com, но нет совпадения с mywebsite или mycompany.com.  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`(\w{3,}?\.)`|Выделяет по крайней мере 3 буквенных символа как можно меньшее количество раз, за которыми следует символ точки.  Это первая группа записи.|  
|`(\w{3,}?\.){2}?`|Выделить шаблон в первой группе два раза, но как можно меньшее количество раз.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
### Выделяет как минимум n раз \(ленивое совпадение\): {n,}?  
 Квантор `{`*n*`,}?` выделяет предыдущий элемент хотя бы `n` раз \(где *n* — это любое целое число\), но как можно меньшее количество раз.  Это ленивый квантор, дополняющий жадный квантор `{`*n*`,}`.  
  
 См. пример использования квантора `{`*n*`}?` в предыдущем разделе.  В регулярном выражении из этого примера квантор `{`*n*`,}` используется для поиска строки, состоящей по крайней мере из трех знаков, после которых стоит точка.  
  
### Выделяет от n до m раз \(ленивое совпадение\): {n, m}?  
 Квантор `{`*n*`,`*m*`}?` выделяет предыдущий элемент от `n` до `m` раз \(где *n* и *m* — целые числа\), но как можно меньшее число раз.  Это ленивый квантор, дополняющий жадный квантор `{`*n*`,`*m*`}`.  
  
 В следующем примере регулярное выражение `\b[A-Z](../../../amples/snippets/visualbasic/VS_Snippets_Remoting/SoapAttributes1/VB/s.vb){1,10}?[.!?]` соответствует фразам, содержащим от одного до десяти слов.  Ему соответствуют все приложения исходной строки кроме одного предложения, длина которого составляет 18 слов.  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 В следующей таблице представлено определение шаблона регулярных выражений.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Начало на границе слова.|  
|`[A-Z]`|Выделяет символ верхнего регистра от А до Z.|  
|`(\w*\s+)`|Выделить ноль или несколько буквенных символов, за которыми следует один или несколько символов пробела.  Это первая группа записи.|  
|`{1,10}?`|Выделить предыдущий шаблон от 1 до 10 раз, но как можно меньшее число раз.|  
|`[.!?]`|Выделяет любой из знаков препинания ".", "\!" или "?".|  
  
<a name="Greedy"></a>   
## Жадные и ленивые квантификаторы  
 У некоторых квантификаторов есть две версии.  
  
-   Жадная версия.  
  
     Жадный квантор пытается найти максимально возможное число соответствий элемента.  
  
-   Нежадная \(ленивая\) версия.  
  
     При использовании нежадных кванторов предпринимается попытка найти минимально возможное число соответствий элемента.  Чтобы превратить "жадный" квантификатор в "отложенный" квантификатор, достаточно добавить `?`.  
  
 Представьте простое регулярное выражение, позволяющее находить последние четыре цифры в числовой строке, например в номере кредитной карты.  Версия этого выражения с жадным квантификатором `*` будет иметь вид `\b.*([0-9]{4})\b`.  Однако если строка содержит два числа, то с помощью такого регулярного выражения будут найдены только последние четыре цифры второго числа, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 Регулярное выражение не совпадает с первым числом, поскольку при использовании квантификатора `*` предпринимается попытка найти максимально возможное число совпадений с предыдущим элементом во всей строке, и поэтому совпадение находится только в конце строки.  
  
 Это не то, что нам нужно.  Вместо этого можно использовать ленивый квантор `*?` ``  для извлечения цифр из обоих чисел, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 В большинстве случаев регулярные выражения с жадными и ленивыми квантификаторами возвращают одни и те же результаты.  Результаты обычно различаются, если в регулярных выражениях используется подстановочный метазнак `.`, который соответствует любому знаку.  
  
## Кванторы и пустые соответствия  
 Квантификаторы `*`, `+` и `{`*n*`,`*m*`}`, а также их "отложенные" аналоги никогда не повторяются после пустого соответствия, если найдено минимальное количество фиксаций.  Это правило предотвращает вхождение квантификаторов в бесконечные циклы при пустых соответствиях частей выражений, если максимальное количество возможных фиксаций группы бесконечно или приближено к бесконечному.  
  
 Например, в следующем коде показан результат вызова метода <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=fullName> с шаблоном регулярного выражения `(a?)*`, который соответствует ноль или один символ "a" ноль или более раз.  Обратите внимание, что отдельная группа записи записывает каждое вхождение "а", как и <xref:System.String.Empty?displayProperty=fullName>, но второго пустого совпадения нет, потому что первое пустое совпадение предписывает квантификатору прекратить повторение.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 Чтобы увидеть практическое различие между группой фиксации, определяющей минимальное и максимальное количество фиксаций, и группой, определяющей фиксированное количество фиксаций, воспользуйтесь шаблонами регулярных выражений `(a\1|(?(1)\1)){0,2}` и `(a\1|(?(1)\1)){2}`.  Оба регулярных выражения состоят из одной группы записи, которая определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`(a\1`|Каждое из выражений сопоставляет "a" вместе со значением первой группы записи ...|  
|`&#124;(?(1)`|… или проверьте, была ли определена первая записанная группа. \(Обратите внимание, что конструкция `(?(1)` не определяет группу записи.\)|  
|`\1))`|Если первая сохраненная группа существует, сопоставьте ее значение.  Если группа не существует, группа будет соответствовать <xref:System.String.Empty?displayProperty=fullName>.|  
  
 Первое регулярное выражение пытается сопоставить этот шаблон от 0 до двух раз; второе, ровно два раза.  Поскольку первый шаблон достигает своего минимального количества записей при первой записи значения <xref:System.String.Empty?displayProperty=fullName>, он не повторяет попытку сопоставить `a\1`; квантификатор `{0,2}` допускает только пустые соответствия в последней итерации.  Напротив, второе регулярное выражение соответствует "а", потому что оно вычисляет `a\1` второй раз; минимальное число итераций \(2\) предписывает обработчику выполнять повтор после пустого соответствия.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## См. также  
 [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)   
 [Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)