---
title: "кванторы в регулярных выражениях"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
caps.latest.revision: "22"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: ab06aa0c331c8cbd4c8986cced29334046f30264
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="quantifiers-in-regular-expressions"></a>кванторы в регулярных выражениях
Квантификаторы определяют количество экземпляров символа, группы или класса символов, которое должно присутствовать во входных данных, чтобы было зафиксировано совпадение.  В приведенной ниже таблице перечислены квантификаторы, поддерживаемые платформой .NET.  
  
|Жадный квантификатор|Ленивый квантификатор|Описание|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|Совпадение ноль или несколько раз.|  
|`+`|`+?`|Совпадение один или несколько раз.|  
|`?`|`??`|Совпадение ноль или один раз.|  
|`{` *n* `}`|`{` *n* `}?`|Точное соответствие  *n*  раз.|  
|`{` *n* `,}`|`{` *n* `,}?`|По крайней мере соответствует  *n*  раз.|  
|`{` *n* `,` *м* `}`|`{` *n* `,` *м* `}?`|Выделяет от  *n*  для *m* раз.|  
  
 Количества `n` и `m` являются целочисленными константами. Обычно квантификаторы "жадные" — они заставляют обработчик регулярных выражений выделить максимально возможное число вхождений определенного шаблона. Добавление символа `?` в квантификатор делает его отложенным (или ленивым). Это приводит к тому, что обработчик регулярных выражений пытается сопоставить так мало вхождений, как это возможно. Полное описание различий между "жадными" и "ленивыми" квантификаторами см. в разделе [Жадные и ленивые квантификаторы](#Greedy) далее в этой статье.  
  
> [!IMPORTANT]
>  Вложенные квантификаторы (например, шаблон регулярного выражения `(a*)*`) могут увеличить количество сравнений, которые должен выполнять обработчик регулярных выражений, как экспоненциальная функция количества символов во входной строке. Дополнительные сведения о это поведение и его обходные пути см. в разделе [поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
## <a name="regular-expression-quantifiers"></a>Квантификаторы регулярных выражений  
 В следующих разделах перечислены квантификаторы, поддерживаемые регулярными выражениями платформы .NET.  
  
> [!NOTE]
>  Если *, +,?, {, и} символы встречаются в шаблоне регулярного выражения, обработчик регулярных выражений интерпретирует их как кванторы или как часть конструкции квантификатор, если они включены в [класс символов](../../../docs/standard/base-types/character-classes-in-regular-expressions.md). Чтобы они интерпретировались как символы-литералы за пределами класса символов, необходимо ставить перед ними escape-символ — обратную косую черту. Например, строка `\*` в регулярном выражении шаблон интерпретируется как символ звездочки («\*») символов.  
  
### <a name="match-zero-or-more-times-"></a>Совпадение ноль или несколько раз: *  
 Квалификатор `*` выделяет предыдущий элемент, повторяющийся ноль или более раз. Это эквивалентно `{0,}` квантификатор. `*`является жадный квантор, отложенным эквивалентом является `*?`.  
  
 В следующем примере показано, как использовать это регулярное выражение. Пять из девяти чисел в исходной строке соответствуют заданному шаблону, четыре числа (`95`, `929`, `9129` и `9919`) — нет.  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`91*`|Совпадение с символом "9", за которыми следует ноль или более символов "1".|  
|`9*`|Выделить ноль или больше символов "9".|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-one-or-more-times-"></a>Совпадение один или несколько раз: +  
 `+` Квантификатор соответствует предыдущий элемент повторяется один или несколько раз. Это эквивалентно `{1,}`. `+`является жадный квантор, отложенным эквивалентом является `+?`.  
  
 Например, с помощью регулярного выражения `\ban+\w*?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна или несколько букв `n`. В следующем примере показано, как использовать это регулярное выражение. Регулярное выражение соответствует словам `an`, `annual`, `announcement` и `antique` и не соответствует словам `autumn` и `all`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`an+`|Совпадение с "a"с последующим одним или несколькими символами "n".|  
|`\w*?`|Совпадение со словообразующим символом ноль или несколько раз (по возможности минимальное количество раз).|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-zero-or-one-time-"></a>Совпадение ноль или один раз: ?  
 `?` Квантор выделяет предыдущий элемент ноль или один раз. Это эквивалентно `{0,1}`. `?`является жадный квантор, отложенным эквивалентом является `??`.  
  
 Например, с помощью регулярного выражения `\ban?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна буква `n` или не следует ни одной такой буквы. Иными словами, предпринимается попытка найти слова `a` и `an`. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`an?`|Совпадение с "a"с последующими символами "n" (при их наличии).|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-exactly-n-times-n"></a>Совпадение ровно n раз: {n}  
 `{`  *n*  `}` Квантор выделяет предыдущий элемент повторяется ровно  *n*  раз, где  *n* — любое целое число. `{`*n*`}`является жадный квантор, отложенным эквивалентом является `{`  *n*  `}?`.  
  
 Например, с помощью регулярного выражения `\b\d+\,\d{3}\b` осуществляется поиск границы слова, за которой следует один или более десятичных знаков, еще три десятичных знака и граница слова. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\,`|Совпадение с символом запятой.|  
|`\d{3}`|Совпадение с тремя десятичными цифрами.|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-at-least-n-times-n"></a>Совпадение как минимум n раз: {n,}  
 `{`  *n*  `,}` Квантор выделяет предыдущий элемент повторяется по крайней мере  *n*  раз, где  *n* — любое целое число. `{`*n*`,}`является жадный квантор, отложенным эквивалентом является `{`  *n*  `}?`.  
  
 Например, с помощью регулярного выражения `\b\d{2,}\b\D+` осуществляется поиск границы слова, за которой следует по крайней мере два десятичных знака, граница слова и знак, не являющийся числом. В следующем примере показано, как использовать это регулярное выражение. Регулярное выражение не соответствует фразу `"7 days"` , так как он содержит всего один десятичный знак, но соответствует фразах `"10 weeks and 300 years"`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\d{2,}`|Совпадение как минимум с двумя десятичными цифрами.|  
|`\b`|Соответствует границе слова.|  
|`\D+`|Совпадение как минимум с одной цифрой, не являющейся десятичной.|  
  
### <a name="match-between-n-and-m-times-nm"></a>Совпадение от n до m раз: {n,m}  
 `{`  *n*  `,` *m* `}` квантор выделяет предыдущий элемент повторяется по крайней мере  *n*  время, но не более чем *m* раз, где  *n*  и *m* являются целыми числами. `{`*n*`,`*m* `}` является жадный квантор, отложенным эквивалентом является `{`  *n*  `,` *m*`}?`.  
  
 В следующем примере с помощью регулярного выражения `(00\s){2,4}` осуществляется поиск от двух до четырех вхождений двух нулей, за которыми следует пробел. Обратите внимание, что в конце входной строки имеются пять вхождений этого фрагмента при максимуме в четыре вхождения. Однако только начало этой части строки (до пробела и пятой пары нулей) соответствует шаблону регулярного выражения.  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a>Совпадение ноль или несколько раз (ленивое совпадение): *?  
 `*?` Квантор выделяет предыдущий элемент повторяется ноль или более раз, но как можно меньшее число раз. Это ленивый квантор жадный квантификатор `*`.  
  
 В следующем примере регулярное выражение `\b\w*?oo\w*?\b` сопоставляет все слова, которые содержат строку `oo`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\w*?`|Совпадение с нулем или минимально возможным числом словообразующих символов.|  
|`oo`|Совпадение со строкой "oo".|  
|`\w*?`|Совпадение с нулем или минимально возможным числом словообразующих символов.|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-one-or-more-times-lazy-match-"></a>Совпадение один или несколько раз (ленивое совпадение): +?  
 `+?` Квантор выделяет предыдущий элемент повторяется один или несколько раз, но как можно меньшее число раз. Это ленивый квантор жадный квантификатор `+`.  
  
 Например, регулярное выражение `\b\w+?\b` соответствует одному или нескольким символам, разделенным границами слов. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a>Совпадение ноль или один раз (ленивое совпадение): ??  
 `??` Квантор выделяет предыдущий элемент ноль или один раз, но как можно меньшее число раз. Это ленивый квантор жадный квантификатор `?`.  
  
 Например, регулярное выражение `^\s*(System.)??Console.Write(Line)??\(??` пытается сопоставить строки "Console.Write" или "Console.WriteLine". Строка может также включать "System." перед "Console", за ней может следовать открывающая скобка. Искомый текст должен находиться в начале строки, хотя перед ним может стоять пробел. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Соответствует концу входной строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`(System.)??`|Совпадение с нулевым или единичным вхождением строки "System.".|  
|`Console.Write`|Совпадение со строкой "Console.Write".|  
|`(Line)??`|Совпадение с нулевым или единичным вхождением строки "Line".|  
|`\(??`|Совпадение с нулем или одним экземпляром открывающих круглых скобок.|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a>Совпадение ровно n раз (ленивое совпадение): {n}?  
 `{`  *n*  `}?` Квантор выделяет предыдущий элемент повторяется ровно `n` раз, где  *n*  — любое целое число. Это ленивый квантор жадный квантификатор `{`  *n*  `}+`.  
  
 В следующем примере регулярное выражение `\b(\w{3,}?\.){2}?\w{3,}?\b` используется для определения адреса веб-сайта. Обратите внимание, что есть совпадение с "www.microsoft.com" и "msdn.microsoft.com", но нет совпадения с "mywebsite" или "mycompany.com".  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`(\w{3,}?\.)`|Совпадение с минимум тремя словообразующими символами как можно меньшее количество раз, зак которыми следует символ точки. Это первая группа записи.|  
|`(\w{3,}?\.){2}?`|Совпадение с шаблоном в первой группе два раза, но как можно меньшее количество раз.|  
|`\b`|Сопоставление заканчивается на границе слова.|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a>Совпадение как минимум n раз (ленивое совпадение): {n,}?  
 `{`  *n*  `,}?` Квантор выделяет предыдущий элемент повторяется по крайней мере `n` раз, где  *n*  — любое целое число, но как можно меньшее число раз невозможно. Это ленивый квантор жадный квантификатор `{`  *n*  `,}`.  
  
 Далее приведен пример `{`  *n*  `}?` квантификатор иллюстрация предыдущего раздела. В регулярном выражении, в этом примере используется `{`  *n*  `,}` квантификатор для сопоставления строки, которая содержит менее трех символов, за которым следует.  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a>Совпадение от n до m раз (ленивое совпадение): {n,m}?  
 `{`  *n*  `,` *m* `}?` квантификатор выделяет предыдущий элемент между `n` и `m` раз, где  *n*  и *m* — целые числа, но как можно меньшее число раз. Это ленивый квантор жадный квантификатор `{`  *n*  `,` *m*`}`.  
  
 В следующем примере регулярное выражение `\b[A-Z](\w*\s+){1,10}?[.!?]` сопоставляет фразы, содержащие от одного до десяти слов. Ему соответствуют все предложения в исходной строке кроме одного, длина которого составляет 18 слов.  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`[A-Z]`|Совпадение с любым символом верхнего регистра от А до Z.|  
|`(\w*\s+)`|Совпадение с нулем или несколькими словообразующими символами, за которыми следует один или несколько символов пробела. Это первая захватываемая группа.|  
|`{1,10}?`|Совпадение с предыдущим шаблоном от 1 до 10 раз, но как можно меньшее количество раз.|  
|`[.!?]`|Совпадение с любым из знаков препинания ".", "!" или "?".|  
  
<a name="Greedy"></a>   
## <a name="greedy-and-lazy-quantifiers"></a>Жадные и ленивые квантификаторы  
 У некоторых квантификаторов есть две версии.  
  
-   Жадная версия.  
  
     Жадный квантификатор пытается найти максимально возможное число соответствий элемента.  
  
-   Нежадное (ленивая) версия.  
  
     При использовании нежадных идентификаторов предпринимается попытка найти минимально возможное число соответствий элемента. Жадный квантификатор можно превратить в ленивый квантификатор, просто добавляя `?`.  
  
 Представьте простое регулярное выражение, позволяющее находить последние четыре цифры в числовой строке, например в номере кредитной карты. Регулярное выражение, которое использует версию `*` — жадный квантификатор `\b.*([0-9]{4})\b`. Однако если строка содержит два числа, то с помощью такого регулярного выражения будут найдены только последние четыре цифры второго числа, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 Не удается сопоставить первое число, так как регулярное выражение `*` квантификаторов предпринимается попытка предыдущий элемент повторяется как много раз во всей строке, и поэтому совпадение в конце строки.  
  
 Это не то, что нам нужно. Вместо этого можно использовать `*?`для извлечения цифр из обоих чисел, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 В большинстве случаев регулярные выражения с жадными и ленивыми квантификаторами возвращают одни и те же результаты. Они чаще всего возвращают различные результаты при их использовании с символом-шаблоном (`.`) метасимвол, которая соответствует любому знаку.  
  
## <a name="quantifiers-and-empty-matches"></a>Квантификаторы и пустые соответствия  
 Кванторы `*`, `+`, и `{`  *n*  `,` *m* `}` и их аналогами отложенной никогда не повторять по прошествии пустой соответствует обнаружила минимальное количество записей. Это правило препятствует вхождению квантификаторов в бесконечные циклы при пустых соответствиях частей выражений, если максимальное количество возможных фиксаций группы бесконечно или приближено к бесконечному.  
  
 Например, в следующем коде показано результат вызова <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> метод с шаблоном регулярного выражения `(a?)*`, который сопоставляется ноль или один символ, «» ноль или более раз. Обратите внимание, что одной группы записи соответствует каждая как «» как <xref:System.String.Empty?displayProperty=nameWithType>, но в этом совпадение не найдено второй пустой, так как первое совпадение пустой квантор прекратил повторы.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 Чтобы увидеть практическое различие между захватываемой группой, определяющей минимальное и максимальное количество записей, и группой, определяющей фиксированное количество записей, воспользуйтесь шаблонами регулярных выражений `(a\1|(?(1)\1)){0,2}` и `(a\1|(?(1)\1)){2}`. Оба регулярных выражения состоят из одной захватываемой группы, которая определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(a\1`|Сопоставление "a" вместе со значением первой захваченной группы...|  
|`&#124;(?(1)`|… или проверка того, была ли определена первая захваченная группа. (Обратите внимание, что `(?(1)` конструкция не определяет группы записи.)|  
|`\1))`|Если первая захваченная группа существует, следует сопоставить ее значение. Если группа не существует, будет соответствовать группе <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Первое регулярное выражение пытается сопоставить этот шаблон от нуля до двух раз. Второй — ровно два раза. Так как первый шаблон достигает его минимальное число снимки с его первой записью <xref:System.String.Empty?displayProperty=nameWithType>, он никогда не повторяется, чтобы попытаться сравнить `a\1`; `{0,2}` квантификатор разрешает только пустые совпадения в последней итерации. Напротив, второе регулярное выражение соответствует "а", потому что оно вычисляет `a\1` второй раз. Минимальное число итераций (2) предписывает обработчику выполнять повтор после пустого соответствия.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a>См. также  
 [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
