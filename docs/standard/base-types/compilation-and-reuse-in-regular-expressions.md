---
title: "Компиляция и многократное использование в регулярных выражениях"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- parsing text with regular expressions, compilation
- searching with regular expressions, compilation
- .NET Framework regular expressions, engines
- .NET Framework regular expressions, compilation
- regular expressions, compilation
- compilation, regular expressions
- pattern-matching with regular expressions, compilation
- regular expressions, engines
ms.assetid: 182ec76d-5a01-4d73-996c-0b0d14fcea18
caps.latest.revision: "11"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 76acdf2d0d2f7805ec78ea44136bfc63441b9bc9
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="compilation-and-reuse-in-regular-expressions"></a>Компиляция и многократное использование в регулярных выражениях
Производительность приложений, активно использующих регулярные выражения, можно оптимизировать, если понимать, каким образом обработчик регулярных выражений компилирует выражения и как кэшируются регулярные выражения. В этом разделе описаны и компиляция, и кэширование.  
  
## <a name="compiled-regular-expressions"></a>Скомпилированные регулярные выражения  
 По умолчанию обработчик регулярных выражений компилирует регулярные выражения в последовательность внутренних инструкций (это коды высокого уровня, которые отличаются от языка MSIL). Когда обработчик выполняет регулярное выражение, он преобразовывает внутренние коды.  
  
 Если <xref:System.Text.RegularExpressions.Regex> объект создан с <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> параметр компиляции регулярного выражения для явного код MSIL вместо внутренних инструкций высокого уровня регулярного выражения. Это позволяет JIT-компилятору платформы .NET преобразовывать выражение в изначальный машинный код данного объекта для повышения производительности.  
  
Однако созданный язык MSIL выгрузить невозможно. Выгрузить код можно, только выгрузив весь домен приложения (т. е. выгрузив весь код приложения). По сути когда регулярное выражение компилируется с <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> никогда не освобождает ресурсы, используемые скомпилированное выражение, даже если была создана регулярного выражения, то <xref:System.Text.RegularExpressions.Regex> объект, который сам готов для сборки мусора.  
  
 Будьте внимательны, чтобы ограничить число различных регулярных выражений, при компиляции <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> параметр, чтобы не потребляет слишком много ресурсов. Если в приложении необходимо использовать большое или неограниченное число регулярных выражений, их необходимо преобразовывать, а не компилировать. Тем не менее, при повторном использовании небольшое количество регулярных выражений они должны быть скомпилированы с <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> для повышения производительности. Альтернативой является использование предварительно скомпилированных регулярных выражений. Все выражения в повторно используемую DLL можно скомпилировать с помощью <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> метод. Это исключает необходимость компиляции во время выполнения при сохранит скорость скомпилированных регулярных выражений.  
  
## <a name="the-regular-expressions-cache"></a>Кэш регулярных выражений  
 Для повышения производительности обработчик регулярных выражений поддерживает кэш скомпилированных регулярных выражений на уровне приложения. Кэш хранит шаблоны регулярных выражений, которые используются только при вызове статических методов. (Шаблоны регулярных выражений, предоставляемые методами экземпляра, не кэшируются.) Это устраняет потребность в повторном разборе выражения в байт-код высокого уровня при каждом его использовании.  
  
 Максимальное число кэшированных регулярных выражений определяется по значению `static` (`Shared` в Visual Basic) <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> свойство. По умолчанию обработчик регулярных выражений кэширует до 15 скомпилированных регулярных выражений. Если число скомпилированных регулярных выражений превышает размер кэша, из него удаляется наиболее давнее по использованию регулярное выражение и кэшируется новое регулярное выражение.  
  
 Приложение может воспользоваться преимуществом заранее скомпилированных регулярных выражений одним из указанных далее двух способов.  
  
-   С помощью статического метода <xref:System.Text.RegularExpressions.Regex> объекта для определения регулярных выражений. Если используется шаблон регулярного выражения, который уже был определен при вызове другого статического метода, обработчик регулярных выражений будет извлекать его из кэша. Если нет, обработчик скомпилирует регулярное выражение и добавит его в кэш.  
  
-   Повторное использование существующего <xref:System.Text.RegularExpressions.Regex> объекта, при условии, что требуется шаблон регулярного выражения.  
  
 Из-за издержек при создании объектов и компиляции регулярных выражений, создание и быстрое уничтожение многочисленных <xref:System.Text.RegularExpressions.Regex> объекты — это процесс, очень дорого. Для приложений, использующих большое количество различных регулярных выражений, производительность можно оптимизировать с помощью вызова статических `Regex` методы и возможно, путем увеличения размера кэша регулярных выражений.  
  
## <a name="see-also"></a>См. также  
 [Регулярные выражения .NET](../../../docs/standard/base-types/regular-expressions.md)
