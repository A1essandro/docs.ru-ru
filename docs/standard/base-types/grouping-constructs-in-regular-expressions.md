---
title: "Конструкции группировки в регулярных выражениях"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 9b9e54d8bbc9ca7cc9172fd83bd15968b3cef8e1
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="438dc-102">Конструкции группировки в регулярных выражениях</span><span class="sxs-lookup"><span data-stu-id="438dc-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="438dc-103">Конструкции группирования отображают части выражений регулярных выражений и захватывают части строки входной строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="438dc-104">Конструкции группирования можно использовать в следующих целях.</span><span class="sxs-lookup"><span data-stu-id="438dc-104">You can use grouping constructs to do the following:</span></span>  
  
-   <span data-ttu-id="438dc-105">Сопоставление с частью выражения, которая повторяется во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-105">Match a subexpression that is repeated in the input string.</span></span>  
  
-   <span data-ttu-id="438dc-106">Применение квантификатору к части выражения с несколькими языковыми элементами регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="438dc-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="438dc-107">Дополнительные сведения о квантификаторах см. в разделе [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="438dc-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
-   <span data-ttu-id="438dc-108">Добавление в строку части выражения, которая возвращается методами <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="438dc-109">Извлечение отдельных частей выражения из свойства <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> и обработка их по отдельности от всего текста.</span><span class="sxs-lookup"><span data-stu-id="438dc-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="438dc-110">В следующей таблице перечислены конструкции группирования, поддерживаемые механизмом регулярных выражений .NET, с указанием, выполняют ли они захват выражений.</span><span class="sxs-lookup"><span data-stu-id="438dc-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="438dc-111">Конструкция группирования</span><span class="sxs-lookup"><span data-stu-id="438dc-111">Grouping construct</span></span>|<span data-ttu-id="438dc-112">Захватываемая или незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="438dc-113">Сопоставляемые части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="438dc-114">Захватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-114">Capturing</span></span>|  
|[<span data-ttu-id="438dc-115">Именованные сопоставленные части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="438dc-116">Захватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-116">Capturing</span></span>|  
|[<span data-ttu-id="438dc-117">Сбалансированные определения группы</span><span class="sxs-lookup"><span data-stu-id="438dc-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="438dc-118">Захватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-118">Capturing</span></span>|  
|[<span data-ttu-id="438dc-119">Незахватываемые группы</span><span class="sxs-lookup"><span data-stu-id="438dc-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="438dc-120">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-120">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-121">Параметры группы</span><span class="sxs-lookup"><span data-stu-id="438dc-121">Group options</span></span>](#group_options)|<span data-ttu-id="438dc-122">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-122">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-123">Утверждения положительного просмотра вперед нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="438dc-124">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-124">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-125">Утверждения отрицательного просмотра вперед нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="438dc-126">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-126">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-127">Утверждения положительного просмотра назад нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="438dc-128">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-128">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-129">Утверждения отрицательного просмотра назад нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="438dc-130">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-130">Noncapturing</span></span>|  
|[<span data-ttu-id="438dc-131">Невозвращающиеся части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-131">Nonbacktracking subexpressions</span></span>](#nonbacktracking_subexpression)|<span data-ttu-id="438dc-132">Незахватываемая</span><span class="sxs-lookup"><span data-stu-id="438dc-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="438dc-133">Сведения о группах и объектной модели регулярных выражений см. в разделе [Конструкции группирования и объекты регулярных выражений](#Objects).</span><span class="sxs-lookup"><span data-stu-id="438dc-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a><span data-ttu-id="438dc-134">Сопоставляемые части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="438dc-135">Следующая конструкция группирования выделяет сопоставленную часть выражения:</span><span class="sxs-lookup"><span data-stu-id="438dc-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="438dc-136">`(` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-137">Где *часть выражения* — любой допустимый шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="438dc-138">Выделения, использующие круглые скобки, нумеруются автоматически слева направо в зависимости от порядка открывающих скобок в регулярном выражении, начиная с 1.</span><span class="sxs-lookup"><span data-stu-id="438dc-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="438dc-139">Выделение с нулевым номером — это текст, сопоставленный всем регулярным выражением.</span><span class="sxs-lookup"><span data-stu-id="438dc-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="438dc-140">По умолчанию языковой элемент `(`*часть выражения*`)` выделяет сопоставленную часть выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="438dc-141">Но если параметр <xref:System.Text.RegularExpressions.RegexOptions> метода сопоставления шаблона регулярного выражения содержит флаг <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или к части выражения применен параметр `n` (см. [Параметры группы](#group_options) далее в этой статье), сопоставленная часть выражения не захватывается.</span><span class="sxs-lookup"><span data-stu-id="438dc-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="438dc-142">Доступ к захватываемым группам можно получить четырьмя способами:</span><span class="sxs-lookup"><span data-stu-id="438dc-142">You can access captured groups in four ways:</span></span>  
  
-   <span data-ttu-id="438dc-143">Используя конструкцию обратной ссылки в регулярном выражении.</span><span class="sxs-lookup"><span data-stu-id="438dc-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="438dc-144">Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\`*number*, где *number* — это порядковый номер выделенной части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="438dc-145">Используя именованную конструкцию обратной ссылки в регулярном выражении.</span><span class="sxs-lookup"><span data-stu-id="438dc-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="438dc-146">Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\k<`*name*`>`, где *name* — это имя захватываемой группы, или `\k<`*number*`>`, где *number* — это порядковый номер захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="438dc-147">Имя захватываемой группы по умолчанию совпадает с ее порядковым номером.</span><span class="sxs-lookup"><span data-stu-id="438dc-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="438dc-148">Дополнительные сведения см. в разделе [Именованные сопоставляемые части выражения](#named_matched_subexpression) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="438dc-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
-   <span data-ttu-id="438dc-149">Используя последовательность замены `$`*число* в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, где *число* обозначает порядковый номер захваченной части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="438dc-150">Программным способом, используя объект <xref:System.Text.RegularExpressions.GroupCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="438dc-151">Член коллекции в нулевой позиции представляет все сопоставление регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="438dc-152">Каждый последующий член представляет сопоставленную часть выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="438dc-153">Дополнительные сведения см. в разделе [Grouping Constructs and Regular Expression Objects](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="438dc-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="438dc-154">В следующем примере показано регулярное выражение, которое определяет повторяющиеся слова в тексте.</span><span class="sxs-lookup"><span data-stu-id="438dc-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="438dc-155">Две захватываемые группы шаблона регулярного выражения представляют два экземпляра повторяющегося слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="438dc-156">Второй экземпляр выделяется для определения его начальной позиции во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="438dc-157">Шаблон регулярного выражения выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="438dc-157">The regular expression pattern is the following:</span></span>  
  
```  
(\w+)\s(\1)\W  
```  
  
 <span data-ttu-id="438dc-158">В следующей таблице показано, как интерпретируется шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="438dc-159">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-159">Pattern</span></span>|<span data-ttu-id="438dc-160">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="438dc-161">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-161">Match one or more word characters.</span></span> <span data-ttu-id="438dc-162">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="438dc-163">Соответствует пробелу.</span><span class="sxs-lookup"><span data-stu-id="438dc-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="438dc-164">Сопоставление строки в первой захватываемой группе.</span><span class="sxs-lookup"><span data-stu-id="438dc-164">Match the string in the first captured group.</span></span> <span data-ttu-id="438dc-165">Это вторая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-165">This is the second capturing group.</span></span> <span data-ttu-id="438dc-166">Этот пример назначает ее захватываемой группе таким образом, что начальную позицию повторяющегося слова можно извлечь из свойства `Match.Index` .</span><span class="sxs-lookup"><span data-stu-id="438dc-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="438dc-167">Сопоставление несловообразующего символа, включая пробел и знак пунктуации.</span><span class="sxs-lookup"><span data-stu-id="438dc-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="438dc-168">Это не позволяет шаблону регулярного выражения сопоставить слово, которое начинается со слова из первой захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a><span data-ttu-id="438dc-169">Именованные сопоставленные части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="438dc-170">Следующая конструкция группировки выделяет сопоставленную часть выражения и позволяет получить к ней доступ по имени или номеру:</span><span class="sxs-lookup"><span data-stu-id="438dc-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
```  
(?<name>subexpression)  
```  
  
 <span data-ttu-id="438dc-171">или</span><span class="sxs-lookup"><span data-stu-id="438dc-171">or:</span></span>  
  
```  
(?'name'subexpression)  
```  
  
 <span data-ttu-id="438dc-172">Где *имя* — это допустимое имя группы, а *часть выражения* — любой допустимый шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="438dc-173">Параметр*имя* не должен содержать знаки пунктуации и не может начинаться с цифры.</span><span class="sxs-lookup"><span data-stu-id="438dc-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="438dc-174">Если параметр <xref:System.Text.RegularExpressions.RegexOptions> метода сопоставления шаблона регулярного выражения содержит флаг <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или к части выражения применен параметр `n` (см. [Параметры группы](#group_options) далее в этой статье), захват части выражения доступен только через явно именованные группы записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="438dc-175">Доступ к именованным захватываемым группам можно получить следующими способами:</span><span class="sxs-lookup"><span data-stu-id="438dc-175">You can access named captured groups in the following ways:</span></span>  
  
-   <span data-ttu-id="438dc-176">Используя именованную конструкцию обратной ссылки в регулярном выражении.</span><span class="sxs-lookup"><span data-stu-id="438dc-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="438dc-177">Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\k<`*name*`>`, где *name* — это имя захватываемой части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="438dc-178">Используя конструкцию обратной ссылки в регулярном выражении.</span><span class="sxs-lookup"><span data-stu-id="438dc-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="438dc-179">Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\`*number*, где *number* — это порядковый номер выделенной части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="438dc-180">Именованные сопоставленные части выражения нумеруются последовательно слева направо после сопоставленных частей выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
-   <span data-ttu-id="438dc-181">Используя последовательность замены `${`*имя*`}` в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, где *имя* обозначает имя захватываемой части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="438dc-182">Используя последовательность замены `$`*число* в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, где *число* обозначает порядковый номер захваченной части выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
-   <span data-ttu-id="438dc-183">Программным способом, используя объект <xref:System.Text.RegularExpressions.GroupCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="438dc-184">Член коллекции в нулевой позиции представляет все сопоставление регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="438dc-185">Каждый последующий член представляет сопоставленную часть выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="438dc-186">Именованные захватываемые группы хранятся в коллекции после нумерованных захватываемых групп.</span><span class="sxs-lookup"><span data-stu-id="438dc-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
-   <span data-ttu-id="438dc-187">Программно, передавая имя части выражения индексатору объекта <xref:System.Text.RegularExpressions.GroupCollection> (в C#) или свойству <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="438dc-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="438dc-188">В простом шаблоне регулярного выражения показано, как нумерованные (безымянные) и именованные группы можно указывать программно или с помощью языка регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="438dc-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="438dc-189">Регулярное выражение `((?<One>abc)\d+)?(?<Two>xyz)(.*)` формирует следующие захватываемые группы по номеру и имени.</span><span class="sxs-lookup"><span data-stu-id="438dc-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="438dc-190">Первая захватываемая группа (с номером 0) всегда указывает на весь шаблон.</span><span class="sxs-lookup"><span data-stu-id="438dc-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="438dc-191">number</span><span class="sxs-lookup"><span data-stu-id="438dc-191">Number</span></span>|<span data-ttu-id="438dc-192">name</span><span class="sxs-lookup"><span data-stu-id="438dc-192">Name</span></span>|<span data-ttu-id="438dc-193">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="438dc-194">0</span><span class="sxs-lookup"><span data-stu-id="438dc-194">0</span></span>|<span data-ttu-id="438dc-195">0 (имя по умолчанию)</span><span class="sxs-lookup"><span data-stu-id="438dc-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="438dc-196">1</span><span class="sxs-lookup"><span data-stu-id="438dc-196">1</span></span>|<span data-ttu-id="438dc-197">1 (имя по умолчанию)</span><span class="sxs-lookup"><span data-stu-id="438dc-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="438dc-198">2</span><span class="sxs-lookup"><span data-stu-id="438dc-198">2</span></span>|<span data-ttu-id="438dc-199">2 (имя по умолчанию)</span><span class="sxs-lookup"><span data-stu-id="438dc-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="438dc-200">3</span><span class="sxs-lookup"><span data-stu-id="438dc-200">3</span></span>|<span data-ttu-id="438dc-201">Один</span><span class="sxs-lookup"><span data-stu-id="438dc-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="438dc-202">4</span><span class="sxs-lookup"><span data-stu-id="438dc-202">4</span></span>|<span data-ttu-id="438dc-203">Два</span><span class="sxs-lookup"><span data-stu-id="438dc-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="438dc-204">В следующем примере показано регулярное выражение, которое определяет повторяющиеся слова и слова, которые следуют за каждым повторяющимся словом.</span><span class="sxs-lookup"><span data-stu-id="438dc-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="438dc-205">Шаблон регулярного выражения определяет две именованных части выражения: `duplicateWord`, которая представляет повторяющееся слово, и `nextWord`, которая представляет слово после повторяющегося слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="438dc-206">Шаблон регулярного выражения выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="438dc-206">The regular expression pattern is as follows:</span></span>  
  
```  
(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)  
```  
  
 <span data-ttu-id="438dc-207">В следующей таблице показано, как интерпретируется регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="438dc-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="438dc-208">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-208">Pattern</span></span>|<span data-ttu-id="438dc-209">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="438dc-210">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-210">Match one or more word characters.</span></span> <span data-ttu-id="438dc-211">Установка для группы имени `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="438dc-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="438dc-212">Соответствует пробелу.</span><span class="sxs-lookup"><span data-stu-id="438dc-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="438dc-213">Сопоставление строки из захватываемой группы с именем `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="438dc-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="438dc-214">Сопоставление несловообразующего символа, включая пробел и знак пунктуации.</span><span class="sxs-lookup"><span data-stu-id="438dc-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="438dc-215">Это не позволяет шаблону регулярного выражения сопоставить слово, которое начинается со слова из первой захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="438dc-216">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-216">Match one or more word characters.</span></span> <span data-ttu-id="438dc-217">Установка для группы имени `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="438dc-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="438dc-218">Обратите внимание на то, что имя группы может повторяться в регулярном выражении.</span><span class="sxs-lookup"><span data-stu-id="438dc-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="438dc-219">Например, несколько групп могут называться `digit`, как показано в примере ниже.</span><span class="sxs-lookup"><span data-stu-id="438dc-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="438dc-220">В случае повторяющихся имен значение объекта <xref:System.Text.RegularExpressions.Group> определяется последней успешной записью во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="438dc-221">Кроме того, коллекция <xref:System.Text.RegularExpressions.CaptureCollection> заполняется сведениями о каждой записи так же, как и в случае, когда имя группы не повторяется.</span><span class="sxs-lookup"><span data-stu-id="438dc-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="438dc-222">В примере ниже регулярное выражение `\D+(?<digit>\d+)\D+(?<digit>\d+)?` включает два вхождения группы с именем `digit`.</span><span class="sxs-lookup"><span data-stu-id="438dc-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="438dc-223">Первая группа с именем `digit` записывает одну или несколько цифр.</span><span class="sxs-lookup"><span data-stu-id="438dc-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="438dc-224">Вторая группа с именем `digit` записывает нуль или одно вхождение одной или нескольких цифр.</span><span class="sxs-lookup"><span data-stu-id="438dc-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="438dc-225">Как видно из выходных данных примера, если вторая захватывающая группа соответствует тексту, этот текст определяет значение объекта <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="438dc-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="438dc-226">Если вторая захватывающая группа не соответствует входной строке, значение последнего успешного сопоставления определяет значение объекта <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="438dc-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="438dc-227">В следующей таблице показано, как интерпретируется регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="438dc-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="438dc-228">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-228">Pattern</span></span>|<span data-ttu-id="438dc-229">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="438dc-230">Совпадение с одной или несколькими недесятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="438dc-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="438dc-231">Совпадение с одной или несколькими десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="438dc-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="438dc-232">Назначение соответствия для группы с именем `digit` .</span><span class="sxs-lookup"><span data-stu-id="438dc-232">Assign the match to the `digit` named group.</span></span>|  
|<span data-ttu-id="438dc-233">\D+</span><span class="sxs-lookup"><span data-stu-id="438dc-233">\D+</span></span>|<span data-ttu-id="438dc-234">Совпадение с одной или несколькими недесятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="438dc-234">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="438dc-235">Совпадение с нулем или одним вхождением одной или нескольких десятичных цифр.</span><span class="sxs-lookup"><span data-stu-id="438dc-235">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="438dc-236">Назначение соответствия для группы с именем `digit` .</span><span class="sxs-lookup"><span data-stu-id="438dc-236">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a><span data-ttu-id="438dc-237">Сбалансированные определения группы</span><span class="sxs-lookup"><span data-stu-id="438dc-237">Balancing Group Definitions</span></span>  
 <span data-ttu-id="438dc-238">Сбалансированное определение группы удаляет определение ранее заданной группы и сохраняет в текущей группе интервал между предыдущей и текущей группами.</span><span class="sxs-lookup"><span data-stu-id="438dc-238">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="438dc-239">Конструкция группировки использует следующий формат:</span><span class="sxs-lookup"><span data-stu-id="438dc-239">This grouping construct has the following format:</span></span>  
  
```  
(?<name1-name2>subexpression)  
```  
  
 <span data-ttu-id="438dc-240">или</span><span class="sxs-lookup"><span data-stu-id="438dc-240">or:</span></span>  
  
```  
(?'name1-name2' subexpression)  
```  
  
 <span data-ttu-id="438dc-241">Где *name1* — текущая группа (необязательный параметр), *name2* — ранее заданная группа, а *subexpression* — любой допустимый шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-241">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="438dc-242">Это сбалансированное определение группы удаляет определение *name2* и сохраняет интервал между *name2* и *name1* в *name1*.</span><span class="sxs-lookup"><span data-stu-id="438dc-242">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="438dc-243">Если группа *name2* не определена, для соответствия выполняется обратный поиск.</span><span class="sxs-lookup"><span data-stu-id="438dc-243">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="438dc-244">Так как удаление последнего определения *name2* предоставляет доступ к предыдущему определению *name2*, эта конструкция позволяет использовать стек выделений для группы *name2* в качестве счетчика вложенный конструкций, например круглых скобок или открывающих и закрывающих квадратных скобок.</span><span class="sxs-lookup"><span data-stu-id="438dc-244">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="438dc-245">Сбалансированное определение группы использует в качестве стека *name2* .</span><span class="sxs-lookup"><span data-stu-id="438dc-245">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="438dc-246">Начальный символ каждой вложенной конструкции размещается в группе и в коллекции <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-246">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="438dc-247">При сопоставлении закрывающего символа соответствующий открывающий символ удаляется из группы, а коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A> уменьшается на один элемент.</span><span class="sxs-lookup"><span data-stu-id="438dc-247">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="438dc-248">После сопоставления открывающих и закрывающих символов всех вложенных конструкций, группа *name1* оказывается пустой.</span><span class="sxs-lookup"><span data-stu-id="438dc-248">After the opening and closing characters of all nested constructs have been matched, *name1* is empty.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="438dc-249">Если изменить регулярное выражение в следующем примере для использования соответствующего открывающего и закрывающего символа вложенной конструкции, вы сможете использовать его для обработки большинства вложенных конструкций, таких как математические выражения или строки программного кода, которые могут содержать множества вложенных вызовов методов.</span><span class="sxs-lookup"><span data-stu-id="438dc-249">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="438dc-250">В следующем примере сбалансированное определение группы используется для сопоставления левой и правой угловой скобки (<>) во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-250">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="438dc-251">В примере определены две именованные группы, `Open` и `Close`, которые используются как стек для отслеживания соответствующих пар угловых скобок.</span><span class="sxs-lookup"><span data-stu-id="438dc-251">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="438dc-252">Каждая выделенная левая угловая скобка помещается в коллекцию группы `Open` , а каждая выделенная правая угловая скобка помещается в коллекцию группы `Close` .</span><span class="sxs-lookup"><span data-stu-id="438dc-252">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="438dc-253">Сбалансированное определение группы позволяет убедиться, что для каждой левой угловой скобки существует соответствующая правая угловая скобка.</span><span class="sxs-lookup"><span data-stu-id="438dc-253">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="438dc-254">В противном случае последний подшаблон, `(?(Open)(?!))`, вычисляется, только если группа `Open` не пуста (следовательно, все вложенные конструкции не закрыты).</span><span class="sxs-lookup"><span data-stu-id="438dc-254">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="438dc-255">Если последний подшаблон вычисляется, сопоставление вызывает ошибку, так как подшаблон `(?!)` является утверждением отрицательного поиска вперед нулевой ширины, которое всегда возвращает ошибку.</span><span class="sxs-lookup"><span data-stu-id="438dc-255">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="438dc-256">Шаблон регулярного выражения выглядит следующим образом:</span><span class="sxs-lookup"><span data-stu-id="438dc-256">The regular expression pattern is:</span></span>  
  
```  
^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$  
```  
  
 <span data-ttu-id="438dc-257">Регулярное выражение интерпретируется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="438dc-257">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="438dc-258">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-258">Pattern</span></span>|<span data-ttu-id="438dc-259">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-259">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="438dc-260">Начало с первого символа строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-260">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="438dc-261">Сопоставление нуля или большего числа символов, которые не являются правой или левой угловой скобкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-261">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="438dc-262">Сопоставление левой угловой скобки и ее назначение группе `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-262">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="438dc-263">Сопоставление нуля или большего числа символов, которые не являются правой или левой угловой скобкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-263">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*) +`|<span data-ttu-id="438dc-264">Сопоставление одного или нескольких вхождений левой угловой скобки, за которой следует ноль или больше символов, не являющихся левой или правой угловой скобкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-264">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="438dc-265">Это вторая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-265">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="438dc-266">Сопоставление правой угловой скобки, назначение подстроки между группой `Open` и текущей группой группе `Close` и удаление определения группы `Open` .</span><span class="sxs-lookup"><span data-stu-id="438dc-266">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="438dc-267">Сопоставление нуля или большего числа вхождений любого символа, не являющегося левой или правой угловой скобкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-267">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="438dc-268">Сопоставление одного или нескольких вхождений правой угловой скобки, за которой следует ноль или больше символов, не являющихся левой или правой угловой скобкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-268">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="438dc-269">При сопоставлении правой угловой скобки подстрока между группой `Open` и текущей группой назначается группе `Close` , а определение группы `Open` удаляется.</span><span class="sxs-lookup"><span data-stu-id="438dc-269">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="438dc-270">Это третья группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-270">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="438dc-271">Сопоставление нуля или большего числа вхождений следующего шаблона: одно или несколько вхождений левой угловой скобки, за которой следуют ноль или большее число символов, отличных от угловых скобок, одно или несколько вхождений правой угловой скобки и ноль или большее число символов, отличных от угловых скобок.</span><span class="sxs-lookup"><span data-stu-id="438dc-271">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="438dc-272">При сопоставлении правой угловой скобки определение группы `Open` удаляется, а подстрока между группой `Open` и текущей группой назначается группе `Close` .</span><span class="sxs-lookup"><span data-stu-id="438dc-272">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="438dc-273">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-273">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="438dc-274">Если группа `Open` существует, поиск совпадения прекращается, если возможно сопоставление пустой строки, но позиция механизма регулярных выражений в строке не изменяется.</span><span class="sxs-lookup"><span data-stu-id="438dc-274">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="438dc-275">Это утверждение отрицательного просмотра вперед нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="438dc-275">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="438dc-276">Так как пустая строка всегда неявно присутствует во входной строке, это сопоставление всегда возвращает ошибку.</span><span class="sxs-lookup"><span data-stu-id="438dc-276">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="438dc-277">Ошибка этого сопоставления указывает на то, что угловые скобки не сбалансированы.</span><span class="sxs-lookup"><span data-stu-id="438dc-277">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="438dc-278">Соответствует концу входной строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-278">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="438dc-279">Последняя часть выражения, `(?(Open)(?!))`, указывает, правильно ли сбалансированы вложенные конструкции во входной строке (например, существует ли для каждой левой угловой скобки соответствующая правая угловая скобка).</span><span class="sxs-lookup"><span data-stu-id="438dc-279">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="438dc-280">В ней используется условное сопоставление на основе действительной захватываемой группы. Дополнительные сведения см. в разделе [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="438dc-280">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="438dc-281">Если группа `Open` определена, механизм регулярных выражений пытается сопоставить часть выражения `(?!)` во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-281">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="438dc-282">Группа `Open` должна быть определена, только если вложенные конструкции не сбалансированы.</span><span class="sxs-lookup"><span data-stu-id="438dc-282">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="438dc-283">Поэтому шаблон для сопоставления во входной строке должен всегда вызывать ошибку соответствия.</span><span class="sxs-lookup"><span data-stu-id="438dc-283">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="438dc-284">В этом случае `(?!)` — это утверждение отрицательного просмотра вперед нулевой ширины, которое всегда вызывает ошибку, так как пустая строка всегда неявно присутствует в следующей позиции во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-284">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="438dc-285">В этом примере механизм регулярных выражений обрабатывает входную строку "\<abc><mno\<xyz>>" так, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-285">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-286">Шаг</span><span class="sxs-lookup"><span data-stu-id="438dc-286">Step</span></span>|<span data-ttu-id="438dc-287">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-287">Pattern</span></span>|<span data-ttu-id="438dc-288">Результат</span><span class="sxs-lookup"><span data-stu-id="438dc-288">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="438dc-289">1</span><span class="sxs-lookup"><span data-stu-id="438dc-289">1</span></span>|`^`|<span data-ttu-id="438dc-290">Начало соответствия в начале входной строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-290">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="438dc-291">2</span><span class="sxs-lookup"><span data-stu-id="438dc-291">2</span></span>|`[^<>]*`|<span data-ttu-id="438dc-292">Поиск символов, отличных от угловых скобок, до левой угловой скобки. Совпадения не найдены.</span><span class="sxs-lookup"><span data-stu-id="438dc-292">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="438dc-293">3</span><span class="sxs-lookup"><span data-stu-id="438dc-293">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="438dc-294">Сопоставляет левую угловую скобку в строке "\<abc>" и присваивает ее группе `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-294">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="438dc-295">4</span><span class="sxs-lookup"><span data-stu-id="438dc-295">4</span></span>|`[^<>]*`|<span data-ttu-id="438dc-296">Сопоставляется строка "abc".</span><span class="sxs-lookup"><span data-stu-id="438dc-296">Matches "abc".</span></span>|  
|<span data-ttu-id="438dc-297">5</span><span class="sxs-lookup"><span data-stu-id="438dc-297">5</span></span>|`)+`|<span data-ttu-id="438dc-298">"<abc" — это значение второй захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-298">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="438dc-299">Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-299">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-300">6</span><span class="sxs-lookup"><span data-stu-id="438dc-300">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="438dc-301">Сопоставляет правую угловую скобку в "<abc\<" и назначает подстроку "abc", расположенную между группой `Open` и правой угловой скобкой, группе записи `Close`, а также удаляет текущее значение ("<") из группы записи `Open`, которая теперь становится пустой.</span><span class="sxs-lookup"><span data-stu-id="438dc-301">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="438dc-302">7</span><span class="sxs-lookup"><span data-stu-id="438dc-302">7</span></span>|`[^<>]*`|<span data-ttu-id="438dc-303">Поиск символов, отличных от угловых скобок, после правой угловой скобки. Совпадения не найдены.</span><span class="sxs-lookup"><span data-stu-id="438dc-303">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="438dc-304">8</span><span class="sxs-lookup"><span data-stu-id="438dc-304">8</span></span>|`)+`|<span data-ttu-id="438dc-305">Значение третьей захватываемой группы — ">".</span><span class="sxs-lookup"><span data-stu-id="438dc-305">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="438dc-306">Следующий символ во входной строке не является правой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-306">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-307">9</span><span class="sxs-lookup"><span data-stu-id="438dc-307">9</span></span>|`)*`|<span data-ttu-id="438dc-308">Первой группе записи присвоено значение "\<abc>".</span><span class="sxs-lookup"><span data-stu-id="438dc-308">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="438dc-309">Следующий символ во входной строке является левой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-309">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-310">10</span><span class="sxs-lookup"><span data-stu-id="438dc-310">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="438dc-311">Сопоставляет левую угловую скобку в строке "\<mno>" и назначает ее группе `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-311">Matches the left angle bracket in "\<mno>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="438dc-312">Теперь ее коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> содержит один символ, "<".</span><span class="sxs-lookup"><span data-stu-id="438dc-312">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="438dc-313">11</span><span class="sxs-lookup"><span data-stu-id="438dc-313">11</span></span>|`[^<>]*`|<span data-ttu-id="438dc-314">Сопоставляется подстрока "mno".</span><span class="sxs-lookup"><span data-stu-id="438dc-314">Matches "mno".</span></span>|  
|<span data-ttu-id="438dc-315">12</span><span class="sxs-lookup"><span data-stu-id="438dc-315">12</span></span>|`)+`|<span data-ttu-id="438dc-316">"<mno" — это значение второй захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-316">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="438dc-317">Следующий символ во входной строке является левой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-317">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-318">13</span><span class="sxs-lookup"><span data-stu-id="438dc-318">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="438dc-319">Сопоставляет левую угловую скобку в строке "\<xyz>" и назначает ее группе `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-319">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="438dc-320">Коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> группы записи `Open` теперь содержит два захвата: левую угловую скобку из "\<mno>" и правую угловую скобку из "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="438dc-320">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno>", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="438dc-321">14</span><span class="sxs-lookup"><span data-stu-id="438dc-321">14</span></span>|`[^<>]*`|<span data-ttu-id="438dc-322">Сопоставляется подстрока "xyz".</span><span class="sxs-lookup"><span data-stu-id="438dc-322">Matches "xyz".</span></span>|  
|<span data-ttu-id="438dc-323">15</span><span class="sxs-lookup"><span data-stu-id="438dc-323">15</span></span>|`)+`|<span data-ttu-id="438dc-324">"<xyz" — это значение второй захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-324">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="438dc-325">Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-325">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-326">16</span><span class="sxs-lookup"><span data-stu-id="438dc-326">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="438dc-327">Сопоставляет правую угловую скобку в строке "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="438dc-327">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="438dc-328">"xyz" задает подстроку между группой `Open` и правой угловой скобкой группы `Close` и удаляет текущее значение группы `Open` .</span><span class="sxs-lookup"><span data-stu-id="438dc-328">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="438dc-329">Значение предыдущего захвата (левая угловая скобка из "\<mno>") становится текущим значением группы `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-329">The value of the previous capture (the left angle bracket in "\<mno>") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="438dc-330">Коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A> группы `Open` теперь содержит один символ: левую угловую скобку из "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="438dc-330">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="438dc-331">17</span><span class="sxs-lookup"><span data-stu-id="438dc-331">17</span></span>|`[^<>]*`|<span data-ttu-id="438dc-332">Поиск символов, отличных от угловых скобок. Совпадения не найдены.</span><span class="sxs-lookup"><span data-stu-id="438dc-332">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="438dc-333">18</span><span class="sxs-lookup"><span data-stu-id="438dc-333">18</span></span>|`)+`|<span data-ttu-id="438dc-334">Значение третьей захватываемой группы — ">".</span><span class="sxs-lookup"><span data-stu-id="438dc-334">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="438dc-335">Следующий символ во входной строке является правой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-335">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-336">19</span><span class="sxs-lookup"><span data-stu-id="438dc-336">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="438dc-337">Сопоставляет последнюю правую угловую скобку в "xyz>>" и назначает подстроку "mno\<xyz>", которая располагается между группой `Open` и правой угловой скобкой, группе `Close`, а также удаляет текущее значение группы `Open`.</span><span class="sxs-lookup"><span data-stu-id="438dc-337">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="438dc-338">Теперь группа `Open` пуста.</span><span class="sxs-lookup"><span data-stu-id="438dc-338">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="438dc-339">20</span><span class="sxs-lookup"><span data-stu-id="438dc-339">20</span></span>|`[^<>]*`|<span data-ttu-id="438dc-340">Поиск символов, отличных от угловых скобок. Совпадения не найдены.</span><span class="sxs-lookup"><span data-stu-id="438dc-340">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="438dc-341">21</span><span class="sxs-lookup"><span data-stu-id="438dc-341">21</span></span>|`)+`|<span data-ttu-id="438dc-342">Значение третьей захватываемой группы — ">".</span><span class="sxs-lookup"><span data-stu-id="438dc-342">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="438dc-343">Следующий символ во входной строке не является правой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-343">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-344">22</span><span class="sxs-lookup"><span data-stu-id="438dc-344">22</span></span>|`)*`|<span data-ttu-id="438dc-345">Присваивает первой группе записи значение "<mno\<xyz>>".</span><span class="sxs-lookup"><span data-stu-id="438dc-345">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="438dc-346">Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-346">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="438dc-347">23</span><span class="sxs-lookup"><span data-stu-id="438dc-347">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="438dc-348">Группа `Open` не определена, поиск соответствий не выполняется.</span><span class="sxs-lookup"><span data-stu-id="438dc-348">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="438dc-349">24</span><span class="sxs-lookup"><span data-stu-id="438dc-349">24</span></span>|`$`|<span data-ttu-id="438dc-350">Сопоставление конца входной строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-350">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a><span data-ttu-id="438dc-351">Незахватываемые группы</span><span class="sxs-lookup"><span data-stu-id="438dc-351">Noncapturing Groups</span></span>  
 <span data-ttu-id="438dc-352">Следующая конструкция группировки не захватывает подстроку, сопоставленную частью выражения:</span><span class="sxs-lookup"><span data-stu-id="438dc-352">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
```  
(?:subexpression)  
```  
  
 <span data-ttu-id="438dc-353">Где *часть выражения* — любой допустимый шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-353">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="438dc-354">Незахватываемая конструкция группировки обычно используется, если к группе применяется квантификатор, но подстроки, выделенные группой, не представляют интереса.</span><span class="sxs-lookup"><span data-stu-id="438dc-354">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="438dc-355">Если регулярное выражение содержит вложенные конструкции группировки, внешняя незахватываемая конструкция группировки не применяется к внутренним вложенным конструкциям группировки.</span><span class="sxs-lookup"><span data-stu-id="438dc-355">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="438dc-356">В следующем примере показано регулярное выражение, содержащее незахватываемые группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-356">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="438dc-357">Обратите внимание, что результат не содержит захватываемые группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-357">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="438dc-358">Регулярное выражение `(?:\b(?:\w+)\W*)+\.` сопоставляет предложение, которое заканчивается точкой.</span><span class="sxs-lookup"><span data-stu-id="438dc-358">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="438dc-359">Так как оно ищет предложения, а не отдельные слова, конструкции группировки используются только как квантификаторы.</span><span class="sxs-lookup"><span data-stu-id="438dc-359">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="438dc-360">Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-360">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-361">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-361">Pattern</span></span>|<span data-ttu-id="438dc-362">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-362">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-363">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-363">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="438dc-364">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-364">Match one or more word characters.</span></span> <span data-ttu-id="438dc-365">Сопоставленные текст не назначается захватываемой группе.</span><span class="sxs-lookup"><span data-stu-id="438dc-365">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="438dc-366">Совпадение с нулем или большим числом несловообразующих символов.</span><span class="sxs-lookup"><span data-stu-id="438dc-366">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="438dc-367">Совпадение шаблона с одним или несколькими словообразующими символами начиная с границы слова, за которыми следует ноль и более несловообразующих символов, один или более раз.</span><span class="sxs-lookup"><span data-stu-id="438dc-367">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="438dc-368">Сопоставленные текст не назначается захватываемой группе.</span><span class="sxs-lookup"><span data-stu-id="438dc-368">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="438dc-369">Сопоставляется точка.</span><span class="sxs-lookup"><span data-stu-id="438dc-369">Match a period.</span></span>|  
  
<a name="group_options"></a>   
## <a name="group-options"></a><span data-ttu-id="438dc-370">Параметры группы</span><span class="sxs-lookup"><span data-stu-id="438dc-370">Group Options</span></span>  
 <span data-ttu-id="438dc-371">Следующая конструкция группировки применяет или отключает указанные параметры в части выражения:</span><span class="sxs-lookup"><span data-stu-id="438dc-371">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="438dc-372">`(?imnsx-imnsx:` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-372">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-373">Где *часть выражения* — любой допустимый шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-373">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="438dc-374">Например, `(?i-s:)` отключает учет регистра и однострочный режим.</span><span class="sxs-lookup"><span data-stu-id="438dc-374">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="438dc-375">Дополнительные сведения о доступных встроенных параметрах см. в разделе [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="438dc-375">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="438dc-376">Вы можете указать параметры, которые применяются ко всему регулярному выражению, а не его части, используя конструктор класса <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> или статичный метод.</span><span class="sxs-lookup"><span data-stu-id="438dc-376">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="438dc-377">Также можно указать встроенные параметры, которые применяются после определенной точки в регулярном выражении с использованием языковой конструкции `(?imnsx-imnsx)` .</span><span class="sxs-lookup"><span data-stu-id="438dc-377">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="438dc-378">Конструкция параметров группы не является захватываемой группой.</span><span class="sxs-lookup"><span data-stu-id="438dc-378">The group options construct is not a capturing group.</span></span> <span data-ttu-id="438dc-379">Это значит, что несмотря на то, что любая часть строки, захватываемая *частью выражения* , включается в соответствие, она не добавляется в захватываемую группу и не используется для заполнения объекта <xref:System.Text.RegularExpressions.GroupCollection> .</span><span class="sxs-lookup"><span data-stu-id="438dc-379">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="438dc-380">Например, регулярное выражение `\b(?ix: d \w+)\s` в следующем примере использует встроенные параметры в конструкции группировки, чтобы включить сопоставление без учета регистра и игнорировать пробелы при определении слов, начинающихся с буквы "d".</span><span class="sxs-lookup"><span data-stu-id="438dc-380">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern whitespace in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="438dc-381">Определение регулярного выражения показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-381">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-382">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-382">Pattern</span></span>|<span data-ttu-id="438dc-383">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-383">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-384">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-384">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="438dc-385">Выполняется сопоставление буквы "d", за которой следует один или более словообразующих символов без учета регистра, пробелы в шаблоне пропускаются.</span><span class="sxs-lookup"><span data-stu-id="438dc-385">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="438dc-386">Соответствует пробелу.</span><span class="sxs-lookup"><span data-stu-id="438dc-386">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="438dc-387">Утверждения положительного просмотра вперед нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-387">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="438dc-388">Следующая конструкция группировки определяет утверждение положительного просмотра вперед нулевой ширины:</span><span class="sxs-lookup"><span data-stu-id="438dc-388">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="438dc-389">`(?=` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-389">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-390">Где *часть выражения* — любой шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-390">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="438dc-391">Для успешного сопоставления входная строка должна соответствовать шаблону регулярного выражения в *части выражения*, хотя сопоставленная подстрока не включается в результат сопоставления.</span><span class="sxs-lookup"><span data-stu-id="438dc-391">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="438dc-392">Утверждение положительного просмотра вперед нулевой ширины не выполняет обратный поиск.</span><span class="sxs-lookup"><span data-stu-id="438dc-392">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="438dc-393">Обычно утверждение положительного просмотра вперед нулевой ширины находится в конце шаблона регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-393">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="438dc-394">Оно определяет подстроку, которую необходимо найти в конце строки для сопоставления, но которая не включается в сопоставление.</span><span class="sxs-lookup"><span data-stu-id="438dc-394">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="438dc-395">Это также полезно для предотвращения излишнего обратного поиска.</span><span class="sxs-lookup"><span data-stu-id="438dc-395">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="438dc-396">Утверждение положительного просмотра вперед нулевой ширины можно использовать, чтобы определенная захватываемая группа начиналась с текста, соответствующего подмножеству шаблона, заданного для этой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-396">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="438dc-397">Например, если захватываемая группа соответствует последовательным словообразующим символом, вы можете использовать утверждение положительного просмотра вперед нулевой ширины, чтобы указать, что первый символ должен быть прописной буквой.</span><span class="sxs-lookup"><span data-stu-id="438dc-397">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="438dc-398">Следующий пример использует утверждение положительного просмотра вперед нулевой ширины для сопоставления слова, которое идет перед глаголом "is" во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-398">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="438dc-399">Возможные интерпретации регулярного выражения `\b\w+(?=\sis\b)` показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-399">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-400">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-400">Pattern</span></span>|<span data-ttu-id="438dc-401">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-401">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-402">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-402">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="438dc-403">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-403">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="438dc-404">Определяется, следуют ли за словообразующими словами пробел и строка "is", которая оканчивается на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-404">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="438dc-405">Если это так, совпадение успешно.</span><span class="sxs-lookup"><span data-stu-id="438dc-405">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="438dc-406">Утверждения отрицательного просмотра вперед нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-406">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="438dc-407">Следующая конструкция группировки определяет утверждение отрицательного просмотра вперед нулевой ширины:</span><span class="sxs-lookup"><span data-stu-id="438dc-407">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="438dc-408">`(?!` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-408">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-409">Где *часть выражения* — любой шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-409">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="438dc-410">Для успешного сопоставления входная строка не должна соответствовать шаблону регулярного выражения в *части выражения*, хотя сопоставленная подстрока не включается в результат сопоставления.</span><span class="sxs-lookup"><span data-stu-id="438dc-410">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="438dc-411">Утверждение отрицательного просмотра вперед нулевой ширины обычно используется в начале или в конце регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-411">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="438dc-412">В начале регулярного выражения оно может определить шаблон, для которого не должно быть совпадения, когда в начале регулярного выражения определен похожий, но более общий шаблон для сопоставления.</span><span class="sxs-lookup"><span data-stu-id="438dc-412">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="438dc-413">В этом случае утверждение часто используется для ограничения обратного поиска.</span><span class="sxs-lookup"><span data-stu-id="438dc-413">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="438dc-414">В конце регулярного выражения утверждение может определять часть выражения, которое не должно присутствовать в конце совпадения.</span><span class="sxs-lookup"><span data-stu-id="438dc-414">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="438dc-415">В следующем примере определяется регулярное выражение, использующее утверждение просмотра вперед нулевой ширины в начале регулярного выражения для сопоставления слов, которые не начинаются на "un".</span><span class="sxs-lookup"><span data-stu-id="438dc-415">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="438dc-416">Возможные интерпретации регулярного выражения `\b(?!un)\w+\b` показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-416">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-417">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-417">Pattern</span></span>|<span data-ttu-id="438dc-418">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-418">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-419">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-419">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="438dc-420">Определяется, являются ли два следующих символа "un".</span><span class="sxs-lookup"><span data-stu-id="438dc-420">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="438dc-421">Если это не так, сопоставление возможно.</span><span class="sxs-lookup"><span data-stu-id="438dc-421">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="438dc-422">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-422">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="438dc-423">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-423">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="438dc-424">В следующем примере определяется регулярное выражение, использующее утверждение просмотра вперед нулевой ширины в конце регулярного выражения для сопоставления слов, которые не начинаются на знак пунктуации.</span><span class="sxs-lookup"><span data-stu-id="438dc-424">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="438dc-425">Возможные интерпретации регулярного выражения `\b\w+\b(?!\p{P})` показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-425">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-426">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-426">Pattern</span></span>|<span data-ttu-id="438dc-427">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-427">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-428">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-428">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="438dc-429">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-429">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="438dc-430">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-430">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="438dc-431">Если следующий символ — не знак пунктуации (например, точка или запятая), сопоставление выполняется успешно.</span><span class="sxs-lookup"><span data-stu-id="438dc-431">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="438dc-432">Утверждения положительного просмотра назад нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-432">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="438dc-433">Следующая конструкция группировки определяет утверждение положительного просмотра назад нулевой ширины:</span><span class="sxs-lookup"><span data-stu-id="438dc-433">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="438dc-434">`(?<=` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-434">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-435">Где *часть выражения* — любой шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-435">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="438dc-436">Для успешного сопоставления *часть выражения* должна содержаться во входной строке слева от текущей позиции, хотя `subexpression` не включается в результат.</span><span class="sxs-lookup"><span data-stu-id="438dc-436">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="438dc-437">Утверждение положительного просмотра назад нулевой ширины не выполняет обратный поиск.</span><span class="sxs-lookup"><span data-stu-id="438dc-437">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="438dc-438">Утверждения положительного просмотра назад нулевой ширины обычно используются в начале регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="438dc-438">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="438dc-439">Определяемый ими шаблон — это предварительное условие сопоставления, но не часть результата сопоставления.</span><span class="sxs-lookup"><span data-stu-id="438dc-439">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="438dc-440">Например, следующий пример сопоставляет две последних цифры года для 21-го века (т. е. сопоставляемой строке должны предшествовать цифры "20").</span><span class="sxs-lookup"><span data-stu-id="438dc-440">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="438dc-441">Возможные интерпретации шаблона регулярного выражения `(?<=\b20)\d{2}\b` показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-441">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-442">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-442">Pattern</span></span>|<span data-ttu-id="438dc-443">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-443">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="438dc-444">Совпадение с двумя десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="438dc-444">Match two decimal digits.</span></span>|  
|`{?<=\b20)`|<span data-ttu-id="438dc-445">Сопоставление продолжается, если двум десятичным цифрам предшествуют десятичные цифры "20" на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-445">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="438dc-446">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-446">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="438dc-447">Утверждения положительного просмотра назад нулевой ширины также используются для ограничения обратного поиска, если последний символ или символы в захватываемой группе должны быть подмножеством символов, соответствующих шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-447">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="438dc-448">Например, если группа захватывает все последовательные словообразующие символы, вы можете использовать утверждение положительного просмотра назад нулевой ширины, чтобы указать, что последний символ должен быть буквой.</span><span class="sxs-lookup"><span data-stu-id="438dc-448">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="438dc-449">Утверждения отрицательного просмотра назад нулевой ширины</span><span class="sxs-lookup"><span data-stu-id="438dc-449">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="438dc-450">Следующая конструкция группировки определяет утверждение отрицательного просмотра назад нулевой ширины:</span><span class="sxs-lookup"><span data-stu-id="438dc-450">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="438dc-451">`(?<!` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-451">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-452">Где *часть выражения* — любой шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-452">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="438dc-453">Для успешного сопоставления *часть выражения* не должна находиться во входной строке слева от текущей позиции.</span><span class="sxs-lookup"><span data-stu-id="438dc-453">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="438dc-454">Однако любая подстрока, не соответствующая `subexpression` , не включается в результат сопоставления.</span><span class="sxs-lookup"><span data-stu-id="438dc-454">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="438dc-455">Утверждения отрицательного просмотра назад нулевой ширины обычно используются в начале регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="438dc-455">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="438dc-456">Определяемый ими шаблон препятствует сопоставлению в последующей строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-456">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="438dc-457">Они также используются для ограничения обратного поиска, если последний символ или символы в захватываемой группе не должны соответствовать одному или нескольким символам, соответствующим шаблону регулярного выражения группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-457">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="438dc-458">Например, если группа захватывает все последовательные словообразующие символы, вы можете использовать утверждение отрицательного просмотра назад нулевой ширины, чтобы указать, что последний символ не должен быть символом подчеркивания (_).</span><span class="sxs-lookup"><span data-stu-id="438dc-458">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (_).</span></span>  
  
 <span data-ttu-id="438dc-459">Следующий пример сопоставляет дату каждого дня буднего недели (т. е. не субботы или воскресенья).</span><span class="sxs-lookup"><span data-stu-id="438dc-459">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="438dc-460">Возможные интерпретации шаблона регулярного выражения `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` показаны в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-460">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-461">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-461">Pattern</span></span>|<span data-ttu-id="438dc-462">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-462">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-463">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-463">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="438dc-464">Сопоставляется один или несколько словообразующих символов, за которыми следует пробел.</span><span class="sxs-lookup"><span data-stu-id="438dc-464">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="438dc-465">Сопоставляется одна или две десятичные цифры, за которыми следует пробел и запятая.</span><span class="sxs-lookup"><span data-stu-id="438dc-465">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="438dc-466">Сопоставляются 4 десятичные цифры, сопоставление прекращается на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-466">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="438dc-467">Если сопоставлению предшествуют строки, отличные от "Saturday" или "Sunday", за которыми следует пробел, сопоставление выполняется успешно.</span><span class="sxs-lookup"><span data-stu-id="438dc-467">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="nonbacktracking_subexpression"></a>   
## <a name="nonbacktracking-subexpressions"></a><span data-ttu-id="438dc-468">Невозвращающиеся части выражения</span><span class="sxs-lookup"><span data-stu-id="438dc-468">Nonbacktracking Subexpressions</span></span>  
 <span data-ttu-id="438dc-469">Следующая конструкция группировки представляет невозвращающуюся часть выражения (так называемую "жадную" часть выражения):</span><span class="sxs-lookup"><span data-stu-id="438dc-469">The following grouping construct represents a nonbacktracking subexpression (also known as a "greedy" subexpression):</span></span>  
  
 <span data-ttu-id="438dc-470">`(?>` *часть выражения* `)`</span><span class="sxs-lookup"><span data-stu-id="438dc-470">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="438dc-471">Где *часть выражения* — любой шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="438dc-471">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="438dc-472">Обычно, если регулярное выражение содержит необязательный или альтернативный шаблон сопоставления, а сопоставление завершается неудачно, механизм регулярных выражений может разветвляться по разным направлениям для сопоставления входной строки с шаблоном.</span><span class="sxs-lookup"><span data-stu-id="438dc-472">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="438dc-473">Если сопоставление не найдено в первой ветви, механизм регулярных выражений может вернуться к точке, где было найдено первое сопоставление и повторить попытку во второй ветви.</span><span class="sxs-lookup"><span data-stu-id="438dc-473">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="438dc-474">Этот процесс может продолжаться, пока не будут обойдены все ветви.</span><span class="sxs-lookup"><span data-stu-id="438dc-474">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="438dc-475">Группа `(?>`*часть выражения*`)` отключает обратное отслеживание.</span><span class="sxs-lookup"><span data-stu-id="438dc-475">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="438dc-476">Механизм регулярных выражений сопоставляет максимально возможное число символов во входной строке.</span><span class="sxs-lookup"><span data-stu-id="438dc-476">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="438dc-477">Если дальнейшее сопоставление невозможно, обратный поиск для применения альтернативных шаблонов не выполняется.</span><span class="sxs-lookup"><span data-stu-id="438dc-477">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="438dc-478">(Т. е. часть выражения сопоставляет только строки, которые могут быть сопоставлены только частью выражения, попытка сопоставить строку на основе этой и последующих частей выражения не осуществляется.)</span><span class="sxs-lookup"><span data-stu-id="438dc-478">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="438dc-479">Этот вариант рекомендуется, если вы знаете, что обратный поиск не даст результатов.</span><span class="sxs-lookup"><span data-stu-id="438dc-479">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="438dc-480">Если запретить механизму регулярных выражений выполнять ненужные операции поиска, производительность станет выше.</span><span class="sxs-lookup"><span data-stu-id="438dc-480">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="438dc-481">В следующем примере показано, как невозвращающаяся часть выражения изменяет результаты сопоставления шаблона.</span><span class="sxs-lookup"><span data-stu-id="438dc-481">The following example illustrates how a nonbacktracking subexpression modifies the results of a pattern match.</span></span> <span data-ttu-id="438dc-482">Возвращающееся регулярное выражение успешно сопоставляет ряд повторяющихся символов, за которыми следует один или более экземпляров того же символа на границе слова, а невозвращающееся регулярное выражение — нет.</span><span class="sxs-lookup"><span data-stu-id="438dc-482">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="438dc-483">Определение невозвращающегося регулярного выражения `(?>(\w)\1+).\b` показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-483">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-484">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-484">Pattern</span></span>|<span data-ttu-id="438dc-485">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-485">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="438dc-486">Сопоставляется один словообразующий символ, который назначается первой захватываемой группе.</span><span class="sxs-lookup"><span data-stu-id="438dc-486">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="438dc-487">Значение первой захваченной подстроки сопоставляется один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="438dc-487">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="438dc-488">Сопоставляется любой символ.</span><span class="sxs-lookup"><span data-stu-id="438dc-488">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="438dc-489">Сопоставление заканчивается на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-489">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="438dc-490">Сопоставляется один или несколько экземпляров повторяющегося словообразующего слова, но обратный поиск для сопоставления последнего символа на границе слова не выполняется.</span><span class="sxs-lookup"><span data-stu-id="438dc-490">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="438dc-491">Конструкции группирования и объекты регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="438dc-491">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="438dc-492">Подстроки, сопоставляемые захватываемой группой регулярного выражения, представлены объектами <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType>, которые можно извлечь из объекта <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType>, возвращаемого свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-492">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="438dc-493">Объект <xref:System.Text.RegularExpressions.GroupCollection> заполняется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="438dc-493">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
-   <span data-ttu-id="438dc-494">Первый объект <xref:System.Text.RegularExpressions.Group> в коллекции (объект с нулевым индексом) представляет все сопоставление.</span><span class="sxs-lookup"><span data-stu-id="438dc-494">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
-   <span data-ttu-id="438dc-495">Следующий набор объектов <xref:System.Text.RegularExpressions.Group> представляет неименованные (нумерованные) захватываемые группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-495">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="438dc-496">Они указываются в том порядке, в котором они определены в регулярном выражении, слева направо.</span><span class="sxs-lookup"><span data-stu-id="438dc-496">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="438dc-497">Значения индекса этих групп лежат в диапазоне от 1 до числа неименованных захватываемых групп в коллекции.</span><span class="sxs-lookup"><span data-stu-id="438dc-497">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="438dc-498">(Индекс определенной группы эквивалентен нумерованной обратной ссылке.</span><span class="sxs-lookup"><span data-stu-id="438dc-498">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="438dc-499">Дополнительные сведения об обратных ссылках см. в разделе [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="438dc-499">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
-   <span data-ttu-id="438dc-500">Последний набор объектов <xref:System.Text.RegularExpressions.Group> представляет именованные захватываемые группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-500">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="438dc-501">Они указываются в том порядке, в котором они определены в регулярном выражении, слева направо.</span><span class="sxs-lookup"><span data-stu-id="438dc-501">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="438dc-502">Значение индекса первой именованной захватываемой группы на единицу больше индекса, последней неименованной захватываемой группы.</span><span class="sxs-lookup"><span data-stu-id="438dc-502">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="438dc-503">Если в регулярном выражении нет неименованных захватываемых групп, индекс первой именованной захватываемой группы равен единице.</span><span class="sxs-lookup"><span data-stu-id="438dc-503">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="438dc-504">Если к захватываемой группе применяется квантификатор, соответствующие свойства <xref:System.Text.RegularExpressions.Group>, <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType> объекта <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> отражают последнюю подстроку, выделяемую захватываемой группой.</span><span class="sxs-lookup"><span data-stu-id="438dc-504">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="438dc-505">Вы можете получить полный набор подстрок, выделяемые группами с квантификаторами, из объекта <xref:System.Text.RegularExpressions.CaptureCollection>, возвращаемого свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-505">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="438dc-506">В следующем примере показана связь между объектами <xref:System.Text.RegularExpressions.Group> и <xref:System.Text.RegularExpressions.Capture> .</span><span class="sxs-lookup"><span data-stu-id="438dc-506">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="438dc-507">Шаблон регулярного выражения `\b(\w+)\W+)+` извлекает отдельные слова из строки.</span><span class="sxs-lookup"><span data-stu-id="438dc-507">The regular expression pattern `\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="438dc-508">Определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="438dc-508">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="438dc-509">Шаблон</span><span class="sxs-lookup"><span data-stu-id="438dc-509">Pattern</span></span>|<span data-ttu-id="438dc-510">Описание:</span><span class="sxs-lookup"><span data-stu-id="438dc-510">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="438dc-511">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-511">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="438dc-512">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-512">Match one or more word characters.</span></span> <span data-ttu-id="438dc-513">Вместе эти символы формируют слово.</span><span class="sxs-lookup"><span data-stu-id="438dc-513">Together, these characters form a word.</span></span> <span data-ttu-id="438dc-514">Это вторая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-514">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="438dc-515">Совпадение с одним или большим числом несловообразующих символов.</span><span class="sxs-lookup"><span data-stu-id="438dc-515">Match one or more non-word characters.</span></span>|  
|`(\w+)\W+)+`|<span data-ttu-id="438dc-516">Шаблон из одного или нескольких словообразующих символов, за которыми следует ноль или несколько словообразующих слов, выделяется один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="438dc-516">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="438dc-517">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="438dc-517">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="438dc-518">Первая группа сопоставляет каждое слово предложения.</span><span class="sxs-lookup"><span data-stu-id="438dc-518">The first capturing group matches each word of the sentence.</span></span> <span data-ttu-id="438dc-519">Вторая группа сопоставляет каждое слово вместе со знаками пунктуации и пробелом после слова.</span><span class="sxs-lookup"><span data-stu-id="438dc-519">The second capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="438dc-520">Объект <xref:System.Text.RegularExpressions.Group> с индексом 2 предоставляет сведения о тексте, сопоставленном второй группой.</span><span class="sxs-lookup"><span data-stu-id="438dc-520">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="438dc-521">Полный набор слов, выделенных захватываемой группой, доступен в объекте <xref:System.Text.RegularExpressions.CaptureCollection>, который возвращается свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="438dc-521">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="438dc-522">См. также</span><span class="sxs-lookup"><span data-stu-id="438dc-522">See Also</span></span>  
 [<span data-ttu-id="438dc-523">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="438dc-523">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
 [<span data-ttu-id="438dc-524">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="438dc-524">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
