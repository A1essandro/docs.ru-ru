---
title: "Конструкции обратных ссылок в регулярных выражениях | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "регулярные выражения .NET Framework, конструкции обратных ссылок"
  - "обратные ссылки"
  - "конструкции, обратная ссылка"
  - "регулярные выражения, конструкции обратных ссылок"
ms.assetid: 567a4b8d-0e79-49dc-8df9-f4b1aa376a2a
caps.latest.revision: 11
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 11
---
# Конструкции обратных ссылок в регулярных выражениях
Обратные ссылки предоставляют удобный способ идентификации повторяющегося символа или подстроки в строке.  Например, если входная строка содержит несколько экземпляров произвольной подстроки, то можно найти первое вхождение с помощью группы записи, а затем использовать обратную ссылку для поиска последующих вхождений подстроки.  
  
> [!NOTE]
>  Отдельный синтаксис используется для ссылки на именованные и нумерованные захватываемые группы в строках замены.  Для получения дополнительной информации см. [Подстановки](../../../docs/standard/base-types/substitutions-in-regular-expressions.md).  
  
 Платформа .NET Framework определяет отдельные элементы языка для ссылки на нумерованные и именованные группы захвата.  Дополнительные сведения о захватываемых группах см. в разделе [Конструкции группирования](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).  
  
## Нумерованные обратные ссылки  
 Нумерованная обратная ссылка использует следующий синтаксис:  
  
 `\` *number*  
  
 где *number* — это порядковое положение группы записи, определенное в шаблоне регулярного выражения.  Например, `\4` соответствует содержимому четвертой захватываемой группы.  Если *number* не определен в шаблоне регулярного выражения, то возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  Например, регулярное выражение `\b(\w+)\s\1` является допустимым, поскольку `(\w+)` является первой и единственной захватываемой группой в выражении.  С другой стороны, выражение `\b(\w+)\s\2` недопустимо и создает исключение аргумента, поскольку нет группы захвата с номером `\2`.  
  
 Следует отметить неоднозначность такой записи, используемой как в восьмеричных escape\-кодах \(`\16`\), так и в обратных ссылках `\`*number*.  Эта неопределенность разрешается следующим образом:  
  
-   Выражения `\1` в `\9` всегда являются обратными ссылками, а не восьмеричными числами.  
  
-   Если первая цифра многоразрядного выражения – 8 или 9 \(например `\80` или `\91`\), то выражение интерпретируется как литерал.  
  
-   Выражения от `\10` и более считаются обратными ссылками, если имеется обратная ссылка, соответствующая этому номеру; в противном случае они интерпретируются как восьмеричные коды.  
  
-   Если регулярное выражение содержит обратную ссылку на неопределенный номер группы, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  
  
 Если неоднозначность представляет проблему, можно использовать представление `\k<`*name*`>`, которое является однозначным, и его невозможно спутать с восьмеричными кодами знаков.  Аналогичным образом шестнадцатеричные коды, например `\xdd`, однозначны и их нельзя спутать с обратными ссылками.  
  
 В следующем примере в строке выделяются символы, представленные двойными словами.  Определяет регулярное выражение, `(\w)\1`, которое состоит из следующих элементов.  
  
|Элемент|Описание|  
|-------------|--------------|  
|`(\w)`|Выделяет буквенный символ и назначает его первой группе записи.|  
|`\1`|Выделить следующий символ, значение которого совпадает с первой группой записи.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference1.cs#1)]
 [!code-vb[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference1.vb#1)]  
  
## Именованные обратные ссылки  
 Именованная обратная ссылка задается с помощью следующего синтаксиса:  
  
 `\k<` *name* `>`  
  
 или  
  
 `\k'` *name* `'`  
  
 где *name* — это имя группы записи, определенное в шаблоне регулярного выражения.  Если *name* не определен в шаблоне регулярного выражения, то возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  
  
 В следующем примере в строке выделяются символы, представленные двойными словами.  Определяет регулярное выражение, `(?<char>\w)\k<char>`, которое состоит из следующих элементов.  
  
|Элемент|Описание|  
|-------------|--------------|  
|`(?<char>\w)`|Выделяет буквенный символ и назначает его группе записи с именем `char`.|  
|`\k<char>`|Выделить следующий символ, значение которого совпадает с группой записи `char`.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference2.cs#2)]
 [!code-vb[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference2.vb#2)]  
  
 Обратите внимание, что *name* также может быть строковым представлением числа.  Например, в следующем примере используется регулярное выражение `(?<2>\w)\k<2>` для поиска в строке двойных буквенных символов.  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference3.cs#3)]
 [!code-vb[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference3.vb#3)]  
  
## С чем сопоставляются обратные ссылки  
 Обратная ссылка относится к самому недавнему определению группы \(самому ближнему слева определению при обработке слева направо\).  Если из группы создается несколько шаблонов для поиска, то обратная ссылка относится к самому последнему шаблону.  
  
 Следующий пример включает шаблон регулярного выражения `(?<1>a)(?<1>\1b)*`, который переопределяет именованную группу \\1.  В следующей таблице описывается каждый шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|------------|--------------|  
|`(?<1>a)`|Выделить символ "a" и присвоить результат группе записи с именем `1`.|  
|`(?<1>\1b)*`|Выделяет 0 или 1 вхождение группы с именем `1` вместе с "b" и присваивает результат группе записи с именем `1`.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference4.cs#4)]
 [!code-vb[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference4.vb#4)]  
  
 При сравнении регулярного выражения со строкой ввода \("aababb"\) обработчик регулярных выражений выполняет следующие операции:  
  
1.  Начинается с первого символа строки и сопоставляет "a" с выражением `(?<1>a)`.  Теперь значение группы `1` будет равно "a".  
  
2.  Перемещается ко второму символу и успешно сопоставляет строку "ab" с выражением `\1b` или "ab".  Затем результат, "ab", присваивается свойству `\1`.  
  
3.  Перемещает к четвертому символу.  Выражение `(?<1>\1b)` должно выдать ноль или больше соответствий, поэтому он успешно сопоставляет строку "abb" с выражением `\1b`.  Результат, "abb", передается в `\1`.  
  
 В данном примере `*` является циклическим квантором – он вычисляется многократно до тех пор, пока обработчик регулярных выражений не сможет обнаружить соответствие заданному им шаблону.  Кванторы циклов не удаляют определения групп.  
  
 Если для группы не было найдено ни одной подстроки, то обратная ссылка на эту группу не определена и не работает.  Это иллюстрируется шаблоном регулярного выражения `\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b`, который определяется следующим образом:  
  
|Шаблон|Описание|  
|------------|--------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(\p{Lu}{2})`|Выделить две прописные буквы.  Это первая группа записи.|  
|`(\d{2})?`|Выделить ноль или одно вхождение двух десятичных цифр.  Это вторая группа записи.|  
|`(\p{Lu}{2})`|Выделить две прописные буквы.  Это третья группа записи.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 Строка ввода может соответствовать этому регулярному выражению, даже если отсутствуют две десятичные цифры, которые заданы второй захватываемой группой.  В следующем примере показано, что, даже несмотря на то что совпадение является успешным, между двумя группами успешной записи найдена пустая группа.  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference5.cs#5)]
 [!code-vb[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference5.vb#5)]  
  
## См. также  
 [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)