---
title: "Конструкции обратных ссылок в регулярных выражениях"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- backreferences
- constructs, backreference
- .NET Framework regular expressions, backreference constructs
- regular expressions, backreference constructs
ms.assetid: 567a4b8d-0e79-49dc-8df9-f4b1aa376a2a
caps.latest.revision: "11"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: a884e70f542c2ed7ff63e39cb7eadedf0ef7b4d0
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="backreference-constructs-in-regular-expressions"></a>Конструкции обратных ссылок в регулярных выражениях
Обратные ссылки предоставляют удобный способ идентификации повторяющегося символа или подстроки в строке. Например, если входная строка содержит несколько экземпляров произвольной подстроки, можно найти первое вхождение с помощью группы записи, а затем использовать обратную ссылку для поиска последующих вхождений подстроки.  
  
> [!NOTE]
>  Для ссылки на именованные и нумерованные захватываемые группы в строках замены используется отдельный синтаксис. Для получения дополнительной информации см. [Substitutions](substitutions-in-regular-expressions.md).  
  
 .NET определяет отдельные элементы языка для ссылки на нумерованные и именованные захватываемые группы. Дополнительные сведения о захватываемые группы в разделе [конструкции группировки](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).  
  
## <a name="numbered-backreferences"></a>Нумерованные обратные ссылки  
 Нумерованная обратная ссылка использует следующий синтаксис:  
  
 `\` *number*  
  
 где *число* — это порядковое положение захватываемой группы в регулярном выражении. Например, `\4` соответствует содержимому четвертой захватываемой группы. Если *номер* не определен в шаблоне регулярного выражения, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>. Например, регулярное выражение `\b(\w+)\s\1` является допустимым, поскольку `(\w+)` — это первая и единственная захватываемая группа в выражении. С другой стороны, выражение `\b(\w+)\s\2` недопустимо и создает исключение аргумента, так как захватываемая группа с номером `\2` отсутствует.  
  
 Следует отметить неоднозначность восьмеричных escape-кодах (такие как `\16`) и `\` *номер* обратные ссылки, используют одну нотацию. Эта неопределенность разрешается следующим образом:  
  
-   Выражения с `\1` по `\9` всегда интерпретируются как обратные ссылки, а не как восьмеричные коды.  
  
-   Если первая цифра многоразрядного выражения — 8 или 9 (например, `\80` или `\91`), выражение интерпретируется как литерал.  
  
-   Выражения от `\10` и более считаются обратными ссылками, если имеется обратная ссылка, соответствующая этому номеру. В противном случае они интерпретируются как восьмеричные коды.  
  
-   Если регулярного выражения содержит обратную ссылку на неопределенный номер группы, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  
  
 Если неоднозначность нежелательна, можно использовать `\k<` *имя* `>` представление, которое является однозначным и не следует путать с восьмеричными кодами знаков. Аналогичным образом шестнадцатеричные коды, например `\xdd`, однозначны, и их нельзя спутать с обратными ссылками.  
  
 В приведенном ниже примере в строке выделяются двойные словообразующие символы. Здесь определяется регулярное выражение, `(\w)\1`, которое состоит из следующих элементов.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|`(\w)`|Совпадение со словообразующим символом и его назначение первой захватываемой группе.|  
|`\1`|Совпадение со следующим символом, значение которого совпадает с первой захватываемой группой.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference1.cs#1)]
 [!code-vb[RegularExpressions.Language.Backreferences#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference1.vb#1)]  
  
## <a name="named-backreferences"></a>Именованные обратные ссылки  
 Именованная обратная ссылка задается с помощью следующего синтаксиса:  
  
 `\k<` *имя* `>`  
  
 или  
  
 `\k'` *name* `'`  
  
 где *name*— это имя захватываемой группы, определенное в шаблоне регулярного выражения. Если *имя* не определен в шаблоне регулярного выражения, возникает ошибка синтаксического анализа, и обработчик регулярных выражений создает исключение <xref:System.ArgumentException>.  
  
 В приведенном ниже примере в строке выделяются двойные словообразующие символы. Здесь определяется регулярное выражение, `(?<char>\w)\k<char>`, которое состоит из следующих элементов.  
  
|Элемент|Описание|  
|-------------|-----------------|  
|`(?<char>\w)`|Совпадение с символом слова и назначьте его группе записи с именем `char`.|  
|`\k<char>`|Следующий символ, который является таким же, как значение соответствует `char` захватываемой группой.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference2.cs#2)]
 [!code-vb[RegularExpressions.Language.Backreferences#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference2.vb#2)]  
  
 Обратите внимание, что *name* также может быть строковым представлением числа. Например, далее используется регулярное выражение `(?<2>\w)\k<2>` для поиска в строке двойных словообразующих символов.  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference3.cs#3)]
 [!code-vb[RegularExpressions.Language.Backreferences#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference3.vb#3)]  
  
## <a name="what-backreferences-match"></a>С чем сопоставляются обратные ссылки  
 Обратная ссылка относится к самому недавнему определению группы (самому ближнему слева определению при обработке слева направо). Если из группы создается несколько шаблонов для поиска, обратная ссылка относится к самому последнему шаблону.  
  
 В примере ниже показан шаблон регулярного выражения `(?<1>a)(?<1>\1b)*`, который переопределяет именованную группу \1. В следующей таблице описывается каждый шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(?<1>a)`|Соответствует символу «a» и присвоить результат группе записи с именем `1`.|  
|`(?<1>\1b)*`|Соответствует 0 или 1 вхождения группы с именем `1` вместе с «b» и назначить результат группе записи с именем `1`.|  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference4.cs#4)]
 [!code-vb[RegularExpressions.Language.Backreferences#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference4.vb#4)]  
  
 При сравнении регулярного выражения с входной строкой ("aababb") обработчик регулярных выражений выполняет указанные далее операции.  
  
1.  Начинается с первого символа и успешно сопоставляет "a" с выражением `(?<1>a)`. Значение `1` теперь является группа «».  
  
2.  Перемещается ко второму символу и успешно сопоставляет строку "ab" с выражением `\1b` или "ab". Затем результат "ab" присваивается `\1`.  
  
3.  Переходит к четвертому символу. Выражение `(?<1>\1b)` должно выдать ноль или больше совпадений, поэтому он успешно сопоставляет строку "abb" с выражением `\1b`. Затем результат "abb" присваивается `\1`.  
  
 В этом примере `*` является циклическим квантификатором — он вычисляется многократно до тех пор, пока обработчик регулярных выражений не сможет обнаружить соответствие заданному им шаблону. Квантификаторы циклов не удаляют определения групп.  
  
 Если для группы не было найдено ни одной подстроки, то обратная ссылка на эту группу не определена и не работает. Это продемонстрировано в шаблоне регулярного выражения `\b(\p{Lu}{2})(\d{2})?(\p{Lu}{2})\b`, определяется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Сопоставление начинается на границе слова.|  
|`(\p{Lu}{2})`|Совпадение с двумя прописными буквами. Это первая группа записи.|  
|`(\d{2})?`|Совпадение с нулевым или единичным вхождением двух десятичных цифр. Это вторая группа записи.|  
|`(\p{Lu}{2})`|Совпадение с двумя прописными буквами. Это третья группа записи.|  
|`\b`|Сопоставление заканчивается на границе слова.|  
  
 Входная строка может соответствовать этому регулярному выражению, даже если отсутствуют две десятичные цифры, которые заданы второй захватываемой группой. В следующем примере показано, что даже несмотря на то, что сопоставление является успешным, между двумя группами успешной записи найдена пустая группа.  
  
 [!code-csharp[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.backreferences/cs/backreference5.cs#5)]
 [!code-vb[RegularExpressions.Language.Backreferences#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.backreferences/vb/backreference5.vb#5)]  
  
## <a name="see-also"></a>См. также  
 [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
