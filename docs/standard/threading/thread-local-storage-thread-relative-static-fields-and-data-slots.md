---
title: "Thread Local Storage: Thread-Relative Static Fields and Data Slots | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "threading [.NET Framework], local storage"
  - "threading [.NET Framework], thread-relative static fields"
  - "local thread storage"
  - "TLS"
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
caps.latest.revision: 13
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 13
---
# Thread Local Storage: Thread-Relative Static Fields and Data Slots
Для хранения данных, уникально относящихся к потоку и домену приложения, служит управляемое локальное хранилище потока \(TLS\).  Платформа .NET Framework предоставляет два метода для использования локального хранилища потока: статические поля потока и области данных.  
  
-   Если фактические требования к приложению можно определить во время компиляции, следует использовать статические поля потока \(поля `Shared` для потока в Visual Basic\).  Статические поля потока обеспечивают самую высокую производительность.  Они также дают преимущества проверки типов во время компиляции.  
  
-   Если фактические требования могут определяться только во время выполнения, следует использовать области данных.  Области данных работают медленнее и не столь удобны в применении по сравнению со статическими полями потока, а данные хранятся с типом <xref:System.Object>, поэтому перед использованием их необходимо привести к правильному типу.  
  
 В неуправляемом коде C\+\+ функция `TlsAlloc` используется для динамического выделения областей, а функция `__declspec(thread)` объявляет, что в хранилище потока необходимо выделить переменную.  Статические поля потока и области данных предоставляют управляемую версию этих функций.  
  
 В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] можно использовать класс <xref:System.Threading.ThreadLocal%601?displayProperty=fullName> для создания локальных объектов потока, с отложенной инициализацией при первом использовании объекта.  Для получения дополнительной информации см. [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).  
  
## Уникальность данных в управляемом локальном хранилище потока  
 При использовании статических полей потока или областей данных управляемое локальное хранилище потока будет содержать данные, уникальные относительно сочетания потока и домена приложения.  
  
-   Один поток не может изменять данные из другого потока в пределах домена приложений, даже если оба потока используют одно поле или одну область данных.  
  
-   Если поток получает доступ к одному потоку или области данных из нескольких доменов приложений, в каждом домене приложения хранится отдельное значение.  
  
 Например, если поток устанавливает значение статического поля потока, входит в другой домен приложения и запрашивает значение этого поля, то значение, возвращаемое во втором домене приложения, отличается от значения в первом домене.  Задание нового значения для поля во втором домене приложения не затрагивает значение поля в первом домене.  
  
 Аналогично, когда поток получает доступ к области данных, имеющей одинаковое имя в двух доменах приложения, данные в первом домене приложения остаются независимыми от данных во втором домене.  
  
## Статические поля потока  
 Если известно, что некоторый фрагмент данных всегда является уникальным для сочетания потока и домена приложения, примените к статическому полю атрибут <xref:System.ThreadStaticAttribute>.  Это поле можно использовать аналогично любому другому статическому полю.  Данные в этом поле являются уникальными для каждого потока, использующего поле.  
  
 Статические поля потоков обеспечивают более высокую производительность, чем области данных, и дают преимущества проверки типов во время компиляции.  
  
 Следует учитывать, что любой код конструктора класса будет работать с первым потоком в первом контексте, получающим доступ к полю.  Поля во всех других потоках и во всех других контекстах в пределах того же домена приложения будут инициализированы значением `null` \(`Nothing` в Visual Basic\), если они имеют ссылочные типы, или значениями по умолчанию, если они имеют типы значения.  Поэтому не следует полагаться на инициализацию статических полей потока конструкторами классов.  Напротив, следует избегать инициализации статических полей потока и предполагать, что они инициализированы значениями `null` \(`Nothing`\) или значениями по умолчанию.  
  
## Области данных  
 Платформа .NET Framework предоставляет динамические области данных, которые являются уникальными для сочетания потока и домена приложения.  Существует два типа областей данных: именованные и безымянные.  Оба типа реализуются с помощью структуры <xref:System.LocalDataStoreSlot>.  
  
-   Для создания именованной области данных служит метод <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=fullName> или <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=fullName>.  Чтобы получить ссылку на существующую именованную область, передайте ее имя методу <xref:System.Threading.Thread.GetNamedDataSlot%2A>.  
  
-   Для создания безымянной области данных служит метод <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=fullName>.  
  
 Методы <xref:System.Threading.Thread.SetData%2A?displayProperty=fullName> и <xref:System.Threading.Thread.GetData%2A?displayProperty=fullName> используются для задания и получения данных в областях обоих типов.  Эти статические методы всегда работают с данными в потоке, который выполняет их в текущий момент.  
  
 Использование именованных областей может быть удобным, поскольку позволяет получить необходимую область, передав ее имя методу <xref:System.Threading.Thread.GetNamedDataSlot%2A>, а не хранить ссылку на безымянную область.  Однако если в другом компоненте для хранилища потока используется то же имя, и поток выполняет код из обоих компонентов, то эти компоненты могут повредить данные друг друга. \(В этом сценарии предполагается, что оба компонента работают в одном домене приложения и не рассчитаны на совместное использование данных.\)  
  
## См. также  
 <xref:System.ContextStaticAttribute>   
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=fullName>   
 <xref:System.ThreadStaticAttribute>   
 <xref:System.Runtime.Remoting.Messaging.CallContext>   
 [Threading](../../../docs/standard/threading/index.md)