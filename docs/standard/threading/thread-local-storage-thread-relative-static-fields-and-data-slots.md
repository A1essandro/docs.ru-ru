---
title: "Локальное хранилище потока: статические поля потока и области данных"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
caps.latest.revision: "13"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 39dd80d378171563f2aadadaa146278e8a417d32
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a>Локальное хранилище потока: статические поля потока и области данных
Можно использовать локальное хранилище управляемого потока (TLS) для хранения данных, уникальное для потока и домена приложения. Платформа .NET Framework предоставляет два способа использования локального Хранилища: потока статические поля и ячейки данных.  
  
-   Используйте статические поля потоков (потока `Shared` поля в Visual Basic), если предполагается свои конкретные нужды во время компиляции. Статические поля потока обеспечивает улучшенную производительность. Они также дают преимущества проверки типов во время компиляции.  
  
-   Если фактические требования могут определяться только во время выполнения, следует используйте области данных. Области данных работают медленнее и более удобны в использовании, чем статические поля потока и данные хранятся в виде типа <xref:System.Object>, поэтому перед использованием их необходимо привести к правильному типу.  
  
 В неуправляемом коде C++ используйте `TlsAlloc` выделения ячеек и `__declspec(thread)` объявить, что в хранилище потока необходимо выделить переменную. Потока статические поля и области данных предоставляют управляемую версию этого поведения.  
  
 В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], можно использовать <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> класс для создания объектов локального потока, инициализацией при первом использовании объекта. Дополнительные сведения см. в статье [Отложенная инициализация](../../../docs/framework/performance/lazy-initialization.md).  
  
## <a name="uniqueness-of-data-in-managed-tls"></a>Уникальность данных в управляемом TLS  
 Используется ли статические поля потока и области данных, данных управляемое локальное хранилище потока является уникальным для сочетания потока и домена приложения.  
  
-   В домене приложения один поток не могут изменять данные из другого потока, даже в том случае, если оба потока используют одно поле или области памяти.  
  
-   Когда поток обращается к одному потоку или области из нескольких доменов приложений, в каждом домене приложения хранится отдельное значение.  
  
 Например если поток устанавливает значение статического поля потока, переходит в другом домене приложения, а затем извлекает значение поля, значение, возвращаемое во втором домене приложения, отличается от значения в первом домене приложения. Задав новое значение для поля во втором домене приложения не влияет на значение поля в первом домене приложения.  
  
 Аналогичным образом когда поток получает же именованную область данных в двух разных доменах приложений, данные в первом домене остается независимо от данных во втором домене приложения.  
  
## <a name="thread-relative-static-fields"></a>Статические поля потоков  
 Если вы знаете, что часть данных всегда является уникальным для потока и домену приложения, применить <xref:System.ThreadStaticAttribute> атрибут для статического поля. Используйте поле при использовании статического поля. Данные в поле является уникальным для каждого потока, который его использует.  
  
 Статические поля потока обеспечивают более высокую производительность, чем области данных и воспользоваться преимуществами проверки типов во время компиляции.  
  
 Имейте в виду, что любой код конструктора класса будет запускаться на первый поток в первом контексте, который обращается к полю. Во всех других потоков или контекстов в том же домене приложения, поля будут присвоены `null` (`Nothing` в Visual Basic) или если они являются ссылочными типами по умолчанию значения, если они являются типами значений. Таким образом не следует полагаться на конструкторы класса, чтобы инициализировать статические поля потока. Вместо этого следует избегать инициализации статические поля потока и предполагается, что они инициализируются `null` (`Nothing`) или значениями по умолчанию.  
  
## <a name="data-slots"></a>Области данных  
 Платформа .NET Framework предоставляет ячейки данных, которые являются уникальными для сочетания потока и домена приложения. Существует два типа областей данных: именованные и безымянные. Оба реализуются с помощью <xref:System.LocalDataStoreSlot> структуры.  
  
-   Чтобы создать именованную область данных, используйте <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> или <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> метод. Чтобы получить ссылку на существующую именованную область, передайте ее имя на <xref:System.Threading.Thread.GetNamedDataSlot%2A> метод.  
  
-   Чтобы создать неименованную область данных, используйте <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> метод.  
  
 Для обоих именованные и неименованные слотов, используйте <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> и <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> методы задания и получения данных в областях. Это статические методы, которые всегда работают с данными потока, который в данный момент их.  
  
 Именованных областей может быть удобным, поскольку позволяет получить необходимую область, при необходимости, передав его имя <xref:System.Threading.Thread.GetNamedDataSlot%2A> метода, а не хранить ссылку на безымянную область. Тем не менее если другой компонент использует то же имя для его хранения потока и поток выполняет код из компонента и других компонентов, эти компоненты могут повредить данные друг друга. (Этот сценарий предполагает, что оба компонента работают в одном домене приложения, и что они не предназначены для совместного использования тех же данных.)  
  
## <a name="see-also"></a>См. также  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [Работа с потоками](../../../docs/standard/threading/index.md)
