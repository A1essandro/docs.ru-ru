---
title: "Рекомендации по работе с потоками"
ms.custom: 
ms.date: 11/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- threading [.NET Framework], design guidelines
- threading [.NET Framework], best practices
- managed threading
ms.assetid: e51988e7-7f4b-4646-a06d-1416cee8d557
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: e396bb1f6a710e49e311ca1526a7aae9bca7bf90
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="managed-threading-best-practices"></a>Рекомендации по работе с потоками
Многопоточность требует тщательного программирования. Большинство задач можно упростить, поместив запросы на выполнение в очередь по потокам пулов потоков. В этом разделе рассматриваются более сложные ситуации, такие как координация работы нескольких потоков или обработка потоков, вызывающих блокировку.  
  
> [!NOTE]
> Начиная с .NET Framework 4, библиотека параллельных задач и PLINQ предоставляют интерфейсы API, которые уменьшают сложность и риски многопотокового программирования. Дополнительные сведения см. в разделе [параллельное программирование в .NET](../../../docs/standard/parallel-programming/index.md).  
  
## <a name="deadlocks-and-race-conditions"></a>Взаимоблокировки и конфликты  
 Многопоточность позволяет решить проблемы с пропускной способностью и скоростью реагирования, но при этом возникают новые проблемы: взаимоблокировки и конфликты.  
  
### <a name="deadlocks"></a>Взаимоблокировки  
 Взаимоблокировка происходит, когда каждый из двух потоков пытается заблокировать ресурс, уже заблокированный другим потоком. Ни один из потоков не может продолжить работу.  
  
 Многие методы классов управляемых потоков предоставляют значения времени ожидания для обнаружения взаимоблокировок. Например, следующий код пытается получить блокировку на объект с именем `lockObject`. Если блокировка не может быть получен в течение 300 миллисекунд <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType> возвращает `false`.  
  
```vb  
If Monitor.TryEnter(lockObject, 300) Then  
    Try  
        ' Place code protected by the Monitor here.  
    Finally  
        Monitor.Exit(lockObject)  
    End Try  
Else  
    ' Code to execute if the attempt times out.  
End If  
```  
  
```csharp  
if (Monitor.TryEnter(lockObject, 300)) {  
    try {  
        // Place code protected by the Monitor here.  
    }  
    finally {  
        Monitor.Exit(lockObject);  
    }  
}  
else {  
    // Code to execute if the attempt times out.  
}  
```  
  
### <a name="race-conditions"></a>Конфликты  
 Конфликт — это ошибка, которая возникает, когда результат программы зависит от того, какой из двух или более потоков первым достигнет определенного блока кода. Выполнение программы часто дает различные результаты, и предсказать результат выполнения конкретного запуска невозможно.  
  
 Простой пример состояния гонки — увеличение поля. Предположим, что класс содержит закрытое поле **static** (**Shared** в Visual Basic), которое увеличивается всякий раз при создании класса с помощью кода, например `objCt++;` (в C#) или `objCt += 1` (в Visual Basic). Для этой операции необходимо загрузить значение из `objCt` в регистр, увеличить или уменьшить это значение и сохранить его в `objCt`.  
  
 В многопоточных приложениях поток, загружающий и увеличивающий значение, может быть вытеснен другим потоком, который выполняет все три эти действия; если первый поток возобновляет выполнение и сохраняет его значение, он переопределяет `objCt`, не принимая во внимание тот факт, что в промежутке значение изменилось.  
  
 Подобного состояния гонки можно легко избежать с помощью методов <xref:System.Threading.Interlocked> класса, такие как <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>. Сведения о других технологиях синхронизации данных между несколькими потоками см. в разделе [Синхронизация данных для многопоточности](../../../docs/standard/threading/synchronizing-data-for-multithreading.md).  
  
 Конфликты могут также возникать при синхронизации действий различных потоков. При написании каждой строки кода необходимо учитывать, что может произойти, если поток будет вытеснен другим потоком до ее выполнения (или до одной из индивидуальных машинных команд, составляющих эту строку).  
  
## <a name="number-of-processors"></a>Число процессоров  
 Сейчас большинство компьютеров, включая компактные устройства, такие как планшетные ПК и телефоны, имеют несколько процессоров (так называемых ядер). Если вы знаете, что ваше программное обеспечение будет выполняться на однопроцессорных компьютерах, учитывайте тот факт, что многопоточность решает разные задачи для однопроцессорных и многопроцессорных компьютеров.  
  
### <a name="multiprocessor-computers"></a>Многопроцессорные компьютеры  
 Многопоточность обеспечивает более высокую пропускную способность. Десять процессоров могут сделать в десять раз больше работы, чем один, но только если работа распределена таким образом, что все десять работают одновременно; распределить работу и использовать дополнительные вычислительные мощности помогают потоки. При использовании многопоточности на многопроцессорном компьютере:  
  
-   Число потоков, которые могут выполняться параллельно, ограничивается числом процессоров.  
  
-   Фоновый поток выполняется, только если число основных потоков меньше, чем количество процессоров.  
  
-   При вызове <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType> метод в потоке этот поток может или начала его выполнения немедленно, в зависимости от количества процессоров и потоков, которые в настоящее время в очереди на выполнение.  
  
-   Конфликты могут возникать не только из-за внезапного вытеснения потоков, но и потому, что два потока, которые выполняются на разных процессорах, могут претендовать на один и тот же блок кода.  
  
### <a name="single-processor-computers"></a>Однопроцессорные компьютеры  
 Многопоточность увеличивает скорость реагирования компьютера на действия пользователя, а также использует время простоя для выполнения фоновых задач. При использовании многопоточности на однопроцессорном компьютере:  
  
-   В любой момент времени может выполняться только один поток.  
  
-   Фоновый поток выполняется, только когда основной поток пользователя бездействует. Выполняемый основной поток постоянно нуждается в фоновых потоках процессорного времени.  
  
-   При вызове <xref:System.Threading.Thread.Start%2A?displayProperty=nameWithType> метод в потоке, что поток не запускается выполнение до текущего потока или будет прерван операционной системы.  
  
-   Обычно конфликты возникают потому, что программист не предусмотрел то, что поток может быть вытеснен в самый неподходящий момент, позволив другому потоку первым добраться до определенного блока кода.  
  
## <a name="static-members-and-static-constructors"></a>Статические члены и статические конструкторы  
 Класс не инициализируется, пока не завершится выполнение его конструктора (конструктор `static` в C# `Shared Sub New` в Visual Basic). Чтобы предотвратить выполнение кода в еще не инициализированном типе, CLR блокирует все вызовы из других потоков для членов класса `static` (члены `Shared` в Visual Basic) до тех пор, пока выполнение конструктора класса не будет завершено.  
  
 Например, если конструктор класса запускает новый поток, а процедура потока вызывает член `static` класса, новый поток блокируется до завершения конструктора класса.  
  
 Это относится к любому типу, который может иметь конструктор `static`.  
  
## <a name="general-recommendations"></a>Основные рекомендации  
 При использовании нескольких потоков соблюдайте следующие рекомендации:  
  
-   Не используйте <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> для завершения других потоков. Вызов метода **Abort** для другого потока аналогичен вызову исключения в этом потоке, когда неизвестно, на каком этапе находится обработка этого потока.  
  
-   Не используйте <xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType> и <xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType> для синхронизации действий нескольких потоков. Используйте <xref:System.Threading.Mutex>, <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, и <xref:System.Threading.Monitor>.  
  
-   Не контролируйте выполнение рабочих потоков из основной программы (например, с помощью событий). Вместо этого составьте программу так, чтобы рабочие потоки ожидали доступности задания, выполняли его и оповещали другие части программы о его завершении. Если рабочие потоки не блокируются, можно использовать потоки из пула потоков. <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>можно использовать в ситуациях, когда рабочие потоки блокируются.  
  
-   Не используйте типы как объекты блокировки. То есть, избегайте кода, такие как `lock(typeof(X))` в C# или `SyncLock(GetType(X))` в Visual Basic или использование <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> с <xref:System.Type> объектов. Для данного типа имеется только один экземпляр <xref:System.Type?displayProperty=nameWithType> домена приложения. Если блокируемый тип является открытым, его может заблокировать чужой код, вызвав тем самым взаимоблокировку. Дополнительные вопросы см. [Рекомендации по обеспечению надежности](../../../docs/framework/performance/reliability-best-practices.md).  
  
-   Будьте внимательны при блокировке экземпляров, например `lock(this)` в C# или `SyncLock(Me)` в Visual Basic. Если другой код в приложении, который является внешним для типа, заблокирует объект, может возникнуть взаимоблокировка.  
  
-   Следите за тем, чтобы каждый поток, который входит в монитор, обязательно вышел из этого монитора, даже если за время, пока поток находится в мониторе, возникает исключение. C# [блокировки](~/docs/csharp/language-reference/keywords/lock-statement.md) инструкции и Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) инструкции это поведение автоматически предоставляют, использующей **наконец** блок, чтобы убедиться, что <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> — вызывается. Если вы не можете проконтролировать вызов метода **Exit**, включите в свое приложение **мьютекс**. Мьютекс автоматически освобождается, как только прекращается выполнение владеющего им потока.  
  
-   Для задач, которые требуют различных ресурсов, используйте несколько потоков и старайтесь не назначать несколько потоков одному ресурсу. Например, любая задача с использованием ввода-вывода выигрывает от наличия собственного потока, поскольку во время операций ввода-вывода этот поток блокируется и, таким образом, разрешает выполнение других потоков. Входные данные пользователя — еще один ресурс, которому пойдет на пользу выделенный поток. На однопроцессорном компьютере задача, требующая активных вычислений, сосуществует с входными данными пользователя и задачами, которые предусматривают операции ввода-вывода, однако несколько ресурсоемких задач могут конкурировать друг с другом.  
  
-   Рассмотрите возможность использования методов <xref:System.Threading.Interlocked> класс для изменения простых состояний вместо `lock` инструкции (`SyncLock` в Visual Basic). `lock` Инструкция является хорошим средством общего назначения, но <xref:System.Threading.Interlocked> класс обеспечивает лучшую производительность для обновлений, которые должны быть атомарными. Если конкуренции нет, он выполняет внутри единственный префикс lock. При проверке кода ищите код, похожий на показанный в следующих примерах. В первом примере увеличивается переменная состояния:  
  
    ```vb  
    SyncLock lockObject  
        myField += 1  
    End SyncLock  
    ```  
  
    ```csharp  
    lock(lockObject)   
    {  
        myField++;  
    }  
    ```  
  
     Можно повысить производительность с помощью <xref:System.Threading.Interlocked.Increment%2A> вместо метода `lock` следующим образом:  
  
    ```vb  
    System.Threading.Interlocked.Increment(myField)  
    ```  
  
    ```csharp  
    System.Threading.Interlocked.Increment(myField);  
    ```  
  
    > [!NOTE]
    >  В .NET Framework версии 2.0 <xref:System.Threading.Interlocked.Add%2A> метод предоставляет атомарные обновления с приращением значения более чем 1.  
  
     Во втором примере переменная ссылочного типа обновляется только в том случае, если она является пустой ссылкой (`Nothing` в Visual Basic).  
  
    ```vb  
    If x Is Nothing Then  
        SyncLock lockObject  
            If x Is Nothing Then  
                x = y  
            End If  
        End SyncLock  
    End If  
    ```  
  
    ```csharp  
    if (x == null)  
    {  
        lock (lockObject)  
        {  
            if (x == null)  
            {  
                x = y;  
            }  
        }  
    }  
    ```  
  
     Можно повысить производительность, используя <xref:System.Threading.Interlocked.CompareExchange%2A> метод вместо этого, как показано ниже:  
  
    ```vb  
    System.Threading.Interlocked.CompareExchange(x, y, Nothing)  
    ```  
  
    ```csharp  
    System.Threading.Interlocked.CompareExchange(ref x, y, null);  
    ```  
  
    > [!NOTE]
    >  В .NET Framework версии 2.0 <xref:System.Threading.Interlocked.CompareExchange%2A> метод имеет универсальную перегрузку, которая может использоваться для замены типобезопасный любого ссылочного типа.  
  
## <a name="recommendations-for-class-libraries"></a>Рекомендации для библиотек классов  
 При разработке библиотек классов для многопоточности необходимо учитывать следующие рекомендации.  
  
-   Старайтесь не создавать потребность в синхронизации. Особенно это относится к коду, который используется наиболее часто. Например, алгоритм можно скорректировать таким образом, чтобы он допускал конфликты, а не устранял их. Ненужная синхронизация снижает производительность и может привести к взаимоблокировке и конфликтам.  
  
-   Сделайте статические данные (`Shared` в Visual Basic) по умолчанию потокобезопасными.  
  
-   Данные экземпляров не должны быть потокобезопасными по умолчанию. Добавление блокировок для создания потокобезопасного кода снижает производительность, увеличивает конфликт блокировки и создает условия для возникновения взаимоблокировок. В обычных моделях приложений пользовательский код одновременно выполняется только одним потоком, что уменьшает необходимость потокобезопасности. По этой причине библиотеки классов .NET Framework не являются потокобезопасными по умолчанию.  
  
-   Не предоставляйте статические методы, изменяющие статическое состояние. В обычных сценариях сервера статическое состояние используется запросами совместно, а значит, код одновременно могут выполнять сразу несколько потоков. Это открывает возможность для появления потоковых ошибок. Попробуйте применить конструктивный шаблон, инкапсулирующий данные в экземпляры, которые не являются общими для запросов. Кроме того, если статические данные синхронизируются, вызовы между статическими методами, изменяющие состояние, могут приводить к взаимоблокировкам или избыточной синхронизации, что, в свою очередь, снижает производительность.  
  
## <a name="see-also"></a>См. также  
 [Работа с потоками](../../../docs/standard/threading/index.md)  
 [Потоки и работа с потоками](../../../docs/standard/threading/threads-and-threading.md)
