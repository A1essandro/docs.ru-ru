---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a>EventWaitHandle
<xref:System.Threading.EventWaitHandle> Класс позволяет потокам взаимодействовать друг с другом путем передачи сигналов и ожидания сигналов. Дескрипторы ожидания событий (также называется просто событий), дескрипторы ожидания, которые могут сигнализировать, что позволяет освободить один или более ожидающих потоков. После получения сигнала, дескриптор ожидания событий сбрасывается вручную или автоматически. <xref:System.Threading.EventWaitHandle> Класс может представлять любой локальный дескриптор ожидания событий (локальное событие) или именованный системный дескриптор ожидания событий (с именем событие или системное событие, видимое всеми процессами).  
  
> [!NOTE]
>  Дескрипторы ожидания событий не являются событиями, в том смысле, употребления это слово в платформе .NET Framework. Участвуют не делегаты или обработчики событий. Слово «событие» используется для описания их, поскольку они традиционно называются событиями операционной системы, а во время передачи сигналов дескриптора ожидания указывает ожидающим потокам, произошло событие.  
  
 Как локальные, так и именованные дескрипторы ожидания событий используют объекты синхронизации системы, которые защищены <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> программы-оболочки для освобождения ресурсов. Можно использовать <xref:System.Threading.WaitHandle.Dispose%2A> метод для освобождения ресурсов, сразу же после завершения с помощью объекта.  
  
## <a name="event-wait-handles-that-reset-automatically"></a>Дескрипторы ожидания событий, которые сбрасываются автоматически  
 Создание события автоматического сброса, указав <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> при создании <xref:System.Threading.EventWaitHandle> объекта. Как и предполагает его имя, это событие синхронизации сбрасывается автоматически при получении сигнала после освобождения одного ожидающего потока. Сообщить о событии путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> метод.  
  
 События автоматического сброса обычно используются для предоставления монопольного доступа к ресурсу для одного потока одновременно. Поток запрашивает ресурс путем вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод. Если ни один поток не удерживает дескриптор ожидания, метод возвращает `true` и вызывающий поток получает управление ресурсом.  
  
> [!IMPORTANT]
>  Как и для всех механизмы синхронизации, необходимо убедиться, что все пути кода ожидание подходящий дескриптор ожидания перед получением доступа к защищенному ресурсу. Синхронизация потоков выполняется совместно.  
  
 Если при возникновении события автоматического сброса, получает сигнал при отсутствии ожидающих потоков, он остается сигнальное, пока поток пытается ожидания. Событие освобождает поток и немедленно сбрасывается, блокируя последующие потоки.  
  
## <a name="event-wait-handles-that-reset-manually"></a>Дескрипторы ожидания событий, которые сбрасываются вручную  
 Событие сброса вручную создать, указав <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> при создании <xref:System.Threading.EventWaitHandle> объекта. Как и предполагает его имя, это событие синхронизации необходимо сбросить вручную после было сообщено. Пока будет сброшен, путем вызова его <xref:System.Threading.EventWaitHandle.Reset%2A> метод, потоки, ожидающие дескриптор события немедленно продолжить работу без блокировки.  
  
 Ручной Сброс событий действует как шлюз загона. Если событие не сигнализирует, блок потоков, ожидающие, как в загоне. Если событие сигнализирует, путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> , все ожидающие потоки становятся свободными. Событие получает сигнал до его <xref:System.Threading.EventWaitHandle.Reset%2A> вызывается метод. Это делает событие ручного сброса идеальным способом удерживания потоков, которые необходимо подождать, пока один поток завершает задачу.  
  
 Как загона затрачивается время освобожденные потоки для планирования операционной системой, чтобы возобновить выполнение. Если <xref:System.Threading.EventWaitHandle.Reset%2A> метод вызывается до возобновления выполнения все потоки, оставшиеся потоки снова блокируются. Какие потоки возобновляют работу, а какие блокируются зависит от случайных факторов, как нагрузку на систему, число потоков, ожидающих для планировщика и т. д. Это не проблема, если поток, который сигнализирует событие завершается после подачи сигнала, который является наиболее распространенных шаблонов использования. Если вы хотите потока, которая оповещает событие, чтобы начать новую задачу, после того как все ожидающих потоков возобновления работы, необходимо заблокировать до возобновления работы всех ожидающих потоков. В противном случае у вас есть условие состязания и поведение кода будет непредсказуемым.  
  
## <a name="features-common-to-automatic-and-manual-events"></a>Компоненты, общие для автоматического и ручного события.  
 Как правило, один или несколько потоков блокируются на <xref:System.Threading.EventWaitHandle> до как незаблокированный поток вызовет <xref:System.Threading.EventWaitHandle.Set%2A> метод, который освобождает один из ожидающих потоков (в случае события автоматического сброса) или все из них (случае событий ручного сброса). Поток может сообщить <xref:System.Threading.EventWaitHandle> и затем заблокировать, как атомарную операцию, вызвав статическое <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> метод.  
  
 <xref:System.Threading.EventWaitHandle>объекты, которые могут использоваться вместе со статическими <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы. Поскольку <xref:System.Threading.EventWaitHandle> и <xref:System.Threading.Mutex> оба класса являются производными от <xref:System.Threading.WaitHandle>, с помощью этих методов можно использовать оба класса.  
  
### <a name="named-events"></a>Именованные события  
 Операционная система Windows дескрипторы ожидания событий могут иметь имена. Именованное событие относится ко всей системе. То есть после создания именованного события является видимым для всех потоков во всех процессах. Таким образом именованного события могут использоваться для синхронизации действий процессов, а также потоков.  
  
 Можно создать <xref:System.Threading.EventWaitHandle> объект, который представляет именованное системное событие с помощью одного из конструкторов, указывающих имя события.  
  
> [!NOTE]
>  Так как именованные события применимы ко всей системе, можно иметь несколько <xref:System.Threading.EventWaitHandle> объектов, представляющих одно именованное событие. При каждом вызове конструктора или <xref:System.Threading.EventWaitHandle.OpenExisting%2A> метод, новый <xref:System.Threading.EventWaitHandle> создан объект. Если указать то же имя несколько раз создает несколько объектов, представляющих одно именованное событие.  
  
 Следует соблюдать осторожность при использовании именованных событий. Так как они относятся ко всей системе, другой процесс, использующий то же имя может неожиданно заблокировать потоки. Вредоносный код, выполняемый на одном компьютере может использовать это как основу для атак типа "отказ в обслуживании".  
  
 Используйте безопасность управления доступом для защиты <xref:System.Threading.EventWaitHandle> , представляющий события с заданным именем, предпочтительно с помощью конструктора, который определяет <xref:System.Security.AccessControl.EventWaitHandleSecurity> объекта. Также можно применить безопасность управления доступом с помощью <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> метода, однако это оставит брешь в защите между временем создания дескриптора ожидания и времени, он защищен. Защита событий с помощью управления доступом безопасности способствует предотвращению атак злоумышленников, но не решает проблемы непреднамеренного конфликта имен.  
  
> [!NOTE]
>  В отличие от <xref:System.Threading.EventWaitHandle> класс, производными классами <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent> могут представлять только локальные дескрипторы ожидания. Они не могут представлять именованного системного события.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
