---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="f04e8-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="f04e8-102">EventWaitHandle</span></span>
<span data-ttu-id="f04e8-103"><xref:System.Threading.EventWaitHandle> Класс позволяет потокам взаимодействовать друг с другом путем передачи сигналов и ожидания сигналов.</span><span class="sxs-lookup"><span data-stu-id="f04e8-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="f04e8-104">Дескрипторы ожидания событий (также называется просто событий), дескрипторы ожидания, которые могут сигнализировать, что позволяет освободить один или более ожидающих потоков.</span><span class="sxs-lookup"><span data-stu-id="f04e8-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="f04e8-105">После получения сигнала, дескриптор ожидания событий сбрасывается вручную или автоматически.</span><span class="sxs-lookup"><span data-stu-id="f04e8-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="f04e8-106"><xref:System.Threading.EventWaitHandle> Класс может представлять любой локальный дескриптор ожидания событий (локальное событие) или именованный системный дескриптор ожидания событий (с именем событие или системное событие, видимое всеми процессами).</span><span class="sxs-lookup"><span data-stu-id="f04e8-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f04e8-107">Дескрипторы ожидания событий не являются событиями, в том смысле, употребления это слово в платформе .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f04e8-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="f04e8-108">Участвуют не делегаты или обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="f04e8-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="f04e8-109">Слово «событие» используется для описания их, поскольку они традиционно называются событиями операционной системы, а во время передачи сигналов дескриптора ожидания указывает ожидающим потокам, произошло событие.</span><span class="sxs-lookup"><span data-stu-id="f04e8-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="f04e8-110">Как локальные, так и именованные дескрипторы ожидания событий используют объекты синхронизации системы, которые защищены <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> программы-оболочки для освобождения ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f04e8-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="f04e8-111">Можно использовать <xref:System.Threading.WaitHandle.Dispose%2A> метод для освобождения ресурсов, сразу же после завершения с помощью объекта.</span><span class="sxs-lookup"><span data-stu-id="f04e8-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="f04e8-112">Дескрипторы ожидания событий, которые сбрасываются автоматически</span><span class="sxs-lookup"><span data-stu-id="f04e8-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="f04e8-113">Создание события автоматического сброса, указав <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> при создании <xref:System.Threading.EventWaitHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="f04e8-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="f04e8-114">Как и предполагает его имя, это событие синхронизации сбрасывается автоматически при получении сигнала после освобождения одного ожидающего потока.</span><span class="sxs-lookup"><span data-stu-id="f04e8-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="f04e8-115">Сообщить о событии путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="f04e8-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="f04e8-116">События автоматического сброса обычно используются для предоставления монопольного доступа к ресурсу для одного потока одновременно.</span><span class="sxs-lookup"><span data-stu-id="f04e8-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="f04e8-117">Поток запрашивает ресурс путем вызова <xref:System.Threading.WaitHandle.WaitOne%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="f04e8-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f04e8-118">Если ни один поток не удерживает дескриптор ожидания, метод возвращает `true` и вызывающий поток получает управление ресурсом.</span><span class="sxs-lookup"><span data-stu-id="f04e8-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f04e8-119">Как и для всех механизмы синхронизации, необходимо убедиться, что все пути кода ожидание подходящий дескриптор ожидания перед получением доступа к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="f04e8-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="f04e8-120">Синхронизация потоков выполняется совместно.</span><span class="sxs-lookup"><span data-stu-id="f04e8-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="f04e8-121">Если при возникновении события автоматического сброса, получает сигнал при отсутствии ожидающих потоков, он остается сигнальное, пока поток пытается ожидания.</span><span class="sxs-lookup"><span data-stu-id="f04e8-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="f04e8-122">Событие освобождает поток и немедленно сбрасывается, блокируя последующие потоки.</span><span class="sxs-lookup"><span data-stu-id="f04e8-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="f04e8-123">Дескрипторы ожидания событий, которые сбрасываются вручную</span><span class="sxs-lookup"><span data-stu-id="f04e8-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="f04e8-124">Событие сброса вручную создать, указав <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> при создании <xref:System.Threading.EventWaitHandle> объекта.</span><span class="sxs-lookup"><span data-stu-id="f04e8-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="f04e8-125">Как и предполагает его имя, это событие синхронизации необходимо сбросить вручную после было сообщено.</span><span class="sxs-lookup"><span data-stu-id="f04e8-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="f04e8-126">Пока будет сброшен, путем вызова его <xref:System.Threading.EventWaitHandle.Reset%2A> метод, потоки, ожидающие дескриптор события немедленно продолжить работу без блокировки.</span><span class="sxs-lookup"><span data-stu-id="f04e8-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="f04e8-127">Ручной Сброс событий действует как шлюз загона.</span><span class="sxs-lookup"><span data-stu-id="f04e8-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="f04e8-128">Если событие не сигнализирует, блок потоков, ожидающие, как в загоне.</span><span class="sxs-lookup"><span data-stu-id="f04e8-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="f04e8-129">Если событие сигнализирует, путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> , все ожидающие потоки становятся свободными.</span><span class="sxs-lookup"><span data-stu-id="f04e8-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="f04e8-130">Событие получает сигнал до его <xref:System.Threading.EventWaitHandle.Reset%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="f04e8-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="f04e8-131">Это делает событие ручного сброса идеальным способом удерживания потоков, которые необходимо подождать, пока один поток завершает задачу.</span><span class="sxs-lookup"><span data-stu-id="f04e8-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="f04e8-132">Как загона затрачивается время освобожденные потоки для планирования операционной системой, чтобы возобновить выполнение.</span><span class="sxs-lookup"><span data-stu-id="f04e8-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="f04e8-133">Если <xref:System.Threading.EventWaitHandle.Reset%2A> метод вызывается до возобновления выполнения все потоки, оставшиеся потоки снова блокируются.</span><span class="sxs-lookup"><span data-stu-id="f04e8-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="f04e8-134">Какие потоки возобновляют работу, а какие блокируются зависит от случайных факторов, как нагрузку на систему, число потоков, ожидающих для планировщика и т. д.</span><span class="sxs-lookup"><span data-stu-id="f04e8-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="f04e8-135">Это не проблема, если поток, который сигнализирует событие завершается после подачи сигнала, который является наиболее распространенных шаблонов использования.</span><span class="sxs-lookup"><span data-stu-id="f04e8-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="f04e8-136">Если вы хотите потока, которая оповещает событие, чтобы начать новую задачу, после того как все ожидающих потоков возобновления работы, необходимо заблокировать до возобновления работы всех ожидающих потоков.</span><span class="sxs-lookup"><span data-stu-id="f04e8-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="f04e8-137">В противном случае у вас есть условие состязания и поведение кода будет непредсказуемым.</span><span class="sxs-lookup"><span data-stu-id="f04e8-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="f04e8-138">Компоненты, общие для автоматического и ручного события.</span><span class="sxs-lookup"><span data-stu-id="f04e8-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="f04e8-139">Как правило, один или несколько потоков блокируются на <xref:System.Threading.EventWaitHandle> до как незаблокированный поток вызовет <xref:System.Threading.EventWaitHandle.Set%2A> метод, который освобождает один из ожидающих потоков (в случае события автоматического сброса) или все из них (случае событий ручного сброса).</span><span class="sxs-lookup"><span data-stu-id="f04e8-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="f04e8-140">Поток может сообщить <xref:System.Threading.EventWaitHandle> и затем заблокировать, как атомарную операцию, вызвав статическое <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="f04e8-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f04e8-141"><xref:System.Threading.EventWaitHandle>объекты, которые могут использоваться вместе со статическими <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> методы.</span><span class="sxs-lookup"><span data-stu-id="f04e8-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f04e8-142">Поскольку <xref:System.Threading.EventWaitHandle> и <xref:System.Threading.Mutex> оба класса являются производными от <xref:System.Threading.WaitHandle>, с помощью этих методов можно использовать оба класса.</span><span class="sxs-lookup"><span data-stu-id="f04e8-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="f04e8-143">Именованные события</span><span class="sxs-lookup"><span data-stu-id="f04e8-143">Named Events</span></span>  
 <span data-ttu-id="f04e8-144">Операционная система Windows дескрипторы ожидания событий могут иметь имена.</span><span class="sxs-lookup"><span data-stu-id="f04e8-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="f04e8-145">Именованное событие относится ко всей системе.</span><span class="sxs-lookup"><span data-stu-id="f04e8-145">A named event is system wide.</span></span> <span data-ttu-id="f04e8-146">То есть после создания именованного события является видимым для всех потоков во всех процессах.</span><span class="sxs-lookup"><span data-stu-id="f04e8-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="f04e8-147">Таким образом именованного события могут использоваться для синхронизации действий процессов, а также потоков.</span><span class="sxs-lookup"><span data-stu-id="f04e8-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="f04e8-148">Можно создать <xref:System.Threading.EventWaitHandle> объект, который представляет именованное системное событие с помощью одного из конструкторов, указывающих имя события.</span><span class="sxs-lookup"><span data-stu-id="f04e8-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f04e8-149">Так как именованные события применимы ко всей системе, можно иметь несколько <xref:System.Threading.EventWaitHandle> объектов, представляющих одно именованное событие.</span><span class="sxs-lookup"><span data-stu-id="f04e8-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="f04e8-150">При каждом вызове конструктора или <xref:System.Threading.EventWaitHandle.OpenExisting%2A> метод, новый <xref:System.Threading.EventWaitHandle> создан объект.</span><span class="sxs-lookup"><span data-stu-id="f04e8-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="f04e8-151">Если указать то же имя несколько раз создает несколько объектов, представляющих одно именованное событие.</span><span class="sxs-lookup"><span data-stu-id="f04e8-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="f04e8-152">Следует соблюдать осторожность при использовании именованных событий.</span><span class="sxs-lookup"><span data-stu-id="f04e8-152">Caution is advised in using named events.</span></span> <span data-ttu-id="f04e8-153">Так как они относятся ко всей системе, другой процесс, использующий то же имя может неожиданно заблокировать потоки.</span><span class="sxs-lookup"><span data-stu-id="f04e8-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="f04e8-154">Вредоносный код, выполняемый на одном компьютере может использовать это как основу для атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="f04e8-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="f04e8-155">Используйте безопасность управления доступом для защиты <xref:System.Threading.EventWaitHandle> , представляющий события с заданным именем, предпочтительно с помощью конструктора, который определяет <xref:System.Security.AccessControl.EventWaitHandleSecurity> объекта.</span><span class="sxs-lookup"><span data-stu-id="f04e8-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="f04e8-156">Также можно применить безопасность управления доступом с помощью <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> метода, однако это оставит брешь в защите между временем создания дескриптора ожидания и времени, он защищен.</span><span class="sxs-lookup"><span data-stu-id="f04e8-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="f04e8-157">Защита событий с помощью управления доступом безопасности способствует предотвращению атак злоумышленников, но не решает проблемы непреднамеренного конфликта имен.</span><span class="sxs-lookup"><span data-stu-id="f04e8-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f04e8-158">В отличие от <xref:System.Threading.EventWaitHandle> класс, производными классами <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent> могут представлять только локальные дескрипторы ожидания.</span><span class="sxs-lookup"><span data-stu-id="f04e8-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="f04e8-159">Они не могут представлять именованного системного события.</span><span class="sxs-lookup"><span data-stu-id="f04e8-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f04e8-160">См. также</span><span class="sxs-lookup"><span data-stu-id="f04e8-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="f04e8-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="f04e8-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
