---
title: Обзор примитивов синхронизации
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5098eea86ee910baad57115419e147df02e41ed9
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2018
ms.locfileid: "43485538"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="1d764-102">Обзор примитивов синхронизации</span><span class="sxs-lookup"><span data-stu-id="1d764-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="1d764-103">Платформа .NET Framework предоставляет ряд примитивов синхронизации для управления взаимодействием потоков и предотвращения состояний гонки.</span><span class="sxs-lookup"><span data-stu-id="1d764-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="1d764-104">Их можно условно разделить на три категории: блокировка, сигнал и блокированные операции.</span><span class="sxs-lookup"><span data-stu-id="1d764-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="1d764-105">Эти категории точно не определены: некоторые механизмы синхронизации имеют признаки нескольких категорий; события, которые освобождают по одному потоку за раз, функционируют как блокировки; снятие любой блокировки может быть воспринято как сигнал, а блокированные операции могут быть использованы для создания блокировок.</span><span class="sxs-lookup"><span data-stu-id="1d764-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="1d764-106">Однако эти категории все же полезны.</span><span class="sxs-lookup"><span data-stu-id="1d764-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="1d764-107">Важно помнить, что синхронизация потоков выполняется совместно.</span><span class="sxs-lookup"><span data-stu-id="1d764-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="1d764-108">Если хотя бы один поток обходит механизм синхронизации и получает доступ напрямую к защищенному ресурсу, такой механизм синхронизации не может считаться эффективным.</span><span class="sxs-lookup"><span data-stu-id="1d764-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="1d764-109">Обзор включает следующие разделы.</span><span class="sxs-lookup"><span data-stu-id="1d764-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="1d764-110">Блокировка</span><span class="sxs-lookup"><span data-stu-id="1d764-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="1d764-111">Сигнальный NaN</span><span class="sxs-lookup"><span data-stu-id="1d764-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="1d764-112">Типы упрощенной синхронизации</span><span class="sxs-lookup"><span data-stu-id="1d764-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="1d764-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="1d764-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="1d764-114">Блокируемые операции</span><span class="sxs-lookup"><span data-stu-id="1d764-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="1d764-115">Блокировка</span><span class="sxs-lookup"><span data-stu-id="1d764-115">Locking</span></span>  
 <span data-ttu-id="1d764-116">Блокировки предоставляют единовременное управление ресурсом одному потоку или определенному количеству потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="1d764-117">Поток, запрашивающий монопольную блокировку, если блокировка уже используется, блокируется до того момента, как блокировка станет доступной.</span><span class="sxs-lookup"><span data-stu-id="1d764-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="1d764-118">Монопольные блокировки</span><span class="sxs-lookup"><span data-stu-id="1d764-118">Exclusive Locks</span></span>  
 <span data-ttu-id="1d764-119">Самым простым способом блокировки является оператор `lock` в C# и оператор `SyncLock` в Visual Basic, который управляет доступом к блоку кода.</span><span class="sxs-lookup"><span data-stu-id="1d764-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="1d764-120">Как правило, этот блок называется критической секцией.</span><span class="sxs-lookup"><span data-stu-id="1d764-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="1d764-121">Оператор `lock` реализуется с помощью методов <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> и <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Он использует блок `try…finally` для снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="1d764-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="1d764-122">В целом, использование оператора `lock` или `SyncLock` для защиты небольших блоков кода, включающих не более одного метода, является лучшим способом использовать класс <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="1d764-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="1d764-123">Несмотря на все свои возможности, класс <xref:System.Threading.Monitor> подвержен потере блокировок и взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="1d764-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="1d764-124">Класс Monitor</span><span class="sxs-lookup"><span data-stu-id="1d764-124">Monitor Class</span></span>  
 <span data-ttu-id="1d764-125">Класс <xref:System.Threading.Monitor> предоставляет дополнительные возможности, которые можно использовать вместе с оператором `lock`.</span><span class="sxs-lookup"><span data-stu-id="1d764-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="1d764-126">Метод <xref:System.Threading.Monitor.TryEnter%2A> позволяет через указанное время разблокировать поток, который заблокирован в ожидании предоставления ресурса.</span><span class="sxs-lookup"><span data-stu-id="1d764-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="1d764-127">Он возвращает логическое значение, указывающее на успешность выполнения или сбой, которое можно использовать для выявления и устранения возможных взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="1d764-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="1d764-128">Метод <xref:System.Threading.Monitor.Wait%2A> вызывается потоком в критической секции.</span><span class="sxs-lookup"><span data-stu-id="1d764-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="1d764-129">Он отдает управление ресурсом и блокирует поток до тех пор, пока ресурс снова станет доступным.</span><span class="sxs-lookup"><span data-stu-id="1d764-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="1d764-130">Методы <xref:System.Threading.Monitor.Pulse%2A> и <xref:System.Threading.Monitor.PulseAll%2A> разрешают потоку, который должен снять блокировку или вызвать метод <xref:System.Threading.Monitor.Wait%2A>, поместить один или несколько потоков в очередь готовности, чтобы они могли получить блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d764-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="1d764-131">Время ожидания для перегрузок метода <xref:System.Threading.Monitor.Wait%2A> позволяет ожидающим потокам перейти в очередь готовности.</span><span class="sxs-lookup"><span data-stu-id="1d764-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="1d764-132">Класс <xref:System.Threading.Monitor> может предоставить блокировку в нескольких доменах приложений, если объект, используемый для блокировки, является производным от <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="1d764-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="1d764-133">Класс <xref:System.Threading.Monitor> реализует сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="1d764-134">То есть поток, вошедший в этот класс, должен выйти посредством вызова метода <xref:System.Threading.Monitor.Exit%2A> или <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d764-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="1d764-135">Класс <xref:System.Threading.Monitor> не поддерживает создание экземпляров.</span><span class="sxs-lookup"><span data-stu-id="1d764-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="1d764-136">Его методы являются статическими (`Shared` в Visual Basic) и работают с созданным экземпляром заблокированного объекта.</span><span class="sxs-lookup"><span data-stu-id="1d764-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="1d764-137">Обзор концепции см. в разделе [Мониторы](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="1d764-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="1d764-138">Класс Mutex</span><span class="sxs-lookup"><span data-stu-id="1d764-138">Mutex Class</span></span>  
 <span data-ttu-id="1d764-139">Потоки запрашивают <xref:System.Threading.Mutex> путем вызова перегрузки его метода <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d764-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1d764-140">Перегрузки со временем ожидания предоставляются для освобождения потоков после определенного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d764-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="1d764-141">В отличие от класса <xref:System.Threading.Monitor> мьютекс может быть или локальным, или глобальным.</span><span class="sxs-lookup"><span data-stu-id="1d764-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="1d764-142">Глобальные мьютексы, также называемые именованными мьютексами, видны в операционной системе и могут использоваться для синхронизации потоков в различных доменах приложений или процессах.</span><span class="sxs-lookup"><span data-stu-id="1d764-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="1d764-143">Локальные мьютексы происходят от <xref:System.MarshalByRefObject> и могут использоваться за границами домена приложения.</span><span class="sxs-lookup"><span data-stu-id="1d764-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1d764-144">Кроме того, <xref:System.Threading.Mutex> происходит от <xref:System.Threading.WaitHandle>, что означает возможность его использования в сигнальных механизмах, предоставленных <xref:System.Threading.WaitHandle>, таких как методы <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d764-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="1d764-145">Как и класс <xref:System.Threading.Monitor>, класс <xref:System.Threading.Mutex> поддерживает сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="1d764-146">В отличие от <xref:System.Threading.Monitor> класс <xref:System.Threading.Mutex> поддерживает создание экземпляров.</span><span class="sxs-lookup"><span data-stu-id="1d764-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="1d764-147">Обзор концепции см. в разделе [Объекты Mutex](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="1d764-148">Класс SpinLock</span><span class="sxs-lookup"><span data-stu-id="1d764-148">SpinLock Class</span></span>  
 <span data-ttu-id="1d764-149">Начиная с [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], класс <xref:System.Threading.SpinLock> можно использовать в тех случаях, когда накладные расходы от применения <xref:System.Threading.Monitor> ухудшают быстродействие.</span><span class="sxs-lookup"><span data-stu-id="1d764-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="1d764-150">Когда объект <xref:System.Threading.SpinLock> обнаруживает блокированную критическую секцию, он просто входит в цикл, пока блокировка не станет доступной.</span><span class="sxs-lookup"><span data-stu-id="1d764-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="1d764-151">Если блокировка сохраняется в течение очень короткого времени, вхождение в цикл может обеспечить лучшее быстродействие, чем блокировка.</span><span class="sxs-lookup"><span data-stu-id="1d764-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="1d764-152">Но если блокировка сохраняется дольше нескольких десятков тактов процессора, <xref:System.Threading.SpinLock> работает так же хорошо, как и <xref:System.Threading.Monitor>, но использует больше тактов процессора и, таким образом, может понизить быстродействие других потоков или процессов.</span><span class="sxs-lookup"><span data-stu-id="1d764-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="1d764-153">Другие блокировки</span><span class="sxs-lookup"><span data-stu-id="1d764-153">Other Locks</span></span>  
 <span data-ttu-id="1d764-154">Блокировки не обязательно должны быть монопольными.</span><span class="sxs-lookup"><span data-stu-id="1d764-154">Locks need not be exclusive.</span></span> <span data-ttu-id="1d764-155">Часто бывает полезным разрешить одновременный доступ к ресурсу ограниченному количеству потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="1d764-156">Семафоры и блокировки чтения и записи предназначены для управления доступом к ресурсу в пуле.</span><span class="sxs-lookup"><span data-stu-id="1d764-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="1d764-157">Класс ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="1d764-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="1d764-158">Класс <xref:System.Threading.ReaderWriterLockSlim> предназначен для тех случаев, когда поток, изменяющий данные, (модуль записи) должен иметь монопольный доступ к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="1d764-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="1d764-159">Если модуль записи не активен, любое количество модулей чтения может получить доступ к ресурсу (например, путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>).</span><span class="sxs-lookup"><span data-stu-id="1d764-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="1d764-160">Если поток запрашивает монопольный доступ (например, путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>), последующие запросы модуля чтения блокируются до того момента, как все существующие модули чтения не освободят блокировку, а модуль записи не установит и не снимет блокировку.</span><span class="sxs-lookup"><span data-stu-id="1d764-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="1d764-161">Класс <xref:System.Threading.ReaderWriterLockSlim> реализует сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="1d764-162">Обзор концепции см. в разделе [Блокировки чтения и записи](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="1d764-163">Semaphore - класс</span><span class="sxs-lookup"><span data-stu-id="1d764-163">Semaphore Class</span></span>  
 <span data-ttu-id="1d764-164">Класс <xref:System.Threading.Semaphore> разрешает доступ к ресурсу определенному количеству потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="1d764-165">Дополнительные потоки, запрашивающие ресурс, блокируются до освобождения потоком семафора.</span><span class="sxs-lookup"><span data-stu-id="1d764-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="1d764-166">Как и класс <xref:System.Threading.Mutex>, класс <xref:System.Threading.Semaphore> является производным от класса <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1d764-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1d764-167">Кроме того, как и класс <xref:System.Threading.Mutex>, класс <xref:System.Threading.Semaphore> может быть локальным или глобальным.</span><span class="sxs-lookup"><span data-stu-id="1d764-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="1d764-168">Он может использоваться за пределами границ домена приложения.</span><span class="sxs-lookup"><span data-stu-id="1d764-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1d764-169">В отличие от классов <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> и <xref:System.Threading.ReaderWriterLock>, класс <xref:System.Threading.Semaphore> не поддерживает сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="1d764-170">Это означает, что его можно использовать в сценариях, в которых один поток получает семафор, а другой поток освобождает его.</span><span class="sxs-lookup"><span data-stu-id="1d764-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="1d764-171">Обзор концепции см. в разделе [Класс Semaphore](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="1d764-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> — это упрощенный семафор для синхронизации в границах одного процесса.</span><span class="sxs-lookup"><span data-stu-id="1d764-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="1d764-173">К началу</span><span class="sxs-lookup"><span data-stu-id="1d764-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="1d764-174">Сигнальный NaN</span><span class="sxs-lookup"><span data-stu-id="1d764-174">Signaling</span></span>  
 <span data-ttu-id="1d764-175">Самым простым способом ожидания сигнала от другого потока является вызов метода <xref:System.Threading.Thread.Join%2A>, который блокирует поток до завершения другого потока.</span><span class="sxs-lookup"><span data-stu-id="1d764-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="1d764-176">У метода <xref:System.Threading.Thread.Join%2A> есть две перегрузки, которые позволяют блокированному потоку освободиться от ожидания по истечении заданного времени.</span><span class="sxs-lookup"><span data-stu-id="1d764-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="1d764-177">Дескрипторы ожидания предоставляют более полный набор возможностей ожидания и сигнализации.</span><span class="sxs-lookup"><span data-stu-id="1d764-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="1d764-178">Дескрипторы ожидания</span><span class="sxs-lookup"><span data-stu-id="1d764-178">Wait Handles</span></span>  
 <span data-ttu-id="1d764-179">Дескрипторы ожидания являются производными от класса <xref:System.Threading.WaitHandle>, который, в свою очередь, является производным от <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="1d764-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="1d764-180">Поэтому дескрипторы ожидания можно использовать для синхронизации действий потоков за границами доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="1d764-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1d764-181">Потоки блокируются при дескрипторах ожидания посредством вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A> или одного из статических методов <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> или <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d764-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="1d764-182">Способ их освобождения зависит от того, какой метод был вызван, а также от типа дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d764-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="1d764-183">Обзор концепции см. в разделе [Дескрипторы ожидания](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="1d764-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="1d764-184">Дескрипторы ожидания событий</span><span class="sxs-lookup"><span data-stu-id="1d764-184">Event Wait Handles</span></span>  
 <span data-ttu-id="1d764-185">Дескрипторы ожидания событий включают класс <xref:System.Threading.EventWaitHandle> и его производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="1d764-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="1d764-186">Потоки освобождаются от дескриптора ожидания событий, если этот дескриптор получает сигнал посредством вызова метода <xref:System.Threading.EventWaitHandle.Set%2A> или с помощью метода <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="1d764-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="1d764-187">Дескрипторы ожидания событий или сбрасывают себя автоматически, как турникет, разрешающий только один поток при каждом сигнале, или должны быть сброшены вручную, как ворота, которые закрыты до получения сигнала, а затем открыты, пока их кто-нибудь не закроет.</span><span class="sxs-lookup"><span data-stu-id="1d764-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="1d764-188">В соответствии с их именами классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent> представляют соответственно первый и второй подходы.</span><span class="sxs-lookup"><span data-stu-id="1d764-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="1d764-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> — это упрощенное событие для синхронизации в границах одного процесса.</span><span class="sxs-lookup"><span data-stu-id="1d764-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="1d764-190">Дескриптор <xref:System.Threading.EventWaitHandle> может представлять любой тип события и может быть локальным или глобальным.</span><span class="sxs-lookup"><span data-stu-id="1d764-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="1d764-191">Производные классы <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent> всегда являются локальными.</span><span class="sxs-lookup"><span data-stu-id="1d764-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="1d764-192">Дескрипторы ожидания событий не поддерживают сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="1d764-193">Любой поток может подать сигнал дескриптору ожидания событий.</span><span class="sxs-lookup"><span data-stu-id="1d764-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="1d764-194">Обзор концепции см. в разделе [EventWaitHandle, AutoResetEvent и ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="1d764-195">Классы Mutex и Semaphore</span><span class="sxs-lookup"><span data-stu-id="1d764-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="1d764-196">Так как классы <xref:System.Threading.Mutex> и <xref:System.Threading.Semaphore> являются производными от класса <xref:System.Threading.WaitHandle>, они могут использоваться со статическими методами класса <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="1d764-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1d764-197">Например, поток может использовать метод <xref:System.Threading.WaitHandle.WaitAll%2A> для ожидания выполнения всех трех условий: подан сигнал дескриптору <xref:System.Threading.EventWaitHandle>, освобожден мьютекс <xref:System.Threading.Mutex> и сброшен семафор <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="1d764-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="1d764-198">Также поток может использовать метод <xref:System.Threading.WaitHandle.WaitAny%2A> для ожидания выполнения одного из этих условий.</span><span class="sxs-lookup"><span data-stu-id="1d764-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="1d764-199">Для классов <xref:System.Threading.Mutex> и <xref:System.Threading.Semaphore> получение сигнала означает освобождение.</span><span class="sxs-lookup"><span data-stu-id="1d764-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="1d764-200">Если в качестве первого аргумента метода <xref:System.Threading.WaitHandle.SignalAndWait%2A> используется любой из этих типов, он освобождается.</span><span class="sxs-lookup"><span data-stu-id="1d764-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="1d764-201">В случае класса <xref:System.Threading.Mutex>, поддерживающего сходство потоков, исключение создается, если вызывающий поток не имеет собственного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="1d764-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="1d764-202">Как отмечалось ранее, семафоры не поддерживают сходство потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="1d764-203">Барьер</span><span class="sxs-lookup"><span data-stu-id="1d764-203">Barrier</span></span>  
 <span data-ttu-id="1d764-204">Класс <xref:System.Threading.Barrier> предоставляет способ циклической синхронизации нескольких потоков, позволяющий заблокировать их все в одной точке и дождаться завершения всех остальных потоков.</span><span class="sxs-lookup"><span data-stu-id="1d764-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="1d764-205">Барьер полезен, когда одному или нескольким потокам для перехода к следующему этапу алгоритма требуются результаты выполнения другого потока.</span><span class="sxs-lookup"><span data-stu-id="1d764-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="1d764-206">Дополнительные сведения см. в разделе [Барьер](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="1d764-207">К началу</span><span class="sxs-lookup"><span data-stu-id="1d764-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="1d764-208">Типы упрощенной синхронизации</span><span class="sxs-lookup"><span data-stu-id="1d764-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="1d764-209">Начиная с [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], можно использовать примитивы синхронизации, обеспечивающие высокое быстродействие путем предотвращения по возможности ресурсоемкого использования объектов ядра Win32, таких как дескрипторы ожидания.</span><span class="sxs-lookup"><span data-stu-id="1d764-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="1d764-210">Обычно эти типы следует использовать при небольшом времени ожидания и только после того, как исходные типы синхронизации были испытаны и признаны негодными.</span><span class="sxs-lookup"><span data-stu-id="1d764-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="1d764-211">Эти упрощенные типы нельзя использовать в сценариях, требующих взаимодействия между процессами.</span><span class="sxs-lookup"><span data-stu-id="1d764-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="1d764-212">Семафор <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> является упрощенной версией семафора <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d764-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="1d764-213">Семафор <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> является упрощенной версией семафора <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1d764-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="1d764-214">Класс <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> представляет событие, возникающее, когда его счетчик становится равным нулю.</span><span class="sxs-lookup"><span data-stu-id="1d764-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="1d764-215">Барьер <xref:System.Threading.Barrier?displayProperty=nameWithType> позволяет синхронизировать друг с другом несколько потоков без управления со стороны главного потока.</span><span class="sxs-lookup"><span data-stu-id="1d764-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="1d764-216">Барьер не позволяет каждому из потоков продолжить выполнение, пока все потоки не достигнут заданной точки.</span><span class="sxs-lookup"><span data-stu-id="1d764-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="1d764-217">К началу</span><span class="sxs-lookup"><span data-stu-id="1d764-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="1d764-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="1d764-218">SpinWait</span></span>  
 <span data-ttu-id="1d764-219">Начиная с [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], вы можете использовать структуру <xref:System.Threading.SpinWait?displayProperty=nameWithType> в тех случаях, когда потоку нужно дождаться возникновения события или выполнения условия, но фактическое время ожидания будет меньше периода, требуемого для применения дескриптора ожидания или других способов блокировки текущего потока.</span><span class="sxs-lookup"><span data-stu-id="1d764-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="1d764-220">Используя <xref:System.Threading.SpinWait>, можно задать короткий интервал времени для цикла ожидания, а затем вернуть управление (например, с помощью ожидания или спящего режима), только если условие не было выполнено в течение заданного времени.</span><span class="sxs-lookup"><span data-stu-id="1d764-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="1d764-221">К началу</span><span class="sxs-lookup"><span data-stu-id="1d764-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="1d764-222">Блокируемые операции</span><span class="sxs-lookup"><span data-stu-id="1d764-222">Interlocked Operations</span></span>  
 <span data-ttu-id="1d764-223">Блокируемые операции — это простые атомарные операции, выполняемые в области памяти статическими методами класса <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="1d764-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="1d764-224">Эти атомарные операции включают добавление, увеличение и уменьшение, обмен, условный обмен в зависимости от сравнения, а также операции чтения для 64-разрядных значений на 32-разрядных платформах.</span><span class="sxs-lookup"><span data-stu-id="1d764-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d764-225">Гарантия атомарности ограничена отдельными операциями. Если необходимо выполнить несколько операций в одном блоке, следует использовать более весомые механизмы синхронизации.</span><span class="sxs-lookup"><span data-stu-id="1d764-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="1d764-226">Несмотря на то что ни одна из этих операций не является блокировкой или сигналом, они могут использоваться для создания блокировок и сигналов.</span><span class="sxs-lookup"><span data-stu-id="1d764-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="1d764-227">Так как блокируемые операции являются собственными операциями ОС Windows, они выполняются очень быстро.</span><span class="sxs-lookup"><span data-stu-id="1d764-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="1d764-228">Блокируемые операции можно использовать с энергонезависимой памятью для написания приложений, демонстрирующих эффективную параллельную работу без блокировок.</span><span class="sxs-lookup"><span data-stu-id="1d764-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="1d764-229">Но для них требуется сложное низкоуровневое программирование, поэтому для большинства задач оптимальным выбором оказываются простые блокировки.</span><span class="sxs-lookup"><span data-stu-id="1d764-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="1d764-230">Обзор концепции см. в разделе [Блокируемые операции](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="1d764-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1d764-231">См. также</span><span class="sxs-lookup"><span data-stu-id="1d764-231">See Also</span></span>  
 [<span data-ttu-id="1d764-232">Синхронизация данных для многопоточности</span><span class="sxs-lookup"><span data-stu-id="1d764-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="1d764-233">Мониторы</span><span class="sxs-lookup"><span data-stu-id="1d764-233">Monitors</span></span>](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="1d764-234">Мьютексы</span><span class="sxs-lookup"><span data-stu-id="1d764-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="1d764-235">Классы Semaphore и SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="1d764-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="1d764-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="1d764-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="1d764-237">Дескрипторы ожидания</span><span class="sxs-lookup"><span data-stu-id="1d764-237">Wait Handles</span></span>](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="1d764-238">Блокируемые операции</span><span class="sxs-lookup"><span data-stu-id="1d764-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="1d764-239">Блокировки чтения и записи</span><span class="sxs-lookup"><span data-stu-id="1d764-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="1d764-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="1d764-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="1d764-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="1d764-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="1d764-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="1d764-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
