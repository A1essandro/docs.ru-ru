---
title: Потоки и работа с потоками
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: ''
ms.suite: ''
ms.technology: dotnet-standard
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
caps.latest.revision: 14
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 02c676e3bb6c0dcc9e65858367d13f41adc797e8
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2018
---
# <a name="threads-and-threading"></a>Потоки и работа с потоками
В операционных системах для разделения нескольких выполняемых приложений используются процессы. Потоки являются базовыми единицами, для которых операционная система выделяет процессорное время, и в каждом процессе код может выполняться в нескольких потоках. Каждый поток поддерживает обработчики исключений, приоритет планирования и набор структур, в которых система сохраняет контекст потока до его очередного выполнения. Контекст потока содержит все сведения, позволяющие потоку безболезненно возобновить выполнение в адресном пространстве хост-процесса потока, в том числе набор регистров процессора и стек потока.  
  
 Платформа .NET Framework разделяет процессы операционной системы на еще более мелкие управляемые подпроцессы, которые именуются доменами приложений (объект <xref:System.AppDomain?displayProperty=nameWithType>). Один или несколько управляемых потоков, представленных объектами <xref:System.Threading.Thread?displayProperty=nameWithType>, могут выполняться в одном или нескольких доменах приложений в одном управляемом процессе. Несмотря на то что каждый домен приложения запускается с одним потоком, код в этом домене приложения может создавать дополнительные домены приложений и дополнительные потоки. Благодаря такому подходу управляемый поток может свободно перемещаться между доменами приложения внутри одного управляемого процесса. Вы даже можете выполнять все задачи в одном потоке, который перемещается между несколькими доменами приложений.  
  
 Операционная система, которая поддерживает вытесняющую многозадачность, создает иллюзию одновременного выполнения нескольких потоков из нескольких процессов. Для достижения такого эффекта доступное процессорное время распределяется между выполняемыми потоками. Для каждого потока поочередно выделяется срез процессорного времени. Когда завершается срез времени, выделенный текущему потоку, этот поток приостанавливается и возобновляется другой поток. Когда система переключается с одного потока на другой, она сохраняет контекст вытесняемого потока и восстанавливает сохраненный контекст следующего потока из очереди потоков.  
  
 Длительность среза времени зависит от конкретной операционной системы и процессора. Каждый временной срез очень мал, поэтому даже на одном процессоре вся система работает так, как будто несколько потоков выполняются одновременно. А на многопроцессорных системах выполняемые потоки действительно одновременно распределяются между доступными процессорами.  
  
## <a name="when-to-use-multiple-threads"></a>Цели применения нескольких потоков  
 Программное обеспечение, ожидающее действий пользователя, обязано максимально быстро реагировать на эти действия, чтобы обеспечить высокое качество взаимодействия. Но одновременно с этим необходимо выполнять вычисления, чтобы как можно быстрее представить пользователю нужные данные. Если приложение использует только один поток выполнения, вы можете применить методики [асинхронного программирования](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) и [удаленного взаимодействия .NET Framework](https://msdn.microsoft.com/library/eccb1d31-0a22-417a-97fd-f4f1f3aa4462) или [веб-службы XML](https://msdn.microsoft.com/library/1e64af78-d705-4384-b08d-591a45f4379c) на основе ASP.NET, чтобы воспользоваться процессорным временем других компьютеров в дополнение к локальному компьютеру. Это позволяет улучшить скорость реагирования и снизить время обработки данных в приложении. Если вам нужно выполнять много операций ввода-вывода, скорость реагирования приложения можно повысить с помощью портов завершения ввода-вывода.  
  
### <a name="advantages-of-multiple-threads"></a>Преимущества применения нескольких потоков  
 Использование нескольких потоков является наиболее мощным средством для повышения скорости реагирования на действия пользователя и скорости обработки данных, позволяя выполнять работу почти мгновенно. На компьютере с одним процессором несколько потоков создают эффект одновременного выполнения, используя небольшие паузы между обработкой событий пользователя для фоновой обработки данных. Например, одно приложение может обрабатывать как действия пользователя, который редактирует электронную таблицу, так и вычисление других частей этой таблицы в другом потоке.  
  
 Качество взаимодействия с пользователем в этом же приложении может кардинально улучшиться без каких-либо модификаций, если запустить его на компьютере с несколькими процессорами. В одном домене приложения можно применить несколько потоков для выполнения следующих задач:  
  
-   Обмен данными по сети с веб-сервером и с базой данных.  
  
-   Выполнение операций, для которых требуется много времени.  
  
-   Распределение задач по приоритетам. Например, можно создать поток с высоким приоритетом для управления срочными задачами, а остальную работу переложить на поток с низким приоритетом.  
  
-   Сохранение скорости реагирования пользовательского интерфейса при выделении процессорного времени для фоновых задач.  
  
### <a name="disadvantages-of-multiple-threads"></a>Недостатки применения нескольких потоков  
 Мы рекомендуем всегда использовать минимально необходимое число потоков, чтобы сократить потребление ресурсов операционной системы и повысить производительность. Управление потоками требует определенных ресурсов и повышает риск потенциальных конфликтов, что также необходимо учитывать при разработке приложения. Действуют следующие требования к ресурсам:  
  
-   Система потребляет память для хранения сведений о контексте для всех процессов, объектов **доменов приложений** и потоков. Таким образом, число процессов, объектов **доменов приложений** и потоков ограничено объемом доступной памяти.  
  
-   Для отслеживания работы большого числа потоков требуется много процессорного времени. Если потоков слишком много, большинство из них будут работать очень медленно. Если большинство потоков относятся к одному процессу, потоки других процессов назначаются для выполнения реже.  
  
-   Контроль над выполнением кода при большом числе потоков становится сложной задачей и может стать источником многочисленных ошибок.  
  
-   Для правильного уничтожения потоков важно учитывать возможные последствия и правильно обрабатывать эти проблемы.  
  
 Предоставление общего доступа к ресурсам может приводить к конфликтам. Во избежание конфликтов нужно синхронизировать (или контролировать иным образом) доступ к общим ресурсам. Нарушение принципов синхронизации (в пределах одного домена приложения или в разных доменах) может привести к взаимоблокировкам (это ситуация, в которой два потока прекращают работу, ожидая завершения друг друга) и состояниям гонки (это ситуация, в которой возникает непредвиденный результат из-за нарушения правильного порядка событий). Система предоставляет объекты синхронизации, которые позволяют координировать совместное использование ресурсов несколькими потоками. Уменьшение числа потоков упрощает синхронизацию ресурсов.  
  
 Ниже перечислены ресурсы, для которых требуется синхронизация:  
  
-   ресурсы системы (например, последовательные порты);  
  
-   ресурсы, используемые несколькими процессами (например, дескрипторы файлов);  
  
-   ресурсы отдельного домена приложения, доступ к которым осуществляется из нескольких потоков (например, глобальные поля, статические поля и поля экземпляров).  
  
### <a name="threading-and-application-design"></a>Управление потоками при разработке приложений  
 Обычно для работы с несколькими потоками проще всего использовать класс <xref:System.Threading.ThreadPool>, если задачи относительно просты, не ожидается риска блокировки других потоков и нет необходимости строго соблюдать последовательность задач. Но в описанных ниже ситуациях будет лучше создать собственные потоки.  
  
-   Если у вас есть задача, для которой нужен определенный приоритет.  
  
-   Если у вас есть задача, которая может выполняться очень долго, блокируя работу других задач.  
  
-   Если вам нужно поместить потоки в однопотоковое подразделение (все потоки **ThreadPool** находятся в многопотоковом подразделении).  
  
-   Если вам нужны стабильные идентификаторы потоков. Например, если требуется возможность прервать определенный поток, приостановить его или найти по имени.  
  
-   Если вам нужно выполнять фоновые потоки, которые взаимодействуют с пользовательским интерфейсом, платформа .NET Framework версии 2.0 предоставляет компонент <xref:System.ComponentModel.BackgroundWorker>, который взаимодействует с потоком пользовательского интерфейса, используя события и межпотоковый маршалинг.  
  
### <a name="threading-and-exceptions"></a>Потоки и исключения  
 Исключения следует обрабатывать в потоках. Необработанные исключения в потоках, даже в фоновых, обычно приводят к завершению процесса. Существует три исключения из этого правила.  
  
-   В потоке создается исключение <xref:System.Threading.ThreadAbortException> из-за вызова <xref:System.Threading.Thread.Abort%2A>.  
  
-   Исключение <xref:System.AppDomainUnloadedException>, которое создается в потоке из-за выгрузки домена приложения.  
  
-   Среда CLR или процесс ведущего приложения прерывает выполнение потока.  
  
 Дополнительные сведения см. в статье [Исключения в управляемых потоках](../../../docs/standard/threading/exceptions-in-managed-threads.md).  
  
> [!NOTE]
>  На платформе .NET Framework версий 1.0 и 1.1 среда CLR перехватывает некоторые исключения, например в потоках из пула потоков, без уведомления. Это может нарушить состояние приложения и в итоге привести к его "зависанию", отладить которое может быть очень сложно.  
  
## <a name="see-also"></a>См. также  
 <xref:System.Threading.ThreadPool>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [Синхронизация данных для многопоточности](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [Пул управляемых потоков](../../../docs/standard/threading/the-managed-thread-pool.md)
