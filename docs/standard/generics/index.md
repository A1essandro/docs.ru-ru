---
title: "Универсальные шаблоны в .NET Framework | Документация Майкрософт"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- generic methods, type inference
- generics [.NET Framework], collections
- generic interfaces [.NET Framework]
- constructed generic types
- nested generic types
- generic type definitions
- generic classes [.NET Framework]
- generics [.NET Framework], interfaces
- generics [.NET Framework], about
- generics [.NET Framework]
- generic collections [.NET Framework]
- generic delegates [.NET Framework]
- generic type arguments
- generics [.NET Framework], delegates
- generics [.NET Framework], features
- constraints [.NET Framework]
- generic types
- generic type parameters
ms.assetid: 2994d786-c5c7-4666-ab23-4c83129fe39c
caps.latest.revision: 23
author: mairaw
ms.author: mairaw
manager: wpickett
ms.translationtype: Human Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 9e352489bb22b691d9024a651f3864d2604a90cd
ms.contentlocale: ru-ru
ms.lasthandoff: 05/02/2017

---
# <a name="generics-in-the-net-framework"></a><span data-ttu-id="99e83-102">Универсальные шаблоны в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="99e83-102">Generics in the .NET Framework</span></span>
<span data-ttu-id="99e83-103"><a name="top"></a> Универсальные шаблоны позволяют точно настроить метод, класс или структуру в соответствии с типом обрабатываемых данных.</span><span class="sxs-lookup"><span data-stu-id="99e83-103"><a name="top"></a> Generics let you tailor a method, class, structure, or interface to the precise data type it acts upon.</span></span> <span data-ttu-id="99e83-104">Например, вместо использования класса <xref:System.Collections.Hashtable>, который позволяет ключам и значениям быть любого типа, можно использовать универсальный класс <xref:System.Collections.Generic.Dictionary%602> и указать допустимый тип ключа и тип значения.</span><span class="sxs-lookup"><span data-stu-id="99e83-104">For example, instead of using the <xref:System.Collections.Hashtable> class, which allows keys and values to be of any type, you can use the <xref:System.Collections.Generic.Dictionary%602> generic class and specify the type allowed for the key and the type allowed for the value.</span></span> <span data-ttu-id="99e83-105">Помимо прочего, преимуществами универсальных шаблонов являются улучшенная возможность многократного использования кода и сохранения типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-105">Among the benefits of generics are increased code reusability and type safety.</span></span>  
  
 <span data-ttu-id="99e83-106">В этом разделе содержатся общие сведения об универсальных шаблонах платформы .NET Framework и сводка по универсальным типам или методам.</span><span class="sxs-lookup"><span data-stu-id="99e83-106">This topic provides an overview of generics in the .NET Framework and a summary of generic types or methods.</span></span> <span data-ttu-id="99e83-107">Он содержит следующие подразделы:</span><span class="sxs-lookup"><span data-stu-id="99e83-107">It contains the following sections:</span></span>  
  
-   [<span data-ttu-id="99e83-108">Определение и использование универсальных шаблонов</span><span class="sxs-lookup"><span data-stu-id="99e83-108">Defining and Using Generics</span></span>](#defining_and_using_generics)  
  
-   [<span data-ttu-id="99e83-109">Терминология универсальных шаблонов</span><span class="sxs-lookup"><span data-stu-id="99e83-109">Generics Terminology</span></span>](#generics_terminology)  
  
-   [<span data-ttu-id="99e83-110">Библиотека классов и языковая поддержка</span><span class="sxs-lookup"><span data-stu-id="99e83-110">Class Library and Language Support</span></span>](#class_library_and_language_support)  
  
-   [<span data-ttu-id="99e83-111">Вложенные типы и универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="99e83-111">Nested Types and Generics</span></span>](#nested_types_and_generics)  
  
-   [<span data-ttu-id="99e83-112">См. также</span><span class="sxs-lookup"><span data-stu-id="99e83-112">Related Topics</span></span>](#related_topics)  
  
-   [<span data-ttu-id="99e83-113">Ссылки</span><span class="sxs-lookup"><span data-stu-id="99e83-113">Reference</span></span>](#reference)  
  
<a name="defining_and_using_generics"></a>   
## <a name="defining-and-using-generics"></a><span data-ttu-id="99e83-114">Определение и использование универсальных шаблонов</span><span class="sxs-lookup"><span data-stu-id="99e83-114">Defining and Using Generics</span></span>  
 <span data-ttu-id="99e83-115">Универсальными шаблонами являются классы, структуры, интерфейсы и методы, которые имеют прототипы (параметры типов) для одного или нескольких типов, которые они хранят или используют.</span><span class="sxs-lookup"><span data-stu-id="99e83-115">Generics are classes, structures, interfaces, and methods that have placeholders (type parameters) for one or more of the types that they store or use.</span></span> <span data-ttu-id="99e83-116">Класс универсальной коллекции может использовать параметр типа в качестве заполнителя для типа объектов, которые в нем хранятся. Параметры типа отображаются как типы его полей и типы параметров его методов.</span><span class="sxs-lookup"><span data-stu-id="99e83-116">A generic collection class might use a type parameter as a placeholder for the type of objects that it stores; the type parameters appear as the types of its fields and the parameter types of its methods.</span></span> <span data-ttu-id="99e83-117">Универсальный метод может использовать параметр типа в качестве типа возвращаемого значения или как тип одного из своих формальных параметров.</span><span class="sxs-lookup"><span data-stu-id="99e83-117">A generic method might use its type parameter as the type of its return value or as the type of one of its formal parameters.</span></span> <span data-ttu-id="99e83-118">Следующий код иллюстрирует определение простого универсального класса.</span><span class="sxs-lookup"><span data-stu-id="99e83-118">The following code illustrates a simple generic class definition.</span></span>  
  
 <span data-ttu-id="99e83-119">[!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)]
 [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)]
 [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="99e83-119">[!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)]
 [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)]
 [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]</span></span>  
  
 <span data-ttu-id="99e83-120">При создании экземпляра универсального класса необходимо указать фактические типы для замены параметров типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-120">When you create an instance of a generic class, you specify the actual types to substitute for the type parameters.</span></span> <span data-ttu-id="99e83-121">При этом создается новый универсальный класс, называемый сконструированным универсальным классом, с выбранными типами, заменяющими все параметры типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-121">This establishes a new generic class, referred to as a constructed generic class, with your chosen types substituted everywhere that the type parameters appear.</span></span> <span data-ttu-id="99e83-122">Результатом является типобезопасный класс, соответствующий вашему выбору типов, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="99e83-122">The result is a type-safe class that is tailored to your choice of types, as the following code illustrates.</span></span>  
  
 <span data-ttu-id="99e83-123">[!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)]
 [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)]
 [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="99e83-123">[!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)]
 [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)]
 [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]</span></span>  
  
<a name="generics_terminology"></a>   
### <a name="generics-terminology"></a><span data-ttu-id="99e83-124">Терминология универсальных шаблонов</span><span class="sxs-lookup"><span data-stu-id="99e83-124">Generics terminology</span></span>  
 <span data-ttu-id="99e83-125">В обсуждении универсальных шаблонов на платформе .NET Framework используются следующие термины.</span><span class="sxs-lookup"><span data-stu-id="99e83-125">The following terms are used to discuss generics in the .NET Framework:</span></span>  
  
-   <span data-ttu-id="99e83-126">*Определение универсального типа* — это объявление класса, структуры или интерфейса, которое работает в качестве шаблона с прототипами для типов, которые он может содержать или использовать.</span><span class="sxs-lookup"><span data-stu-id="99e83-126">A *generic type definition* is a class, structure, or interface declaration that functions as a template, with placeholders for the types that it can contain or use.</span></span> <span data-ttu-id="99e83-127">Например, класс <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> может содержать два типа: ключи и значения.</span><span class="sxs-lookup"><span data-stu-id="99e83-127">For example, the <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> class can contain two types: keys and values.</span></span> <span data-ttu-id="99e83-128">Поскольку определение универсального типа — это только шаблон, создавать экземпляры класса, структуры или интерфейса, являющиеся определением универсального типа, нельзя.</span><span class="sxs-lookup"><span data-stu-id="99e83-128">Because a generic type definition is only a template, you cannot create instances of a class, structure, or interface that is a generic type definition.</span></span>  
  
-   <span data-ttu-id="99e83-129">*Параметры универсального типа* или *параметры типа* являются прототипами в определении универсального типа или метода.</span><span class="sxs-lookup"><span data-stu-id="99e83-129">*Generic type parameters*, or *type parameters*, are the placeholders in a generic type or method definition.</span></span> <span data-ttu-id="99e83-130">У универсального типа <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> есть два параметра типа, `TKey` и `TValue`, представляющие типы его ключей и значений.</span><span class="sxs-lookup"><span data-stu-id="99e83-130">The <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> generic type has two type parameters, `TKey` and `TValue`, that represent the types of its keys and values.</span></span>  
  
-   <span data-ttu-id="99e83-131">*Сконструированный универсальный тип* или *сконструированный тип* является результатом указания типов для параметров универсального типа в определении универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-131">A *constructed generic type*, or *constructed type*, is the result of specifying types for the generic type parameters of a generic type definition.</span></span>  
  
-   <span data-ttu-id="99e83-132">*Аргумент универсального типа* является любым типом, заменяемым на параметр универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-132">A *generic type argument* is any type that is substituted for a generic type parameter.</span></span>  
  
-   <span data-ttu-id="99e83-133">Общий термин *универсальный тип* описывает определения как сконструированных типов, так и универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-133">The general term *generic type* includes both constructed types and generic type definitions.</span></span>  
  
-   <span data-ttu-id="99e83-134">*Ковариация* и *контравариация* параметров универсального типа позволяют использовать сконструированные универсальные типы, аргументы типов которых находятся на более высоком (в случае ковариации) или низком (в случае контравариации) уровне иерархии наследования, чем у целевого сконструированного типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-134">*Covariance* and *contravariance* of generic type parameters enable you to use constructed generic types whose type arguments are more derived (covariance) or less derived (contravariance) than a target constructed type.</span></span> <span data-ttu-id="99e83-135">Вместе ковариантность и контравариантность называются *вариацией*.</span><span class="sxs-lookup"><span data-stu-id="99e83-135">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="99e83-136">Дополнительные сведения см. в разделе [Ковариация и контравариантность](../../../docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="99e83-136">For more information, see [Covariance and Contravariance](../../../docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
-   <span data-ttu-id="99e83-137">*Ограничения* — это пределы, наложенные на параметры универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-137">*Constraints* are limits placed on generic type parameters.</span></span> <span data-ttu-id="99e83-138">Например, можно ограничить параметр типа типами, реализующими универсальный интерфейс <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName>, чтобы обеспечить упорядочивание экземпляров типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-138">For example, you might limit a type parameter to types that implement the <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> generic interface, to ensure that instances of the type can be ordered.</span></span> <span data-ttu-id="99e83-139">Можно также ограничить параметры типа типами, имеющими определенный базовый класс, который имеет конструктор по умолчанию, или типами, являющимися ссылочными типами или типами значений.</span><span class="sxs-lookup"><span data-stu-id="99e83-139">You can also constrain type parameters to types that have a particular base class, that have a default constructor, or that are reference types or value types.</span></span> <span data-ttu-id="99e83-140">Пользователи универсального типа не могут подставить аргументы типа, которые не удовлетворяют ограничениям.</span><span class="sxs-lookup"><span data-stu-id="99e83-140">Users of the generic type cannot substitute type arguments that do not satisfy the constraints.</span></span>  
  
-   <span data-ttu-id="99e83-141">*Определение универсального метода* — это метод с двумя списками параметров: списком параметров универсальных типов и списком формальных параметров.</span><span class="sxs-lookup"><span data-stu-id="99e83-141">A *generic method definition* is a method with two parameter lists: a list of generic type parameters and a list of formal parameters.</span></span> <span data-ttu-id="99e83-142">Параметры типа могут отображаться в качестве возвращаемого типа или в качестве типов формальных параметров, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="99e83-142">Type parameters can appear as the return type or as the types of the formal parameters, as the following code shows.</span></span>  
  
 <span data-ttu-id="99e83-143">[!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)]
 [!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)]
 [!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="99e83-143">[!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)]
[!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)]
[!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]</span></span>  
  
 <span data-ttu-id="99e83-144">Универсальные методы могут присутствовать в универсальных и неуниверсальных типах.</span><span class="sxs-lookup"><span data-stu-id="99e83-144">Generic methods can appear on generic or nongeneric types.</span></span> <span data-ttu-id="99e83-145">Важно отметить, что метод не является универсальным только потому, что он принадлежит универсальному типу или даже в том случае, если он имеет формальные параметры, типы которых являются универсальными параметрами для включающего их типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-145">It is important to note that a method is not generic just because it belongs to a generic type, or even because it has formal parameters whose types are the generic parameters of the enclosing type.</span></span> <span data-ttu-id="99e83-146">Метод является универсальным только в том случае, если он имеет свой собственный список параметров типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-146">A method is generic only if it has its own list of type parameters.</span></span> <span data-ttu-id="99e83-147">В следующем коде только метод `G` является универсальным.</span><span class="sxs-lookup"><span data-stu-id="99e83-147">In the following code, only method `G` is generic.</span></span>  
  
 <span data-ttu-id="99e83-148">[!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)]
 [!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)]
 [!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="99e83-148">[!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)]
[!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)]
[!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]</span></span>  
  
 [<span data-ttu-id="99e83-149">К началу</span><span class="sxs-lookup"><span data-stu-id="99e83-149">Back to top</span></span>](#top)  
  
<a name="advantages_limitations"></a>   
## <a name="advantages-and-disadvantages-of-generics"></a><span data-ttu-id="99e83-150">Преимущества и недостатки универсальных шаблонов</span><span class="sxs-lookup"><span data-stu-id="99e83-150">Advantages and disadvantages of generics</span></span>  
 <span data-ttu-id="99e83-151">Использование универсальных коллекций и делегатов предоставляет целый ряд преимуществ.</span><span class="sxs-lookup"><span data-stu-id="99e83-151">There are many advantages to using generic collections and delegates:</span></span>  
  
-   <span data-ttu-id="99e83-152">Типобезопасность.</span><span class="sxs-lookup"><span data-stu-id="99e83-152">Type safety.</span></span> <span data-ttu-id="99e83-153">Универсальные шаблоны позволяют передать компилятору обязанности обеспечения типовой безопасности.</span><span class="sxs-lookup"><span data-stu-id="99e83-153">Generics shift the burden of type safety from you to the compiler.</span></span> <span data-ttu-id="99e83-154">Нет необходимости написания кода для проверки правильности типа данных, так как проверка происходит во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="99e83-154">There is no need to write code to test for the correct data type because it is enforced at compile time.</span></span> <span data-ttu-id="99e83-155">Уменьшается потребность приведения типов и вероятность ошибок во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="99e83-155">The need for type casting and the possibility of run-time errors are reduced.</span></span>  
  
-   <span data-ttu-id="99e83-156">Объем кода уменьшен и поддерживает многократную реализацию.</span><span class="sxs-lookup"><span data-stu-id="99e83-156">Less code and code is more easily reused.</span></span> <span data-ttu-id="99e83-157">Нет необходимости наследования базового типа и преобладающих членов.</span><span class="sxs-lookup"><span data-stu-id="99e83-157">There is no need to inherit from a base type and override members.</span></span> <span data-ttu-id="99e83-158">Например, <xref:System.Collections.Generic.LinkedList%601> можно использовать сразу.</span><span class="sxs-lookup"><span data-stu-id="99e83-158">For example, the <xref:System.Collections.Generic.LinkedList%601> is ready for immediate use.</span></span> <span data-ttu-id="99e83-159">Например, можно создать связанный список строк со следующим объявлением переменной:</span><span class="sxs-lookup"><span data-stu-id="99e83-159">For example, you can create a linked list of strings with the following variable declaration:</span></span>  
  
     <span data-ttu-id="99e83-160">[!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]
     [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]
     [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="99e83-160">[!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]
 [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]
 [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]</span></span>  
  
-   <span data-ttu-id="99e83-161">Повышенная производительность.</span><span class="sxs-lookup"><span data-stu-id="99e83-161">Better performance.</span></span> <span data-ttu-id="99e83-162">Универсальные типы коллекций имеют более высокую производительность при хранении и управлении типами значений, поскольку отсутствует необходимость их упаковки.</span><span class="sxs-lookup"><span data-stu-id="99e83-162">Generic collection types generally perform better for storing and manipulating value types because there is no need to box the value types.</span></span>  
  
-   <span data-ttu-id="99e83-163">Универсальные делегаты поддерживают типобезопасные обратные вызовы без необходимости создания нескольких классов делегатов.</span><span class="sxs-lookup"><span data-stu-id="99e83-163">Generic delegates enable type-safe callbacks without the need to create multiple delegate classes.</span></span> <span data-ttu-id="99e83-164">Например, универсальный метод-делегат <xref:System.Predicate%601> позволяет создать метод, который реализует ваши собственные условия поиска для определенного типа, и использовать ваш метод с методами типа <xref:System.Array>, например с <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A> и <xref:System.Array.FindAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="99e83-164">For example, the <xref:System.Predicate%601> generic delegate allows you to create a method that implements your own search criteria for a particular type and to use your method with methods of the <xref:System.Array> type such as <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A>.</span></span>  
  
-   <span data-ttu-id="99e83-165">Универсальные шаблоны упрощают динамически создаваемый код.</span><span class="sxs-lookup"><span data-stu-id="99e83-165">Generics streamline dynamically generated code.</span></span> <span data-ttu-id="99e83-166">Универсальные делегаты можно также использовать в динамически создаваемом коде без необходимости создания типа делегата.</span><span class="sxs-lookup"><span data-stu-id="99e83-166">When you use generics with dynamically generated code you do not need to generate the type.</span></span> <span data-ttu-id="99e83-167">Это увеличивает количество ситуаций, в которых можно использовать облегченные динамические методы вместо создания целых сборок.</span><span class="sxs-lookup"><span data-stu-id="99e83-167">This increases the number of scenarios in which you can use lightweight dynamic methods instead of generating entire assemblies.</span></span> <span data-ttu-id="99e83-168">Подробнее см. в разделе "Практическое руководство. Определение и выполнение динамических методов" и в описании метода DynamicMethod.</span><span class="sxs-lookup"><span data-stu-id="99e83-168">For more information, see How to: Define and Execute Dynamic Methods and DynamicMethod.</span></span>  
  
 <span data-ttu-id="99e83-169">Ниже перечислены некоторые ограничения универсальных шаблонов.</span><span class="sxs-lookup"><span data-stu-id="99e83-169">The following are some limitations of generics:</span></span>  
  
-   <span data-ttu-id="99e83-170">Универсальные типы могут быть наследованы от большинства базовых классов, таких как <xref:System.MarshalByRefObject> (а ограничения могут использоваться для обеспечения того, чтобы параметры универсальных типов наследовались от базовых классов, таких как <xref:System.MarshalByRefObject>).</span><span class="sxs-lookup"><span data-stu-id="99e83-170">Generic types can be derived from most base classes, such as <xref:System.MarshalByRefObject> (and constraints can be used to require that generic type parameters derive from base classes like <xref:System.MarshalByRefObject>).</span></span> <span data-ttu-id="99e83-171">Тем не менее, [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] не поддерживает контекстно-связанные универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="99e83-171">However, the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] does not support context-bound generic types.</span></span> <span data-ttu-id="99e83-172">Универсальный тип может быть наследован от <xref:System.ContextBoundObject>, но при попытке создать экземпляр этого типа возникает <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="99e83-172">A generic type can be derived from <xref:System.ContextBoundObject>, but trying to create an instance of that type causes a <xref:System.TypeLoadException>.</span></span>  
  
-   <span data-ttu-id="99e83-173">Перечисления не могут иметь параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-173">Enumerations cannot have generic type parameters.</span></span> <span data-ttu-id="99e83-174">Перечисление может быть универсальным только случайно (например, если оно является вложенным в универсальный тип, который определен с помощью Visual Basic, C# или C++).</span><span class="sxs-lookup"><span data-stu-id="99e83-174">An enumeration can be generic only incidentally (for example, because it is nested in a generic type that is defined using Visual Basic, C#, or C++).</span></span> <span data-ttu-id="99e83-175">Дополнительные сведения см. в статье [Система общих типов CTS](../../../docs/standard/base-types/common-type-system.md) в разделе "Перечисления".</span><span class="sxs-lookup"><span data-stu-id="99e83-175">For more information, see "Enumerations" in [Common Type System](../../../docs/standard/base-types/common-type-system.md).</span></span>  
  
-   <span data-ttu-id="99e83-176">Облегченные динамические методы не могут быть универсальными.</span><span class="sxs-lookup"><span data-stu-id="99e83-176">Lightweight dynamic methods cannot be generic.</span></span>  
  
-   <span data-ttu-id="99e83-177">В Visual Basic, C# и C++ вложенный тип, заключенный в универсальном типе, не может быть использован для создания объекта, кроме тех случаев, когда типы были назначены параметрам типа всех заключенных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-177">In Visual Basic, C#, and C++, a nested type that is enclosed in a generic type cannot be instantiated unless types have been assigned to the type parameters of all enclosing types.</span></span> <span data-ttu-id="99e83-178">Другими словами, вложенный тип, который определен с помощью этих языков, включает параметры типов всех его заключенных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-178">Another way of saying this is that in reflection, a nested type that is defined using these languages includes the type parameters of all its enclosing types.</span></span> <span data-ttu-id="99e83-179">Это позволяет использовать параметры типа заключающих типов в определениях членов вложенного типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-179">This allows the type parameters of enclosing types to be used in the member definitions of a nested type.</span></span> <span data-ttu-id="99e83-180">Дополнительные сведения см. в статье о методе <xref:System.Type.MakeGenericType%2A> в разделе "Вложенные типы".</span><span class="sxs-lookup"><span data-stu-id="99e83-180">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="99e83-181">Вложенный тип, который определяется путем создания кода в динамической сборке или с помощью [ассемблера IL (Ilasm.exe)](../../../docs/framework/tools/ilasm-exe-il-assembler.md), не обязательно должен включать параметры его заключающих типов. Тем не менее, если он их не включает, параметры типов находятся вне области вложенного класса.</span><span class="sxs-lookup"><span data-stu-id="99e83-181">A nested type that is defined by emitting code in a dynamic assembly or by using the [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) is not required to include the type parameters of its enclosing types; however, if it does not include them, the type parameters are not in scope in the nested class.</span></span>  
  
     <span data-ttu-id="99e83-182">Дополнительные сведения см. в статье о методе <xref:System.Type.MakeGenericType%2A> в разделе "Вложенные типы".</span><span class="sxs-lookup"><span data-stu-id="99e83-182">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 [<span data-ttu-id="99e83-183">К началу</span><span class="sxs-lookup"><span data-stu-id="99e83-183">Back to top</span></span>](#top)  
  
<a name="class_library_and_language_support"></a>   
## <a name="class-library-and-language-support"></a><span data-ttu-id="99e83-184">Библиотека классов и языковая поддержка</span><span class="sxs-lookup"><span data-stu-id="99e83-184">Class Library and Language Support</span></span>  
 <span data-ttu-id="99e83-185">Платформа .NET Framework предоставляет ряд универсальных классов коллекций в следующих пространствах имен.</span><span class="sxs-lookup"><span data-stu-id="99e83-185">The .NET Framework provides a number of generic collection classes in the following namespaces:</span></span>  
  
-   <span data-ttu-id="99e83-186">Пространство имен <xref:System.Collections.Generic> каталогизирует большинство типов универсальных коллекций, предоставляемых платформой .NET Framework, например универсальные классы <xref:System.Collections.Generic.List%601> и <xref:System.Collections.Generic.Dictionary%602>.</span><span class="sxs-lookup"><span data-stu-id="99e83-186">The <xref:System.Collections.Generic> namespace catalogs most of the generic collection types provided by the .NET Framework, such as the <xref:System.Collections.Generic.List%601> and <xref:System.Collections.Generic.Dictionary%602> generic classes.</span></span>  
  
-   <span data-ttu-id="99e83-187">Пространство имен <xref:System.Collections.ObjectModel> каталогизирует дополнительные типы универсальных коллекций (например, универсальный класс <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>), которые можно использовать для предоставления моделей объектов пользователям классов.</span><span class="sxs-lookup"><span data-stu-id="99e83-187">The <xref:System.Collections.ObjectModel> namespace catalogs additional generic collection types, such as the <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> generic class, that are useful for exposing object models to users of your classes.</span></span>  
  
 <span data-ttu-id="99e83-188">Универсальные интерфейсы для реализации сортировки и сравнений на равенство предоставляются в пространстве имен <xref:System> вместе с универсальными типами методов-делегатов для обработчиков событий, преобразований и предикатов поиска.</span><span class="sxs-lookup"><span data-stu-id="99e83-188">Generic interfaces for implementing sort and equality comparisons are provided in the <xref:System> namespace, along with generic delegate types for event handlers, conversions, and search predicates.</span></span>  
  
 <span data-ttu-id="99e83-189">В пространство имен <xref:System.Reflection> добавлена поддержка универсальных шаблонов для обеспечения возможности проверки универсальных типов и универсальных методов, в пространство имен <xref:System.Reflection.Emit> добавлена поддержка шаблонов для создания динамических сборок, содержащих универсальные типы и методы, в пространство имен <xref:System.CodeDom> добавлена поддержка шаблонов для создания графов исходного кода, включающих универсальные шаблоны.</span><span class="sxs-lookup"><span data-stu-id="99e83-189">Support for generics has been added to the <xref:System.Reflection> namespace for examining generic types and generic methods, to <xref:System.Reflection.Emit> for emitting dynamic assemblies that contain generic types and methods, and to <xref:System.CodeDom> for generating source graphs that include generics.</span></span>  
  
 <span data-ttu-id="99e83-190">Среда CLR предоставляет новые коды операций и префиксы для поддержки универсальных типов в промежуточном языке Майкрософт (MSIL), в частности <xref:System.Reflection.Emit.OpCodes.Stelem>, <xref:System.Reflection.Emit.OpCodes.Ldelem>, <xref:System.Reflection.Emit.OpCodes.Unbox_Any>, <xref:System.Reflection.Emit.OpCodes.Constrained> и <xref:System.Reflection.Emit.OpCodes.Readonly>.</span><span class="sxs-lookup"><span data-stu-id="99e83-190">The common language runtime provides new opcodes and prefixes to support generic types in Microsoft intermediate language (MSIL), including <xref:System.Reflection.Emit.OpCodes.Stelem>, <xref:System.Reflection.Emit.OpCodes.Ldelem>, <xref:System.Reflection.Emit.OpCodes.Unbox_Any>, <xref:System.Reflection.Emit.OpCodes.Constrained>, and <xref:System.Reflection.Emit.OpCodes.Readonly>.</span></span>  
  
 <span data-ttu-id="99e83-191">В языках Visual C++, C# и Visual Basic обеспечивается полноценная поддержка определения и использования универсальных шаблонов.</span><span class="sxs-lookup"><span data-stu-id="99e83-191">Visual C++, C#, and Visual Basic all provide full support for defining and using generics.</span></span> <span data-ttu-id="99e83-192">Дополнительные сведения о поддержке языков см. в статьях [Универсальные типы в Visual Basic](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md), [Введение в универсальные шаблоны](~/docs/csharp/programming-guide/generics/introduction-to-generics.md) и [Обзор универсальных типов в Visual C++](http://msdn.microsoft.com/library/21f10637-0fce-4916-b925-6c86a126d3aa).</span><span class="sxs-lookup"><span data-stu-id="99e83-192">For more information about language support, see [Generic Types in Visual Basic](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md), [Introduction to Generics](~/docs/csharp/programming-guide/generics/introduction-to-generics.md), and [Overview of Generics in Visual C++](http://msdn.microsoft.com/library/21f10637-0fce-4916-b925-6c86a126d3aa).</span></span>  
  
 [<span data-ttu-id="99e83-193">К началу</span><span class="sxs-lookup"><span data-stu-id="99e83-193">Back to top</span></span>](#top)  
  
<a name="nested_types_and_generics"></a>   
## <a name="nested-types-and-generics"></a><span data-ttu-id="99e83-194">Вложенные типы и универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="99e83-194">Nested Types and Generics</span></span>  
 <span data-ttu-id="99e83-195">Тип, вложенный в универсальный тип, может зависеть от параметров типа этого универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-195">A type that is nested in a generic type can depend on the type parameters of the enclosing generic type.</span></span> <span data-ttu-id="99e83-196">Среда CLR рассматривает вложенные типы как универсальные, даже если они не имеют своих собственных параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="99e83-196">The common language runtime considers nested types to be generic, even if they do not have generic type parameters of their own.</span></span> <span data-ttu-id="99e83-197">При создании экземпляра вложенного типа необходимо задать аргументы типа для всех включающих его универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-197">When you create an instance of a nested type, you must specify type arguments for all enclosing generic types.</span></span>  
  
 [<span data-ttu-id="99e83-198">К началу</span><span class="sxs-lookup"><span data-stu-id="99e83-198">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="99e83-199">Связанные разделы</span><span class="sxs-lookup"><span data-stu-id="99e83-199">Related Topics</span></span>  
  
|<span data-ttu-id="99e83-200">Заголовок</span><span class="sxs-lookup"><span data-stu-id="99e83-200">Title</span></span>|<span data-ttu-id="99e83-201">Описание</span><span class="sxs-lookup"><span data-stu-id="99e83-201">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="99e83-202">Универсальные коллекции в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="99e83-202">Generic Collections in the .NET Framework</span></span>](../../../docs/standard/generics/collections.md)|<span data-ttu-id="99e83-203">Описание классов универсальных коллекций и других универсальных типов в составе платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="99e83-203">Describes generic collection classes and other generic types in the .NET Framework.</span></span>|  
|[<span data-ttu-id="99e83-204">Универсальные методы-делегаты для управления массивами и списками</span><span class="sxs-lookup"><span data-stu-id="99e83-204">Generic Delegates for Manipulating Arrays and Lists</span></span>](../../../docs/standard/generics/delegates-for-manipulating-arrays-and-lists.md)|<span data-ttu-id="99e83-205">Описание универсальных делегатов для преобразований, предикатов поиска и действий, осуществляемых с элементами массива или коллекции.</span><span class="sxs-lookup"><span data-stu-id="99e83-205">Describes generic delegates for conversions, search predicates, and actions to be taken on elements of an array or collection.</span></span>|  
|[<span data-ttu-id="99e83-206">Универсальные интерфейсы</span><span class="sxs-lookup"><span data-stu-id="99e83-206">Generic Interfaces</span></span>](../../../docs/standard/generics/interfaces.md)|<span data-ttu-id="99e83-207">Описание универсальных интерфейсов, которые предоставляют общие функции для различных семейств универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-207">Describes generic interfaces that provide common functionality across families of generic types.</span></span>|  
|[<span data-ttu-id="99e83-208">Ковариация и контрвариантность</span><span class="sxs-lookup"><span data-stu-id="99e83-208">Covariance and Contravariance</span></span>](../../../docs/standard/generics/covariance-and-contravariance.md)|<span data-ttu-id="99e83-209">Описание ковариации и контравариации в параметрах универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-209">Describes covariance and contravariance in generic type parameters.</span></span>|  
|[<span data-ttu-id="99e83-210">Часто используемые типы коллекций</span><span class="sxs-lookup"><span data-stu-id="99e83-210">Commonly Used Collection Types</span></span>](../../../docs/standard/collections/commonly-used-collection-types.md)|<span data-ttu-id="99e83-211">Предоставление сводных данных о характеристиках и сценариях использования типов коллекций в составе платформы .NET Framework, включая универсальные типы.</span><span class="sxs-lookup"><span data-stu-id="99e83-211">Provides summary information about the characteristics and usage scenarios of the collection types in the .NET Framework, including generic types.</span></span>|  
|[<span data-ttu-id="99e83-212">Когда следует использовать универсальные коллекции</span><span class="sxs-lookup"><span data-stu-id="99e83-212">When to Use Generic Collections</span></span>](../../../docs/standard/collections/when-to-use-generic-collections.md)|<span data-ttu-id="99e83-213">Описание общих правил для определения ситуаций, когда следует использовать универсальные типы коллекций.</span><span class="sxs-lookup"><span data-stu-id="99e83-213">Describes general rules for determining when to use generic collection types.</span></span>|  
|[<span data-ttu-id="99e83-214">Практическое руководство. Определение универсального типа с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="99e83-214">How to: Define a Generic Type with Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)|<span data-ttu-id="99e83-215">Описание способов создания динамических сборок, содержащих универсальные типы и методы.</span><span class="sxs-lookup"><span data-stu-id="99e83-215">Explains how to generate dynamic assemblies that include generic types and methods.</span></span>|  
|[<span data-ttu-id="99e83-216">Универсальные типы в Visual Basic</span><span class="sxs-lookup"><span data-stu-id="99e83-216">Generic Types in Visual Basic</span></span>](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md)|<span data-ttu-id="99e83-217">Описание универсальных шаблонов для пользователей Visual Basic, включая практические руководства об использовании и определении универсальных типов.</span><span class="sxs-lookup"><span data-stu-id="99e83-217">Describes the generics feature for Visual Basic users, including how-to topics for using and defining generic types.</span></span>|  
|[<span data-ttu-id="99e83-218">Введение в универсальные шаблоны</span><span class="sxs-lookup"><span data-stu-id="99e83-218">Introduction to Generics</span></span>](~/docs/csharp/programming-guide/generics/introduction-to-generics.md)|<span data-ttu-id="99e83-219">Общие сведения об определении и использовании универсальных типов для пользователей C#.</span><span class="sxs-lookup"><span data-stu-id="99e83-219">Provides an overview of defining and using generic types for C# users.</span></span>|  
|[<span data-ttu-id="99e83-220">Обзор универсальных типов в Visual C++</span><span class="sxs-lookup"><span data-stu-id="99e83-220">Overview of Generics in Visual C++</span></span>](http://msdn.microsoft.com/library/21f10637-0fce-4916-b925-6c86a126d3aa)|<span data-ttu-id="99e83-221">Описание универсальных шаблонов для пользователей C++, включая описание различий между шаблонами и универсальными шаблонами.</span><span class="sxs-lookup"><span data-stu-id="99e83-221">Describes the generics feature for C++ users, including the differences between generics and templates.</span></span>|  
  
<a name="reference"></a>   
## <a name="reference"></a><span data-ttu-id="99e83-222">Ссылка</span><span class="sxs-lookup"><span data-stu-id="99e83-222">Reference</span></span>  
 <span data-ttu-id="99e83-223"><xref:System.Collections.Generic></span><span class="sxs-lookup"><span data-stu-id="99e83-223"><xref:System.Collections.Generic></span></span>  
  
 <span data-ttu-id="99e83-224"><xref:System.Collections.ObjectModel></span><span class="sxs-lookup"><span data-stu-id="99e83-224"><xref:System.Collections.ObjectModel></span></span>  
  
 <span data-ttu-id="99e83-225"><xref:System.Reflection.Emit.OpCodes?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="99e83-225"><xref:System.Reflection.Emit.OpCodes?displayProperty=fullName></span></span>  
  
 [<span data-ttu-id="99e83-226">К началу</span><span class="sxs-lookup"><span data-stu-id="99e83-226">Back to top</span></span>](#top)
